{
  "hash": "76128046688860d6ef70cb21123da95a",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n\n# Variance Swaps {sec-c:variance_swaps} \n\n::: {#e0c5ff7f .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"></script>\n```\n:::\n:::\n\n\nVariance swaps are a type of futures contracts that allows investors to trade future realized volatility against current option implied variance. Unlike traditional futures, which provide a payoff based on the difference between the underlying asset's price and the futures price, variance swaps provide a payoff based on the difference between the realized variance of the underlying asset and the predetermined variance level (termed ``Strike'' in practice), which is the futures price in variance unit. \n\nVariance swaps have gained popularity due to their ability to provide pure exposure to the volatility of an underlying asset, independent of its price movements. Unlike traditional options, variance swaps allow investors to speculate on or hedge against changes in volatility without the need for constant delta hedging. This makes them an effective tool for managing volatility risk and for executing volatility arbitrage strategies, as they simplify the trading of variance and offer a more straightforward payoff structure based on realized versus implied volatility.\n\n\n\n### Payoff of a Variance Swap\n\nA variance swap is a future contract on future realized variance. Its main components include:\n\n- **Notional Amount**: Specifies the amount of money to be paid for each unit of variance difference.\n- **Strike**: The predetermined level of variance agreed upon at the inception of the swap.\n- **Realized Variance**: Calculated from the returns of the underlying asset over the life of the swap.\n\nThe payoff of a variance swap is given by:\n\n$$\n\\text{Payoff} = \\text{Notional} \\times (\\text{Realized Variance} - \\text{Strike})\n$$\n\nWhere:\n\n- **Realized Variance** is typically calculated using the formula:\n\n$$\n\\text{Realized Variance} = \\frac{252}{N} \\sum_{i=1}^{N} \\left( \\log\\left(\\frac{S_i}{S_{i-1}}\\right) \\right)^2\n$$\n\nHere, $S_i$ represents the price of the underlying asset at time $i$, and $N$ is the number of trading days over the contract period.\n\n\n**Example**: Suppose an investor enters into a variance swap with a notional amount of \\$100,000 and a strike of 0.04 (implying a volatility strike of 20%). If the realized variance over the swap's life is 0.06 (implying a realized volatility of 24.5%), the payoff would be:\n\n$$\n\\text{Payoff} = 100,000 \\times (0.06 - 0.04) = 100,000 \\times 0.02 = 2,000\n$$\n\nThis means the investor would receive \\$2,000 at the end of the swap period.\n\nAs all futures constracts, variance swaps are marked to market on each trading day. \n\nVariance swaps can be used to hedge against volatility risk. For example, a portfolio manager concerned about increasing market volatility can buy variance swaps to protect the portfolio's value. \n\nTraders can also use variance swaps to speculate or arbitrage on future volatility. For example, If a trader believes that future volatility will be higher than the current implied volatility, they can enter a variance swap to profit from this view.\n\n### Pricing of a Variance Swap for Stocks with Geometric Brownian Motion Prices\n\nSimilor the pricing of a futures, we need find the fair swap strike such that the initial value of the swap is zero. For simplicity, consider a stock whose price $S_t$ follows a geometric Brownian motion process:\n\n$$ \\frac{dS_t}{S_t} = \\mu \\, dt + \\sigma \\, dZ_t\n $$\n\nApplying Ito's Lemma to $\\log(S_t)$:\n\n$$ d(\\log S_t) = \\left( \\mu - \\frac{\\sigma^2}{2} \\right) \\, dt + \\sigma \\, dZ_t \n$$\n\nRearranging terms, we get:\n\n$$ \\frac{dS_t}{S_t} - d(\\log S_t) = \\frac{\\sigma^2}{2} \\, dt\n $$\n\n\nIntegrating over the life of the swap \\( [0, T] \\):\n\n$$ \\text{Total Variance} = \\frac{1}{T} \\int_0^T \\sigma^2 \\, dt = \\frac{2}{T} \\left( \\int_0^T \\frac{dS_t}{S_t} - \\log \\left( \\frac{S_T}{S_0} \\right) \\right),  \n$$\nwhich implies that the total variance can be replicated by continuously rebalancing the stock position with weight $1/S_t$ and shorting one unit of the security which pays the $\\log$ return of the stock. However, this $\\log$ return secutiry is not traded in the market. Fortunately, we can synthesize this security with a forward and options, because \n\n$$\n-ln (\\frac{S_T}{S^*})=-\\frac{S-S^*}{S^*}+\\int_0^{S^*}\\frac{(K-S)^+}{K^2}dK+\\int_{S^*}^\\infty\\frac{(S-K)^+}{K^2}dK,\n$$\nwhere $S^*$ is an arbitrary cut-off strike for calls and puts, the first term on the right hand side represents a short position in the forward contract on the stock, the second term represents a continuum of put options with strike prices from 0 to $S^*$, and  the third term represents a continuum of call options with strike prices above $S^*$. Taking expectation under the risk-neutral probability, we have that the fair swap strike $K_{\\text{var}}$ is equal to:\n\n$$ K_{\\text{var}} = \\frac{2}{T} \\left( rT - \\left( \\frac{S_0}{S^*} e^{rT} - 1 \\right) - \\log \\left( \\frac{S^*}{S_0} \\right) + e^{rT} \\int_0^{S^*} \\frac{1}{K^2} P(K) \\, dK + e^{rT} \\int_{S^*}^\\infty \\frac{1}{K^2} C(K) \\, dK \\right) \n$$\n\n\nChoosing $S^*$ to be the current forward price $F_0=S_0 e^{rT}$:\n\n$$ K_{\\text{var}} = \\frac{2 e^{rT}}{T} \\left( \\int_0^{F_0} \\frac{P(K)}{K^2} \\, dK + \\int_{F_0}^\\infty \\frac{C(K)}{K^2} \\, dK \\right) \n$$\n\nThis formula allows us to compute the fair strike price of a variance swap using the prices of European call and put options. The following code provides an example of this computation using data from Yahoo finance for Apple.\n\n::: {#variance_swap_pricing .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\nfrom scipy.stats import norm\nimport yfinance as yf\n\ndef indicator_function(condition):\n    return 1 if condition else 0\n\ndef calculate_variance_swap_strike(S, r, T, options_data):\n    # Extract call and put prices\n    call_data = options_data[options_data['Type'] == 'call'].copy()\n    put_data = options_data[options_data['Type'] == 'put'].copy()\n    \n    # Interpolate call and put prices\n    strikes = np.unique(options_data['Strike'])\n    call_interp = interp1d(call_data['Strike'], call_data['Price'], fill_value=\"extrapolate\")\n    put_interp = interp1d(put_data['Strike'], put_data['Price'], fill_value=\"extrapolate\")\n    \n    # Integrate using numerical methods (trapezoidal rule)\n    \n    K_min, K_max = strikes.min(), strikes.max()\n    K = np.linspace(K_min, S*np.exp(r*T), 500)\n    integral1 = np.trapezoid(put_interp(K) / K**2, K)\n    K = np.linspace(S*np.exp(r*T),K_max, 500)\n    integral2 = np.trapezoid(call_interp(K) / K**2, K)\n    \n    # Calculate the variance swap strike\n    variance_swap_strike = np.sqrt(2 * (integral1+integral2) / T)\n    return variance_swap_strike\n\n# Example usage\nticker = \"AAPL\"\nS = 150.0  # Current stock price\nr = 0.01  # Risk-free rate\nT = 0.5  # Time to maturity (6 months)\n\n# Fetch options data from Yahoo Finance\nstock = yf.Ticker(ticker)\nexpiry = stock.options[0]\nopt_chain = stock.option_chain(expiry)\ncalls = opt_chain.calls[['strike', 'lastPrice']].copy()\nputs = opt_chain.puts[['strike', 'lastPrice']].copy()\ncalls.columns = ['Strike', 'Price']\nputs.columns = ['Strike', 'Price']\ncalls['Type'] = 'call'\nputs['Type'] = 'put'\noptions_data = pd.concat([calls, puts])\n\n# Calculate the variance swap strike\nvariance_swap_strike = calculate_variance_swap_strike(S, r, T, options_data)\nprint(f\"Variance Swap Strike: {variance_swap_strike:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVariance Swap Strike: 0.6075\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Chapter_VarianceSwaps_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\nif (typeof require !== 'undefined') {\nrequire.undef(\"plotly\");\nrequirejs.config({\n    paths: {\n        'plotly': ['https://cdn.plot.ly/plotly-2.35.2.min']\n    }\n});\nrequire(['plotly'], function(Plotly) {\n    window._Plotly = Plotly;\n});\n}\n</script>\n\n"
      ]
    }
  }
}