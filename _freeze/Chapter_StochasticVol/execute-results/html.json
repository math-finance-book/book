{
  "hash": "f0d5463fe3e1a249755dcc9442bffe5c",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n\n# Stochastic Volatility {#sec-c:stochasticvolatility} \n\n::: {#d1ce5b0b .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"></script>\n```\n:::\n:::\n\n\nThe volatility is stochastic (random) in a GARCH model, but it is determined by the changes in the stock price.  In this section, in contrast, we will consider models in which the volatility depends on a second Brownian motion.  \\index{stochastic volatility} The most popular model of this type is the model of Heston [@Heston].  \\index{Heston model} In this model, we have, as usual, \n\n\n$$\n\\d \\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\d   t + \\sigma\\d   B_s\\;,\n$$ {#eq-heston1}\n\nwhere $B_s$ is a Brownian motion under the risk-neutral probability but now $\\sigma$ is not a constant but instead evolves as $\\sigma_t = \\sqrt{v_t}$ where\n\n$$\ndv_t = \\kappa \\big[\\theta-v_t\\big]\\d   t + \\gamma \\sqrt{v_t}\\d   B_v\\;,\n$$ {#eq-heston2}\n\n\nwhere $B_v$ is a Brownian motion under the risk-neutral probability having a constant correlation $\\rho$ with the Brownian motion $B_s$.  In this equation, $\\kappa$, $\\theta$ and $\\gamma$ are positive constants.  Given the empirical fact that negative return shocks have a bigger impact on future volatility than do positive shocks, one would expect the correlation $\\rho$ to be negative.\n\nThe term $\\kappa (\\theta-v)$ will be positive when $v<\\theta$ and negative when $v>\\theta$ and hence $\\sigma^2=v$ will tend to drift towards $\\theta$, which, as in the GARCH model, is the long-run or unconditional mean of $\\sigma^2$.  Thus, the volatility is said to mean revert. \\index{mean reversion} The rate at which it drifts towards $\\theta$ is obviously determined by the magnitude of $\\kappa$, also as in the GARCH model.  \n\nThe specification @eq-heston2 implies that the volatility of $v$ approaches zero whenever $v$ approaches zero.      In this circumstance, one might expect the drift towards $\\theta$ to dominate the volatility and keep $v$ nonnegative, and this is indeed the case; thus, the definition $\\sigma_t = \\sqrt{v_t}$ is possible.  Moreover, the parameter $\\gamma$ plays a role here that is similar to the role of $1-\\lambda$ in the GARCH model---the variance of the variance in the GARCH model @eq-garch10 depends on the weight $1-\\lambda$ placed on the scaled return $y_i$, just as the variance of the variance in the stochastic volatility model @eq-heston2 depends on the weight $\\gamma$ placed on  $\\d  B_v$.\n\nWe could discretize @eq-heston1 - @eq-heston2 as:\n\n\n$$\n\\log S(t_{i+1}) = \\log S_{t_i} + \\left(r-q-\\frac{1}{2}\\sigma_{t_i}^2\\right)\\,\\Delta t + \\sqrt{v_{t_i}}\\,\\Delta B_s,\n$$ {#eq-heston3}\n\n$$\nv(t_{i+1}) = v_{t_i} + \\kappa \\big[\\theta-v_{t_i}\\big]\\,\\Delta t + \\gamma \\sqrt{v_{t_i}}\\,\\Delta B_v\\;.\n$$ {#eq-heston4}\n\n\n\nHowever, even though in the continuous-time model @eq-heston1 - @eq-heston2 we always have $v_t \\geq 0$ and hence can define $\\sigma_t=\\sqrt{v_t}$, there is no guarantee that $v(t_{i+1})$ defined by @eq-heston4 will be nonnegative.  A simple remedy is to define $v(t_{i+1})$ as the larger of zero and the right-hand side of @eq-heston4; thus, we will simulate the Heston model as @eq-heston3 and^[There are better (but more complicated) ways to simulate the Heston model.  An excellent discussion of ways to simulate the volatility process can be found in Glasserman [@Glasserman].  Broadie and Kaya [@broadiekaya] present a method for simulating from the exact distribution of the asset price in the Heston model and related models.]\n$$\nv(t_{i+1}) = \\max\\left\\{0,v_{t_i} + \\kappa \\big[\\theta-v_{t_i}\\big]\\,\\Delta t + \\gamma \\sqrt{v_{t_i}}\\,\\Delta B_v\\right\\}\\;.\n$$ {#eq-heston41}\n\n\n\nA simple way to simulate the changes $\\Delta B_s$ and $\\Delta B_v$ in the two correlated Brownian motions is to generate two independent standard normals $z_1$ and $z_2$ and take\n$$\\Delta B_s = \\sqrt{\\Delta t}\\,z \\qquad \\text{and} \\qquad \\Delta B_v = \\sqrt{\\Delta t}\\,z^*\\; ,$$\nwhere we define \n$$z = z_1 \\qquad \\text{and} \\qquad z^* = \\rho z_1 + \\sqrt{1-\\rho^2}\\,z_2\\; .$$\nThe random variable $z^*$ is also a standard normal, and the correlation between $z$ and $z^*$ is $\\rho$. \n\nAs in the GARCH model, we can simulate a path of an asset price that follows a GARCH process and the path of its volatility as follows.  The following python code produces three columns of data (with headings), the first column being time, the second  the asset price, and the third  the volatility in the Heston model.\n\n::: {#59319771 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport pandas as pd\n\ndef simulating_stochastic_volatility(S, V0, r, q, dt, N, theta, kappa, sigma, rho):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    V0 = initial variance\n    r = risk-free rate\n    q = dividend yield\n    dt = length of each time period (Delta t)\n    N = number of time periods\n    theta = long-term variance (mean of variance)\n    kappa = rate of mean reversion of variance\n    sigma = volatility of variance\n    rho = correlation between the two Wiener processes\n    \"\"\"\n    LogS = np.log(S)\n    Sqrdt = np.sqrt(dt)\n    \n    time = np.zeros(N + 1)\n    stock_price = np.zeros(N + 1)\n    volatility = np.zeros(N + 1)\n    \n    stock_price[0] = S\n    volatility[0] = V0    \n    \n    for i in range(1, N + 1):\n        time[i] = i * dt\n        Z1 = np.random.randn()\n        Z2 = np.random.randn()\n        W1 = Z1\n        W2 = rho * Z1 + np.sqrt(1 - rho**2) * Z2\n        \n        LogS = LogS + (r - q - 0.5 * volatility[i-1]**2) * dt + np.sqrt(volatility[i-1]**2 * dt) * W1\n        S = np.exp(LogS)\n        stock_price[i] = S\n        \n        volatility[i] = np.sqrt(np.maximum(volatility[i-1]**2 + kappa * (theta - volatility[i-1]**2) * dt + sigma * np.sqrt(volatility[i-1]**2 * dt) * W2, 0))\n\n    df_stochastic_vol = pd.DataFrame({'Time': time, 'Stock Price': stock_price, 'Volatility': volatility})\n    df_stochastic_vol.to_csv('stochastic_volatility_simulation.csv', index=False)\n    return df_stochastic_vol\n\n# Example usage:\nS = 100       # Initial stock price\nV0 = 0.04     # Initial variance\nr = 0.05      # Risk-free rate\nq = 0.02      # Dividend yield\ndt = 1/252    # Length of each time period (daily)\nN = 252       # Number of time periods (one year)\ntheta = 0.04  # Long-term variance\nkappa = 2.0   # Rate of mean reversion of variance\nsigma = 0.3   # Volatility of variance\nrho = -0.7    # Correlation between the two Wiener processes\n\ndf_stochastic_vol = simulating_stochastic_volatility(S, V0, r, q, dt, N, theta, kappa, sigma, rho)\nprint(df_stochastic_vol)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Time  Stock Price  Volatility\n0    0.000000   100.000000    0.040000\n1    0.003968    99.726158    0.054538\n2    0.007937   100.074946    0.048307\n3    0.011905    99.945809    0.059813\n4    0.015873   100.129575    0.054439\n..        ...          ...         ...\n248  0.984127    93.344123    0.171872\n249  0.988095    94.087522    0.152977\n250  0.992063    94.266084    0.149252\n251  0.996032    93.395937    0.163006\n252  1.000000    94.255783    0.140319\n\n[253 rows x 3 columns]\n```\n:::\n:::\n\n\nThe following code plots the simulated stock price and the variance paths. \n\n::: {#02923b1e .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Heston model parameters\nS0 = 100     # Initial stock price\nV0 = 0.04    # Initial variance\nrho = -0.7   # Correlation between the two Wiener processes\nkappa = 2.0  # Rate of mean reversion of variance\ntheta = 0.04 # Long-term variance\nsigma = 0.3  # Volatility of variance\nr = 0.05     # Risk-free rate\nT = 1.0      # Time to maturity\nN = 252      # Number of time steps\ndt = T / N   # Time step size\nn_simulations = 1000  # Number of simulations\n\n# Preallocate arrays\nS = np.zeros((N+1, n_simulations))\nV = np.zeros((N+1, n_simulations))\nS[0] = S0\nV[0] = V0\n\n# Simulate the paths\nfor t in range(1, N+1):\n    Z1 = np.random.normal(size=n_simulations)\n    Z2 = np.random.normal(size=n_simulations)\n    W1 = Z1\n    W2 = rho * Z1 + np.sqrt(1 - rho**2) * Z2\n    \n    V[t] = np.maximum(V[t-1] + kappa * (theta - V[t-1]) * dt + sigma * np.sqrt(V[t-1] * dt) * W2, 0)\n    S[t] = S[t-1] * np.exp((r - 0.5 * V[t-1]) * dt + np.sqrt(V[t-1] * dt) * W1)\n\n# Plot the results\nplt.figure(figsize=(12, 6))\nfor i in range(n_simulations):\n    plt.plot(S[:, i], lw=0.5, alpha=0.3)\nplt.title('Stock Price Paths with Stochastic Volatility (Heston Model)')\nplt.xlabel('Time Steps')\nplt.ylabel('Stock Price')\nplt.grid(True)\nplt.show()\n\n# Plot the volatility paths\nplt.figure(figsize=(12, 6))\nfor i in range(n_simulations):\n    plt.plot(V[:, i], lw=0.5, alpha=0.3)\nplt.title('Variance Paths with Stochastic Volatility (Heston Model)')\nplt.xlabel('Time Steps')\nplt.ylabel('Variance')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Chapter_StochasticVol_files/figure-html/cell-4-output-1.png){width=965 height=523}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Chapter_StochasticVol_files/figure-html/cell-4-output-2.png){width=969 height=523}\n:::\n:::\n\n\nThe following code shows that the stock returns under the stochastic volatility model display fat-tails with positive kurtosis. \n\n::: {#b4b7ec6a .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import norm, kurtosis\n\ndef simulating_stochastic_volatility(S, V0, r, q, dt, N, theta, kappa, sigma, rho, n_simulations):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    V0 = initial variance\n    r = risk-free rate\n    q = dividend yield\n    dt = length of each time period (Delta t)\n    N = number of time periods\n    theta = long-term variance (mean of variance)\n    kappa = rate of mean reversion of variance\n    sigma = volatility of variance\n    rho = correlation between the two Wiener processes\n    n_simulations = number of simulations\n    \"\"\"\n    LogS = np.log(S)\n    Sqrdt = np.sqrt(dt)\n    \n    log_returns = []\n    \n    for _ in range(n_simulations):\n        stock_price = S\n        variance = V0\n        for _ in range(N):\n            Z1 = np.random.randn()\n            Z2 = np.random.randn()\n            W1 = Z1\n            W2 = rho * Z1 + np.sqrt(1 - rho**2) * Z2\n            \n            log_return = (r - q - 0.5 * variance) * dt + np.sqrt(variance * dt) * W1\n            LogS = np.log(stock_price) + log_return\n            stock_price = np.exp(LogS)\n            \n            variance = np.maximum(variance + kappa * (theta - variance) * dt + sigma * np.sqrt(variance * dt) * W2, 0)\n            \n            log_returns.append(log_return)\n    \n    return log_returns\n\n# Example usage:\nS = 100       # Initial stock price\nV0 = 0.04     # Initial variance\nr = 0.05      # Risk-free rate\nq = 0.02      # Dividend yield\ndt = 1/252    # Length of each time period (daily)\nN = 252       # Number of time periods (one year)\ntheta = 0.04  # Long-term variance\nkappa = 0.2   # Rate of mean reversion of variance\nsigma = 0.3   # Volatility of variance\nrho = -0.7    # Correlation between the two Wiener processes\nn_simulations = 1000  # Number of simulations\n\nlog_returns = simulating_stochastic_volatility(S, V0, r, q, dt, N, theta, kappa, sigma, rho, n_simulations)\n\n# Plotting the distribution of log returns\nsns.histplot(log_returns, bins=100, kde=True, stat=\"density\", color=\"blue\", label=\"Simulated Log Returns\")\nxmin, xmax = plt.xlim()\nx = np.linspace(xmin, xmax, 100)\np = norm.pdf(x, np.mean(log_returns), np.std(log_returns))\nplt.plot(x, p, 'k', linewidth=2, label=\"Normal Distribution\")\nplt.title('Distribution of Log Returns with Stochastic Volatility')\nplt.xlabel('Log Return')\nplt.ylabel('Density')\nplt.legend()\n\n# Display kurtosis\nkurt = kurtosis(log_returns)\nplt.figtext(0.15, 0.8, f'Kurtosis: {kurt:.2f}', fontsize=12)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Chapter_StochasticVol_files/figure-html/cell-5-output-1.png){width=585 height=302}\n:::\n:::\n\n\nTo price European options, we again need to compute \n$$\\text{prob}^S(S_T>K) \\qquad \\text{and} \\qquad \\text{prob}^R(S_T>K)\\; .$$\nThe virtue of modelling volatility as in @eq-heston2 is that these probabilities can be computed quite efficiently, as shown by Heston [@Heston].^[Further discussion can be found in Epps [@Epps].]  There are many other ways in which one could model volatility, but the computations may be more difficult.  For example, one could  replace @eq-heston2 by\n$$\n\\sigma_t = \\mathrm{e}^{v_t} \\quad \\text{and} \\quad dv_t = \\kappa (\\theta-v_t)\\d   t + \\lambda \\d   B^*\\;.\n$$ {#eq-heston5}\n\nThis implies a lognormal volatility and is simpler to simulate than @eq-heston2---because $\\mathrm{e}^{v}$ is well defined even when $v$ is negative---but it is easier to calculate the probabilities $\\text{prob}^S(S_T>K)$ and $\\text{prob}^R(S_T>K)$ if we assume @eq-heston2.\n\nOne way to implement the GARCH or stochastic volatility model is to imply both the initial volatility $\\sigma_0$ and the constants $\\kappa$, $\\theta$ and $\\lambda$ or $\\kappa$, $\\theta$, $\\gamma$ and $\\rho$ from observed option prices.  These four (or five) constants can be computed by forcing the model prices of four (or five) options to equal the observed market prices.  Or, a larger set of prices can be used and the constants can be chosen to minimize the average squared error or some other measure of goodness-of-fit between the model and market prices.\n\n\n\n## Hedging and Market Completeness\n\nThe GARCH model is inherently a discrete-time model.  If returns have a GARCH structure at one frequency (e.g., monthly), they will not have a GARCH structure at a different frequency (e.g., weekly).  Hence, the return period (monthly, weekly, \\ldots) is part of the specification of the model.  One interpretation of the model is that the dates $t_i$ at which the variance changes are the only dates at which investors can trade.  Under this interpretation, it is impossible to perfectly hedge an option: the gross return $S_{t_i}/S_{t_{i-1}}$ over the interval $(t_{i-1},t_i)$ is lognormally distributed, so no portfolio of the stock and riskless asset formed at $t_{i-1}$ and held over the interval $(t_{i-1},t_i)$ can perfectly replicate the return of an option over the interval.  As discussed in @sec-s:incomplete, we call a market in which some derivatives cannot be perfectly hedged an incomplete market. \\index{incomplete market}  Thus, the GARCH model is an example of an incomplete market, if investors can only trade at the frequency at which returns have a GARCH structure.  However, it is unreasonable to assume that investors can only trade weekly or monthly or even daily.\n\nAnother interpretation of the GARCH model is that investors can trade continuously and the asset has a constant volatility within each period $(t_{i-1},t_i)$.  Under this interpretation, the market is complete and options can be delta-hedged.  The completeness is a result of the fact that the change $\\sigma_{i+1}-\\sigma_i$ in the volatility  at date $t_i$ (recall that $\\sigma_i$ is the volatility over the period $(t_{i-1},t_i)$ and $\\sigma_{i+1}$ is the volatility over the period $(t_{i},t_{i+1})$) depends only on $\\log S_{t_i}$.  Thus, the only random factor in the model that needs to be hedged is, as usual, the underlying asset price.  However, this interpretation of the model is also a bit strange.  Suppose for example that monthly returns are assumed to have a GARCH structure.  Then the model states that the volatility in February will be higher if there is an unusually large return (in absolute value) in January.  Suppose there is an unusually large return in the first half of January.  Then, intuitively, one would expect the change in the volatility to occur in the second half of January rather than being delayed until February.  However, the model specifies that the volatility is constant during each month, hence constant during January in this example.\n\nThe stochastic volatility model is more straightforward.  The market is definitely incomplete.  The value of a call option at date $t<T$, where $T$ is the maturity of the option, will depend on the underlying asset price $S_t$ and the volatility $\\sigma_t$.  Denoting the value by $C(t,S_t,\\sigma_t)$, we have\nfrom Ito's formula that\n$$\n\\d  C_t = \\text{something}\\;\\d  t + \\frac{\\partial C}{\\partial S}\\d   S_t + \\frac{\\partial C}{\\partial \\sigma}\\d   \\sigma_t\\; .$$\nA replicating portfolio must have the same dollar change at each date $t$.  If we hold $\\partial C/\\partial S$ shares of the underlying asset, then the change in the value of the shares will be $(\\partial C/\\partial S)\\d   S$.  However, there is no way to match the  \n$(\\partial C/\\partial \\sigma)\\d   \\sigma$ term using the underlying asset and the riskless asset.  \n\nThe significance of the market being incomplete is that the value of a derivative asset that cannot be replicated using traded assets (e.g., the underlying and riskless assets) is not uniquely determined by arbitrage considerations.  As discussed in @sec-s:incomplete, one must use equilibrium pricing in this circumstance.  \\index{equilibrium pricing} That is what we have implicitly done in this chapter.  By assuming particular dynamics for the volatility under the risk-neutral probability, we have implicitly selected a particular risk-neutral probability from the set of risk-neutral probabilitys that are consistent with the absence of arbitrage.  \n\n\n## Variance Swaps\n\nVariance swaps are a type of futures contracts that allows investors to trade future realized volatility against current option implied variance. Unlike traditional futures, which provide a payoff based on the difference between the underlying asset's price and the futures price, variance swaps provide a payoff based on the difference between the realized variance of the underlying asset and the predetermined variance level (termed ``Strike'' in practice), which is the futures price in variance unit. \n\nVariance swaps have gained popularity due to their ability to provide pure exposure to the volatility of an underlying asset, independent of its price movements. Unlike traditional options, variance swaps allow investors to speculate on or hedge against changes in volatility without the need for constant delta hedging. This makes them an effective tool for managing volatility risk and for executing volatility arbitrage strategies, as they simplify the trading of variance and offer a more straightforward payoff structure based on realized versus implied volatility.\n\n\n\n### Payoff of a Variance Swap\n\nA variance swap is a future contract on future realized variance. Its main components include:\n\n- **Notional Amount**: Specifies the amount of money to be paid for each unit of variance difference.\n- **Strike**: The predetermined level of variance agreed upon at the inception of the swap.\n- **Realized Variance**: Calculated from the returns of the underlying asset over the life of the swap.\n\nThe payoff of a variance swap is given by:\n\n$$\n\\text{Payoff} = \\text{Notional} \\times (\\text{Realized Variance} - \\text{Strike})\n$$\n\nWhere:\n\n- **Realized Variance** is typically calculated using the formula:\n\n$$\n\\text{Realized Variance} = \\frac{252}{N} \\sum_{i=1}^{N} \\left( \\log\\left(\\frac{S_i}{S_{i-1}}\\right) \\right)^2\n$$\n\nHere, $S_i$ represents the price of the underlying asset at time $i$, and $N$ is the number of trading days over the contract period.\n\n\n**Example**: Suppose an investor enters into a variance swap with a notional amount of \\$100,000 and a strike of 0.04 (implying a volatility strike of 20%). If the realized variance over the swap's life is 0.06 (implying a realized volatility of 24.5%), the payoff would be:\n\n$$\n\\text{Payoff} = 100,000 \\times (0.06 - 0.04) = 100,000 \\times 0.02 = 2,000\n$$\n\nThis means the investor would receive \\$2,000 at the end of the swap period.\n\nAs all futures constracts, variance swaps are marked to market on each trading day. \n\nVariance swaps can be used to hedge against volatility risk. For example, a portfolio manager concerned about increasing market volatility can buy variance swaps to protect the portfolio's value. \n\nTraders can also use variance swaps to speculate or arbitrage on future volatility. For example, If a trader believes that future volatility will be higher than the current implied volatility, they can enter a variance swap to profit from this view.\n\n### Pricing of a Variance Swap for Stocks with Geometric Brownian Motion Prices\n\nSimilor the pricing of a futures, we need find the fair swap strike such that the initial value of the swap is zero. For simplicity, consider a stock whose price $S_t$ follows a geometric Brownian motion process:\n\n$$ \\frac{dS_t}{S_t} = \\mu \\, dt + \\sigma \\, dZ_t\n $$\n\nApplying Ito's Lemma to $\\log(S_t)$:\n\n$$ d(\\log S_t) = \\left( \\mu - \\frac{\\sigma^2}{2} \\right) \\, dt + \\sigma \\, dZ_t \n$$\n\nRearranging terms, we get:\n\n$$ \\frac{dS_t}{S_t} - d(\\log S_t) = \\frac{\\sigma^2}{2} \\, dt\n $$\n\n\nIntegrating over the life of the swap \\( [0, T] \\):\n\n$$ \\text{Total Variance} = \\frac{1}{T} \\int_0^T \\sigma^2 \\, dt = \\frac{2}{T} \\left( \\int_0^T \\frac{dS_t}{S_t} - \\log \\left( \\frac{S_T}{S_0} \\right) \\right),  \n$$\nwhich implies that the total variance can be replicated by continuously rebalancing the stock position with weight $1/S_t$ and shorting one unit of the security which pays the $\\log$ return of the stock. However, this $\\log$ return secutiry is not traded in the market. Fortunately, we can synthesize this security with a forward and options, because \n\n$$\n-ln (\\frac{S_T}{S^*})=-\\frac{S-S^*}{S^*}+\\int_0^{S^*}\\frac{(K-S)^+}{K^2}dK+\\int_{S^*}^\\infty\\frac{(S-K)^+}{K^2}dK,\n$$\nwhere $S^*$ is an arbitrary cut-off strike for calls and puts, the first term on the right hand side represents a short position in the forward contract on the stock, the second term represents a continuum of put options with strike prices from 0 to $S^*$, and  the third term represents a continuum of call options with strike prices above $S^*$. Taking expectation under the risk-neutral probability, we have that the fair swap strike $K_{\\text{var}}$ is equal to:\n\n$$ K_{\\text{var}} = \\frac{2}{T} \\left( rT - \\left( \\frac{S_0}{S^*} e^{rT} - 1 \\right) - \\log \\left( \\frac{S^*}{S_0} \\right) + e^{rT} \\int_0^{S^*} \\frac{1}{K^2} P(K) \\, dK + e^{rT} \\int_{S^*}^\\infty \\frac{1}{K^2} C(K) \\, dK \\right) \n$$\n\n\nChoosing $S^*$ to be the current forward price $F_0=S_0 e^{rT}$:\n\n$$ K_{\\text{var}} = \\frac{2 e^{rT}}{T} \\left( \\int_0^{F_0} \\frac{P(K)}{K^2} \\, dK + \\int_{F_0}^\\infty \\frac{C(K)}{K^2} \\, dK \\right) \n$$\n\nThis formula allows us to compute the fair strike price of a variance swap using the prices of European call and put options. The following code provides an example of this computation using data from Yahoo finance for Apple.\n\n::: {#variance_swap_pricing .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\nfrom scipy.stats import norm\nimport yfinance as yf\n\ndef indicator_function(condition):\n    return 1 if condition else 0\n\ndef calculate_variance_swap_strike(S, r, T, options_data):\n    # Extract call and put prices\n    call_data = options_data[options_data['Type'] == 'call'].copy()\n    put_data = options_data[options_data['Type'] == 'put'].copy()\n    \n    # Interpolate call and put prices\n    strikes = np.unique(options_data['Strike'])\n    call_interp = interp1d(call_data['Strike'], call_data['Price'], fill_value=\"extrapolate\")\n    put_interp = interp1d(put_data['Strike'], put_data['Price'], fill_value=\"extrapolate\")\n    \n    # Integrate using numerical methods (trapezoidal rule)\n    \n    K_min, K_max = strikes.min(), strikes.max()\n    K = np.linspace(K_min, S*np.exp(r*T), 500)\n    integral1 = np.trapezoid(put_interp(K) / K**2, K)\n    K = np.linspace(S*np.exp(r*T),K_max, 500)\n    integral2 = np.trapezoid(call_interp(K) / K**2, K)\n    \n    # Calculate the variance swap strike\n    variance_swap_strike = np.sqrt(2 * (integral1+integral2) / T)\n    return variance_swap_strike\n\n# Example usage\nticker = \"AAPL\"\nS = 150.0  # Current stock price\nr = 0.01  # Risk-free rate\nT = 0.5  # Time to maturity (6 months)\n\n# Fetch options data from Yahoo Finance\nstock = yf.Ticker(ticker)\nexpiry = stock.options[0]\nopt_chain = stock.option_chain(expiry)\ncalls = opt_chain.calls[['strike', 'lastPrice']].copy()\nputs = opt_chain.puts[['strike', 'lastPrice']].copy()\ncalls.columns = ['Strike', 'Price']\nputs.columns = ['Strike', 'Price']\ncalls['Type'] = 'call'\nputs['Type'] = 'put'\noptions_data = pd.concat([calls, puts])\n\n# Calculate the variance swap strike\nvariance_swap_strike = calculate_variance_swap_strike(S, r, T, options_data)\nprint(f\"Variance Swap Strike: {variance_swap_strike:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVariance Swap Strike: 0.6075\n```\n:::\n:::\n\n\n## {.unnumbered}\n\n::: {#exr-e_mixture}\n  The purpose of this exercise is to generate a fat-tailed distribution from a model that is simpler than the GARCH and stochastic volatility models but has somewhat the same flavor.  The distribution will be a mixture of normals. Create a python program in which the user can input $S$, $r$, $q$, $T$, $\\sigma_1$ and $\\sigma_2$.  Use these inputs to produce a column of 500 simulated $\\log S_T$.  In each simulation, define $\\log S_T$ as\n$$\\log S_T = \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma \\sqrt{T}z\\;,$$\nwhere $z$ is a standard normal,\n$\\sigma = x\\sigma_1 + (1-x)\\sigma_2$,\nand $x$ is a random variable that equals zero or one with equal probabilities.  \n\nCalculate the mean and standard deviation of the $\\log S_T$ and calculate the fraction that lie more than two standard deviations below the mean.  If the $\\log S_T$ all came from a normal distribution with the same variance, then this fraction should equal $\\mathrm{N}(-2) =$ 2.275\\%.  If the fraction is higher, then the distribution is fat tailed.  (Of course, the actual fraction would differ from 2.275\\% in any particular case due to the randomness of the simulation, even if all of the $\\log S_T$ came from a normal distribution with the same variance).\n:::\n\n::: {#exr-e_GARCH1}\n  Create a python program prompting the user to input the same inputs as in the `simulating_garch` function except for the initial volatility and $\\theta$.  Simulate 500 paths of a GARCH process and output $\\log S_T$ for each simulation (you don't need to output the entire paths as in the `simulating_garch` function).  Take the initial volatility to be 0.3 and $\\theta = 0.09$.  Determine whether the distribution is fat-tailed by computing the fraction of the $\\log S_T$ that lie two or more standard deviations below the mean, as in the previous exercise.  For what values of $\\kappa$ and $\\lambda$ does the distribution appear to be especially fat-tailed? \n:::\n::: Exercise\n Repeat @exr-e_GARCH1 for the Heston stochastic volatility model, describing the values of $\\kappa$,  $\\gamma$ and $\\rho$ that appear to generate especially fat-tailed distributions.\n\n:::\n\n",
    "supporting": [
      "Chapter_StochasticVol_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\nif (typeof require !== 'undefined') {\nrequire.undef(\"plotly\");\nrequirejs.config({\n    paths: {\n        'plotly': ['https://cdn.plot.ly/plotly-2.35.2.min']\n    }\n});\nrequire(['plotly'], function(Plotly) {\n    window._Plotly = Plotly;\n});\n}\n</script>\n\n"
      ]
    }
  }
}