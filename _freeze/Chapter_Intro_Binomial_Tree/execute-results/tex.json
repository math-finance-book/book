{
  "hash": "54c6b39572122b96a60684521b94b93f",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n\n# Introduction\nThe binomial tree model is a discrete-time framework used to price derivative securities. It is widely used in financial engineering for valuing options and other contingent claims. This model is particularly useful because it provides an intuitive approach to pricing and allows for easy incorporation of various features such as early exercise in American options.\n\n## Basics of the Binomial Tree Model\nThe binomial tree model is based on the assumption that, over a small time step, the price of an underlying asset can move up or down by a certain factor. The model is constructed iteratively to estimate the fair value of derivatives such as options.\n\n### Assumptions:\n1. There are $n$ time points with $t=0, \\Delta t, 2 \\Delta t, ..., n\\Delta t$, where $ \\Delta t $ is the time step.\n\n2. At each time point $t$, the price of the underlying asset either goes up by a factor $u_t>1$ with probability $p_t\\in(0,1)$ or goes down by a factor $d_t<1$ with probability $1-p_t$.\n\n3. Given an initial stock price $ S_0 $,  the price of the underlying asset evolves as:\n\n$$\nS_{t+\\Delta t} = S_t \\times u_t \\quad \\text{(up move)}\n$$\nor\n$$\nS_{t+\\Delta t} = S_t \\times d_t \\quad \\text{(down move)}\n$$\n\n4. The absence of arbitrage ensures the model can be solved using risk-neutral valuation, where the risk-neutral probability of an up move is:\n\n$$\np_t = \\frac{e^{r_t \\Delta t} - d_t}{u_t - d_t}\n$$\n\nwhere $ r_t $ is the risk-free rate from $t$ to $t+\\Delta t$.\n\n\n## Example: Three-Period Recombining Binomial Tree\nUsing Python and Plotly to visualize a three-period recombining binomial tree with $n=3$, $u=1.1$, $d=1/u$, $\\Delta t=1$:\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport plotly.graph_objects as go\n\ndef plot_non_recombining_binomial_tree(u=1.2, d=0.8, periods=3):\n    \"\"\"\n    Plots a non-recombining three-period binomial tree where the root node\n    is explicitly labeled 100 at t=0, and '0' indicates up, '1' indicates down.\n\n    Parameters:\n    u : float  : Up factor (default: 1.2)\n    d : float  : Down factor (default: 0.8)\n    periods : int : Number of periods (default: 3)\n    \"\"\"\n    nodes = {}\n    edges = []\n\n    # Build the tree\n    for t in range(periods + 1):\n        for path in range(2**t):\n            x = t\n            y = -(path - (2**t) / 2)  # Negate for top-down orientation\n\n            # Special case: root node at t=0 => price = 100\n            if t == 0 and path == 0:\n                price = 100\n            else:\n                # Build the move sequence in binary and apply up/down\n                moves = bin(path)[2:].zfill(t)  # e.g., '010'\n                price = 100  # Start from 100 at root\n                for move in moves:\n                    if move == '0':\n                        price *= u  # Up move\n                    else:\n                        price *= d  # Down move\n\n            nodes[(x, y)] = round(price, 2)\n\n    # Define edges between nodes in consecutive time steps\n    for t in range(periods):\n        for path in range(2**t):\n            x = t\n            y = -(path - (2**t) / 2)\n            # For each path, there are two possible next moves (up=0, down=1)\n            for move in [0, 1]:\n                new_x = x + 1\n                new_y = -((path * 2 + move) - (2**(t+1)) / 2)\n                edges.append(((x, y), (new_x, new_y)))\n\n    # Create Plotly figure\n    fig = go.Figure()\n\n    # Plot edges\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        fig.add_trace(go.Scatter(\n            x=x_coords, y=y_coords,\n            mode='lines',\n            line=dict(color='black'),\n            showlegend=False\n        ))\n\n    # Plot nodes (with labeled prices)\n    x_vals = [key[0] for key in nodes.keys()]\n    y_vals = [key[1] for key in nodes.keys()]\n    labels = [str(nodes[key]) for key in nodes.keys()]\n\n    fig.add_trace(go.Scatter(\n        x=x_vals, y=y_vals,\n        mode='markers+text',\n        marker=dict(size=15, color='lightblue'),\n        text=labels,\n        textposition=\"top center\",\n        showlegend=False\n    ))\n\n    fig.update_layout(\n        title=\"Three-Period Non-Recombining Binomial Tree (Root Node = 100)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        plot_bgcolor='white',\n        width=800,\n        height=600\n    )\n\n    fig.show()\n\n# Run in a local environment or Jupyter Notebook\nplot_non_recombining_binomial_tree()\n```\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n:::\n\n\nWe can generalize the binomial tree model to one with each node having $b$ branches. The following is an example of a trinomial tree (i.e., $b=3$).\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport plotly.graph_objects as go\nimport numpy as np\n\ndef plot_binomial_tree(S0=100, u=1.1, d=0.9, periods=4, branches=2):\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t * branches + 1):\n            x = t  # Time step\n            y = j - t * (branches // 2)  # Centering the tree\n            nodes[(x, y)] = round(S0 * (u ** j) * (d ** (t * branches - j)), 2)\n    \n    edges = []\n    for t in range(periods):\n        for j in range(t * branches + 1):\n            x = t\n            y = j - t * (branches // 2)\n            for b in range(branches + 1):\n                new_x = x + 1\n                new_y = y + (b - (branches // 2))\n                if (new_x, new_y) in nodes:\n                    edges.append(((x, y), (new_x, new_y)))\n    \n    fig = go.Figure()\n    \n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        fig.add_trace(go.Scatter(x=x_coords, y=y_coords, mode='lines', line=dict(color='black'), showlegend=False))\n    \n    x_vals = [key[0] for key in nodes.keys()]\n    y_vals = [key[1] for key in nodes.keys()]\n    labels = [str(nodes[key]) for key in nodes.keys()]\n    \n    fig.add_trace(go.Scatter(\n        x=x_vals, y=y_vals, mode='markers+text',\n        marker=dict(size=20, color='lightblue'),\n        text=labels, textposition=\"top center\",\n        showlegend=False\n    ))\n    \n    fig.update_layout(\n        title=f\"{periods}-Period trinomial Tree u=1.1, d=0.9\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        plot_bgcolor='white',\n        width=900,\n        height=600\n    )\n    \n    fig.show()\n\nplot_binomial_tree(S0=100, u=1.1, d=0.9, periods=4, branches=2)\n```\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n:::\n\n\n## Conclusion\nThe binomial tree model provides an effective method for pricing derivative securities. Recombining trees are efficient and reduce computational complexity, while non-recombining trees may be necessary for more complex option pricing models. In further chapters, we will explore the valuation of European and American options using these models.\n\n",
    "supporting": [
      "Chapter_Intro_Binomial_Tree_files\\figure-pdf"
    ],
    "filters": []
  }
}