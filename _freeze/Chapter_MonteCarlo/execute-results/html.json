{
  "hash": "1e895db74124c24ffac9c2aa8cdbf30d",
  "result": {
    "engine": "jupyter",
    "markdown": "## Monte Carlo Methods {#sec-c_montecarlo}\n\nIn this chapter, we will introduce two principal numerical methods for valuing derivative securities: Monte Carlo and binomial models.  We will consider two applications: valuing European options in the presence of stochastic volatility with Monte Carlo and valuing American options via binomial models.   Throughout the chapter, we will assume there is a constant risk-free rate.  The last section, while quite important, could be skimmed on first reading---the rest of the book does not build upon it.\n\n## Introduction to Monte Carlo {#sec-s_mc_europeans}\n\nAccording to our risk-neutral pricing @eq-riskneutralformula, the value of a security paying an amount $x$ at date $T$ is\n$$\n\\mathrm{e}^{-rT}E^R[x]\\;.\n$$ {#eq-montecarlo1}\n\nTo estimate this by Monte-Carlo \\index{Monte Carlo} means to simulate a sample of values for the random variable\n$x$\nand to estimate the expectation by averaging the sample values.^[Boyle~[@boyle] introduced Monte-Carlo methods for derivative valuation, including the variance-reduction methods of control variates and antithetic variates to be discussed later].  Of course, for this to work, the sample must be generated from a population having a distribution consistent with the risk-neutral probabilities.\n\nThe simplest example is valuing a European option under the Black-Scholes assumptions.  Of course, for calls and puts, this is redundant, because we already have the Black-Scholes formulas.  Nevertheless, we will describe how to do this for the sake of introducing the Monte Carlo method.  In the case of a call option, the random variable $x$ in @eq-montecarlo1 is $\\max(0,S(T)-K)$.  To simulate a sample of values for this random variable, we need to simulate the terminal stock price $S(T)$.  This is easy to do, because, under the Black-Scholes assumptions, the logarithm of $S(T)$ is normally distributed under the risk-neutral probability with mean $\\log S(0)+\\mathrm{n}u T$ and variance $\\sigma^2T$, where $\\mathrm{n}u=r-q-\\sigma^2/2$.  Thus, we can simulate values for $\\log S(T)$ as $\\log S(0)+\\mathrm{n}u T + \\sigma\\sqrt{T}z$, where $z$ is a standard normal.  We can  average the simulated values of $\\max(0,S(T)-K)$, or whatever the payoff of the derivative is, and then discount at the risk-free rate to compute the date--0 value of the derivative.  This means that we generate some number $M$ of standard normals $z_i$ and estimate the option value as $\\mathrm{e}^{-rT}\\bar{x}$, where $\\bar{x}$ is the mean of \n$$x_i = \\max\\left(0,\\mathrm{e}^{\\log S(0)+\\mathrm{n}u T + \\sigma\\sqrt{T}z_i}-K\\right)\\; .$$\nTo value options that are path-dependent  we need to simulate the path of the underlying asset price.  Path-dependent options are discussed in Chaps.~\\ref{c_exotics} and~\\ref{c_montecarlo}.\n\nThere are two main drawbacks to Monte-Carlo methods.  First, it is difficult (though not impossible) to value early-exercise features.^[Monte-Carlo methods for valuing early exercise include the stochastic mesh method of Broadie and Glasserman [@BG] and the regression method of Longstaff and Schwartz [@LS01].  Glasserman [@Glasserman] provides a good discussion of these methods and the relation between them.]  To value early exercise, we need to know the value at each date if not exercised, to compare to the intrinsic value.  One could consider performing a simulation at each date to calculate the value if not exercised, but this value depends on the option to exercise early at later dates, which cannot be calculated without knowing the value of being able to exercise early at even later dates, etc.  In contrast, the binomial model (and finite difference models discussed in @sec-c_pde) can easily handle early exercise but cannot easily handle path dependencies.  \n\nThe second drawback of Monte Carlo methods is that they can be quite inefficient in terms of computation time (though, as will be explained later, they may be faster than alternative methods for derivatives written on multiple assets).  As in statistics, the standard error of the estimate depends on the sample size.  Specifically, \nwe observed in @sec-s_statistics that, given a random sample $\\{x_1,\\ldots,x_M\\}$ of size $M$ from a population with mean $\\mu$ and variance $\\sigma^2$, the best estimate of $\\mu$ is the sample mean $\\bar{x}$, and the standard error of $\\bar{x}$ (which means the standard deviation of $\\bar{x}$ in repeated samples) is best estimated by\n$$\n\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^{M} x_i^2-M\\bar{x}^2\\right)}\\;.\n$$ {#eq-standarderror}\n \\index{standard error}\nRecall that $\\bar{x}$ plus or minus 1.96 standard errors is a 95\\% confidence interval for $\\mu$ when the $x_i$ are normally distributed.\nIn the context of European option valuation, the expression @eq-standarderror gives the  standard error of the estimated option value at maturity, and multiplication of @eq-standarderror by $\\mathrm{e}^{-rT}$ gives the standard error of the estimated date--0 option value.\n\nTo obtain an estimate with an acceptably small standard error may require a large sample size and hence a relatively large amount of computation time.  The complexities of Monte Carlo methods arise from trying to reduce the required sample size.  Later, we will describe two such methods (antithetic variates and control variates).   For those who want to engage in a more detailed study of Monte Carlo methods, the book of Glasserman [@Glasserman] is highly recommended.  J\\\"ackel [@Jackel] is useful for more advanced readers, and Clewlow and Strickland [@CS] and  Brandimarte [@Brandimarte] are useful references that include computer code.\n\n\n### Monte Carlo Valuation of a European Call\nWe will illustrate Monte Carlo by valuing a European call under the Black-Scholes assumptions.  We will also estimate the delta by each of the methods described in @sec-s_montecarlogreeks1 and~\\ref{s_montecarlogreeks2}.  Of course, we know the call value and its delta from the Black-Scholes formulas, and they can be used to evaluate the accuracy of the Monte Carlo estimates.  We use the code in Chapter @sec-c_continuoustime.  In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process. Therefore we  set $m=1$. However, we use a large number of paths, $n=10000$ to get a large sample of terminal stock prices.\n\n::: {#616474ed .cell execution_count=1}\n``` {.python .cell-code}\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 10000\n#number of divisions\nm = 1\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Dividend Yield\nq=0.0\n# Delta t\ndt = T/m\n# Drift\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2020\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n```\n:::\n\n\nAs before, this code generates two samples $St$, which adds the simulated standard (zero mean) normal random variable, and $St1$ which subtracts the simulated (zero mean) standard normal random variable.  Each sample produces and estimate for the Black-Scholes European call option.\n\n::: {#dcceb903 .cell execution_count=2}\n``` {.python .cell-code}\ncc=np.maximum(St[m,:]-K,0)\ncp = np.mean(cc) * np.exp(-r * T)\ncc1=np.maximum(St1[m,:]-K,0)*np.exp(-r * T)\ncp1= np.mean(np.maximum(St1[m,:]-K,0)) * np.exp(-r * T)\n\nprint('The first sample gives an estimated call price=',cp)\nprint('The second sample gives an estimated call price=',cp1)\nbsc = (cp+cp1)/2\nprint('The average of the two estimates=',bsc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe first sample gives an estimated call price= 4.791646287615179\nThe second sample gives an estimated call price= 4.687624646438364\nThe average of the two estimates= 4.739635467026771\n```\n:::\n:::\n\n\nThe true call price is given by\n\n::: {#da993383 .cell execution_count=3}\n``` {.python .cell-code}\nfrom scipy import stats\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n    \n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n        \n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n #    <!-- norm = sp.stats.norm -->\n    norm = stats.norm\n    if call:\n        return np.exp(- q *T) * S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1) \n    else:\n        return -np.exp(-q * T) * S0 * norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc=blackscholes(S0, K, r, q, sig, T, call = True)\nprint('The black scholes fromula=',truebsc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe black scholes fromula= 4.759422392871532\n```\n:::\n:::\n\n\n  Notice that even with 10000 data points for each sample the individual estimates are not very accurate compared to the exact Black Scoles price.  This is a well known problem that is difficult to estimate the mean, even with a lot of data and is a drawback to Monte Carlo as discussed earlier. However, the average of the two prices is sgnificantly more accurate.  This is an example of an antithetic variable which is discussed later.  One simple intution is the two samples yield negatively correlated errors; if the plus sample is two high, then the minus sample will be too low.  Combined, the simulation error will cancel out.  Another intution is that each individual sample has a wrong estimate of the mean.  However, the combined sample has zero mean by construction.  Therefore combining the samples give the right mean of the simulated standard normal random variable.  Nevertheless, there is still sampling error since we are estimating the mean of the discounted call payoffs, not the mean of the standard normal.  This method and other methods to reduce sampling error are discussed next.\n\n  ## Antithetic Variates in Monte Carlo\n\nIn this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method.  These are two of the simplest methods.  They are used extensively, but there are other important methods that are also widely used.  J\\\"ackel [@Jackel] and Glasserman [@Glasserman] provide a wealth of information on this topic.\n\nThe Monte Carlo method estimates the mean $\\mu$ of a random variable $x$ as the sample average of randomly generated values of $x$.  An antithetic variate \\index{antithetic variate} is a random variable $y$ with the same mean as $x$ and a negative correlation with $x$.  It follows that the random variable $z=(x+y)/2$ will have the same mean as $x$ and a lower variance.  Therefore the sample mean of $M$ simulations of $z$ will be an unbiased estimate of $\\mu$ and will have a lower standard error than the sample mean of $M$ simulations of $x$.  Thus, we should obtain a more efficient estimator of $\\mu$ by simulating $z$ instead of $x$.^[\nThe negative correlation between $x$ and $y$ is essential for this method to generate a real gain in efficiency.  To generate $M$ simulations of $z$, one must generate $M$ simulations of $x$ and $M$ of $y$, which will generally require about as much computation time as generating $2M$ simulations of $x$.  If $x$ and $y$ were independent, the standard error from $M$ simulations of $z$ would be the same as the standard error from $2M$ simulations of $x$, so using the antithetic variate would be no better than just doubling the sample size for $x$.]\n\nIn the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent).  The terminal value of the derivative written on the first asset serves as $x$ and the terminal value of the derivative written on the second serves as $y$.  Because both asset prices have the same distribution, the means of $x$ and $y$ will be the same, and the discounted mean is the date--0 value of the derivative. \n\nConsider for example a non-path-dependent option in a world with constant volatility.  In each simulation $i$ ($i=1,\\ldots,M$), we would generate a standard normal $Z_i$ and compute\n\\begin{align*}\n\\log S_i(T) &= \\log S(0) + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z_i\\; ,\\\\\n\\log S_i'(T) &= \\log S(0) + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T - \\sigma\\sqrt{T}Z_i\\;.\n\\end{align*}\nGiven the first terminal price, the value of the derivative will be some number $x_i$ and given the second it will be some number $y_i$.  The date--0 value of the derivative is estimated as\n$$\\mathrm{e}^{-rT}\\frac{1}{M}\\sum_{i=1}^M\\frac{x_i+y_i}{2}\\; .$$\n\n\n## Control Variates in Monte Carlo {#sec-s_controlvariates}\n\\index{control variate}\nAnother approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable.  We can explain this in terms of linear regression in statistics.  Suppose we have a random sample $\\{x_1,\\ldots,x_M\\}$ of a variable $x$ with unknown mean $\\mu$, and suppose we have a corresponding sample $\\{y_1,\\ldots,y_M\\}$ of another variable $y$ with known mean $\\phi$.  Then an efficient estimate of $\\mu$ is $\\hat{\\mu} = \\bar{x} + \\hat{\\beta} (\\phi-\\bar{y})$, where $\\bar{x}$ and $\\bar{y}$ denote the sample means of $x$ and $y$, and where $\\hat{\\beta}$ is the coefficient of $y$ in the linear regression of $x$ on $y$ (i.e., the estimate of $\\beta$ in the linear model $x = \\alpha +\\beta y + \\varepsilon$).  The standard Monte Carlo method, which we have described thus far, simply estimates the mean of $x$ as $\\bar{x}$.  The control variate method adjusts the estimate by adding $\\hat{\\beta} (\\phi-\\bar{y})$.  To understand this correction, assume for example that the true $\\beta$ is positive.  If the random sample is such that $\\bar{y}<\\phi$, then it must be that small values of $y$ were over-represented in the sample.  Since $x$ and $y$ tend to move up and down together (this is the meaning of a positive $\\beta$) it is likely that small values of $x$ were also over-represented in the sample.  Therefore, one should adjust the sample mean of $x$ upwards in order to estimate $\\mu$.  The best adjustment will take into account the extent to which small values of $y$ were over-represented (i.e., the difference between $\\bar{y}$ and $\\phi$) and the strength of the relation between $x$ and $y$ (which the estimate $\\hat{\\beta}$ represents).  The efficient correction of this sort is also the simplest:  just add $\\hat{\\beta}(\\phi-\\bar{y})$ to $\\bar{x}$.  In practice, the estimation of $\\hat{\\beta}$ may be omitted and one may simply take $\\hat{\\beta}=1$, if the relationship between $x$ and $y$ can be assumed to be one-for-one.  If $\\beta$ is to be estimated, the estimate (by ordinary least squares) is\n$$\\hat{\\beta} = \\frac{\\sum_{i=1}^M x_iy_i - M\\bar{x}\\bar{y}}{\\sum_{i=1}^M y_i^2 - M\\bar{y}^2}\\; .$$\nIn general, the correction term $\\hat{\\beta}(\\phi-\\bar{y})$ will have a nonzero mean, which introduces a bias in the estimate of $\\mu$.  To eliminate the bias, one can compute $\\hat{\\beta}$ from a pre-sample of $\\{x,y\\}$ values.  \n\nAs an example of a control variate, in our simulation code to estimate the Black Scholes price for a call option we can use the stock price itself.  The known stock price is the inout price $S0$.  The simulation also produces an estimate for the stock price as the dicsounted expected value of the terminal stock price  $\\hat{S}=\\sum_{i=1}^{n} e^{- r T } St(m,i)$ where $St(m,i)$ is the $i$th simulated stock price at time $T$.  Theoretically these should be the same umber, but due to error they typically wil not be the same.\n\n::: {#4ed66b9a .cell execution_count=4}\n``` {.python .cell-code}\nSS=np.mean(St[m,:])*np.exp(-r*T)\nprint('The Estimated Stock Price for the first sample is =', SS)\nprint('The actual stock price should be=', S0)\nprint('The error is =', S0-SS)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Estimated Stock Price for the first sample is = 42.05899999577932\nThe actual stock price should be= 42\nThe error is = -0.058999995779316805\n```\n:::\n:::\n\n\nThe error is $S0-\\hat{S}$ which corresponds to $\\phi-y$ above.  We then compute $\\hat{\\beta}$ and comute the improved estimate\n$$ \\text{new estimate}= \\text{original estimate} +\\hat{\\beta}(S0-\\hat{S}) $$\nIn the code below we do this procedure for both samples and average the updates.\n\n::: {#c239aefc .cell execution_count=5}\n``` {.python .cell-code}\nhatbeta= np.cov(St[m,:],cc)[0,1]/np.cov(St[m,],cc)[1,1]\nhatbeta1=np.cov(St1[m,:],cc1)[0,1]/np.cov(St1[m,],cc1)[1,1]\ncorrection =hatbeta*(S0-SS)\nupdate=cp + correction\nprint('hatbeta=',hatbeta)\nprint('The original estimate for the call price from the first sample=',cp)\nprint('The original estimate for the call price from the second sample=',cp1)\nprint('The updated estimate from the first sample is=',update)\nSS1=np.mean(St1[m,:])*np.exp(-r*T)\nupdate1=cp1+hatbeta1*(S0-SS1)\nprint('The updated estimate from the second sample is=',update1)\nprint('The average of the updated estimates =',(update+update1)/2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhatbeta= 1.154118640341172\nThe original estimate for the call price from the first sample= 4.791646287615179\nThe original estimate for the call price from the second sample= 4.687624646438364\nThe updated estimate from the first sample is= 4.723553292706219\nThe updated estimate from the second sample is= 4.780385012196883\nThe average of the updated estimates = 4.751969152451551\n```\n:::\n:::\n\n\nWe can compare this to the exact Black Scholes formula from before.\n\n::: {#dd2d79b0 .cell execution_count=6}\n``` {.python .cell-code}\nprint('The exact Black Scholes Price is=', truebsc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe exact Black Scholes Price is= 4.759422392871532\n```\n:::\n:::\n\n\nAs another example,  consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call \\index{average-price option} \\index{geometric-average option} as a control variate.  Let $\\tau$ denote the amount of time that has elapsed since the call was issued and $T$ the amount of time remaining before maturity, so the total maturity of the call is $T+\\tau$.  To simplify somewhat,  assume date $0$ is the beginning of a period between observations.  Let $t_1, \\ldots, t_N$ denote the remaining sampling dates, with $t_1 = \\Delta t$, $t_i-t_{i-1}=\\Delta t = T/N$ for each $i$, and $t_N=T$.  We will input the average price $A(0)$ computed up to date $0$, assuming this average includes the price $S(0)$ at date $0$.  The average price at date $T$ will be \n$$A(T) = \\frac{\\tau}{T+\\tau}A(0) + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S(t_i)}{N}\\right)\\; .$$\nThe average-price call pays $\\max(0,A(T)-K)$ at its maturity $T$, and we can write this as\n\\begin{align*}\n\\max(A(T)-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S(t_i)}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A(0)\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S(t_i)}{N} - K^*,0\\right)\\;,\n\\end{align*}\nwhere \n$$K^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A(0)\\; .$$\nTherefore, the value at date $0$ of the discretely-sampled average-price call is\n$$\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} E^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S(t_i)}{N} - K^*,0\\right)\\right]\\; .$$\nIn terms of the discussion above, the random variable  the mean of which we want to estimate is\n$$x = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S(t_i)}{N} - K^*,0\\right)\\; .$$\nA random variable $y$ that will be closely correlated to $x$ is\n$$y =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S(t_i)/N} - K^*,0\\right)\\; .$$\nThe mean $\\phi$ of $y$ under the risk-neutral probability is given in the pricing @eq-disc_geom_avg_call. \nWe can use the sample mean of $y$ and its known mean $\\phi$ to adjust the sample mean of $x$ as an estimator of the value of the average-price call.  Generally, the estimated adjustment coefficient $\\hat{\\beta}$ will be quite close to 1.  \n\n## Monte Carlo Greeks I: Difference Ratios {#sec-s_montecarlogreeks1}\n\nGreeks can be calculated by Monte Carlo by running the valuation program twice and computing a difference ratio, for example $(C_u-C_d)/(S_u-S_d)$ to estimate a delta.  However, to minimize the error, and minimize the number of computations required, one should use the same set of random draws to estimate the derivative value for different values of the parameter.  For path-independent options (e.g., European puts and calls) under the Black-Scholes assumptions, we only need to generate $S(T)$ and then we can compute $S_u(T)$ as $[S_u(0)/S(0)] \\times S(T)$ and $S_d(T)$ as $[S_u(0)/S(0)] \\times S(T)$.  We can estimate standard errors for the Greeks in the same way that we estimate the standard error of the derivative value.  \n\nActually, there is often a better method available that is just as simple.  This is called pathwise calculation.  We will explain this in the next section.   Here we will describe how to estimate the delta and gamma of a derivative as sample means of difference ratios.\n\nConsider  initial prices for the underlying $S_u>S>S_d$.  Denote the underlying price at the option maturity in a given simulation by $S_u(T)$  when the initial underlying price is $S_u$, by $S(T)$  when the initial underlying price is $S$, and by $S_d(T)$  when the initial underlying price is $S_d$.   Under the Black-Scholes assumptions, the logarithm of the stock price at date $T$ starting from the three initial prices $S_d$, $S$ and $S_u$ is\n\\begin{align*}\n\\log S_d(T) &= \\log S_d + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B(T)\\; ,\\\\\n\\log S(T) &= \\log S + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B(T)\\; ,\\\\\n\\log S_u (T) &= \\log S_u + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B(T)\\;,\n\\end{align*}\nso \n$$\\log S_d(T) = \\log S(T) + \\log S_d - \\log S\\Longrightarrow S_d(T) = \\left(\\frac{S_d}{S}\\right) S(T)\\; ,$$\nand\n$$\\log S_u(T) = \\log S(T) + \\log S_u - \\log S \\Longrightarrow S_u(T) = \\left(\\frac{S_u}{S}\\right) S(T)\\; .$$\nTherefore, under the Black-Scholes assumptions, we only need to simulate $S(T)$ and then perform the multiplications indicated above to obtain $S_d(T)$ and $S_u(T)$. \n\nConsider a particular simulation and let $C_d(T)$ denote the value of the derivative at maturity  when the initial asset price is $S_d$, let  $C(T)$ denote the value of the derivative at maturity  when the initial asset price is $S$, and let $C_u(T)$ denote the value of the derivative at maturity  when the initial asset price is $S_u$.  For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of $S(T)$ as just described.  However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).\n\nThe estimates $C_d$, $C$ and $C_u$ of the date--0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the $C_d(T)$, $C(T)$ and $C_u(T)$.\nOne way to estimate the delta is $(C_u-C_d)/(S_u-S_d)$.  This is a difference of discounted sample means, multiplied by the reciprocal of $S_u-S_d$.  Equivalently, it is the sample mean of the differences $C_u(T)-C_d(T)$, multiplied by $\\mathrm{e}^{-rT}/(S_u-S_d)$.  As a sample mean, its standard error can be estimated as described in @sec-c_stochasticvolatility.   The standard error is\n$$\\frac{\\mathrm{e}^{-rT}}{S_u-S_d}\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^M \\left[C_{ui}(T)-C_{di}(T)\\right]^2 - M\\left[\\overline{C_{u}(T)}-\\overline{C_{d}(T)}\\right]^2\\right)}\\; ,$$ \\index{standard error}\nwhere the overline denotes the sample mean and where $C_{ui}(T)$ [respectively, $C_{di}(T)$] denotes the value of the derivative at maturity in simulation $i$ when the initial asset price is $S_u$ [respectively, $S_d$].\n\nThe corresponding Monte Carlo estimate of the gamma is also a sample mean.  Simple algebra shows that @eq-binomialgamma100 is equivalent to\n$$\n\\Gamma = \\frac{2}{(S_u-S)(S_u-S_d)}C_u - \\frac{2}{(S_u-S)(S-S_d)}C +\\frac{2}{(S-S_d)(S_u-S_d)}C_d\\;.\n$$ {#eq-binomialgamma200}\n\nNormally one would take $S_u=(1+\\alpha)S$ and $S_d = (1-\\alpha)S$ for some $\\alpha$ (e.g., $\\alpha=0.01$).  In this case  @eq-binomialgamma200\nsimplifies to\n$$\n\\Gamma = \\frac{C_u - 2C + C_d}{\\alpha^2S^2}\\;,\n$$ {#eq-binomialgamma300}\n\nand the standard error of the gamma is\n\n\\begin{multline*}\\frac{\\mathrm{e}^{-rT}}{\\alpha^2S^2}\\sqrt{\\frac{1}{M(M-1)}}\\\\\n\\times \\sqrt{\\sum_{i=1}^M \\left[C_{ui}(T)-2C_i(T)+C_{di}(T)\\right]^2 -M\\left[\\overline{C_{u}(T)}-2\\overline{C(T)}+\\overline{C_{d}(T)}\\right]^2}\\; .\n\\end{multline*}\n\n\n## Monte Carlo Greeks II: Pathwise Estimates {#sec-s_montecarlogreeks2}\nWe will examine the bias in the Monte Carlo delta estimate discussed in the preceding section and explain  pathwise estimation of Greeks. By biased, we mean that the expected value of an estimate is different from the true value. \\index{bias} It is important to recognize that if a Monte Carlo estimate is biased, then, even if a large number of simulations is used and the standard error is nearly zero, the answer provided by the Monte Carlo method will be incorrect.   For simplicity, consider a European call under the Black-Scholes assumptions.  \n\nThe delta estimate we have considered is the discounted sample mean of \n$$\n\\frac{C_u(T) - C_d(T)}{S_u-S_d}\\;.$$ {#eq-montecarlodelta2}\n\n\nThis ratio takes on one of three values, depending on $S(T)$:\n\n\n- If $S_u(T) \\leq K$ then the option is out of the money in both the up and down cases; i.e., \n$$C_u(T) = C_d(T) = 0\\; ,$$\nso the ratio @eq-montecarlodelta2 is zero.\n- If $S_d(T) \\geq K$ then the option is in the money in both the up and down cases; i.e.,\n\\begin{align*} C_u(T) &= S_u(T) - K =\\left(\\frac{S_u}{S}\\right)S(T) - K\\; ,\\\\\nC_d(T) &= S_d(T) - K = \\left(\\frac{S_d}{S}\\right)S(T) - K\\;,\n\\end{align*}\nso the ratio  @eq-montecarlodelta2 equals $S(T)/S$.\n- If $S_u(T) > K > S_d(T)$, then the option is in the money in only the up case; i.e.,\n\\begin{align*}\nC_u(T) &= S_u(T) - K = \\left(\\frac{S_u}{S}\\right)S(T) - K\\; ,\\\\\nC_d(T) &= 0\\;,\n\\end{align*}\nso the ratio @eq-montecarlodelta2 equals \n$$\\frac{\\left(\\frac{S_u}{S}\\right)S(T) - K}{S_u-S_d} < \\frac{S(T)}{S}\\; .$$\n\n\nThe bias is induced by the third case above.  We can see this as follows.  We are trying to estimate\n$$\n\\frac{\\partial }{\\partial S} \\mathrm{e}^{-rT}E^R \\big[\\max(0,S(T)-K)\\big] = \\mathrm{e}^{-rT}E^R  \\left[ \\frac{\\partial }{\\partial S} \\max(0,S(T)-K)\\right]\\;.\n$$ {#eq-montecarlodelta4}\n\nThe delta estimate $(C_u-C_d)/(S_u-S_d)$ replaces the mean $E^R$ with the sample mean and replaces\n$$\n\\frac{\\partial }{\\partial S} \\max(0,S(T)-K)\n$$ {#eq-montecarlodelta3}\n\nwith the ratio @eq-montecarlodelta2.  The derivative @eq-montecarlodelta3 takes on two possible values, depending on $S(T)$---we can ignore the case $S(T)=K$ because it occurs with zero probability:\n\n\n- If $S(T) < K$, then $\\max(0,S(T)-K) = 0$ and the derivative is zero.\n- If $S(T)>K$,  then $\\max(0,S(T)-K) = S(T)-K$ and the derivative equals \n$$\\frac{\\partial S(T)}{\\partial S}=\\mathrm{e}^{(r-q-\\sigma^2/2)T + \\sigma B(T)} = \\frac{S(T)}{S}\\; .$$\n\nTherefore, the true delta---the expectation @eq-montecarlodelta4---equals^[By changing numeraires, we can show that @eq-montecarlodelta5 equals $\\mathrm{e}^{-qT}E^V[x] = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)$, as we know from @sec-c_blackscholes is the delta of a European call in the Black-Scholes model (here, as in @sec-c_blackscholes, $V(t)=\\mathrm{e}^{qt}S(t)$ denotes the value of the non-dividend-paying portfolio created from the stock).] \n$$\n\\mathrm{e}^{-rT}E^R\\left[\\frac{S(T)}{S} x\\right]\\;,\n$$ {#eq-montecarlodelta5}\n\nwhere $x$ is the random variable defined as\n\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S(T)>K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\n On the other hand, our  analysis of the ratio @eq-montecarlodelta2 shows that the expected value of the delta estimate $(C_u-C_d)/(S_u-S_d)$ is\n$$\n\\mathrm{e}^{-rT}E^R\\left[\\frac{S(T)}{S} y\\right] + \\mathrm{e}^{-rT}E^R\\left[\\frac{S_uS(T)-SK}{S(S_u-S_d)}z\\right]\\;,\n$$ {#eq-montecarlodelta6}\n\nwhere\n\\begin{align*}\ny &=  \\begin{cases} 1 & \\text{if} S_d(T)>K\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\nand\n\\begin{align*}\nz &=  \\begin{cases} 1 & \\text{if} S_u(T)>K>S_d(T)\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\nTo contrast @eq-montecarlodelta5 and @eq-montecarlodelta6, note that if $y=1$ then $x=1$, so the term \n$E^R\\left[\\frac{S(T)}{S} y\\right]$ in @eq-montecarlodelta6 is part of @eq-montecarlodelta5.  However, there are two partially offsetting errors in @eq-montecarlodelta6: $z$ sometimes equals one when $x$ is zero, and when both $z$ and $x$ are one, then the factor multiplying $z$ is smaller than the factor multiplying $x$.  In any case, the expected value @eq-montecarlodelta6  is not the same as the true delta @eq-montecarlodelta5.  As noted before, this implies that the delta estimate will be incorrect even if its standard error is zero.  The bias can be made as small as one wishes by taking the magnitude $S_u-S_d$ of the perturbation to be small, but taking the perturbation to be very small will introduce unacceptable roundoff error.\n\nThe obvious way to estimate the delta in this situation is simply to compute the discounted sample average of $[S(T)/S]x$.  This is called a pathwise estimate \\index{pathwise Monte Carlo Greeks} of the delta, because it only uses the sample paths of $S(t)$ rather than considering up and down perturbations.  This method is due to Broadie and Glasserman [@bg2]. Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.\n\nTo compute pathwise estimates in other models and for other Greeks, we need the Greek to be an expectation as on the right-hand side of @eq-montecarlodelta4.  Additional examples can be found in  Glasserman [@Glasserman] and J\\\"ackel [@Jackel].\n\n\n\n## Exercises\n\n",
    "supporting": [
      "Chapter_MonteCarlo_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}