{
  "hash": "1ce91a5627382134dbef8fd253336da1",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n\n# GARCH Models {#sec-c:garch} \n\n::: {#95373c9f .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"></script>\n```\n:::\n:::\n\n\nThus far, we have assumed that the volatility of the underlying asset is constant or varying in a non-random way during the lifetime of the derivative.  In this chapter we will look at models that relax this assumption and allow the volatility to change randomly.  This is very important, because there is plenty of evidence that volatilities do change over time in a random way.  \n\nIn the first three sections, we will consider the problem of estimating the volatility.  The discussion of estimation methods leads naturally into the discussion of modeling a changing volatility.  \n\n## Statistics Review {#sec-s:statistics}\n\nWe begin with a brief review of basic statistics.\nGiven a random sample $\\{x_1,\\ldots,x_N\\}$ of size $N$ from a population with mean $\\mu$ and variance $\\sigma^2$, the best estimate of $\\mu$ is of course the sample mean \n$$\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N}x_i\\; .$$\nThe variance is the expected value of $(x-\\mu)^2$, so an obvious estimate of the variance is the sample average of $(x_i-\\mu)^2$, replacing $\\mu$ with its estimate $\\bar{x}$.  This would be\n$$\\frac{1}{N}\\sum_{i=1}^{N} (x_i-\\bar{x})^2$$\nHowever, because $\\bar{x}$ is computed from the $x_i$, the $x_i$ will deviate less on average from $\\bar{x}$ than they do from the true mean $\\mu$.  Hence the estimate proposed above will on average be less than $\\sigma^2$.  To eliminate this bias, it suffices just to scale the estimate up by a factor of $N/(N-1)$.  This leads to the estimate\n$$s^2=\\frac{1}{N-1}\\sum_{i=1}^{N} (x_i-\\bar{x})^2\\; ,$$\nand the best estimate of $\\sigma$ is the square root\n$$s=\\sqrt{\\frac{1}{N-1}\\sum_{i=1}^{N} (x_i-\\bar{x})^2}\\; .$$\nTo calculate $s^2$, notice that \n\\begin{align*}\n\\sum_{i=1}^{N} (x_i-\\bar{x})^2 &= \\sum_{i=1}^{N} (x_i^2-2x_i\\bar{x}+\\bar{x}^2)\\\\\n&=\\sum_{i=1}^{N} x_i^2 -2\\bar{x}\\sum_{i=1}^{N} x_i + \\sum_{i=1}^N \\bar{x}^2\\\\\n&=\\sum_{i=1}^{N} x_i^2 -2\\bar{x}(N\\bar{x})+N\\bar{x}^2\\\\\n&=\\sum_{i=1}^{N} x_i^2 -N\\bar{x}^2\\;.\n\\end{align*}\nTherefore\n$$s=\\sqrt{\\frac{1}{N-1}\\left(\\sum_{i=1}^{N} x_i^2-N\\bar{x}^2\\right)}\\; .$$\n\nIt is important to know how much variation there would be in $\\bar{x}$ if one had access to multiple random samples.  More variation means that an $\\bar{x}$ computed from a single sample will be a less reliable estimate of $\\mu$.  The variance of $\\bar{x}$ in repeated samples is $\\sigma^2/N$,^[The variance of $\\bar{x} = (1/N)(x_1 + \\cdots + x_N)$ is, by independence of the $x_i$, equal to $(1/N)^2(\\mathrm{var}{x_1} + \\cdots + \\mathrm{var}{x_N})$, and, because the $x_i$ all have the same variance $\\sigma^2$, this is equal to $(1/N)^2 \\times N\\sigma^2 = \\sigma^2/N$.] and our best estimate of this variance is $s^2/N$.  The standard deviation of $\\bar{x}$ in repeated samples, which is called the standard error of \\index{standard error} $\\bar{x}$, is $\\sigma/\\sqrt{N}$, and we estimate this by $s/\\sqrt{N}$, which equals\n$$\\sqrt{\\frac{1}{N(N-1)}\\left(\\sum_{i=1}^{N} x_i^2-N\\bar{x}^2\\right)}\\; .$$\nIf the population from which $x$ is sampled has a normal distribution, then a 95\\% confidence interval for $\\mu$ will be $\\bar{x}$ plus or minus 1.96 standard errors.  Even if $x$ does not have a normal distribution, by the Central Limit Theorem, $\\bar{x}/\\sqrt{N}$ will be approximately normally distributed if the sample size $N$ is large enough, and plus or minus 1.96 standard errors will still be approximately a 95\\% confidence interval for $\\mu$. \\index{confidence interval}\n\n## Estimating a Constant Volatility and Mean {#sec-s:estimatingvolatility}\n\nConsider an asset price that is a geometric Brownian motion under the actual probability measure:\n$$\\frac{\\d  S}{S} = \\mu\\d   t + \\sigma\\d   B\\; ,$$\nwhere $\\mu$ and $\\sigma$ are unknown constants and $B$ is a Brownian motion.  We can as usual write this in log form as\n$$\\d \\log S = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)\\d   t + \\sigma\\d   B\\; .$$\nOver a discrete time period of length $\\Delta t$, this implies\n$$\n\\Delta \\log S = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta B\\;.\n$$ {#eq-dlogs}\n\nSuppose we have observed the asset price $S$ at dates $0=t_0<t_1<\\cdots< t_N=T$, where $t_i-t_{i-1}=\\Delta t$.  If the asset pays dividends, we will take $S$ to be the value of the portfolio in which the dividends are reinvested in new shares.  Thus, in general, $S_{t_i}/S_{t_{i-1}}$ denotes the gross return (one plus the rate of return) between dates $t_{i-1}$ and $t_i$.  This return is measured on a non-compounded and non-annualized basis.  The annualized continuously-compounded rate of return is the rate $r_i$ defined by \n$$\\frac{S_{t_i}}{S_{t_{i-1}}} = \\mathrm{e}^{r_i\\Delta t}\\; .$$\nThis implies that\n$$\nr_i = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}}{\\Delta t} = \\mu-\\frac{1}{2}\\sigma^2 + \\sigma \\frac{B_{t_i}-B_{t_{i-1}}}{\\Delta t}\\;.\n$$ {#eq-contcompreturn}\n\nBecause $B_{t_i}-B_{t_{i-1}}$ is normally distributed with mean zero and variance $\\Delta t$, the sample $\\{r_1,\\ldots,r_N\\}$ is a sample of independent random variables each of which is normally distributed with mean $\\mu-\\sigma^2/2$ and variance $\\sigma^2/\\Delta t$.  We are focused on estimating $\\sigma^2$, so it will simplify things to define\n$$\ny_i = r_i\\sqrt{\\Delta t} = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}}{\\sqrt{\\Delta t}}\\;.\n$$ {#eq-volyi}\n\nThe sample $\\{y_1,\\ldots,y_N\\}$ is a sample of independent random variables each of which is normally distributed with mean $(\\mu-\\sigma^2/2)\\sqrt{\\Delta t}$ and variance $\\sigma^2$.\nAs was discussed in the previous section, the best estimate of the mean of $y$ is the sample mean\n$$\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N}y_i\\; ,$$\nand the best estimate of $\\sigma^2$ is\n$$\\hat{\\sigma}^2 = \\frac{1}{N-1}\\sum_{i=1}^{N} (y_i-\\bar{y})^2\\; .$$\nThis means that we estimate $\\mu$ as\n$$\\hat{\\mu} = \\frac{\\bar{y}}{\\sqrt{\\Delta t}} + \\frac{1}{2}\\hat{\\sigma}^2 = \\bar{r}+ \\frac{1}{2}\\hat{\\sigma}^2\\; .$$ \n\nLet us digress for a moment to discuss the reliability of $\\hat{\\mu}$ as an estimate of $\\mu$.  Notice that \n\n$$\n\\bar{r} \n= \\frac{\\sum_{i=1}^N \\log S_{t_i}-\\log S_{t_{i-1}}}{N\\Delta t}\n$$\n$$\n=   \\frac{\\log S_T-\\log S_0}{N\\Delta t}\n$$\n$$\n = \\frac{\\log S_T-\\log S_0}{T}\\;.\n$$ {#eq-volrbar}\n\n\nTherefore the first component $\\bar{r}$ of the estimate of $\\mu$ depends only on the total change in $S$ over the time period.  Hence, the reliability of this component cannot depend on how frequently we observe $S$ within the time period $[0,T]$.  The standard deviation of $\\bar{r}$ in repeated samples\nis the standard deviation of $[\\log S_T-\\log S_0]/T$, which is $\\sigma/\\sqrt{T}$.  This is likely to be quite large.  For example, with $\\sigma =0.3$ and ten years of data ($T=10$), the standard deviation of $\\bar{r}$ is 9.5\\%, which means that a 95\\% confidence interval will be a band of roughly 38\\%.  Given that $\\mu$ itself should be of the order of magnitude of 10\\%, such a wide confidence interval is useless for all practical purposes.\n\nFortunately, it is easier to estimate $\\sigma$.  We observed in the previous section that the $\\hat{\\sigma}^2$ defined above can be calculated as\n$$\n\\frac{1}{N-1}\\sum_{i=1}^N y_i^2 - \\frac{N\\bar{y}^2}{N-1}\\;.\n$$ {#eq-estimator_sig2}\n\nFrom @eq-volyi of $y_i$ and @eq-volrbar, we have\n$$\\bar{y} =  \\frac{\\sqrt{\\Delta t}}{T}[\\log S_T-\\log S_0]\\; .$$\nHence, the second term in @eq-estimator_sig2 is\n$$ \\frac{N}{N-1}\\left(\\frac{\\Delta t}{T^2}\\right)[\\log S_T-\\log S_0]^2\\; .$$\nIf we observe the stock price sufficiently frequently, so that $\\Delta t$ is very small, this term will be negligible.  In this circumstance,  $\\hat{\\sigma}^2$ is approximately\n\n$$\n\\frac{1}{N-1}\\sum_{i=1}^N y_i^2 = \\frac{1}{N-1}\\sum_{i=1}^N \\frac{[\\log S_{t_i}-\\log S_{t_{i-1}}]^2}{\\Delta t}\n$$\n$$\n= \\frac{N}{N-1}\\times \\frac{1}{T}\\times \\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2 \\;.\n$$ {#eq-estimator_sig2_3}\n\n\nIf we observe $S$ more and more frequently, letting $\\Delta t \\rightarrow 0$ and $N \\rightarrow \\infty$, the sum \n$$\\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2$$\nwill converge with probability one to $\\sigma^2T$, as explained in @sec-s:quadraticvariation.  This implies that $\\hat{\\sigma}^2$ will converge to $\\sigma^2$.  Thus, in theory, we can estimate $\\sigma^2$ with any desired degree of precision by simply observing $S$ sufficiently frequently.  This is true no matter how short the overall time period $[0,T]$ may be.  \n\nIn practice, this doesn't work out quite so well.  If we observe minute-by-minute data, or we observe each transaction, much of the variation in the price $S$ will be due to bouncing back and forth between the bid price and the ask price.  This is not really what we want to estimate, and this source of variation will be much less important if we look at weekly or even daily data.  So, there are practical limits to how frequently we should observe $S$.  Nevertheless, it is still true that, if $\\sigma^2$ were truly constant, we could estimate it with a very high degree of precision.\nIn fact, we can estimate the volatility of a stock with enough precision to determine that it really isn't constant!  The real problem that we face is to estimate and model a changing volatility.  \n\n## Estimating a Changing Volatility\nWithout attempting yet to model how the volatility may change, we can say a few things about how we might estimate a changing volatility.  In this and following sections, we will take the observation interval $\\Delta t$ to be fixed.  We assume it is small (say, a day or a week) and focus on the estimate @eq-estimator_sig2_3.  Recall from @sec-s:statistics that the reason we are dividing by $N-1$ rather than $N$ is that the sample standard deviation usually underestimates the actual standard deviation, because it uses the sample mean, which will be closer to the points $x_i$ than will be the true mean.  However, @eq-estimator_sig2_3 does not employ the sample mean (it replaces it with zero), so there is no reason to make this correction.  So, we take as our point of departure the estimate\n$$\\frac{1}{T} \\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2 = \\frac{1}{N}\\sum_{i=1}^N y_i^2 \\; .$$\nAn obvious response to the volatility changing over time is simply to avoid using data from the distant past.  Such data is not likely to be informative about the current value of the volatility.  What distant should mean in this context is not entirely clear, but, for example, we might want to use only the last 60 observations.  If we are using daily data, this would mean that at the end of each day we would add that day's observation and drop the observation from 61 days past.  This leads to a somewhat abruptly varying estimate.  For example, a very large movement in the price on a particular day increases the volatility estimate for the next 60 days.  On the 61st day, this observation would drop from the sample, leading to an abrupt drop in the estimate (presuming that there is not an equally large change in $S$ on the 61st day).  This seems unreasonable.  An estimate in which the impact of each observation decays smoothly over time is more attractive.  \n\nWe can construct such an estimate as\n$$\n\\hat{\\sigma}^2_{i+1} = (1-\\lambda) y_{i}^2 + \\lambda\\hat{\\sigma}^2_{i}\n$$ {#eq-sig_estimator4}\n\nfor any constant $0<\\lambda<1$.\nHere, $\\hat{\\sigma}^2_{i+1}$ denotes the estimate of the volatility from date $t_{i}$ to date $t_{i+1}$.  The estimate @eq-sig_estimator4 is a weighted average of the estimate $\\hat{\\sigma}^2_{i}$ for the previous time period and the most recently observed squared change $y_{i}^2$.  Following the same procedure, the next estimate will be\n\\begin{align*}\n\\hat{\\sigma}^2_{i+2}& = (1-\\lambda) y_{i+1}^2 + \\lambda\\hat{\\sigma}^2_{i+1}\\\\\n&= (1-\\lambda) y_{i+1}^2 + \\lambda(1-\\lambda)  y_{i}^2 + \\lambda^2\\hat{\\sigma}^2_{i}\\;.\n\\end{align*}\nLikewise, the estimate at the following date will be\n$$\\hat{\\sigma}^2_{i+3} = (1-\\lambda) y_{i+2}^2 +\\lambda(1-\\lambda) y_{i+1}^2 + \\lambda^2(1-\\lambda)^2  y_{i}^2 +\\lambda^{3}\\hat{\\sigma}^2_{i}\\; .$$\nThis demonstrates the declining importance of the squared deviation $y_{i}^2$ for future estimates.  At each date, $y_{i}^2$ enters with a weight that is lower by a factor of $\\lambda$, compared to the previous date. \nIf $\\lambda$ is small, the decay in the importance of each squared deviation will be fast.  In fact, @eq-sig_estimator4 shows that, if $\\lambda$ is close to zero, the estimate $\\hat{\\sigma}_{i+1}^2$ is approximately equal to the squared deviation $y_i^2$---previous squared deviations are relatively unimportant.  On the other hand, if $\\lambda$ is close to one, the decay will be slow; i.e., the importance of $y_i^2$ for the estimate $\\hat{\\sigma}^2_{i+2}$ will be nearly the same as for $\\hat{\\sigma}^2_{i+1}$, and nearly the same for $\\hat{\\sigma}^2_{i+3}$ as for $\\hat{\\sigma}^2_{i+2}$, etc.   This will lead to a smooth (slowly varying) volatility estimate.  The slowly varying nature of the estimate in this case is also clear from @eq-sig_estimator4, because it shows that if $\\lambda$ is close to one, then $\\hat{\\sigma}^2_{i+1}$ will be approximately the same as $\\hat{\\sigma}^2_{i}$.\n\nThis method can also be used to estimate covariances, simply by replacing the squared deviations $y_i^2$ by the product of deviations for two different assets.  And, of course, given covariance and variance estimates, we can construct estimates of correlations.  To ensure that an estimated correlation is between $-1$ and $+1$, we will need to use the same $\\lambda$ to estimate each of the variances and the covariance.  This is the method used by RiskMetrics.^[See Mina and Xiao [@MX], available online at www.riskmetrics.com]. \\index{RiskMetrics}\n\n## GARCH Models {#sec-s:garch}\n\nWe are going to adopt a subtle but important change of perspective now.  Instead of considering @eq-sig_estimator4 as simply an estimation procedure, we are going to assume that the actual volatility evolves according to @eq-sig_estimator4, or a generalization thereof.  We are also going to reintroduce the expected change in $\\log S$, which we dropped in going from @eq-estimator_sig2 to @eq-estimator_sig2_3.  Specifically, we return to @eq-dlogs, but we operate under the risk-neutral probability, so \n$\\mu=r-q$, and we have\n$$\n\\log S(t_{i+1}) - \\log S_{t_i} = \\left(r-q-\\frac{1}{2}\\sigma_{i+1}^2\\right)\\Delta t + \\sigma_{i+1} \\Delta B\\;.\n$$ {#eq-dlogs2}\n\nWe assume the volatility $\\sigma_{i+1}$ between dates $t_i$ and $t_{i+1}$ is given by\n$$\n\\sigma_{i+1}^2 = a + b y_{i}^2 + c \\sigma_i^2\\;,\n$$ {#eq-garch}\n\nfor some constants $a > 0$, $b\\geq 0$ and $c\\geq 0$, with $y_i$ now defined by\n$$y_i = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}-\\left(r-q-\\frac{1}{2}\\sigma_i^2\\right)\\Delta t}{\\sqrt{\\Delta t}}\\; .$$\nFrom @eq-dlogs2, applied to the period from $t_{i-1}$ to $t_i$, this implies that $y_i$ is normally distributed with mean zero and variance $\\sigma_i^2$, and of course $y_{i+1}$ has variance $\\sigma_{i+1}^2$, etc.  \nUnder these assumptions, the random process $\\log S$ is called a \\index{GARCH process} GARCH(1,1) process.^[GARCH is the acronym for Generalized Autoregressive Conditional Heteroskedastic.  GARCH(1,1) means that there is only one past $y$  (no $y_{i-1}$, $y_{i-2}$, etc.) and one past $\\sigma$ (no  $\\sigma_{i-1}$, $\\sigma_{i-2}$, etc.) in  @eq-garch.  See Bollerslev [@Bollerslev].]  There are many varieties of GARCH processes that have been proposed in the literature, but we will only consider GARCH(1,1), which is the simplest.\n\nWe assume $b+c<1$, in which case we can write the variance equation as a generalization of @eq-sig_estimator4.  Namely,\n%$$\\sigma_{i+1}^2 = (1-\\phi)d + \\phi\\left[(1-\\lambda) y_{i}^2 + \\lambda \\sigma^2_{i}\\right]\\; ,$$\n$$\n\\sigma_{i+1}^2 = \\kappa\\theta + (1-\\kappa)\\left[  (1-\\lambda) y_{i}^2 + \\lambda\\sigma^2_{i}\\right]\\;,\n$$ {#eq-garch10}\n\nwhere $\\lambda=c/(b+c)$, \n%$\\phi=b+c$, and $d=a/(1-b-c)$.  \n$\\kappa = 1-b-c$, and $\\theta=a/(1-b-c)$.  Hence, $\\sigma_{i+1}^2$ is a weighted average with weights $\\kappa$ and $1-\\kappa$, of two parts, one being the constant $\\theta$ and the other being itself a weighted average of $y_{i}^2$ and $\\sigma^2_{i}$.  Whatever the variance might be at time $t_i$, the variance of $y_j$ at any date $t_j$ far into the future, computed without knowing the intervening $y_{i+1}, y_{i+2},\\ldots$, will be approximately the constant $\\theta$.  The constant $\\theta$ is called the unconditional variance, \\index{unconditional variance} whereas $\\sigma_{i}^2$ is the conditional variance of $y_i$.  \\index{conditional variance}\n\nTo understand the unconditional variance, it is useful to consider the variance forecasting equation.  Specifically, we can calculate $\\\\E_{t_i} \\left[\\sigma_{i+n}^2\\right]$, which is the estimate made at date $t_i$ of the variance of $y_{i+n}$; i.e, we estimate the variance without having observed $y_{i+1},\\ldots,y_{i+n-1}$.  Note that by definition $\\\\E_{t_{i}}[y_{i+1}^2]=\\sigma_{i+1}^2$, so @eq-garch10 implies\n\\begin{align*}\n\\\\E_{t_{i}}\\left[\\sigma_{i+2}^2\\right] &= \\kappa\\theta + (1-\\kappa)\\left[  (1-\\lambda) \\\\E_{t_{i}}[y_{i+1}^2] + \\lambda\\sigma^2_{i+1}\\right] \\\\\n&= \\kappa\\theta + (1-\\kappa)\\sigma^2_{i+1}\\; .\n\\end{align*}\nLikewise,\n$$\\\\E_{t_{i+1}}\\left[\\sigma_{i+3}^2\\right] = \\kappa\\theta + (1-\\kappa)\\sigma^2_{i+2}\\; ,$$\nand taking the expectation at date $t_i$ of both sides of this yields\n\\begin{align*}\n\\\\E_{t_{i}}\\left[\\sigma_{i+3}^2\\right] = \\\\E_{t_{i}}\\left[\\\\E_{t_{i+1}}\\left[\\sigma_{i+3}^2\\right]\\right] &=\\kappa\\theta + (1-\\kappa)\\\\E_{t_{i}}\\left[\\sigma_{i+2}^2\\right]\\\\\n&=\\kappa\\theta + (1-\\kappa)\\left[\\kappa\\theta + (1-\\kappa)\\sigma^2_{i+1}\\right]\\\\\n&=\\kappa\\theta[1+(1-\\kappa)] + (1-\\kappa)^2\\sigma^2_{i+1}\\;.\n\\end{align*}\nThis generalizes to\n$$\\\\E_{t_{i}}\\left[\\sigma_{i+n}^2\\right] = \\kappa\\theta\\left[1+(1-\\kappa)+ \\cdots (1-\\kappa)^{n-2}\\right] + (1-\\kappa)^{n-1}\\sigma^2_{i+1}\\; .$$\nThus, there is decay at rate $\\kappa$ in the importance of the current volatility $\\sigma^2_{i+1}$ for forecasting the future volatility.  Furthermore, as $n\\rightarrow \\infty$, the geometric series\n$$1+(1-\\kappa)+ \\cdots (1-\\kappa)^{n-2}$$\nconverges to $1/\\kappa$, so, as $n \\rightarrow \\infty$ we obtain\n$$\\\\E_{t_{i}}\\left[\\sigma_{i+n}^2\\right] \\rightarrow \\theta\\; .$$\nThis means that our best estimate of the conditional variance, at some date far in the future, is approximately the unconditional variance $\\theta$.\n\nThe most interesting feature of the volatility equation is that large returns (in absolute value) lead to an increase in the variance and hence are likely to be followed by more large returns (whether positive or negative).  This is the phenomenon of volatility clustering, \\index{volatility clustering} which is quite observable in actual markets.  This feature also implies that the distribution of returns will be fat tailed  (more technically, leptokurtic).  \\index{leptokurtic} This means that the probability of extreme returns is higher than under a normal distribution with the same standard deviation.^[Conversely, the probability of returns very near the mean must also be higher than under a normal distribution with the same standard deviation---a fat-tailed distribution must also have a relatively narrow peak.]  It is well documented that daily and weekly returns in most markets have this fat-tailed property.\n\nWe can simulate a path of an asset price that follows a GARCH process and the path of its volatility as follows.  The following python code produces three columns of data (with headings), the first column being time, the second  the asset price, and the third  the volatility.\n\n::: {#f178024d .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport pandas as pd\n\ndef simulating_garch(S, sigma, r, q, dt, N, theta, kappa, lambd):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    sigma = initial volatility\n    r = risk-free rate\n    q = dividend yield\n    dt = length of each time period (Delta t)\n    N = number of time periods\n    theta = theta parameter for GARCH\n    kappa = kappa parameter for GARCH\n    lambd = lambda parameter for GARCH\n    \"\"\"\n    LogS = np.log(S)\n    Sqrdt = np.sqrt(dt)\n    a = kappa * theta\n    b = (1 - kappa) * (1 - lambd)\n    c = (1 - kappa) * lambd\n    \n    time = np.zeros(N + 1)\n    stock_price = np.zeros(N + 1)\n    volatility = np.zeros(N + 1)\n    \n    stock_price[0] = S\n    volatility[0] = sigma    \n    \n    for i in range(1, N + 1):\n        time[i] = i * dt\n        y = sigma * np.random.randn()\n        LogS = LogS + (r - q - 0.5 * sigma * sigma) * dt + Sqrdt * y\n        S = np.exp(LogS)\n        stock_price[i] = S\n        sigma = np.sqrt(a + b * y ** 2 + c * sigma ** 2)\n        volatility[i] = sigma\n\n    df_garch = pd.DataFrame({'Time': time, 'Stock Price': stock_price, 'Volatility': volatility})\n    df_garch.to_csv('garch_simulation.csv', index=False)\n    return df_garch\n\n# Example usage:\nS = 100       # Initial stock price\nsigma = 0.2   # Initial volatility\nr = 0.05      # Risk-free rate\nq = 0.02      # Dividend yield\ndt = 1/252    # Length of each time period (daily)\nN = 252       # Number of time periods (one year)\ntheta = 0.1   # Theta parameter for GARCH\nkappa = 0.1   # Kappa parameter for GARCH\nlambd = 0.9   # Lambda parameter for GARCH\n\ndf_garch = simulating_garch(S, sigma, r, q, dt, N, theta, kappa, lambd)\nprint(df_garch)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Time  Stock Price  Volatility\n0    0.000000   100.000000    0.200000\n1    0.003968   100.199762    0.206123\n2    0.007937    98.087022    0.233983\n3    0.011905    95.742260    0.260066\n4    0.015873    94.016594    0.268839\n..        ...          ...         ...\n248  0.984127   110.281290    0.293693\n249  0.988095   109.411780    0.285078\n250  0.992063   108.299371    0.279602\n251  0.996032   106.029937    0.288896\n252  1.000000   107.266285    0.284035\n\n[253 rows x 3 columns]\n```\n:::\n:::\n\n\nTo price European options, we need to compute the usual probabilities \n$\\text{prob}^S(S_T>K)$ and $\\text{prob}^R(S_T >K)$.\nHeston and Nandi [@HN] provide a fast method for computing these probabilities in a GARCH (1,1) model.^[Actually, a slightly more general model is considered in [@HN], in which large negative returns lead to a greater increase in volatility than do large positive returns.  This accommodates the empirically observed negative correlation between stock returns and volatility.]  Rather than developing this approach, we will show in @sec-c:introcomputation how to apply Monte-Carlo methods.\n\n## Hedging and Market Completeness\n\nThe GARCH model is inherently a discrete-time model.  If returns have a GARCH structure at one frequency (e.g., monthly), they will not have a GARCH structure at a different frequency (e.g., weekly).  Hence, the return period (monthly, weekly, \\ldots) is part of the specification of the model.  One interpretation of the model is that the dates $t_i$ at which the variance changes are the only dates at which investors can trade.  Under this interpretation, it is impossible to perfectly hedge an option: the gross return $S_{t_i}/S_{t_{i-1}}$ over the interval $(t_{i-1},t_i)$ is lognormally distributed, so no portfolio of the stock and riskless asset formed at $t_{i-1}$ and held over the interval $(t_{i-1},t_i)$ can perfectly replicate the return of an option over the interval.  As discussed in @sec-s:incomplete, we call a market in which some derivatives cannot be perfectly hedged an incomplete market. \\index{incomplete market}  Thus, the GARCH model is an example of an incomplete market, if investors can only trade at the frequency at which returns have a GARCH structure.  However, it is unreasonable to assume that investors can only trade weekly or monthly or even daily.\n\nAnother interpretation of the GARCH model is that investors can trade continuously and the asset has a constant volatility within each period $(t_{i-1},t_i)$.  Under this interpretation, the market is complete and options can be delta-hedged.  The completeness is a result of the fact that the change $\\sigma_{i+1}-\\sigma_i$ in the volatility  at date $t_i$ (recall that $\\sigma_i$ is the volatility over the period $(t_{i-1},t_i)$ and $\\sigma_{i+1}$ is the volatility over the period $(t_{i},t_{i+1})$) depends only on $\\log S_{t_i}$.  Thus, the only random factor in the model that needs to be hedged is, as usual, the underlying asset price.  However, this interpretation of the model is also a bit strange.  Suppose for example that monthly returns are assumed to have a GARCH structure.  Then the model states that the volatility in February will be higher if there is an unusually large return (in absolute value) in January.  Suppose there is an unusually large return in the first half of January.  Then, intuitively, one would expect the change in the volatility to occur in the second half of January rather than being delayed until February.  However, the model specifies that the volatility is constant during each month, hence constant during January in this example.\n\n\n\n## {.unnumbered}\n\n::: {#exr-e_mixture}\n  The purpose of this exercise is to generate a fat-tailed distribution from a model that is simpler than the GARCH and stochastic volatility models but has somewhat the same flavor.  The distribution will be a mixture of normals. Create a python program in which the user can input $S$, $r$, $q$, $T$, $\\sigma_1$ and $\\sigma_2$.  Use these inputs to produce a column of 500 simulated $\\log S_T$.  In each simulation, define $\\log S_T$ as\n$$\\log S_T = \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma \\sqrt{T}z\\;,$$\nwhere $z$ is a standard normal,\n$\\sigma = x\\sigma_1 + (1-x)\\sigma_2$,\nand $x$ is a random variable that equals zero or one with equal probabilities.  \n\nCalculate the mean and standard deviation of the $\\log S_T$ and calculate the fraction that lie more than two standard deviations below the mean.  If the $\\log S_T$ all came from a normal distribution with the same variance, then this fraction should equal $\\mathrm{N}(-2) =$ 2.275\\%.  If the fraction is higher, then the distribution is fat tailed.  (Of course, the actual fraction would differ from 2.275\\% in any particular case due to the randomness of the simulation, even if all of the $\\log S_T$ came from a normal distribution with the same variance).\n:::\n\n::: {#exr-e_GARCH1}\n  Create a python program prompting the user to input the same inputs as in the `simulating_garch` function except for the initial volatility and $\\theta$.  Simulate 500 paths of a GARCH process and output $\\log S_T$ for each simulation (you don't need to output the entire paths as in the `simulating_garch` function).  Take the initial volatility to be 0.3 and $\\theta = 0.09$.  Determine whether the distribution is fat-tailed by computing the fraction of the $\\log S_T$ that lie two or more standard deviations below the mean, as in the previous exercise.  For what values of $\\kappa$ and $\\lambda$ does the distribution appear to be especially fat-tailed? \n:::\n::: Exercise\n Repeat @exr-e_GARCH1 for the Heston stochastic volatility model, describing the values of $\\kappa$,  $\\gamma$ and $\\rho$ that appear to generate especially fat-tailed distributions.\n\n:::\n\n",
    "supporting": [
      "Chapter_GARCH_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\nif (typeof require !== 'undefined') {\nrequire.undef(\"plotly\");\nrequirejs.config({\n    paths: {\n        'plotly': ['https://cdn.plot.ly/plotly-2.35.2.min']\n    }\n});\nrequire(['plotly'], function(Plotly) {\n    window._Plotly = Plotly;\n});\n}\n</script>\n\n"
      ]
    }
  }
}