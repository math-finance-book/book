{
  "hash": "f28b652624a4335a3ab9527a503ec6d5",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n# Binomial Tree Models {#sec-c:trees}\n\n::: {#20c7f9b9 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"></script>\n```\n:::\n:::\n\n\nThis chapter introduces binomial tree models for valuing derivative securities. We begin with the fundamental concepts of arbitrage pricing in a one-period model, extend to multi-period trees, and then discuss practical implementation and parameter calibration.\n\n## One-Period Binomial Model\n\nWe start with the simplest possible model. A stock has price $S$ today (date 0) and will have one of two possible values at date $t$: either $S_u$ (up state) or $S_d$ (down state), where $S_u > S_d$. There is also a risk-free asset earning a continuously compounded rate $r$.\n\n#### Delta Hedging and Replication\n\nConsider a European call option with strike $K$ and maturity $t$. Its payoff will be $C_u = \\max(0, S_u - K)$ in the up state and $C_d = \\max(0, S_d - K)$ in the down state.\n\nThe key insight is that we can replicate the option payoff using a portfolio of the stock and risk-free asset. Let $\\delta$ be the number of shares we hold. This delta is chosen so that the portfolio has the same payoff as the option in both states:\n\n$$\\delta = \\frac{C_u - C_d}{S_u - S_d}$$\n\nTo see why this works, consider a portfolio that holds $\\delta$ shares of stock and borrows an amount $B$ at the risk-free rate. The portfolio value at maturity will be:\n- Up state: $\\delta S_u - B e^{rt}$\n- Down state: $\\delta S_d - B e^{rt}$\n\nFor replication, we need these to equal the option payoffs:\n$$\\delta S_u - B e^{rt} = C_u$$\n$$\\delta S_d - B e^{rt} = C_d$$\n\nSubtracting the second equation from the first:\n$$\\delta(S_u - S_d) = C_u - C_d$$\n\nThis gives us our delta formula. We can solve for the borrowing amount:\n$$B = e^{-rt}(\\delta S_u - C_u) = e^{-rt}(\\delta S_d - C_d)$$\n\nThe initial cost of this replicating portfolio is:\n$$\\text{Portfolio Cost} = \\delta S - B = \\delta S - e^{-rt}(\\delta S_u - C_u)$$\n\nBy no-arbitrage, this must equal the option price.\n\n::: Example\nSuppose $S = 100$, $S_u = 110$, $S_d = 90$, $K = 105$, $r = 0.05$, $t = 1$. Then:\n- $C_u = \\max(0, 110 - 105) = 5$\n- $C_d = \\max(0, 90 - 105) = 0$\n- $\\delta = \\frac{5 - 0}{110 - 90} = 0.25$\n- $B = e^{-0.05}(0.25 \\times 110 - 5) = e^{-0.05} \\times 22.5 \\approx 21.43$\n- Option price $= 0.25 \\times 100 - 21.43 = 3.57$\n\n**Verification:** In the up state, the portfolio is worth $0.25 \\times 110 - 22.5 = 5$, matching $C_u$. In the down state, it's worth $0.25 \\times 90 - 22.5 = 0$, matching $C_d$.\n\nThis delta hedging shows that by holding 0.25 shares and borrowing $21.43, we can perfectly replicate the option payoff.\n:::\n\n#### Risk-Neutral Valuation\n\nWe can rearrange the replication formula to express the option value as:\n\n$$C = \\pi_u C_u + \\pi_d C_d$$\n\nwhere the state prices are:\n\n$$\\pi_u = \\frac{S - \\mathrm{e}^{-rt}S_d}{S_u - S_d}, \\quad \\pi_d = \\frac{\\mathrm{e}^{-rt}S_u - S}{S_u - S_d}$$\n\nThese state prices satisfy:\n- $\\pi_u, \\pi_d > 0$ (under no-arbitrage condition $S_u/S > \\mathrm{e}^{rt} > S_d/S$)\n- $\\pi_u \\mathrm{e}^{rt} + \\pi_d \\mathrm{e}^{rt} = 1$\n\nThis motivates defining risk-neutral probabilities:\n\n$$p_u = \\pi_u \\mathrm{e}^{rt}, \\quad p_d = \\pi_d \\mathrm{e}^{rt}$$\n\nThen:\n\n$$C = \\mathrm{e}^{-rt}[p_u C_u + p_d C_d]$$\n\nThe option value is the discounted expected payoff under the risk-neutral probability measure. Note that:\n\n$$p_u = \\frac{\\mathrm{e}^{rt} - S_d/S}{S_u/S - S_d/S}$$\n\n## Two-Period Model\n\nNow consider a two-period model where the stock price evolves over two time steps of length $\\Delta t = t/2$. To simplify notation and ensure the tree recombines, we parameterize the price movements using multiplicative factors $u > 1$ and $d = 1/u < 1$.\n\nStarting from $S$, after one period the stock price is either $uS$ or $dS$. After two periods, the possible prices are:\n- $u^2S$ (two up moves)\n- $udS = S$ (one up, one down)  \n- $d^2S$ (two down moves)\n\nThe tree recombines because $ud = du = 1$, so the middle node has price $S$ regardless of the path taken.\n\n#### Backward Induction Process\n\nThe key to valuing options in multi-period trees is **backward induction**. We start at maturity and work backwards to find today's value.\n\n**Step 1: Final Period (t = 2)**\nCalculate option payoffs at each terminal node:\n- Node (2,2): $C_{uu} = \\max(0, u^2S - K)$ \n- Node (2,1): $C_{ud} = \\max(0, udS - K) = \\max(0, S - K)$\n- Node (2,0): $C_{dd} = \\max(0, d^2S - K)$\n\n**Step 2: Intermediate Period (t = 1)**\nAt each node, calculate the option value as the discounted risk-neutral expectation of the next period's values. \n\nAt the up node (1,1) with stock price $uS$:\n$$C_u = e^{-r\\Delta t}[p \\cdot C_{uu} + (1-p) \\cdot C_{ud}]$$\n\nAt the down node (1,0) with stock price $dS$:\n$$C_d = e^{-r\\Delta t}[p \\cdot C_{ud} + (1-p) \\cdot C_{dd}]$$\n\n**Step 3: Initial Period (t = 0)**\nFinally, calculate today's option value:\n$$C_0 = e^{-r\\Delta t}[p \\cdot C_u + (1-p) \\cdot C_d]$$\n\n**For American Options:**\nAt each intermediate node, compare continuation value with immediate exercise:\n- Up node: $C_u = \\max(\\text{continuation value}, \\max(0, uS - K))$\n- Down node: $C_d = \\max(\\text{continuation value}, \\max(0, dS - K))$\n\nThis backward induction process automatically finds the optimal exercise strategy by comparing holding vs. exercising at each node.\n\n#### Visual Representation of Two-Period Tree\n\nTo illustrate this backward induction process, let's create a visual representation of a two-period binomial tree:\n\n::: {#cell-fig-two-period-tree .cell execution_count=2}\n``` {.python .cell-code}\nimport pydot\nfrom IPython.display import Image, display\nimport numpy as np\n\n# Parameters for the example\nS0 = 100  # Initial stock price\nK = 100   # Strike price\nr = 0.05  # Risk-free rate\nsigma = 0.3  # Volatility\nT = 1.0   # Time to maturity\nN = 2     # Number of periods\n\n# Calculate tree parameters\ndt = T / N\nu = np.exp(sigma * np.sqrt(dt))\nd = 1 / u\np = (np.exp(r * dt) - d) / (u - d)\ndisc = np.exp(-r * dt)\n\n# Calculate stock prices at each node\n# Time 0\nS_00 = S0\n\n# Time 1\nS_10 = S0 * d      # Down\nS_11 = S0 * u      # Up\n\n# Time 2\nS_20 = S0 * d * d  # Down-Down\nS_21 = S0 * u * d  # Up-Down (= Down-Up)\nS_22 = S0 * u * u  # Up-Up\n\n# Calculate call option values (European call)\n# Time 2 (payoffs)\nC_20 = max(0, S_20 - K)\nC_21 = max(0, S_21 - K)\nC_22 = max(0, S_22 - K)\n\n# Time 1 (backward induction)\nC_10 = disc * (p * C_21 + (1-p) * C_20)  # Down node\nC_11 = disc * (p * C_22 + (1-p) * C_21)  # Up node\n\n# Time 0 (backward induction)\nC_00 = disc * (p * C_11 + (1-p) * C_10)\n\n# Create the graph\ngraph = pydot.Dot(graph_type='digraph', rankdir='LR', bgcolor='white')\n\n# Set graph attributes for better layout\ngraph.set_node_defaults(shape='circle', style='filled', fillcolor='lightblue', \n                       fontname='Arial', fontsize='10')\ngraph.set_edge_defaults(fontname='Arial', fontsize='9')\n\n# Add nodes with stock prices and option values\n# Time 0\ngraph.add_node(pydot.Node('t0', \n                         label=f't=0\\\\nS={S_00:.1f}\\\\nC={C_00:.2f}',\n                         fillcolor='lightgreen'))\n\n# Time 1\ngraph.add_node(pydot.Node('t1_u', \n                         label=f't=1 (Up)\\\\nS={S_11:.1f}\\\\nC={C_11:.2f}',\n                         fillcolor='lightyellow'))\ngraph.add_node(pydot.Node('t1_d', \n                         label=f't=1 (Down)\\\\nS={S_10:.1f}\\\\nC={C_10:.2f}',\n                         fillcolor='lightyellow'))\n\n# Time 2\ngraph.add_node(pydot.Node('t2_uu', \n                         label=f't=2 (UU)\\\\nS={S_22:.1f}\\\\nC={C_22:.2f}',\n                         fillcolor='lightcoral'))\ngraph.add_node(pydot.Node('t2_ud', \n                         label=f't=2 (UD)\\\\nS={S_21:.1f}\\\\nC={C_21:.2f}',\n                         fillcolor='lightcoral'))\ngraph.add_node(pydot.Node('t2_dd', \n                         label=f't=2 (DD)\\\\nS={S_20:.1f}\\\\nC={C_20:.2f}',\n                         fillcolor='lightcoral'))\n\n# Add edges with probabilities\ngraph.add_edge(pydot.Edge('t0', 't1_u', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t0', 't1_d', label=f'1-p={1-p:.3f}'))\n\ngraph.add_edge(pydot.Edge('t1_u', 't2_uu', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t1_u', 't2_ud', label=f'1-p={1-p:.3f}'))\n\ngraph.add_edge(pydot.Edge('t1_d', 't2_ud', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t1_d', 't2_dd', label=f'1-p={1-p:.3f}'))\n\n# Save and display\ngraph.write_png('binomial_tree.png')\ndisplay(Image('binomial_tree.png'))\n\nprint(f\"Tree parameters:\")\nprint(f\"u = {u:.4f}, d = {d:.4f}\")\nprint(f\"Risk-neutral probability p = {p:.4f}\")\nprint(f\"Discount factor = {disc:.4f}\")\nprint(f\"\\\\nFinal call option value: {C_00:.4f}\")\n```\n\n::: {.cell-output .cell-output-display}\n![Two-period binomial tree showing stock prices and option values with backward induction](Chapter_Trees_files/figure-html/fig-two-period-tree-output-1.png){#fig-two-period-tree}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTree parameters:\nu = 1.2363, d = 0.8089\nRisk-neutral probability p = 0.5064\nDiscount factor = 0.9753\n\\nFinal call option value: 12.8905\n```\n:::\n:::\n\n\nThe diagram shows:\n\n- **Green node**: Initial time (t=0) with today's stock price and option value\n- **Yellow nodes**: Intermediate time (t=1) showing values after backward induction\n- **Red nodes**: Terminal nodes (t=2) showing payoffs and final stock prices\n- **Edge labels**: Risk-neutral probabilities for up and down moves\n\nNotice how the option values at t=1 are computed by taking the discounted expected value of the t=2 payoffs using the risk-neutral probabilities. The tree recombines at the middle node (UD = DU), which keeps the number of nodes manageable.\n\n## N-Period Model\n\nThe extension to N periods is straightforward. With parameters $u$ and $d = 1/u$, after $n$ periods we have $n+1$ nodes with stock prices:\n\n$$S_j = u^j d^{n-j} S = u^{2j-n} S, \\quad j = 0, 1, \\ldots, n$$\n\nThe critical insight for efficient implementation is backward induction rather than computing all possible paths.\n\n#### Interactive N-Period Trees\n\nBefore diving into the implementation details, let's explore how N-period binomial trees behave with different parameters using an interactive tool:\n\n::: {#fig-binomial-trees}\n\n<iframe width=\"100%\" height=\"800\" src=\"https://binomial-trees.koyeb.app/\"></iframe>\n\n**Interactive Binomial Trees Explorer.** \nThis tool allows you to experiment with N-period binomial trees. Key features:\n- **Interest rate**: Enter the rate per period (for annual rate with N periods, use r/N)\n- **Up move**: This corresponds to $(u-1)$ where $u$ is our up factor\n- **Down move**: The model automatically sets $d = 1/u$ to ensure recombination\n- **Number of periods**: See how increasing N affects option values and convergence\n- **Option types**: Compare European and American option pricing\n- **Parameters**: Observe how volatility, strike price, and time to maturity affect values\n\nExperiment with different values to see how the theoretical concepts we've discussed translate into practice. Notice how American option values equal or exceed European values, and how the tree structure becomes more refined as N increases.\n\n:::\n\n#### Backward Induction Implementation\n\nFor American options especially, we must use backward induction. Here's how the algorithm works:\n\n::: {#ccd700b7 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\ndef binomial_american_detailed(S0, K, r, sigma, T, N, option_type='put'):\n    \"\"\"\n    Price American option using binomial tree with detailed backward induction\n    \n    This function shows exactly how backward induction works step by step\n    \"\"\"\n    # Step 1: Set up tree parameters\n    dt = T / N                          # Time per step\n    u = np.exp(sigma * np.sqrt(dt))     # Up factor\n    d = 1 / u                           # Down factor (ensures recombining tree)\n    p = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n    disc = np.exp(-r * dt)              # Discount factor\n    \n    print(f\"Tree parameters: u={u:.4f}, d={d:.4f}, p={p:.4f}\")\n    \n    # Step 2: Initialize option values at maturity (time N)\n    # At maturity, we have N+1 possible stock prices\n    V = np.zeros(N+1)  # Option values\n    S = np.zeros(N+1)  # Stock prices\n    \n    for j in range(N+1):\n        S[j] = S0 * (u**j) * (d**(N-j))  # Stock price at node j\n        if option_type == 'call':\n            V[j] = max(0, S[j] - K)      # Call payoff\n        else:\n            V[j] = max(0, K - S[j])      # Put payoff\n    \n    print(f\"\\nAt maturity (time {N}):\")\n    print(f\"Stock prices: {[f'{s:.2f}' for s in S]}\")\n    print(f\"Option values: {[f'{v:.4f}' for v in V]}\")\n    \n    # Step 3: Backward induction through the tree\n    for i in range(N-1, -1, -1):  # Work backwards from time N-1 to 0\n        print(f\"\\nTime step {i}:\")\n        \n        # At time i, we have i+1 nodes\n        new_V = np.zeros(i+1)\n        new_S = np.zeros(i+1)\n        \n        for j in range(i+1):\n            # Stock price at this node\n            new_S[j] = S0 * (u**j) * (d**(i-j))\n            \n            # Continuation value (discounted expected value)\n            continuation = disc * (p * V[j+1] + (1-p) * V[j])\n            \n            # Immediate exercise value\n            if option_type == 'call':\n                exercise = max(0, new_S[j] - K)\n            else:\n                exercise = max(0, K - new_S[j])\n            \n            # American option: take maximum of continuation and exercise\n            new_V[j] = max(continuation, exercise)\n            \n            print(f\"  Node {j}: S={new_S[j]:.2f}, Cont={continuation:.4f}, \"\n                  f\"Exercise={exercise:.4f}, Value={new_V[j]:.4f}\")\n        \n        # Update for next iteration\n        V = new_V.copy()\n        S = new_S.copy()\n    \n    return V[0]\n\n# Example with small tree to see the process\nprint(\"Detailed backward induction for 3-step American put:\")\nS0, K, r, sigma, T, N = 50, 50, 0.05, 0.3, 0.25, 3\nput_value = binomial_american_detailed(S0, K, r, sigma, T, N, 'put')\nprint(f\"\\nFinal American put value: {put_value:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDetailed backward induction for 3-step American put:\nTree parameters: u=1.0905, d=0.9170, p=0.5024\n\nAt maturity (time 3):\nStock prices: ['38.56', '45.85', '54.52', '64.83']\nOption values: ['11.4400', '4.1479', '0.0000', '0.0000']\n\nTime step 2:\n  Node 0: S=42.05, Cont=7.7438, Exercise=7.9517, Value=7.9517\n  Node 1: S=50.00, Cont=2.0553, Exercise=0.0000, Value=2.0553\n  Node 2: S=59.46, Cont=0.0000, Exercise=0.0000, Value=0.0000\n\nTime step 1:\n  Node 0: S=45.85, Cont=4.9684, Exercise=4.1479, Value=4.9684\n  Node 1: S=54.52, Cont=1.0184, Exercise=0.0000, Value=1.0184\n\nTime step 0:\n  Node 0: S=50.00, Cont=2.9713, Exercise=0.0000, Value=2.9713\n\nFinal American put value: 2.9713\n```\n:::\n:::\n\n\nNow here's the streamlined version for practical use:\n\n::: {#8782fe5a .cell execution_count=4}\n``` {.python .cell-code}\ndef binomial_american_fast(S0, K, r, sigma, T, N, option_type='put'):\n    \"\"\"\n    Efficient American option pricing using backward induction\n    \n    This version uses vectorized operations for speed\n    \"\"\"\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    disc = np.exp(-r * dt)\n    \n    # Initialize option values at maturity\n    # Use vectorized operations for efficiency\n    j_values = np.arange(N+1)\n    S_final = S0 * (u**j_values) * (d**(N-j_values))\n    \n    if option_type == 'call':\n        V = np.maximum(S_final - K, 0)\n    else:\n        V = np.maximum(K - S_final, 0)\n    \n    # Backward induction\n    for i in range(N-1, -1, -1):\n        j_values = np.arange(i+1)\n        S_current = S0 * (u**j_values) * (d**(i-j_values))\n        \n        # Continuation values (vectorized)\n        V_new = disc * (p * V[1:i+2] + (1-p) * V[0:i+1])\n        \n        # Exercise values\n        if option_type == 'call':\n            exercise = np.maximum(S_current - K, 0)\n        else:\n            exercise = np.maximum(K - S_current, 0)\n        \n        # Take maximum (American feature)\n        V = np.maximum(V_new, exercise)\n    \n    return V[0]\n\n# Examples\nprint(\"\\nAmerican option values:\")\nput_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'put')\ncall_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'call')\nprint(f\"American put (K=105): {put_american:.4f}\")\nprint(f\"American call (K=105): {call_american:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAmerican option values:\nAmerican put (K=105): 8.7476\nAmerican call (K=105): 8.0262\n```\n:::\n:::\n\n\n#### How the Code Works\n\n**Key algorithmic insights:**\n\n1. **Vectorization**: Instead of nested loops, we use NumPy arrays to compute all nodes at each time step simultaneously\n\n2. **Memory efficiency**: We only store option values for the current time step, not the entire tree\n\n3. **Backward induction logic**:\n   - Start with payoffs at maturity\n   - At each prior time step, compute continuation value as discounted expectation\n   - For American options, compare with immediate exercise value\n   - Take the maximum (American feature)\n\n4. **Risk-neutral probability**: The tree converges to the Black-Scholes model when $p = \\frac{e^{r\\Delta t} - d}{u - d}$ and we use the Cox-Ross-Rubinstein parameters.\n\n**Computational complexity**: \n- Time: $O(N^2)$ for American options (must visit all nodes)  \n- Space: $O(N)$ (only current time step stored)\n- This is much better than the $O(2^N)$ complexity of path enumeration\n\n## Parameter Calibration\n\nThe key question is how to choose the parameters $u$, $d$, and $p$ so that the binomial model approximates the continuous-time Black-Scholes model as $N \\to \\infty$.\n\n#### Cox-Ross-Rubinstein Parameters\n\nThe most popular choice, proposed by Cox, Ross, and Rubinstein, sets:\n\n$$u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u}, \\quad p = \\frac{\\mathrm{e}^{(r-q)\\Delta t} - d}{u - d}$$\n\nwhere $q$ is the dividend yield. This choice ensures:\n- The tree recombines ($ud = 1$)\n- The discrete model converges to geometric Brownian motion\n- The risk-neutral probability is well-defined when $d < \\mathrm{e}^{(r-q)\\Delta t} < u$\n\n#### Matching Moments\n\nFor the binomial model to converge properly to the continuous-time model, we need:\n\n$$\\frac{\\mathbb{E}[\\Delta \\log S]}{\\Delta t} \\to r - q - \\frac{\\sigma^2}{2}$$\n\n$$\\frac{\\mathrm{Var}[\\Delta \\log S]}{\\Delta t} \\to \\sigma^2$$\n\nThe Cox-Ross-Rubinstein parameters satisfy these conditions. With $u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}$ and $d = 1/u$:\n\n- $\\log u = \\sigma\\sqrt{\\Delta t}$ and $\\log d = -\\sigma\\sqrt{\\Delta t}$\n- The variance of $\\log(S_{t+\\Delta t}/S_t)$ is approximately $\\sigma^2 \\Delta t$ for small $\\Delta t$\n\n#### Alternative Parameters\n\nOther popular choices include:\n\n**Jarrow-Rudd**: Set $p = 1/2$ and adjust $u$ and $d$ to match the mean and variance:\n$$u = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t + \\sigma\\sqrt{\\Delta t}\\right)$$\n$$d = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t - \\sigma\\sqrt{\\Delta t}\\right)$$\n\n**Equal Probabilities**: This choice simplifies calculations but requires different up and down factors.\n\n#### Convergence and Accuracy\n\nThe binomial model converges to the Black-Scholes model as $N \\to \\infty$, but convergence is not monotonic. For European options:\n- Accuracy improves roughly as $O(1/N)$\n- Oscillations occur due to the discrete nature of the tree\n- Using $N \\approx 100$ typically gives prices accurate to a few cents\n\nFor American options:\n- The binomial model provides one of the most efficient numerical methods\n- Early exercise boundaries can be extracted from the tree\n- Smooth convergence requires larger $N$ than for European options\n\n## Summary\n\nThe binomial tree model provides an intuitive and flexible framework for option pricing:\n\n1. **One-period model**: Introduces replication and risk-neutral valuation\n2. **Multi-period extension**: Uses backward induction for path-independent claims\n3. **Parameter choice**: Cox-Ross-Rubinstein parameters with $u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}$ and $d = 1/u$ ensure convergence\n4. **Implementation**: Efficient for American options and provides exercise boundaries\n\nThe model's strength lies in its simplicity and ability to handle early exercise features. However, for path-dependent options or multiple underlying assets, the computational requirements grow exponentially, making Monte Carlo methods more attractive in those cases.\n\n## Exercises\n\n#### One-Period Model Exercises\n\n::: {#exr-trees1}\nIn a one-period binomial model with $S = 50$, $S_u = 60$, $S_d = 40$, and $r = 0.05$:\na) Calculate the risk-neutral probabilities\nb) Price a call option with strike $K = 55$\nc) Verify your answer using delta hedging\n:::\n\n::: {#exr-binomialcall}\nCreate a Python function in which the user inputs $S$, $S_d$, $S_u$, $K$, $r$ and $t$. Check that the no-arbitrage condition is satisfied ($S_d < Se^{rt} < S_u$). Compute the value of a call option in each of the following ways:\n\n1. Compute the delta and use the replication formula\n2. Compute the state prices and use linear pricing\n3. Compute the risk-neutral probabilities and use discounted expectation\n4. Compute the probabilities using the stock as numeraire\n\nVerify that all of these methods produce the same answer.\n:::\n\n::: {#exr-arbitrage2}\nIn a two-state model, a put option is equivalent to $\\delta_p$ shares of the stock, where $\\delta_p = (P_u-P_d)/(S_u-S_d)$ (this will be negative, meaning a short position) and some money invested in the risk-free asset. Derive the amount of money $x$ that should be invested in the risk-free asset to replicate the put option. The value of the put at date $0$ must be $x+\\delta_pS$.\n:::\n\n::: {#exr-arbitrage3}\nUsing the result of the previous exercise, repeat @exr-binomialcall for a put option using all four pricing methods.\n:::\n\n#### Two-Period and Multi-Period Exercises\n\n::: {#exr-trees-visual}\nModify the visual tree code to create a two-period tree for an American put option with $S_0 = 100$, $K = 105$, $r = 0.05$, $\\sigma = 0.3$, and $T = 0.5$. At each intermediate node, show both the continuation value and the immediate exercise value, highlighting when early exercise is optimal.\n:::\n\n::: {#exr-trees-algorithm}\nCompare the detailed backward induction algorithm with the fast vectorized version for pricing American options. Time both implementations for $N = 50, 100, 200, 500$ time steps. At what point does the speed difference become significant? Verify that both give identical results.\n:::\n\n::: {#exr-trees2}\nShow that in the Cox-Ross-Rubinstein model, the expected return on the stock under the risk-neutral measure equals the risk-free rate: $\\mathbb{E}^p[S_{t+\\Delta t}/S_t] = \\mathrm{e}^{r\\Delta t}$\n:::\n\n#### Parameter Calibration and Convergence\n\n::: {#exr-binomial1}\nConsider an at-the-money European call option on a dividend-reinvested stock with six months to maturity. Take the initial stock price to be $50, the interest rate to be 5% and $\\sigma = 30\\%$. Compute the value in a binomial model with $N = 10, 11, \\ldots, 30$ and plot the values against $N$. Is convergence monotone? Comment on the oscillations you observe.\n:::\n\n::: {#exr-binomial2}\nConsider the same option as in the previous problem. Roughly what value of $N$ is needed to get penny accuracy? (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)\n:::\n\n::: {#exr-trees4}\nCompare the convergence of European option prices using:\na) Cox-Ross-Rubinstein parameters: $u = e^{\\sigma\\sqrt{\\Delta t}}$, $d = 1/u$\nb) Jarrow-Rudd parameters: $p = 1/2$, adjust $u$ and $d$ to match moments\n\nPlot the option values against the number of time steps $N$ for both methods. Which converges faster? Which is more stable?\n:::\n\n::: {#exr-moment-matching}\nVerify that the Cox-Ross-Rubinstein parameters satisfy the moment-matching conditions:\na) Show that $\\frac{\\mathbb{E}[\\Delta \\log S]}{\\Delta t} \\to r - q - \\frac{\\sigma^2}{2}$ as $\\Delta t \\to 0$\nb) Show that $\\frac{\\mathrm{Var}[\\Delta \\log S]}{\\Delta t} \\to \\sigma^2$ as $\\Delta t \\to 0$\n\nwhere the expectation and variance are under the risk-neutral measure.\n:::\n\n#### American Options and Early Exercise\n\n::: {#exr-binomial4}\nThe early exercise premium is the difference between the value of an American option and the value of a European option with the same parameters. Compute the early exercise premium for an American put with varying:\na) Interest rates ($r = 0\\%, 2\\%, 5\\%, 10\\%$)\nb) Exercise prices ($K = 80, 90, 100, 110, 120$ with $S_0 = 100$)\nc) Time to maturity ($T = 0.25, 0.5, 1, 2$ years)\n\nUnder what circumstances is the early exercise premium relatively large?\n:::\n\n::: {#exr-trees3}\nImplement a function to compute the early exercise boundary for an American put option. Plot the boundary as a function of time to maturity for different parameter values. Explain intuitively why the boundary has the shape it does.\n:::\n\n::: {#exr-optimal-exercise}\nFor an American call option on a dividend-paying stock, show analytically that it may be optimal to exercise just before an ex-dividend date. Implement this in your binomial tree by adding discrete dividend payments and compare American and European call values.\n:::\n\n#### Advanced Applications\n\n::: {#exr-shout-option}\nA shout option is an option where the holder is entitled to \"shout\" at any time before expiration. Upon shouting, the holder receives the immediate exercise value paid at expiration, plus an at-the-money option with the same expiration. The payoff if the holder shouts at time $\\tau$ is $\\max(0, S(\\tau)-K, S_T-S(\\tau))$ where $K$ is the original strike.\n\na) Show that it is better to shout at some time where $S(\\tau) > K$ than to never shout at all\nb) Modify the backward induction algorithm to find the optimal shouting strategy\nc) Plot the optimal shouting boundary\n\n:::\n\n::: {#exr-barrier-option}\nA down-and-out barrier option is a call option that becomes worthless if the stock price ever falls below a barrier $B < S_0$. Modify the binomial tree algorithm to price such options by setting the option value to zero at any node where $S \\leq B$. Compare the barrier option price to a standard call for different barrier levels.\n:::\n\n::: {#exr-trinomial}\nExtend the binomial model to a trinomial model with three possible moves at each step: up by factor $u$, stay the same, or down by factor $d$. \na) Derive the risk-neutral probabilities $p_u$, $p_m$, $p_d$ for the three states\nb) Implement trinomial backward induction\nc) Compare trinomial and binomial convergence for the same $\\Delta t$\n:::\n\n",
    "supporting": [
      "Chapter_Trees_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\nif (typeof require !== 'undefined') {\nrequire.undef(\"plotly\");\nrequirejs.config({\n    paths: {\n        'plotly': ['https://cdn.plot.ly/plotly-2.35.2.min']\n    }\n});\nrequire(['plotly'], function(Plotly) {\n    window._Plotly = Plotly;\n});\n}\n</script>\n\n"
      ]
    }
  }
}