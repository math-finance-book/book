<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Mathematical Finance Book - 10&nbsp; Finite Difference Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter11.html" rel="next">
<link href="./Chapter9.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Mathematical Finance Book</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Asset Pricing Basics</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Continuous-Time Models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Black-Scholes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Estimating and Modelling Volatility</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo and Binomial Models</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Foreign Exchange</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter7.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Forward, Futures, and Exchange Options</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter8.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Exotic Options</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter9.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter10.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter11.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter12.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Fixed Income Derivatives</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter13.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Valuing Derivatives in the Extended Vasicek Model</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter14.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">A Brief Survey of Term Structure Models</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#discretizing-the-pde" id="toc-discretizing-the-pde" class="nav-link active" data-scroll-target="#discretizing-the-pde"><span class="toc-section-number">11</span>  Discretizing the PDE</a></li>
  <li><a href="#explicit-and-implicit-methods" id="toc-explicit-and-implicit-methods" class="nav-link" data-scroll-target="#explicit-and-implicit-methods"><span class="toc-section-number">12</span>  Explicit and Implicit Methods</a></li>
  <li><a href="#crank-nicolson" id="toc-crank-nicolson" class="nav-link" data-scroll-target="#crank-nicolson"><span class="toc-section-number">13</span>  Crank-Nicolson</a></li>
  <li><a href="#european-options" id="toc-european-options" class="nav-link" data-scroll-target="#european-options"><span class="toc-section-number">14</span>  European Options</a></li>
  <li><a href="#american-options" id="toc-american-options" class="nav-link" data-scroll-target="#american-options"><span class="toc-section-number">15</span>  American Options</a></li>
  <li><a href="#s_finitedifferencebarriers" id="toc-s_finitedifferencebarriers" class="nav-link" data-scroll-target="#s_finitedifferencebarriers"><span class="toc-section-number">16</span>  Barrier Options</a></li>
  <li><a href="#s_finitedifferences_matlab" id="toc-s_finitedifferences_matlab" class="nav-link" data-scroll-target="#s_finitedifferences_matlab"><span class="toc-section-number">17</span>  Calculations in VBA</a>
  <ul class="collapse">
  <li><a href="#crank-nicolson" id="toc-crank-nicolson" class="nav-link" data-scroll-target="#crank-nicolson">Crank-Nicolson</a></li>
  <li><a href="#crank-nicolson-for-european-options" id="toc-crank-nicolson-for-european-options" class="nav-link" data-scroll-target="#crank-nicolson-for-european-options">Crank-Nicolson for European Options</a></li>
  <li><a href="#crank-nicolson-for-barrier-options" id="toc-crank-nicolson-for-barrier-options" class="nav-link" data-scroll-target="#crank-nicolson-for-barrier-options">Crank-Nicolson for Barrier Options</a></li>
  </ul></li>
  <li><a href="#problems" id="toc-problems" class="nav-link" data-scroll-target="#problems">Problems</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="c_pde" class="quarto-section-identifier d-none d-lg-block"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span></h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>In this chapter we will see how to estimate derivative values by numerically solving the partial differential equation (pde) that the derivative value satisfies, using finite difference methods. More advanced discussions of this topic can be found in Wilmott, DeWynne and Howison <span class="citation" data-cites="WDH">[@WDH]</span>, Wilmott <span class="citation" data-cites="Wilmott">[@Wilmott]</span>, and Tavella <span class="citation" data-cites="Tavella">[@Tavella]</span>, among other places. We will only consider derivatives written on a single underlying asset, but the ideas generalize to derivatives written on multiple underlying assets (e.g., basket and spread options) in much the same way that binomial models can be applied to derivatives on multiple underlying assets. The curse of dimensionality is the same for finite difference methods as for binomial models—the computation time increases exponentially with the number of underlying assets # Fundamental PDE {#fundamentalpde}</p>
<p>Consider an asset with price <span class="math inline">\(S\)</span> and constant dividend yield <span class="math inline">\(q\)</span>.<br>
Set <span class="math inline">\(X=\log S\)</span>. Then we have <span class="math display">\[\D X = \nu\,\D t+\sigma\,\D B\; ,\]</span> where <span class="math inline">\(\nu =r-q-\sigma^2/2\)</span> and <span class="math inline">\(B\)</span> is a Brownian motion under the risk-neutral measure.</p>
<p>Let <span class="math inline">\(T\)</span> denote the maturity date of a derivative security. At time <span class="math inline">\(t\)</span> (when the remaining time to maturity is <span class="math inline">\(T-t\)</span>), assume the price of the derivative can be represented as <span class="math inline">\(C(t,X(t))\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>On the other hand, under the risk-neutral measure, the instantaneous expected rate of return on the derivative is the risk-free rate, so <span class="math display">\[\frac{\D C}{C} =r\,\D t + \text{something}\,\,\D B\; .\]</span> where the “something” is the volatility of the derivative value. We can of course rearrange this as <span class="math display">\[\begin{equation}\label{1}
\D C = rC\,\D t+\text{something}\,\,C\,\D B\;.
\end{equation}\]</span> In order for both <a href="#2" data-reference-type="eqref" data-reference="2">[2]</a> and <a href="#1" data-reference-type="eqref" data-reference="1">[1]</a> to hold, the drifts on both right-hand sides must be equal.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> This implies</p>
<p>Sometimes one writes the derivative value as a function of time to maturity (<span class="math inline">\(\tau = T-t\)</span>) instead of <span class="math inline">\(t\)</span>. The partial derivative of <span class="math inline">\(C\)</span> with respect to <span class="math inline">\(\tau\)</span> is the negative of the partial derivative with respect to <span class="math inline">\(t\)</span>, so the fundamental pde is the same except for a different sign on the first term of the right-hand side of <a href="#3" data-reference-type="eqref" data-reference="3">[3]</a>. Rearranging a little, we have <span class="math display">\[\begin{equation}\label{4}
\frac{\partial C}{\partial \tau} = -rC + \nu\frac{\partial C}{\partial X}+ \frac{1}{2}\sigma^2\frac{\partial^2 C}{\partial X^2}\;.\tag{\ref{3}$'$}
\end{equation}\]</span> In this form, the pde is similar to important equations in physics, in particular the equation for how heat propagates through a rod over time. In fact, it can be transformed exactly into the heat equation, which is how Black and Scholes originally solved the option valuation problem. The terminal condition for a call option, <span class="math inline">\(C = \max(S-K,0)\)</span>, can be viewed as defining <span class="math inline">\(C\)</span> over the <span class="math inline">\(X\)</span> dimension at <span class="math inline">\(\tau=0\)</span>, just as the temperature along the length of the rod might be specified at an initial date, and as <span class="math inline">\(\tau\)</span> increases <span class="math inline">\(C\)</span> changes at each point <span class="math inline">\(X\)</span> according to <a href="#4" data-reference-type="eqref" data-reference="4">[4]</a>, which is similar, as noted, to the equation for the change in temperature at a point on the rod as time passes.</p>
<section id="discretizing-the-pde" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Discretizing the PDE</h1>
<p>To numerically solve the fundamental pde, we consider a discrete grid on the <span class="math inline">\((t,x)\)</span> space. We label the time points as <span class="math inline">\(t_0, t_1, t_2, \ldots, t_N\)</span>, and the <span class="math inline">\(x\)</span> points as <span class="math inline">\(x_{-M}, x_{-M+1}, \ldots, x_0, x_1, \ldots, x_M\)</span>, with <span class="math inline">\(t_0=0\)</span>, <span class="math inline">\(t_N=T\)</span>, and <span class="math inline">\(x_0=\log S(0)\)</span>. The equation should hold for <span class="math inline">\(-\infty&lt; x &lt; \infty\)</span>, but obviously we will have to bound this space, and we have denoted the upper and lower bounds by <span class="math inline">\(x_M\)</span> and <span class="math inline">\(x_{-M}\)</span> here. We take the points to be evenly spaced and set <span class="math inline">\(\varDelta t= t_i-t_{i-1}\)</span> and <span class="math inline">\(\varDelta x = x_j -x_{j-1}\)</span> for any <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>.</p>
<p>For specificity, we will consider a call option, though the discussion in this section applies to any derivative. We will compute a value for the call at each of the points on the grid. Then we return the value of the call at the point <span class="math inline">\((t_0,x_0)\)</span>.</p>
<p>Consider a point <span class="math inline">\((t_i, x_j)\)</span>. We could denote the estimated value of the call at this point by <span class="math inline">\(C_{ij}\)</span> but for now we will just use the symbol <span class="math inline">\(C\)</span>. Think of <span class="math inline">\(t\)</span> being on the horizontal axis and <span class="math inline">\(x\)</span> on the vertical axis. There are four points that can be reached from <span class="math inline">\((t_i,x_j)\)</span> by one step (an increase or decrease) in either <span class="math inline">\(t\)</span> or <span class="math inline">\(x\)</span>. Let’s denote the estimated call value at <span class="math inline">\((t_i, x_j+\varDelta x)\)</span> as <span class="math inline">\(C_{\text{up}}\)</span>, the value at <span class="math inline">\((t_i,x_j-\varDelta x)\)</span> as <span class="math inline">\(C_{\text{down}}\)</span>, the value at <span class="math inline">\((t_i+\varDelta t, x_j)\)</span> as <span class="math inline">\(C_{\text{right}}\)</span> and the value at <span class="math inline">\((t_i-\varDelta t,x_j)\)</span> as <span class="math inline">\(C_{\text{left}}\)</span>.</p>
<p>We want to force <a href="#3" data-reference-type="eqref" data-reference="3">[3]</a> to hold on the grid. To estimate <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span>, we make exactly the same calculations we made to estimate deltas and gammas in a binomial model. At the point <span class="math inline">\((t_i,x_j)\)</span>, we estimate Using the first is called the “explicit” method of solving the pde, and using the second is called the “implicit” method. The reason for these names should become clear below.</p>
</section>
<section id="explicit-and-implicit-methods" class="level1" data-number="12">
<h1 data-number="12"><span class="header-section-number">12</span> Explicit and Implicit Methods</h1>
<p>We first consider the explicit method. We set the value of the call at the final date <span class="math inline">\(t_N\)</span> and each point <span class="math inline">\(x_j\)</span> to be its intrinsic value, <span class="math inline">\(\max\left(\E^{x_j}-K,0\right)\)</span>. Now consider calculating the value at date <span class="math inline">\(t_{N-1}\)</span> and any point <span class="math inline">\(x_j\)</span>. We do this by forcing the approximation to <span class="math inline">\(\eqref{3}\)</span> based on <span class="math inline">\(\eqref{pdedelta}\)</span>–<span class="math inline">\(\eqref{explicit_dt}\)</span> to hold at the point <span class="math inline">\((t_N,x_j)\)</span>. Using the same notation as before, for <span class="math inline">\((t_i,x_j)=(t_N,x_j)\)</span>, implies <span class="math display">\[\begin{equation}\label{explicit}
rC = \frac{C-C_{\text{left}}}{\varDelta t}+ \nu\left(\frac{C_{\text{up}}-C_{\text{down}}}{2\varDelta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C_{\text{up}}+C_{\text{down}}-2C}{(\varDelta x)^2}\right)\;.
\end{equation}\]</span> Given that <span class="math inline">\(t_i\)</span> is the final date <span class="math inline">\(t_N\)</span>, the values <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span> have already been calculated as the intrinsic value of the call at maturity. The only unknown is <span class="math inline">\(C_{\text{left}}\)</span>, which is the value of the call at <span class="math inline">\((t_{N-1},x_j)\)</span>. We can solve this <em>explicitly</em> for <span class="math inline">\(C_{\text{left}}\)</span>, whence the name of the algorithm. We do this at each point <span class="math inline">\(x_j\)</span> at date <span class="math inline">\(t_{N-1}\)</span> (except for the top and bottom points, which we will discuss below) and then we follow the same procedure to back up sequentially to the initial date, as in the binomial model. Equation <span class="math inline">\(\eqref{explicit}\)</span> cannot be used to find <span class="math inline">\(C_{\text{left}}\)</span> at the bottom point <span class="math inline">\(x_{-M}\)</span>, because at this point there is no <span class="math inline">\(C_{\text{down}}\)</span> at date <span class="math inline">\(t_N\)</span>. Similarly, we cannot use it to find <span class="math inline">\(C_{\text{left}}\)</span> at the top point <span class="math inline">\(x_M\)</span>, because at that point there is no <span class="math inline">\(C_{\text{up}}\)</span>. We have to define the values along the top and bottom of the grid in some other fashion. We do this using conditions the derivative is known to satisfy as the stock price approaches <span class="math inline">\(+\infty\)</span> or 0. For example, for a European call option, we use the conditions that <span class="math inline">\(\partial C/\partial S \rightarrow 1\)</span> as <span class="math inline">\(S \rightarrow \infty\)</span> and <span class="math inline">\(\partial C/\partial S \rightarrow 0\)</span> as <span class="math inline">\(S \rightarrow 0\)</span>. We will explain this in more detail in the following section.</p>
<p>The solution of <span class="math inline">\(\eqref{explicit}\)</span> for <span class="math inline">\(C_{\text{left}}\)</span> can be written as <span class="math display">\[\begin{equation}\label{fdtrinomial}
C_{\text{left}} = \big(1-r\varDelta t\big)\big(p_uC_{\text{up}}+pC + p_dC_{\text{down}}\big)\;,\tag{\ref{explicit}$'$}
\end{equation}\]</span> where <span class="math display">\[\begin{align*}
p_u &amp;= \frac{\sigma^2\varDelta t+\nu\varDelta t\varDelta x}{2(1-r\varDelta t)(\varDelta x)^2}\; ,\\
p_d &amp;= \frac{\sigma^2\varDelta t-\nu\varDelta t\varDelta x}{2(1-r\varDelta t)(\varDelta x)^2}\; ,\\
\intertext{and}
p &amp;= 1- p_u-p_d\;.
\end{align*}\]</span> This can be interpreted as discounting the probability-weighted values of the call at the next date, where we consider that starting at the grid point <span class="math inline">\((t_{i},x_j)\)</span>, the logarithm of the stock price takes three possible values (<span class="math inline">\(x_j-\varDelta x\)</span>, <span class="math inline">\(x_j\)</span>, and <span class="math inline">\(x_j+\varDelta x\)</span>) at the next date <span class="math inline">\(t_{i+1}\)</span>, and where we use <span class="math inline">\(1-r\varDelta t\)</span> as the discount factor. Thus, it is essentially a trinomial model. This relationship was first noted by Brennan and Schwartz <span class="citation" data-cites="BrennanSchwartz">[@BrennanSchwartz]</span>.</p>
<p>Actually, for this to be a sensible trinomial model, the “probabilities” <span class="math inline">\(p_u\)</span>, <span class="math inline">\(p\)</span> and <span class="math inline">\(p_d\)</span> should be nonnegative. Assuming <span class="math inline">\(1-r\varDelta t&gt;0\)</span>, this will be the case if and only if <span class="math display">\[\varDelta x \leq  \frac{\sigma^2}{|\nu|} \qquad \text{and} \qquad \varDelta t \leq \frac{(\varDelta x)^2}{\sigma^2 + r(\varDelta x)^2}\; .\]</span> The first of these conditions characterizes <span class="math inline">\(p_u\)</span> and <span class="math inline">\(p_d\)</span> being nonnegative. The second is derived from <span class="math inline">\(p_u+p_d \leq 1\)</span>. It is interesting to examine these conditions in terms of the number <span class="math inline">\(N\)</span> of time periods and the number of steps in the <span class="math inline">\(x\)</span> dimension, which is <span class="math inline">\(2M\)</span>. To simplify the notation in the following somewhat, denote the distance of the upper <span class="math inline">\(x\)</span> boundary from <span class="math inline">\(x_0\)</span> by <span class="math inline">\(D\)</span> (i.e., <span class="math inline">\(D=x_M-x_0\)</span>). Then <span class="math inline">\(\varDelta t=T/N\)</span> and <span class="math inline">\(\varDelta x = D/M\)</span>. The probabilities are nonnegative if and only if <span class="math display">\[M \geq \frac{|\nu| D}{\sigma^2} \qquad \text{and} \qquad N \geq rT + \left(\frac{\sigma^2T}{D^2}\right)M^2\; .\]</span> Consider fixing <span class="math inline">\(D\)</span> and increasing the number of time periods and space steps (i.e., steps along the <span class="math inline">\(x\)</span> dimension). To maintain positive probabilities, the above shows that the number of time periods must increase as the square of the number of space steps: increasing <span class="math inline">\(M\)</span> by a factor of 10 requires increasing <span class="math inline">\(N\)</span> by a factor of 100. The upshot is it can be computationally expensive to use a large number of space steps, if we want to maintain nonnegative probabilities.</p>
<p>One can reasonably ask whether this is important, because we can certainly solve <a href="#explicit" data-reference-type="eqref" data-reference="explicit">[explicit]</a> to estimate the call values even when the “probabilities” are negative. The answer is that it is important, but for a reason we have not yet discussed. In a numerical algorithm for solving a partial differential equation (or for solving many other types of problems) there are two types of errors: discretization error and roundoff error. If we increase <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span> sufficiently, we should reduce the discretization error. However, each calculation on the computer introduces roundoff error. An algorithm is said to be “stable” if the roundoff errors stay small and bounded as the discretization error is reduced. An unfortunate fact about the explicit method is that it is stable only if the number of time steps increases with the square of the number of space steps. In the absence of this condition, the roundoff errors can accumulate and prevent one from reaching a solution of the desired accuracy.</p>
<p>The implicit method is known to be fully stable, so it is to be preferred to the explicit method. We will discuss briefly how to implement this method, before moving in the next section to the “Crank-Nicolson” method, which is also fully stable and known to be more efficient than the implicit method.</p>
<p>The implicit method uses the approximation <a href="#implicit_dt" data-reference-type="eqref" data-reference="implicit_dt">[implicit_dt]</a> for <span class="math inline">\(\partial C/\partial t\)</span>. As before, the call values are defined at the final date as the intrinsic value. Backing up a period, consider a grid point <span class="math inline">\((t_{N-1},x_j)\)</span>. We will try to estimate the call value at this date by forcing <a href="#3" data-reference-type="eqref" data-reference="3">[3]</a> to hold at this point. This means <span class="math display">\[\begin{equation}\label{implicit}
rC = \frac{C_{\text{right}}-C}{\varDelta t}+ \nu\left(\frac{C_{\text{up}}-C_{\text{down}}}{2\varDelta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C_{\text{up}}+C_{\text{down}}-2C}{(\varDelta x)^2}\right)\;.
\end{equation}\]</span> We know <span class="math inline">\(C_{\text{right}}\)</span>, because it is the intrinsic value at <span class="math inline">\((t_N,x_j)\)</span>. This equation links three unknowns (<span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span>, and <span class="math inline">\(C_{\text{down}}\)</span>) to the known value <span class="math inline">\(C_{\text{right}}\)</span>. We cannot solve it explicitly for these three unknowns. Instead, we need to solve a system of linear equations to simultaneously solve for all the call values at date <span class="math inline">\(t_{N-1}\)</span>. There are <span class="math inline">\(2M-1\)</span> equations of the form <span class="math inline">\(\eqref{implicit}\)</span> plus conditions that we will impose at the upper and lower boundaries, and we need to solve these for the <span class="math inline">\(2M+1\)</span> call values. This system of equations has the same form, and is solved in the same way, as the system of equations in the Crank-Nicolson method.</p>
</section>
<section id="crank-nicolson" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Crank-Nicolson</h1>
<p> The estimate <span class="math inline">\(\eqref{implicit_dt}\)</span> of <span class="math inline">\(\partial C/\partial t\)</span> used in the implicit method is best understood as an estimate of <span class="math inline">\(\partial C/\partial t\)</span> at the midpoint of <span class="math inline">\((t_i,x_j)\)</span> and <span class="math inline">\((t_{i+1},x_j)\)</span>, i.e., at <span class="math inline">\((t_i+\varDelta t/2,x_j)\)</span>. This is the basic idea of the Crank-Nicolson method. With this method, we continue to estimate the call values at the grid points, but we do so by forcing <span class="math inline">\(\eqref{3}\)</span> to hold at midpoints of this type. To do this, we also need estimates of <span class="math inline">\(C\)</span>, <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span> at the midpoints, but these are easy to obtain.</p>
<p>Let’s modify the previous notation somewhat, writing <span class="math inline">\(C'\)</span> for <span class="math inline">\(C_{\text{right}}\)</span> and <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span> for the values to the right and one step up and down, i.e., at the grid points <span class="math inline">\((t_i+\varDelta t,x_i+\varDelta x)\)</span> and <span class="math inline">\((t_i+\varDelta t,x_i-\varDelta x)\)</span> respectively. The obvious estimate of the call value at the midpoint <span class="math inline">\((t_i+\varDelta t/2,x_j)\)</span> is the average of <span class="math inline">\(C\)</span> and <span class="math inline">\(C'\)</span>, so set <span class="math display">\[C^{\text{mid}} = \frac{C+C'}{2}\; .\]</span> Analogously, define <span class="math display">\[\begin{equation}\label{cn1000}
C^{\text{mid}}_{\text{up}} = \frac{C_{\text{up}}+C'_{\text{up}}}{2}\;, \qquad \text{and} \qquad
C^{\text{mid}}_{\text{down}} = \frac{C_{\text{down}}+C'_{\text{down}}}{2}\;.
\end{equation}\]</span> The formulas <span class="math inline">\(\eqref{cn1000}\)</span> give us estimates of the call value at the midpoints one space step up and one space step down from <span class="math inline">\(x_j\)</span>—i.e., at <span class="math inline">\((t_i+\varDelta t/2,x_{j+1})\)</span> and <span class="math inline">\((t_i+\varDelta t/2,x_{j-1})\)</span>. We can now estimate <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span> at the midpoint <span class="math inline">\((t_i+\varDelta t/2,x_j)\)</span> exactly as before: <span class="math display">\[\frac{\partial C}{\partial X} \approx \frac{C^{\text{mid}}_{\text{up}}-C^{\text{mid}}_{\text{down}}}{2\varDelta x}\; ,\]</span> and <span class="math display">\[\frac{\partial^2 C}{\partial X^2} \approx \frac{C^{\text{mid}}_{\text{up}}+C^{\text{mid}}_{\text{down}}-2C^{\text{mid}}}{(\varDelta x)^2}\; .\]</span></p>
<p>Now, <span class="math inline">\(\eqref{3}\)</span> becomes <span class="math display">\[\begin{equation}\label{crank}
rC^{\text{mid}} = \frac{C'-C}{\varDelta t}+ \nu\left(\frac{C^{\text{mid}}_{\text{up}}-C^{\text{mid}}_{\text{down}}}{2\varDelta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C^{\text{mid}}_{\text{up}}+C^{\text{mid}}_{\text{down}}-2C^{\text{mid}}}{(\varDelta x)^2}\right)\;.
\end{equation}\]</span> Substituting from the formulas for <span class="math inline">\(C^{\text{mid}}\)</span>, <span class="math inline">\(C^{\text{mid}}_{\text{up}}\)</span>, and <span class="math inline">\(C^{\text{mid}}_{\text{down}}\)</span>, we can re-write <span class="math inline">\(\eqref{crank}\)</span> as <span class="math display">\[\begin{multline}\label{crank2}
\left(\frac{r}{2}+\frac{1}{\varDelta t}+\frac{\sigma^2}{2(\varDelta x)^2}\right)C - \left(\frac{\sigma^2}{4(\varDelta x)^2}+\frac{\nu}{4\varDelta x}\right)C_{\text{up}}\\ - \left(\frac{\sigma^2}{4(\varDelta x)^2}-\frac{\nu}{4\varDelta x}\right)C_{\text{down}}
\quad = \quad \left(\frac{1}{\varDelta t}- \frac{r}{2}-\frac{\sigma^2}{2(\varDelta x)^2}\right)C' \\+ \left(\frac{\sigma^2}{4(\varDelta x)^2}+\frac{\nu}{4\varDelta x}\right)C'_{\text{up}} + \left(\frac{\sigma^2}{4(\varDelta x)^2}-\frac{\nu}{4\varDelta x}\right)C'_{\text{down}}\tag{\ref{crank}$'$}
\end{multline}\]</span> We can also write this as <span class="math display">\[\begin{equation}\label{crank3}
a_1C - a_2C_{\text{up}} - a_3C_{\text{down}}
= a_4C' + a_2C'_{\text{up}} + a_3C'_{\text{down}}\;,\tag{\ref{crank}$''$}
\end{equation}\]</span> where the constants <span class="math inline">\(a_i\)</span> are the factors in parentheses in <span class="math inline">\(\eqref{crank2}\)</span>.</p>
<p>As before, we start at the final date <span class="math inline">\(t_N\)</span> and define the call value at that date by its intrinsic value. Consider a grid point <span class="math inline">\((t_{N-1},x_j)\)</span>. Forcing <a href="#3" data-reference-type="eqref" data-reference="3">[3]</a> to hold at the midpoint <span class="math inline">\((t_{N-1}+\varDelta t/2,x_j)\)</span> leads us to <a href="#crank3" data-reference-type="eqref" data-reference="crank3">[crank3]</a>. In this equation, <span class="math inline">\(C'\)</span>, <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span> are known from the intrinsic value at maturity, and we need to solve for <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span>. There are <span class="math inline">\(2M-1\)</span> linear equations of this type and we will add linear equations at the upper and lower boundaries of the grid and solve the resulting system of <span class="math inline">\(2M+1\)</span> linear equations for the <span class="math inline">\(2M+1\)</span> call values. After finding the call values at date <span class="math inline">\(t_{N-1}\)</span>, we then repeat the calculation at <span class="math inline">\(t_{N-2}\)</span> and continue backing up in this way until we reach the initial date.</p>
<p>Notice that the Crank-Nicolson equations <a href="#crank2" data-reference-type="eqref" data-reference="crank2">[crank2]</a> are similar to the equations <a href="#implicit" data-reference-type="eqref" data-reference="implicit">[implicit]</a> in the implicit method, but more information is used in each step of the Crank-Nicolson method than is used in each step of the implicit method. Equation <a href="#crank2" data-reference-type="eqref" data-reference="crank2">[crank2]</a> links the call values <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span> to the previously calculated <span class="math inline">\(C'\)</span>, <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span>, whereas in the implicit method they were linked only to <span class="math inline">\(C'\)</span> (which we called <span class="math inline">\(C_{\text{right}}\)</span>).</p>
</section>
<section id="european-options" class="level1" data-number="14">
<h1 data-number="14"><span class="header-section-number">14</span> European Options</h1>
<p>To value a European option, one simply defines the values at the final date as the intrinsic value and then backs up to the initial date, using any of the methods described (explicit, implicit, or Crank-Nicolson). The value that should be returned is the value at the middle node at the initial date, which corresponds to the initial price of the underlying.</p>
<p>The boundary conditions normally used at the bottom and top of the grid are conditions that the first derivative <span class="math inline">\(\partial C/\partial S\)</span> of the option value are known to satisfy as <span class="math inline">\(S \rightarrow 0\)</span> and <span class="math inline">\(S \rightarrow \infty\)</span>. These are conditions of the form <span class="math display">\[\begin{equation}\label{cn_boundary}
\lim_{S \rightarrow \infty} \frac{\partial C}{\partial S} =  \lambda_0\;,\qquad \text{and} \qquad
\lim_{S \rightarrow 0} \frac{\partial C}{\partial S} = \lambda_{\infty}\;,
\end{equation}\]</span> for constants <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\lambda_{\infty}\)</span>. In the case of a call option, we have <span class="math inline">\(\lambda_0=0\)</span> and <span class="math inline">\(\lambda_{\infty}=1\)</span>. For a put option, we have <span class="math inline">\(\lambda_0=-1\)</span> and <span class="math inline">\(\lambda_\infty = 0.\)</span></p>
<p>These conditions are implemented on the grid by forcing each value <span class="math inline">\(C\)</span> at a point <span class="math inline">\((t_i,x_{-M})\)</span> on the bottom of the grid to satisfy These two linear equations in the values at time <span class="math inline">\(t_i\)</span> augment the <span class="math inline">\(2M-1\)</span> equations already described to form a system of <span class="math inline">\(2M+1\)</span> linear equations to be solved for the derivative values at the <span class="math inline">\(2M+1\)</span> grid points at time <span class="math inline">\(t_i\)</span>.</p>
</section>
<section id="american-options" class="level1" data-number="15">
<h1 data-number="15"><span class="header-section-number">15</span> American Options</h1>
<p>The explicit method is easily adapted to American options. As in a binomial model, we compute the option value at each node as the larger of its discounted expected value and its intrinsic value. To be somewhat more precise, we replace the “trinomial” value <a href="#fdtrinomial" data-reference-type="eqref" data-reference="fdtrinomial">[fdtrinomial]</a> with <span class="math display">\[C_{\text{left}} = \max\left(\big(1-r\varDelta t\big)\big(p_uC_{\text{up}}+pC + p_dC_{\text{down}}\big), \text{intrinsic value}\right)\; .\]</span> In the Crank-Nicolson method, one can in similar fashion compute the value of the derivative at each space node at any date by solving the system of equations <a href="#crank3" data-reference-type="eqref" data-reference="crank3">[crank3]</a> and then replace the computed values by the intrinsic value when that is higher. However, because the values at the different space nodes are linked (i.e., the method is an implicit-type method), this one-at-a-time replacement of values by intrinsic values is not the most efficient method. See Wilmott <span class="citation" data-cites="Wilmott">[@Wilmott]</span> for more details (and for VBA code implementing the “projected successive over-relaxation” method).</p>
</section>
<section id="s_finitedifferencebarriers" class="level1" data-number="16">
<h1 data-number="16"><span class="header-section-number">16</span> Barrier Options</h1>
<p>Finite-difference methods work well for valuing discretely-sampled barrier options. For a down-and-out option, one should place the bottom of the grid at the knock-out boundary. For an up-and-out option, one should place the top of the grid at the knock-out boundary. As discussed in Chap. <a href="Chapter8.html" data-reference-type="ref" data-reference="c_exotics">[c_exotics]</a>, knock-in options can be valued as standard options minus knock-out options.</p>
<p>For barrier options, the boundary information <a href="#cn_boundary" data-reference-type="eqref" data-reference="cn_boundary">[cn_boundary]</a> can be replaced by assigning a value of zero at the knock-out boundary. For example, for a down-and-out option, the condition <a href="#crank4a" data-reference-type="eqref" data-reference="crank4a">[crank4a]</a> can be replaced by <span class="math inline">\(C=0\)</span>. If the contract specifies that a rebate is to be paid to the buyer when the option is knocked out, then condition <a href="#crank4a" data-reference-type="eqref" data-reference="crank4a">[crank4a]</a> should be replaced by <span class="math inline">\(C=\)</span> Rebate.</p>
</section>
<section id="s_finitedifferences_matlab" class="level1" data-number="17">
<h1 data-number="17"><span class="header-section-number">17</span> Calculations in VBA</h1>
<section id="crank-nicolson" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="crank-nicolson">Crank-Nicolson</h2>
<p>We will create a program that solves a system of equations of the form <a href="#crank3" data-reference-type="eqref" data-reference="crank3">[crank3]</a>, <a href="#crank4a" data-reference-type="eqref" data-reference="crank4a">[crank4a]</a> and <a href="#crank4b" data-reference-type="eqref" data-reference="crank4b">[crank4b]</a>. We input the vector <span class="math inline">\(a\)</span> of coefficients, a vector <span class="math inline">\(y\)</span> of dimension <span class="math inline">\(2M+1\)</span> containing the estimated values of the derivative at any date <span class="math inline">\(t_{i+1}\)</span>, an integer <span class="math inline">\(L\)</span> from which <span class="math inline">\(M\)</span> is defined as <span class="math inline">\(M=(L-1)/2\)</span> (i.e., <span class="math inline">\(L=2M+1\)</span>). The function will return the vector of values at date <span class="math inline">\(t_i\)</span>.</p>
<p>We will write the boundary conditions <span class="math inline">\(\eqref{crank4a}\)</span> and <span class="math inline">\(\eqref{crank4b}\)</span>, respectively, in the more general forms where <span class="math inline">\(z_1\)</span>, <span class="math inline">\(b_1\)</span>, <span class="math inline">\(z_L\)</span> and <span class="math inline">\(b_L\)</span> are numbers to be calculated or input by the user. The equations <a href="#crank4a" data-reference-type="eqref" data-reference="crank4a">[crank4a]</a> and <a href="#crank4b" data-reference-type="eqref" data-reference="crank4b">[crank4b]</a> are the special cases in which <span class="math inline">\(z_1 = \lambda_0(S-S_{\text{up}})\)</span>, <span class="math inline">\(b_1 = 1\)</span>, <span class="math inline">\(z_L = \lambda_\infty(S-S_{\text{down}})\)</span>, and <span class="math inline">\(b_L=1\)</span>. The additional generality in allowing <span class="math inline">\(b_1\)</span> and <span class="math inline">\(b_L\)</span> to be different from one is important for many purposes, and we will see an example of it in the valuation of barrier options.</p>
<p>The system of equations that we want to solve is therefore <span id="page_cn" label="page_cn"></span> <span class="math display">\[
\begin{pmatrix}
1 &amp; -b_1 &amp; 0 &amp; 0 &amp; 0  &amp; \cdots  &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
-a_3 &amp; a_1 &amp; - a_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; - a_3 &amp; a_1 &amp; -a_2 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp;\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; -a_3 &amp; a_1 &amp; - a_2 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 &amp; 0 &amp; -a_3 &amp; a_1 &amp; - a_2 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 &amp; 0 &amp; 0 &amp; -b_L &amp; 1 \end{pmatrix}
\begin{pmatrix}
C_1 \\
C_2\\
C_3\\
\vdots\\
C_{L-2}\\
C_{L-1}\\
C_L
\end{pmatrix}
=
\begin{pmatrix}
z_1 \\
z_2\\
z_3\\
\vdots\\
z_{L-2}\\
z_{L-1}\\
z_L
\end{pmatrix}\]</span> where we are denoting the derivative values to be determined at date <span class="math inline">\(t_i\)</span> across the <span class="math inline">\(L\)</span> (<span class="math inline">\(=2M+1\)</span>) space nodes as <span class="math inline">\(C_1, \ldots, C_L\)</span>. The coefficients <span class="math inline">\(a_i\)</span> are defined in <a href="#crank3" data-reference-type="eqref" data-reference="crank3">[crank3]</a>. The numbers <span class="math inline">\(z_2, \ldots, z_{L-1}\)</span> are the right-hand sides of <a href="#crank3" data-reference-type="eqref" data-reference="crank3">[crank3]</a> and are determined by the coefficients <span class="math inline">\(a_i\)</span> and the derivative values <span class="math inline">\(y_1, \ldots, y_{L}\)</span> at date <span class="math inline">\(t_{i+1}\)</span>. The system of equations that must be solved to implement the implicit method is of this same form.</p>
<p>The first equation in this array (equation <a href="#crank4aa" data-reference-type="eqref" data-reference="crank4aa">[crank4aa]</a>) can be written as Our induction argument gives us <span class="math display">\[C_{L-1} = u_{L-1} + b_{L-1}C_{L}\; ,\]</span> and when we combine these we have two equations in two unknowns and can solve for <span class="math inline">\(C_L\)</span> as <span class="math display">\[C_L = \frac{z_L+ b_Lu_{L-1}}{1-b_Lb_{L-1}}\; .\]</span> We then successively obtain <span class="math inline">\(C_{L-1}, C_{L-2}, \ldots, C_1\)</span> from <span class="math inline">\(\eqref{crank101}\)</span>.</p>

</section>
<section id="crank-nicolson-for-european-options" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="crank-nicolson-for-european-options">Crank-Nicolson for European Options</h2>
<p>We will demonstrate the Crank-Nicolson method by valuing a European call. Any other path-independent European derivative is valued in the same way, by appropriately redefining the value of the derivative at the final date and redefining the constants <span class="math inline">\(z_1\)</span> and <span class="math inline">\(z_L\)</span> in the boundary conditions <a href="#crank4aabbcombined" data-reference-type="eqref" data-reference="crank4aabbcombined">[crank4aabbcombined]</a> at the bottom and top of the grid.</p>
<p>As elsewhere in this chapter, <span class="math inline">\(N\)</span> denotes the number of time periods, and <span class="math inline">\(2M+1\)</span> will be the number of <span class="math inline">\(x\)</span> values on the grid. We use the symbol <span class="math inline">\(D\)</span> to denote the distance of the top (or bottom) of the grid from <span class="math inline">\(\log S(0)\)</span>. In other words, <span class="math inline">\(D = x_M-x_0\)</span>. A reasonable value for <span class="math inline">\(D\)</span> would be three standard deviations for <span class="math inline">\(\log S\)</span>, which would mean <span class="math inline">\(D = |\nu|T +3 \sigma\sqrt{T}\)</span>. For example, for a one-year option on a stock with a volatility of 30%, it should suffice to input <span class="math inline">\(D=1\)</span>.</p>
<p>As should be clear, the program is conceptually very similar to a binomial model. The difference is that the “backing up” procedure, which involves node-by-node discounting in a binomial model, here is accomplished via the Crank-Nicolson algorithm.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>

</section>
<section id="crank-nicolson-for-barrier-options" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="crank-nicolson-for-barrier-options">Crank-Nicolson for Barrier Options</h2>
<p>To price a down-and-out (or up-and-out option), we put the bottom (or top) of the grid at the boundary. The boundary condition that we use is that the value at the boundary is zero. We will consider the example of a down-and-out call option. In this case, the boundary condition at the bottom of the grid is <a href="#crank4aa" data-reference-type="eqref" data-reference="crank4aa">[crank4aa]</a> with <span class="math inline">\(z_1=0\)</span> and <span class="math inline">\(b_1 = 0\)</span>. The boundary condition at the top is the same as for an ordinary call. We can easily handle a rebate paid when the option is knocked out by inputting the value of the rebate as <span class="math inline">\(z_1\)</span>.</p>
<p>The main new issue that we encounter in valuing barriers is locating the boundary of the grid at the barrier. For the down-and-out, we will input the value of the stock price at which the option is knocked out as <code>Bar</code>. We want the bottom of the grid to lie at the natural logarithm of this number. This will influence our choice of the space step <span class="math inline">\(\varDelta x\)</span>, because we want to have an integer number of steps between the bottom of the grid and <span class="math inline">\(\log S(0)\)</span>. We assume that the value <span class="math inline">\(M\)</span> input by the user represents the desired number of space steps above <span class="math inline">\(\log S(0)\)</span>. We start with <span class="math inline">\(\varDelta x=D/M\)</span> as an initial estimate of the size of the space step. We then decrease it, if necessary, to ensure that the distance between <code>Bar</code> and <span class="math inline">\(\log S(0)\)</span> is an integer multiple of <span class="math inline">\(\varDelta x\)</span>. We then increase <span class="math inline">\(M\)</span>, if necessary, to ensure that the top of the grid will still be at or above <span class="math inline">\(D+\log S(0)\)</span>. Finally, we define the top of the grid to be at <span class="math inline">\(\log S(0) +M \cdot \varDelta x\)</span>.</p>

</section>
</section>
<section id="problems" class="level1 unnumbered">
<h1 class="unnumbered">Problems</h1>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>We use a different variable (<span class="math inline">\(y\)</span>) for the call values at the final date—and consequently need to separate the first step of backing up (to the penultimate date) and the other steps of backing up (to date zero)—because element-by-element definition of an array and assignment of an array to a variable require different variable types in VBA. See Appendix A for more discussion.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We use a different variable (<span class="math inline">\(y\)</span>) for the call values at the final date—and consequently need to separate the first step of backing up (to the penultimate date) and the other steps of backing up (to date zero)—because element-by-element definition of an array and assignment of an array to a variable require different variable types in VBA. See Appendix A for more discussion.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>We use a different variable (<span class="math inline">\(y\)</span>) for the call values at the final date—and consequently need to separate the first step of backing up (to the penultimate date) and the other steps of backing up (to date zero)—because element-by-element definition of an array and assignment of an array to a variable require different variable types in VBA. See Appendix A for more discussion.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter9.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter11.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>