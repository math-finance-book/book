<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pricing and Hedging Derivative Securities - 10&nbsp; Finite Difference Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter11.html" rel="next">
<link href="./Chapter9.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter10.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Pricing and Hedging Derivative Securities</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Asset Pricing Basics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Continuous-Time Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Black-Scholes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Estimating and Modelling Volatility</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo\ and Binomial Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Foreign Exchange</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Forward, Futures, and Exchange Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Exotic Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter10.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Fixed Income Derivatives</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Valuing Derivatives in the Extended Vasicek Model</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">A Brief Survey of Term Structure Models</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-fundamentalpde" id="toc-sec-fundamentalpde" class="nav-link active" data-scroll-target="#sec-fundamentalpde"><span class="header-section-number">10.1</span> Fundamental PDE</a></li>
  <li><a href="#discretizing-the-pde" id="toc-discretizing-the-pde" class="nav-link" data-scroll-target="#discretizing-the-pde"><span class="header-section-number">10.2</span> Discretizing the PDE</a></li>
  <li><a href="#explicit-and-implicit-methods" id="toc-explicit-and-implicit-methods" class="nav-link" data-scroll-target="#explicit-and-implicit-methods"><span class="header-section-number">10.3</span> Explicit and Implicit Methods</a></li>
  <li><a href="#crank-nicolson" id="toc-crank-nicolson" class="nav-link" data-scroll-target="#crank-nicolson"><span class="header-section-number">10.4</span> Crank-Nicolson</a></li>
  <li><a href="#european-options" id="toc-european-options" class="nav-link" data-scroll-target="#european-options"><span class="header-section-number">10.5</span> European Options</a></li>
  <li><a href="#american-options" id="toc-american-options" class="nav-link" data-scroll-target="#american-options"><span class="header-section-number">10.6</span> American Options</a></li>
  <li><a href="#sec-s_finitedifferencebarriers" id="toc-sec-s_finitedifferencebarriers" class="nav-link" data-scroll-target="#sec-s_finitedifferencebarriers"><span class="header-section-number">10.7</span> Barrier Options</a></li>
  <li><a href="#sec-s_finitedifferences_matlab" id="toc-sec-s_finitedifferences_matlab" class="nav-link" data-scroll-target="#sec-s_finitedifferences_matlab"><span class="header-section-number">10.8</span> Calculations in VBA</a>
  <ul class="collapse">
  <li><a href="#crank-nicolson-1" id="toc-crank-nicolson-1" class="nav-link" data-scroll-target="#crank-nicolson-1">Crank-Nicolson</a></li>
  <li><a href="#crank-nicolson-for-european-options" id="toc-crank-nicolson-for-european-options" class="nav-link" data-scroll-target="#crank-nicolson-for-european-options">Crank-Nicolson for European Options</a></li>
  <li><a href="#crank-nicolson-for-barrier-options" id="toc-crank-nicolson-for-barrier-options" class="nav-link" data-scroll-target="#crank-nicolson-for-barrier-options">Crank-Nicolson for Barrier Options</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">10.9</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-c_pde" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In this chapter we will see how to estimate derivative values by numerically solving the partial differential equation (pde) that the derivative value satisfies, using finite difference methods. More advanced discussions of this topic can be found in Wilmott, DeWynne and Howison <span class="citation" data-cites="WDH">(<a href="#ref-WDH" role="doc-biblioref">Wilmott, Dewynne, and Howison 2000</a>)</span>, Wilmott <span class="citation" data-cites="Wilmott">(<a href="#ref-Wilmott" role="doc-biblioref">Wilmott 2000</a>)</span>, and Tavella <span class="citation" data-cites="Tavella">(<a href="#ref-Tavella" role="doc-biblioref">Tavella 2002</a>)</span>, among other places. We will only consider derivatives written on a single underlying asset, but the ideas generalize to derivatives written on multiple underlying assets (e.g., basket and spread options) in much the same way that binomial models can be applied to derivatives on multiple underlying assets. The curse of dimensionality is the same for finite difference methods as for binomial models—the computation time increases exponentially with the number of underlying assets.</p>
<section id="sec-fundamentalpde" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="sec-fundamentalpde"><span class="header-section-number">10.1</span> Fundamental PDE</h2>
<p>Consider an asset with price <span class="math inline">\(S\)</span> and constant dividend yield <span class="math inline">\(q\)</span>.<br>
Set <span class="math inline">\(X=\log S\)</span>. Then we have <span class="math display">\[\mathrm{d} X = \nu\,\mathrm{d} t+\sigma\,\mathrm{d} B\; ,\]</span> where <span class="math inline">\(\nu =r-q-\sigma^2/2\)</span> and <span class="math inline">\(B\)</span> is a Brownian motion under the risk-neutral measure.</p>
<p>Let <span class="math inline">\(T\)</span> denote the maturity date of a derivative security. At time <span class="math inline">\(t\)</span> (when the remaining time to maturity is <span class="math inline">\(T-t\)</span>), assume the price of the derivative can be represented as <span class="math inline">\(C(t,X(t))\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><br>
Since <span class="math inline">\(C\)</span> is a function of <span class="math inline">\(t\)</span> and <span class="math inline">\(X\)</span>, Ito’s formula implies</p>
<p><span id="eq-2"><span class="math display">\[
\mathrm{d} C  = \frac{\partial C}{\partial t}\,\mathrm{d} t + \frac{\partial C}{\partial X}\,\mathrm{d} X +\frac{1}{2}\frac{\partial^2 C}{\partial X^2}(\mathrm{d} X)^2
\tag{10.1}\]</span></span></p>
<p><span class="math display">\[
=\frac{\partial C}{\partial t}\,\mathrm{d} t+ \frac{\partial C}{\partial X}\big(\nu\,\mathrm{d} t+\sigma\,\mathrm{d} B\big) + \frac{1}{2}\frac{\partial^2 C}{\partial X^2}\sigma^2\,\mathrm{d} t\;.
\]</span></p>
<p>On the other hand, under the risk-neutral measure, the instantaneous expected rate of return on the derivative is the risk-free rate, so <span class="math display">\[\frac{\mathrm{d} C}{C} =r\,\mathrm{d} t + \text{something}\,\,\mathrm{d} B\; .\]</span> where the something is the volatility of the derivative value. We can of course rearrange this as <span id="eq-1"><span class="math display">\[
\mathrm{d} C = rC\,\mathrm{d} t+\text{something}\,\,C\,\mathrm{d} B\;.
\tag{10.2}\]</span></span></p>
<p>In order for both <a href="#eq-2">Equation&nbsp;<span>10.1</span></a> and <a href="#eq-1">Equation&nbsp;<span>10.2</span></a> to hold, the drifts on both right-hand sides must be equal.^[Suppose a process <span class="math inline">\(X\)</span> satisfies <span class="math inline">\(\mathrm{d] X=\alpha_1\,\mathrm{d} t+\sigma_1\,\mathrm{d} B = \alpha_2\,\mathrm{d} t+\sigma_2\,\mathrm{d} B\)</span> for coefficients <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(\sigma_i\)</span>. This implies <span class="math inline">\((\alpha_1-\alpha_2)\,\mathrm{d} t=(\sigma_2-\sigma_2)\,\mathrm{d} B\)</span>. The right-hand side defines a (local) martingale and the left-hand side defines a continuous finite-variation process. As discussed in <a href="Chapter2.html#sec-s_quadraticvariation"><span>Section&nbsp;2.2</span></a>, the only continuous finite-variation martingales are constants, so the changes must be zero; i.e., <span class="math inline">\(\alpha_1=\alpha_2\)</span> and <span class="math inline">\(\sigma_1=\sigma_2\)</span>.} This implies <span id="eq-3"><span class="math display">\[
rC = \frac{\partial C}{\partial t}+ \nu\frac{\partial C}{\partial X}+ \frac{1}{2}\sigma^2\frac{\partial^2 C}{\partial X^2}\;.
\tag{10.3}\]</span></span></p>
<p>This equation is the fundamental pde. It is an equation that we want to solve for the function~<span class="math inline">\(C\)</span>. Every derivative written on <span class="math inline">\(S\)</span> satisfies this same equation. Different derivatives have different values because of boundary conditions. The boundary conditions are the intrinsic value at maturity, optimality conditions for early exercise, barriers and the like.</p>
<p>To translate the terms in <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> into more familiar ones, notice that, because <span class="math inline">\(S=\mathrm{e}^X\)</span>, we have <span class="math display">\[\frac{\partial S}{\partial X}=\mathrm{e}^X=S\; .\]</span> Therefore, by the chain rule of calculus, <span class="math display">\[\frac{\partial C}{\partial X} = \frac{\partial C}{\partial S}\frac{\partial S}{\partial X} = S\frac{\partial C}{\partial S}\; .\]</span> Thus the term <span class="math inline">\(\partial C/\partial X\)</span> is the delta of the derivative multiplied by the price of the underlying. Similarly, by ordinary calculus, the term <span class="math inline">\(\partial^2 C/\partial X^2\)</span> can be written in terms of the delta and the gamma of the derivative.</p>
<p>Sometimes one writes the derivative value as a function of time to maturity (<span class="math inline">\(\tau = T-t\)</span>) instead of <span class="math inline">\(t\)</span>. The partial derivative of <span class="math inline">\(C\)</span> with respect to <span class="math inline">\(\tau\)</span> is the negative of the partial derivative with respect to <span class="math inline">\(t\)</span>, so the fundamental pde is the same except for a different sign on the first term of the right-hand side of <a href="#eq-3">Equation&nbsp;<span>10.3</span></a>. Rearranging a little, we have <span id="eq-4"><span class="math display">\[
\frac{\partial C}{\partial \tau} = -rC + \nu\frac{\partial C}{\partial X}+ \frac{1}{2}\sigma^2\frac{\partial^2 C}{\partial X^2}\;.
\tag{10.4}\]</span></span></p>
<p>In this form, the pde is similar to important equations in physics, in particular the equation for how heat propagates through a rod over time. In fact, it can be transformed exactly into the heat equation, which is how Black and Scholes originally solved the option valuation problem. The terminal condition for a call option, <span class="math inline">\(C = \max(S-K,0)\)</span>, can be viewed as defining <span class="math inline">\(C\)</span> over the <span class="math inline">\(X\)</span> dimension at <span class="math inline">\(\tau=0\)</span>, just as the temperature along the length of the rod might be specified at an initial date, and as <span class="math inline">\(\tau\)</span> increases <span class="math inline">\(C\)</span> changes at each point <span class="math inline">\(X\)</span> according to <a href="#eq-4">Equation&nbsp;<span>10.4</span></a>, which is similar, as noted, to the equation for the change in temperature at a point on the rod as time passes.</p>
</section>
<section id="discretizing-the-pde" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="discretizing-the-pde"><span class="header-section-number">10.2</span> Discretizing the PDE</h2>
<p>To numerically solve the fundamental pde, we consider a discrete grid on the <span class="math inline">\((t,x)\)</span> space. We label the time points as <span class="math inline">\(t_0, t_1, t_2, \ldots, t_N\)</span>, and the <span class="math inline">\(x\)</span> points as <span class="math inline">\(x_{-M}, x_{-M+1}, \ldots, x_0, x_1, \ldots, x_M\)</span>, with <span class="math inline">\(t_0=0\)</span>, <span class="math inline">\(t_N=T\)</span>, and <span class="math inline">\(x_0=\log S(0)\)</span>. The equation should hold for <span class="math inline">\(-\infty&lt; x &lt; \infty\)</span>, but obviously we will have to bound this space, and we have denoted the upper and lower bounds by <span class="math inline">\(x_M\)</span> and <span class="math inline">\(x_{-M}\)</span> here. We take the points to be evenly spaced and set <span class="math inline">\(\Delta t= t_i-t_{i-1}\)</span> and <span class="math inline">\(\Delta x = x_j -x_{j-1}\)</span> for any <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>.</p>
<p>For specificity, we will consider a call option, though the discussion in this section applies to any derivative. We will compute a value for the call at each of the points on the grid. Then we return the value of the call at the point <span class="math inline">\((t_0,x_0)\)</span>.</p>
<p>Consider a point <span class="math inline">\((t_i, x_j)\)</span>. We could denote the estimated value of the call at this point by <span class="math inline">\(C_{ij}\)</span> but for now we will just use the symbol <span class="math inline">\(C\)</span>. Think of <span class="math inline">\(t\)</span> being on the horizontal axis and <span class="math inline">\(x\)</span> on the vertical axis. There are four points that can be reached from <span class="math inline">\((t_i,x_j)\)</span> by one step (an increase or decrease) in either~<span class="math inline">\(t\)</span> or <span class="math inline">\(x\)</span>. Let’s denote the estimated call value at <span class="math inline">\((t_i, x_j+\Delta x)\)</span> as <span class="math inline">\(C_{\text{up}}\)</span>, the value at <span class="math inline">\((t_i,x_j-\Delta x)\)</span> as <span class="math inline">\(C_{\text{down}}\)</span>, the value at <span class="math inline">\((t_i+\Delta t, x_j)\)</span> as <span class="math inline">\(C_{\text{right}}\)</span> and the value at <span class="math inline">\((t_i-\Delta t,x_j)\)</span> as <span class="math inline">\(C_{\text{left}}\)</span>.</p>
<p>We want to force <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> to hold on the grid. To estimate <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span>, we make exactly the same calculations we made to estimate deltas and gammas in a binomial model. At the point <span class="math inline">\((t_i,x_j)\)</span>, we estimate</p>
<p><span id="eq-pdedelta"><span class="math display">\[
\frac{\partial C}{\partial X} \approx \frac{C_{\text{up}}-C_{\text{down}}}{2\Delta x}\; .
\tag{10.5}\]</span></span></p>
<p>There are two other obvious estimates of this derivative: <span class="math display">\[\frac{C_{\text{up}}-C}{\Delta x} \qquad \text{and} \qquad \frac{C-C_{\text{down}}}{\Delta x}\; .\]</span> The first of these should be understood as an estimate at the midpoint of <span class="math inline">\(x_j\)</span> and <span class="math inline">\(x_j+\Delta x\)</span> and the second as an estimate at the midpoint of <span class="math inline">\(x_j\)</span> and <span class="math inline">\(x_j-\Delta x\)</span>. The distance between these two midpoints is <span class="math inline">\(\Delta x\)</span>, so the difference in these two estimates of <span class="math inline">\(\partial C/\partial X\)</span> divided by <span class="math inline">\(\Delta x\)</span> is an estimate of the second derivative: <span id="eq-pdegamma"><span class="math display">\[
\frac{\partial^2 C}{\partial X^2} \approx \frac{C_{\text{up}}-2C+C_{\text{down}}}{(\Delta x)^2}\; .
\tag{10.6}\]</span></span></p>
<p>The obvious estimate of <span class="math inline">\(\partial C/\partial t\)</span>, which is analogous to the estimate of <span class="math inline">\(\partial C/\partial X\)</span>, is <span class="math display">\[\frac{C_{\text{right}}-C_{\text{left}}}{2\Delta t}\; .\]</span> This is the estimate we are going to use. The reason is that we want to solve for the call values on the grid in much the same way that we solved the binomial model—starting at the end and working backwards. If we use the above estimate of the time derivative, then at each point <span class="math inline">\((t_i,x_j)\)</span>, equation <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> will link the call values at times <span class="math inline">\(t_{i-1}\)</span>, <span class="math inline">\(t_i\)</span> and <span class="math inline">\(t_{i+1}\)</span>. This would substantially complicate the backing up process. However, in a sense, it is the right estimate, and the Crank-Nicolson method to be discussed below uses a similar idea.</p>
<p>The other two choices for estimating <span class="math inline">\(\partial C/\partial t\)</span> are analogous to the other two choices for estimating <span class="math inline">\(\partial C/\partial X\)</span>. We can use either</p>
<p><span id="eq-explicit_dt"><span class="math display">\[
\frac{\partial C}{\partial t} \approx \frac{C-C_{\text{left}}}{\Delta t}\;,
\tag{10.7}\]</span></span></p>
<p><span class="math display">\[
\]</span> or <span id="eq-implicit_dt"><span class="math display">\[
\frac{\partial C}{\partial t} \approx \frac{C_{\text{right}}-C}{\Delta t}\;.
\tag{10.8}\]</span></span></p>
<p>Using the first is called the explicit method of solving the pde, and using the second is called the implicit method. The reason for these names should become clear below.</p>
</section>
<section id="explicit-and-implicit-methods" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="explicit-and-implicit-methods"><span class="header-section-number">10.3</span> Explicit and Implicit Methods</h2>
<p>We first consider the explicit method. We set the value of the call at the final date <span class="math inline">\(t_N\)</span> and each point <span class="math inline">\(x_j\)</span> to be its intrinsic value, <span class="math inline">\(\max\left(\mathrm{e}^{x_j}-K,0\right)\)</span>. Now consider calculating the value at date <span class="math inline">\(t_{N-1}\)</span> and any point <span class="math inline">\(x_j\)</span>. We do this by forcing the approximation to <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> based on <a href="#eq-pdedelta">Equation&nbsp;<span>10.5</span></a>–<a href="#eq-explicit_dt">Equation&nbsp;<span>10.7</span></a> to hold at the point <span class="math inline">\((t_N,x_j)\)</span>. Using the same notation as before, for <span class="math inline">\((t_i,x_j)=(t_N,x_j)\)</span>, implies <span id="eq-explicit"><span class="math display">\[
rC = \frac{C-C_{\text{left}}}{\Delta t}+ \nu\left(\frac{C_{\text{up}}-C_{\text{down}}}{2\Delta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C_{\text{up}}+C_{\text{down}}-2C}{(\Delta x)^2}\right)\;.
\tag{10.9}\]</span></span></p>
<p>Given that <span class="math inline">\(t_i\)</span> is the final date <span class="math inline">\(t_N\)</span>, the values <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span> have already been calculated as the intrinsic value of the call at maturity. The only unknown is <span class="math inline">\(C_{\text{left}}\)</span>, which is the value of the call at <span class="math inline">\((t_{N-1},x_j)\)</span>. We can solve this for <span class="math inline">\(C_{\text{left}}\)</span>, whence the name of the algorithm. We do this at each point <span class="math inline">\(x_j\)</span> at date <span class="math inline">\(t_{N-1}\)</span> (except for the top and bottom points, which we will discuss below) and then we follow the same procedure to back up sequentially to the initial date, as in the binomial model.</p>
<p>Equation <a href="#eq-explicit">Equation&nbsp;<span>10.9</span></a> cannot be used to find <span class="math inline">\(C_{\text{left}}\)</span> at the bottom point <span class="math inline">\(x_{-M}\)</span>, because at this point there is no <span class="math inline">\(C_{\text{down}}\)</span> at date <span class="math inline">\(t_N\)</span>. Similarly, we cannot use it to find <span class="math inline">\(C_{\text{left}}\)</span> at the top point <span class="math inline">\(x_M\)</span>, because at that point there is no <span class="math inline">\(C_{\text{up}}\)</span>. We have to define the values along the top and bottom of the grid in some other fashion. We do this using conditions the derivative is known to satisfy as the stock price approaches <span class="math inline">\(+\infty\)</span> or 0. For example, for a European call option, we use the conditions that <span class="math inline">\(\partial C/\partial S \rightarrow 1\)</span> as <span class="math inline">\(S \rightarrow \infty\)</span> and <span class="math inline">\(\partial C/\partial S \rightarrow 0\)</span> as <span class="math inline">\(S \rightarrow 0\)</span>. We will explain this in more detail in the following section.</p>
<p>The solution of <a href="#eq-explicit">Equation&nbsp;<span>10.9</span></a> for <span class="math inline">\(C_{\text{left}}\)</span> can be written as <span id="eq-fdtrinomial"><span class="math display">\[
C_{\text{left}} = \big(1-r\Delta t\big)\big(p_uC_{\text{up}}+pC + p_dC_{\text{down}}\big)\;,
\tag{10.10}\]</span></span></p>
<p>where <span class="math display">\[\begin{align*}
p_u &amp;= \frac{\sigma^2\Delta t+\nu\Delta t\Delta x}{2(1-r\Delta t)(\Delta x)^2}\; ,\\
p_d &amp;= \frac{\sigma^2\Delta t-\nu\Delta t\Delta x}{2(1-r\Delta t)(\Delta x)^2}\; ,\\
p &amp;= 1- p_u-p_d\;.
\end{align*}\]</span> This can be interpreted as discounting the probability-weighted values of the call at the next date, where we consider that starting at the grid point <span class="math inline">\((t_{i},x_j)\)</span>, the logarithm of the stock price takes three possible values (<span class="math inline">\(x_j-\Delta x\)</span>, <span class="math inline">\(x_j\)</span>, and <span class="math inline">\(x_j+\Delta x\)</span>) at the next date <span class="math inline">\(t_{i+1}\)</span>, and where we use <span class="math inline">\(1-r\Delta t\)</span> as the discount factor. Thus, it is essentially a trinomial model. This relationship was first noted by Brennan and Schwartz <span class="citation" data-cites="BrennanSchwartz">(<a href="#ref-BrennanSchwartz" role="doc-biblioref">Brennan and Schwartz 1978</a>)</span>.</p>
<p>Actually, for this to be a sensible trinomial model, the probabilities <span class="math inline">\(p_u\)</span>, <span class="math inline">\(p\)</span> and <span class="math inline">\(p_d\)</span> should be nonnegative. Assuming <span class="math inline">\(1-r\Delta t&gt;0\)</span>, this will be the case if and only if <span class="math display">\[\Delta x \leq  \frac{\sigma^2}{|\nu|} \qquad \text{and} \qquad \Delta t \leq \frac{(\Delta x)^2}{\sigma^2 + r(\Delta x)^2}\; .\]</span> The first of these conditions characterizes <span class="math inline">\(p_u\)</span> and <span class="math inline">\(p_d\)</span> being nonnegative. The second is derived from <span class="math inline">\(p_u+p_d \leq 1\)</span>. It is interesting to examine these conditions in terms of the number <span class="math inline">\(N\)</span> of time periods and the number of steps in the <span class="math inline">\(x\)</span> dimension, which is <span class="math inline">\(2M\)</span>. To simplify the notation in the following somewhat, denote the distance of the upper <span class="math inline">\(x\)</span> boundary from <span class="math inline">\(x_0\)</span> by <span class="math inline">\(D\)</span> (i.e., <span class="math inline">\(D=x_M-x_0\)</span>). Then <span class="math inline">\(\Delta t=T/N\)</span> and <span class="math inline">\(\Delta x = D/M\)</span>. The probabilities are nonnegative if and only if <span class="math display">\[M \geq \frac{|\nu| D}{\sigma^2} \qquad \text{and} \qquad N \geq rT + \left(\frac{\sigma^2T}{D^2}\right)M^2\; .\]</span> Consider fixing <span class="math inline">\(D\)</span> and increasing the number of time periods and space steps (i.e., steps along the <span class="math inline">\(x\)</span> dimension). To maintain positive probabilities, the above shows that the number of time periods must increase as the square of the number of space steps: increasing <span class="math inline">\(M\)</span> by a factor of 10 requires increasing <span class="math inline">\(N\)</span> by a factor of 100. The upshot is it can be computationally expensive to use a large number of space steps, if we want to maintain nonnegative probabilities.</p>
<p>One can reasonably ask whether this is important, because we can certainly solve <a href="#eq-explicit">Equation&nbsp;<span>10.9</span></a> to estimate the call values even when the probabilities are negative. The answer is that it is important, but for a reason we have not yet discussed. In a numerical algorithm for solving a partial differential equation (or for solving many other types of problems) there are two types of errors: discretization error and roundoff error. If we increase <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span> sufficiently, we should reduce the discretization error. However, each calculation on the computer introduces roundoff error. An algorithm is said to be stable if the roundoff errors stay small and bounded as the discretization error is reduced. An unfortunate fact about the explicit method is that it is stable only if the number of time steps increases with the square of the number of space steps. In the absence of this condition, the roundoff errors can accumulate and prevent one from reaching a solution of the desired accuracy.</p>
<p>The implicit method is known to be fully stable, so it is to be preferred to the explicit method. We will discuss briefly how to implement this method, before moving in the next section to the Crank-Nicolson method, which is also fully stable and known to be more efficient than the implicit method.</p>
<p>The implicit method uses the approximation <a href="#eq-implicit_dt">Equation&nbsp;<span>10.8</span></a> for <span class="math inline">\(\partial C/\partial t\)</span>. As before, the call values are defined at the final date as the intrinsic value. Backing up a period, consider a grid point <span class="math inline">\((t_{N-1},x_j)\)</span>. We will try to estimate the call value at this date by forcing <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> to hold at this point. This means <span id="eq-implicit"><span class="math display">\[
rC = \frac{C_{\text{right}}-C}{\Delta t}+ \nu\left(\frac{C_{\text{up}}-C_{\text{down}}}{2\Delta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C_{\text{up}}+C_{\text{down}}-2C}{(\Delta x)^2}\right)\;.
\tag{10.11}\]</span></span></p>
<p>We know <span class="math inline">\(C_{\text{right}}\)</span>, because it is the intrinsic value at <span class="math inline">\((t_N,x_j)\)</span>. This equation links three unknowns (<span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span>, and <span class="math inline">\(C_{\text{down}}\)</span>) to the known value <span class="math inline">\(C_{\text{right}}\)</span>. We cannot solve it explicitly for these three unknowns. Instead, we need to solve a system of linear equations to simultaneously solve for all the call values at date <span class="math inline">\(t_{N-1}\)</span>. There are <span class="math inline">\(2M-1\)</span> equations of the form <a href="#eq-implicit">Equation&nbsp;<span>10.11</span></a> plus conditions that we will impose at the upper and lower boundaries, and we need to solve these for the <span class="math inline">\(2M+1\)</span> call values. This system of equations has the same form, and is solved in the same way, as the system of equations in the Crank-Nicolson method.</p>
</section>
<section id="crank-nicolson" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="crank-nicolson"><span class="header-section-number">10.4</span> Crank-Nicolson</h2>
<p> The estimate <a href="#eq-implicit_dt">Equation&nbsp;<span>10.8</span></a> of <span class="math inline">\(\partial C/\partial t\)</span> used in the implicit method is best understood as an estimate of <span class="math inline">\(\partial C/\partial t\)</span> at the midpoint of <span class="math inline">\((t_i,x_j)\)</span> and <span class="math inline">\((t_{i+1},x_j)\)</span>, i.e., at <span class="math inline">\((t_i+\Delta t/2,x_j)\)</span>. This is the basic idea of the Crank-Nicolson method. With this method, we continue to estimate the call values at the grid points, but we do so by forcing <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> to hold at midpoints of this type. To do this, we also need estimates of <span class="math inline">\(C\)</span>, <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span> at the midpoints, but these are easy to obtain.</p>
<p>Let’s modify the previous notation somewhat, writing <span class="math inline">\(C'\)</span> for <span class="math inline">\(C_{\text{right}}\)</span> and <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span> for the values to the right and one step up and down, i.e., at the grid points <span class="math inline">\((t_i+\Delta t,x_i+\Delta x)\)</span> and <span class="math inline">\((t_i+\Delta t,x_i-\Delta x)\)</span> respectively. The obvious estimate of the call value at the midpoint <span class="math inline">\((t_i+\Delta t/2,x_j)\)</span> is the average of <span class="math inline">\(C\)</span> and <span class="math inline">\(C'\)</span>, so set <span class="math display">\[C^{\text{mid}} = \frac{C+C'}{2}\; .\]</span> Analogously, define <span id="eq-cn1000"><span class="math display">\[
C^{\text{mid}}_{\text{up}} = \frac{C_{\text{up}}+C'_{\text{up}}}{2}\;, \qquad \text{and} \qquad
C^{\text{mid}}_{\text{down}} = \frac{C_{\text{down}}+C'_{\text{down}}}{2}\;.
\tag{10.12}\]</span></span></p>
<p>The formulas <a href="#eq-cn1000">Equation&nbsp;<span>10.12</span></a> give us estimates of the call value at the midpoints one space step up and one space step down from <span class="math inline">\(x_j\)</span>—i.e., at <span class="math inline">\((t_i+\Delta t/2,x_{j+1})\)</span> and <span class="math inline">\((t_i+\Delta t/2,x_{j-1})\)</span>. We can now estimate <span class="math inline">\(\partial C/\partial X\)</span> and <span class="math inline">\(\partial^2 C/\partial X^2\)</span> at the midpoint <span class="math inline">\((t_i+\Delta t/2,x_j)\)</span> exactly as before: <span class="math display">\[\frac{\partial C}{\partial X} \approx \frac{C^{\text{mid}}_{\text{up}}-C^{\text{mid}}_{\text{down}}}{2\Delta x}\; ,\]</span> and <span class="math display">\[\frac{\partial^2 C}{\partial X^2} \approx \frac{C^{\text{mid}}_{\text{up}}+C^{\text{mid}}_{\text{down}}-2C^{\text{mid}}}{(\Delta x)^2}\; .\]</span> Now, <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> becomes <span id="eq-crank"><span class="math display">\[
rC^{\text{mid}} = \frac{C'-C}{\Delta t}+ \nu\left(\frac{C^{\text{mid}}_{\text{up}}-C^{\text{mid}}_{\text{down}}}{2\Delta x}\right)+ \frac{1}{2}\sigma^2\left(\frac{C^{\text{mid}}_{\text{up}}+C^{\text{mid}}_{\text{down}}-2C^{\text{mid}}}{(\Delta x)^2}\right)\;.
\tag{10.13}\]</span></span></p>
<p>Substituting from the formulas for <span class="math inline">\(C^{\text{mid}}\)</span>, <span class="math inline">\(C^{\text{mid}}_{\text{up}}\)</span>, and <span class="math inline">\(C^{\text{mid}}_{\text{down}}\)</span>, we can re-write <a href="#eq-crank">Equation&nbsp;<span>10.13</span></a> as</p>
<p><span id="eq-crank2"><span class="math display">\[
\begin{multline}
\left(\frac{r}{2}+\frac{1}{\Delta t}+\frac{\sigma^2}{2(\Delta x)^2}\right)C - \left(\frac{\sigma^2}{4(\Delta x)^2}+\frac{\nu}{4\Delta x}\right)C_{\text{up}}\\ - \left(\frac{\sigma^2}{4(\Delta x)^2}-\frac{\nu}{4\Delta x}\right)C_{\text{down}}
\quad = \quad \left(\frac{1}{\Delta t}- \frac{r}{2}-\frac{\sigma^2}{2(\Delta x)^2}\right)C' \\+ \left(\frac{\sigma^2}{4(\Delta x)^2}+\frac{\nu}{4\Delta x}\right)C'_{\text{up}} + \left(\frac{\sigma^2}{4(\Delta x)^2}-\frac{\nu}{4\Delta x}\right)C'_{\text{down}}
\end{multline}
\tag{10.14}\]</span></span></p>
<p>We can also write this as <span id="eq-crank3"><span class="math display">\[
a_1C - a_2C_{\text{up}} - a_3C_{\text{down}}
= a_4C' + a_2C'_{\text{up}} + a_3C'_{\text{down}}\;,
\tag{10.15}\]</span></span></p>
<p>where the constants <span class="math inline">\(a_i\)</span> are the factors in parentheses in <a href="#eq-crank2">Equation&nbsp;<span>10.14</span></a>.</p>
<p>As before, we start at the final date <span class="math inline">\(t_N\)</span> and define the call value at that date by its intrinsic value. Consider a grid point <span class="math inline">\((t_{N-1},x_j)\)</span>. Forcing <a href="#eq-3">Equation&nbsp;<span>10.3</span></a> to hold at the midpoint <span class="math inline">\((t_{N-1}+\Delta t/2,x_j)\)</span> leads us to <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a>. In this equation, <span class="math inline">\(C'\)</span>, <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span> are known from the intrinsic value at maturity, and we need to solve for <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span>. There are <span class="math inline">\(2M-1\)</span> linear equations of this type and we will add linear equations at the upper and lower boundaries of the grid and solve the resulting system of <span class="math inline">\(2M+1\)</span> linear equations for the <span class="math inline">\(2M+1\)</span> call values. After finding the call values at date <span class="math inline">\(t_{N-1}\)</span>, we then repeat the calculation at <span class="math inline">\(t_{N-2}\)</span> and continue backing up in this way until we reach the initial date.</p>
<p>Notice that the Crank-Nicolson equations <a href="#eq-crank2">Equation&nbsp;<span>10.14</span></a> are similar to the equations <a href="#eq-implicit">Equation&nbsp;<span>10.11</span></a> in the implicit method, but more information is used in each step of the Crank-Nicolson method than is used in each step of the implicit method. Equation <a href="#eq-crank2">Equation&nbsp;<span>10.14</span></a> links the call values <span class="math inline">\(C\)</span>, <span class="math inline">\(C_{\text{up}}\)</span> and <span class="math inline">\(C_{\text{down}}\)</span> to the previously calculated <span class="math inline">\(C'\)</span>, <span class="math inline">\(C'_{\text{up}}\)</span> and <span class="math inline">\(C'_{\text{down}}\)</span>, whereas in the implicit method they were linked only to <span class="math inline">\(C'\)</span> (which we called <span class="math inline">\(C_{\text{right}}\)</span>).</p>
</section>
<section id="european-options" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="european-options"><span class="header-section-number">10.5</span> European Options</h2>
<p>To value a European option, one simply defines the values at the final date as the intrinsic value and then backs up to the initial date, using any of the methods described (explicit, implicit, or Crank-Nicolson). The value that should be returned is the value at the middle node at the initial date, which corresponds to the initial price of the underlying.</p>
<p>The boundary conditions normally used at the bottom and top of the grid are conditions that the first derivative <span class="math inline">\(\partial C/\partial S\)</span> of the option value are known to satisfy as <span class="math inline">\(S \rightarrow 0\)</span> and <span class="math inline">\(S \rightarrow \infty\)</span>. These are conditions of the form <span id="eq-cn_boundary"><span class="math display">\[
\lim_{S \rightarrow \infty} \frac{\partial C}{\partial S} =  \lambda_0\;,\qquad \text{and} \qquad
\lim_{S \rightarrow 0} \frac{\partial C}{\partial S} = \lambda_{\infty}\;,
\tag{10.16}\]</span></span></p>
<p>for constants <span class="math inline">\(\lambda_0\)</span> and <span class="math inline">\(\lambda_{\infty}\)</span>. In the case of a call option, we have <span class="math inline">\(\lambda_0=0\)</span> and <span class="math inline">\(\lambda_{\infty}=1\)</span>. For a put option, we have <span class="math inline">\(\lambda_0=-1\)</span> and <span class="math inline">\(\lambda_\infty = 0.\)</span></p>
<p>These conditions are implemented on the grid by forcing each value <span class="math inline">\(C\)</span> at a point <span class="math inline">\((t_i,x_{-M})\)</span> on the bottom of the grid to satisfy</p>
<p><span id="eq-crank4a"><span class="math display">\[
C - C_{\text{up}} = \lambda_0 (S - S_{\text{up}})
\tag{10.17}\]</span></span></p>
<p>and by forcing each value <span class="math inline">\(C\)</span> at a point <span class="math inline">\((t_i,x_{M})\)</span> on the top of the grid to satisfy</p>
<p><span id="eq-crank4b"><span class="math display">\[
C-C_{\text{down}} = \lambda_\infty(S-S_{\text{down}})\;.
\tag{10.18}\]</span></span></p>
<p>These two linear equations in the values at time <span class="math inline">\(t_i\)</span> augment the <span class="math inline">\(2M-1\)</span> equations already described to form a system of <span class="math inline">\(2M+1\)</span> linear equations to be solved for the derivative values at the <span class="math inline">\(2M+1\)</span> grid points at time <span class="math inline">\(t_i\)</span>.</p>
</section>
<section id="american-options" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="american-options"><span class="header-section-number">10.6</span> American Options</h2>
<p>The explicit method is easily adapted to American options. As in a binomial model, we compute the option value at each node as the larger of its discounted expected value and its intrinsic value. To be somewhat more precise, we replace the trinomial value <a href="#eq-fdtrinomial">Equation&nbsp;<span>10.10</span></a> with <span class="math display">\[C_{\text{left}} = \max\left(\big(1-r\Delta t\big)\big(p_uC_{\text{up}}+pC + p_dC_{\text{down}}\big), \text{intrinsic value}\right)\; .\]</span> In the Crank-Nicolson method, one can in similar fashion compute the value of the derivative at each space node at any date by solving the system of equations <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a> and then replace the computed values by the intrinsic value when that is higher. However, because the values at the different space nodes are linked (i.e., the method is an implicit-type method), this one-at-a-time replacement of values by intrinsic values is not the most efficient method. See Wilmott <span class="citation" data-cites="Wilmott">(<a href="#ref-Wilmott" role="doc-biblioref">Wilmott 2000</a>)</span> for more details (and for VBA code implementing the projected successive over-relaxation method).</p>
</section>
<section id="sec-s_finitedifferencebarriers" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="sec-s_finitedifferencebarriers"><span class="header-section-number">10.7</span> Barrier Options</h2>
<p>Finite-difference methods work well for valuing discretely-sampled barrier options. For a down-and-out option, one should place the bottom of the grid at the knock-out boundary. For an up-and-out option, one should place the top of the grid at the knock-out boundary. As discussed in <a href="Chapter8.html"><span>Chapter&nbsp;8</span></a>, knock-in options can be valued as standard options minus knock-out options.</p>
<p>For barrier options, the boundary information <a href="#eq-cn_boundary">Equation&nbsp;<span>10.16</span></a> can be replaced by assigning a value of zero at the knock-out boundary. For example, for a down-and-out option, the condition <a href="#eq-crank4a">Equation&nbsp;<span>10.17</span></a> can be replaced by <span class="math inline">\(C=0\)</span>. If the contract specifies that a rebate is to be paid to the buyer when the option is knocked out, then condition <a href="#eq-crank4a">Equation&nbsp;<span>10.17</span></a> should be replaced by <span class="math inline">\(C=\)</span> Rebate.</p>
</section>
<section id="sec-s_finitedifferences_matlab" class="level2" data-number="10.8">
<h2 data-number="10.8" class="anchored" data-anchor-id="sec-s_finitedifferences_matlab"><span class="header-section-number">10.8</span> Calculations in VBA</h2>
<section id="crank-nicolson-1" class="level3">
<h3 class="anchored" data-anchor-id="crank-nicolson-1">Crank-Nicolson</h3>
<p>We will create a program that solves a system of equations of the form <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a>, <a href="#eq-crank4a">Equation&nbsp;<span>10.17</span></a> and <a href="#eq-crank4b">Equation&nbsp;<span>10.18</span></a>. We input the vector <span class="math inline">\(a\)</span> of coefficients, a vector <span class="math inline">\(y\)</span> of dimension <span class="math inline">\(2M+1\)</span> containing the estimated values of the derivative at any date <span class="math inline">\(t_{i+1}\)</span>, an integer <span class="math inline">\(L\)</span> from which <span class="math inline">\(M\)</span> is defined as <span class="math inline">\(M=(L-1)/2\)</span> (i.e., <span class="math inline">\(L=2M+1\)</span>). The function will return the vector of values at date~<span class="math inline">\(t_i\)</span>.</p>
<p>We will write the boundary conditions <a href="#eq-crank4a">Equation&nbsp;<span>10.17</span></a> and <a href="#eq-crank4b">Equation&nbsp;<span>10.18</span></a>, respectively, in the more general forms</p>
<p><span id="eq-crank4aa"><span class="math display">\[
C = z_1 + b_1C_{\text{up}}\;,
\tag{10.19}\]</span></span></p>
<p>and <span id="eq-crank4bb"><span class="math display">\[
C = z_L + b_LC_{\text{down}}\;,
\tag{10.20}\]</span></span></p>
<p>where <span class="math inline">\(z_1\)</span>, <span class="math inline">\(b_1\)</span>, <span class="math inline">\(z_L\)</span> and <span class="math inline">\(b_L\)</span> are numbers to be calculated or input by the user. The equations <a href="#eq-crank4a">Equation&nbsp;<span>10.17</span></a> and <a href="#eq-crank4b">Equation&nbsp;<span>10.18</span></a> are the special cases in which <span class="math inline">\(z_1 = \lambda_0(S-S_{\text{up}})\)</span>, <span class="math inline">\(b_1 = 1\)</span>, <span class="math inline">\(z_L = \lambda_\infty(S-S_{\text{down}})\)</span>, and <span class="math inline">\(b_L=1\)</span>. The additional generality in allowing <span class="math inline">\(b_1\)</span> and <span class="math inline">\(b_L\)</span> to be different from one is important for many purposes, and we will see an example of it in the valuation of barrier options.</p>
<p>The system of equations that we want to solve is therefore $$ {#eq-page_cn}</p>
<span class="math display">\[\begin{pmatrix}
1 &amp; -b_1 &amp; 0 &amp; 0 &amp; 0  &amp; \cdots  &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
-a_3 &amp; a_1 &amp; - a_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; - a_3 &amp; a_1 &amp; -a_2 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp;\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; -a_3 &amp; a_1 &amp; - a_2 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 &amp; 0 &amp; -a_3 &amp; a_1 &amp; - a_2 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0 &amp; 0 &amp; 0 &amp; -b_L &amp; 1 \end{pmatrix}
\begin{pmatrix}
C_1 \\
C_2\\
C_3\\
\vdots\\
C_{L-2}\\
C_{L-1}\\
C_L
\end{pmatrix}\]</span>
=
<span class="math display">\[\begin{pmatrix}
z_1 \\
z_2\\
z_3\\
\vdots\\
z_{L-2}\\
z_{L-1}\\
z_L
\end{pmatrix}\]</span>
<p>$$ where we are denoting the derivative values to be determined at date <span class="math inline">\(t_i\)</span> across the <span class="math inline">\(L\)</span> (<span class="math inline">\(=2M+1\)</span>) space nodes as <span class="math inline">\(C_1, \ldots, C_L\)</span>. The coefficients <span class="math inline">\(a_i\)</span> are defined in <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a>. The numbers <span class="math inline">\(z_2, \ldots, z_{L-1}\)</span> are the right-hand sides of <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a> and are determined by the coefficients <span class="math inline">\(a_i\)</span> and the derivative values <span class="math inline">\(y_1, \ldots, y_{L}\)</span> at date <span class="math inline">\(t_{i+1}\)</span>. The system of equations that must be solved to implement the implicit method is of this same form.</p>
<p>The first equation in this array (equation <a href="#eq-crank4aa">Equation&nbsp;<span>10.19</span></a>) can be written as</p>
<p><span class="math display">\[
C_1 = u_1 + b_1C_2\;,
\]</span> where <span class="math inline">\(u_1 = z_1\)</span>.<br>
By induction, we will see that we can write, for each <span class="math inline">\(j = 2, \ldots, L\)</span>, <span id="eq-crank101"><span class="math display">\[
C_{j-1} = u_{j-1} + b_{j-1}C_{j}
\tag{10.21}\]</span></span></p>
<p>for some coefficients <span class="math inline">\(u_{j-1}\)</span> and <span class="math inline">\(b_{j-1}\)</span> to be determined.<br>
The <span class="math inline">\(j\)</span>–th equation (<span class="math inline">\(j = 2, \ldots, L-1\)</span>) in the array (equation <a href="#eq-crank3">Equation&nbsp;<span>10.15</span></a>) is <span class="math display">\[-a_3C_{j-1}+a_1C_j-a_2C_{j+1} = z_j\; .\]</span> Supposing <a href="#eq-crank101">Equation&nbsp;<span>10.21</span></a> holds and using it to substitute for <span class="math inline">\(C_{j-1}\)</span>, we have <span class="math display">\[-a_3\left(u_{j-1} + b_{j-1}C_{j}\right) +a_1C_j-a_2C_{j+1} = z_j \quad\Longleftrightarrow\quad C_{j} = u_{j} + b_{j}C_{j+1}\; ,\]</span> where <span class="math display">\[\begin{align*}
u_j &amp;= \frac{z_j + a_3u_{j-1}}{a_1-a_3b_{j-1}} \;,\\
b_j &amp;= \frac{a_2}{a_1-a_3b_{j-1}}\;.
\end{align*}\]</span> This establishes that <a href="#eq-crank101">Equation&nbsp;<span>10.21</span></a> holds for each <span class="math inline">\(j = 2, \ldots, L\)</span>.</p>
<p>The last equation in the array (equation <a href="#eq-crank4bb">Equation&nbsp;<span>10.20</span></a>) is <span class="math display">\[
C_L = z_L + b_LC_{L-1}\; .
\]</span> Our induction argument gives us <span class="math display">\[C_{L-1} = u_{L-1} + b_{L-1}C_{L}\; ,\]</span> and when we combine these we have two equations in two unknowns and can solve for <span class="math inline">\(C_L\)</span> as <span class="math display">\[C_L = \frac{z_L+ b_Lu_{L-1}}{1-b_Lb_{L-1}}\; .\]</span> We then successively obtain <span class="math inline">\(C_{L-1}, C_{L-2}, \ldots, C_1\)</span> from <a href="#eq-crank101">Equation&nbsp;<span>10.21</span></a>.</p>
</section>
<section id="crank-nicolson-for-european-options" class="level3">
<h3 class="anchored" data-anchor-id="crank-nicolson-for-european-options">Crank-Nicolson for European Options</h3>
<p>We will demonstrate the Crank-Nicolson method by valuing a European call. Any other path-independent European derivative is valued in the same way, by appropriately redefining the value of the derivative at the final date and redefining the constants <span class="math inline">\(z_1\)</span> and <span class="math inline">\(z_L\)</span> in the boundary conditions <span class="quarto-unresolved-ref">?eq-crank4aabbcombined</span> at the bottom and top of the grid.</p>
<p>As elsewhere in this chapter, <span class="math inline">\(N\)</span> denotes the number of time periods, and <span class="math inline">\(2M+1\)</span> will be the number of <span class="math inline">\(x\)</span> values on the grid. We use the symbol <span class="math inline">\(D\)</span> to denote the distance of the top (or bottom) of the grid from <span class="math inline">\(\log S(0)\)</span>. In other words, <span class="math inline">\(D = x_M-x_0\)</span>. A reasonable value for <span class="math inline">\(D\)</span> would be three standard deviations for <span class="math inline">\(\log S\)</span>, which would mean <span class="math inline">\(D = |\nu|T +3 \sigma\sqrt{T}\)</span>. For example, for a one-year option on a stock with a volatility of 30%, it should suffice to input <span class="math inline">\(D=1\)</span>.</p>
<p>As should be clear, the program is conceptually very similar to a binomial model. The difference is that the backing up procedure, which involves node-by-node discounting in a binomial model, here is accomplished via the Crank-Nicolson algorithm.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
</section>
<section id="crank-nicolson-for-barrier-options" class="level3">
<h3 class="anchored" data-anchor-id="crank-nicolson-for-barrier-options">Crank-Nicolson for Barrier Options</h3>
<p>To price a down-and-out (or up-and-out option), we put the bottom (or top) of the grid at the boundary. The boundary condition that we use is that the value at the boundary is zero. We will consider the example of a down-and-out call option. In this case, the boundary condition at the bottom of the grid is <a href="#eq-crank4aa">Equation&nbsp;<span>10.19</span></a> with <span class="math inline">\(z_1=0\)</span> and <span class="math inline">\(b_1 = 0\)</span>. The boundary condition at the top is the same as for an ordinary call. We can easily handle a rebate paid when the option is knocked out by inputting the value of the rebate as <span class="math inline">\(z_1\)</span>.</p>
<p>The main new issue that we encounter in valuing barriers is locating the boundary of the grid at the barrier. For the down-and-out, we will input the value of the stock price at which the option is knocked out as . We want the bottom of the grid to lie at the natural logarithm of this number. This will influence our choice of the space step <span class="math inline">\(\Delta x\)</span>, because we want to have an integer number of steps between the bottom of the grid and <span class="math inline">\(\log S(0)\)</span>. We assume that the value <span class="math inline">\(M\)</span> input by the user represents the desired number of space steps above <span class="math inline">\(\log S(0)\)</span>. We start with <span class="math inline">\(\Delta x=D/M\)</span> as an initial estimate of the size of the space step. We then decrease it, if necessary, to ensure that the distance between and <span class="math inline">\(\log S(0)\)</span> is an integer multiple of <span class="math inline">\(\Delta x\)</span>. We then increase~<span class="math inline">\(M\)</span>, if necessary, to ensure that the top of the grid will still be at or above <span class="math inline">\(D+\log S(0)\)</span>. Finally, we define the top of the grid to be at <span class="math inline">\(\log S(0) +M \cdot \Delta x\)</span>.</p>
</section>
</section>
<section id="exercises" class="level2" data-number="10.9">
<h2 data-number="10.9" class="anchored" data-anchor-id="exercises"><span class="header-section-number">10.9</span> Exercises</h2>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.1 </strong></span>Create an Excel worksheet to compare the estimates of the value of a discretely sampled barrier option given by the functions created in Prob.~<span class="math inline">\(\ref{e_knockoutmc}\)</span> and the function . Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(K\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, the knock-out barrier, the number of Monte Carlo simulations, and the number of space steps above <span class="math inline">\(\log S(0)\)</span> in the Crank-Nicolson algorithm.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.2 </strong></span>Create a VBA function to value an up-and-out put option by the Crank-Nicolson method.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.3 </strong></span>Create a VBA function that uses the explicit method <a href="#eq-fdtrinomial">Equation&nbsp;<span>10.10</span></a> to value a European call option.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.4 </strong></span>Write the system of equations <a href="#eq-implicit">Equation&nbsp;<span>10.11</span></a> for the implicit method, together with boundary conditions of the form <span class="quarto-unresolved-ref">?eq-crank4aabbcombined</span> as a matrix system and solve for <span class="math inline">\(u_j\)</span> and <span class="math inline">\(b_j\)</span> in <span class="quarto-unresolved-ref">?eq-crank101combined</span>, as in the subsection that defines the function .</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.5 </strong></span>Create a VBA function that solves the system of equations in the preceding exercise.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.6 </strong></span>Create a VBA function that uses the implicit method to value a European call option.</p>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-BrennanSchwartz" class="csl-entry" role="listitem">
Brennan, M., and E. Schwartz. 1978. <em>Finite Difference Methods and Jump Processes Arising in the Pricing of Contingent Claims: A Synthesis. Journal of Financial and Quantitative Analysis 13</em>. 461–474.
</div>
<div id="ref-Tavella" class="csl-entry" role="listitem">
Tavella, D. A. 2002. <em>Quantitative Methods in Derivatives Pricing</em>. Wiley, New York.
</div>
<div id="ref-Wilmott" class="csl-entry" role="listitem">
Wilmott, P. 2000. <em>Paul Wilmott on Quantitative Finance</em>. Vol.&nbsp;2, Wiley, New York.
</div>
<div id="ref-WDH" class="csl-entry" role="listitem">
Wilmott, P., J. Dewynne, and S. Howison. 2000. <em>Option Pricing: Mathematical Models and Computation</em>. Oxford Financial Press, Oxford.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>If the price of the derivative is a function of the asset price <span class="math inline">\(S\)</span> and time, then we can always write it in this form as a function of the natural logarithm of <span class="math inline">\(S\)</span> and time.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>We use a different variable (<span class="math inline">\(y\)</span>) for the call values at the final date—and consequently need to separate the first step of backing up (to the penultimate date) and the other steps of backing up (to date zero)—because element-by-element definition of an array and assignment of an array to a variable require different variable types in VBA. See Appendix~A for more discussion.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter9.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter11.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>