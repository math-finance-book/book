<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Pricing and Hedging Derivative Securities - 10&nbsp; More on Monte Carlo and Binomial Valuation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter11.html" rel="next">
<link href="./Chapter9.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter10.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Pricing and Hedging Derivative Securities</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Calls and Puts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Binomial Model and Changes of Measure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Black-Scholes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Black-Scholes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Estimating and Modelling Volatility</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo and Binomial Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Foreign Exchange</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Forward, Futures, and Exchange Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter9.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exotic Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter10.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Introduction to Fixed Income Derivatives</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Valuing Derivatives in the Extended Vasicek Model</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">A Brief Survey of Term Structure Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./AppendixB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Miscellaneous Facts about Continuous-Time Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Chapter contents</h2>
   
  <ul class="collapse">
  <li><a href="#monte-carlo-models-for-path-dependent-options" id="toc-monte-carlo-models-for-path-dependent-options" class="nav-link active" data-scroll-target="#monte-carlo-models-for-path-dependent-options"><span class="header-section-number">10.1</span> Monte Carlo Models for Path-Dependent Options</a></li>
  <li><a href="#sec-s_curse" id="toc-sec-s_curse" class="nav-link" data-scroll-target="#sec-s_curse"><span class="header-section-number">10.2</span> Binomial Valuation of Basket and Spread Options</a></li>
  <li><a href="#sec-montecarlomultiple" id="toc-sec-montecarlomultiple" class="nav-link" data-scroll-target="#sec-montecarlomultiple"><span class="header-section-number">10.3</span> Monte Carlo Valuation of Basket and Spread Options</a></li>
  <li><a href="#antithetic-variates-in-monte-carlo" id="toc-antithetic-variates-in-monte-carlo" class="nav-link" data-scroll-target="#antithetic-variates-in-monte-carlo"><span class="header-section-number">10.4</span> Antithetic Variates in Monte Carlo</a></li>
  <li><a href="#sec-s_controlvariates" id="toc-sec-s_controlvariates" class="nav-link" data-scroll-target="#sec-s_controlvariates"><span class="header-section-number">10.5</span> Control Variates in Monte Carlo</a></li>
  <li><a href="#accelerating-binomial-convergence" id="toc-accelerating-binomial-convergence" class="nav-link" data-scroll-target="#accelerating-binomial-convergence"><span class="header-section-number">10.6</span> Accelerating Binomial Convergence</a></li>
  <li><a href="#sec-s_montecarlo_matlab" id="toc-sec-s_montecarlo_matlab" class="nav-link" data-scroll-target="#sec-s_montecarlo_matlab"><span class="header-section-number">10.7</span> Calculations in VBA</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">10.8</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-c_montecarlo" class="quarto-section-identifier"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">More on Monte Carlo and Binomial Valuation</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>This chapter is a continuation of <a href="Chapter6.html"><span>Chapter&nbsp;6</span></a>, introducing somewhat more advanced issues and applications of Monte Carlo and binomial models. We will consider some of the exotic options introduced in the previous chapter for which closed-form solutions do not exist: basket options, spread options, discretely-sampled lookback options, and Asian options. The next chapter introduces finite difference methods, which are similar to binomial models in their applications (useful for American options, not so useful for path-dependent options) but generally faster.</p>
<section id="monte-carlo-models-for-path-dependent-options" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="monte-carlo-models-for-path-dependent-options"><span class="header-section-number">10.1</span> Monte Carlo Models for Path-Dependent Options</h2>
<p>A derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length <span class="math inline">\(\Delta t = T/N\)</span> for some integer <span class="math inline">\(N\)</span>. Under the risk-neutral measure, the logarithm of the stock price changes over such a time period by <span id="eq-pathdependent"><span class="math display">\[
\Delta \log S = \nu\,\Delta t + \sigma\sqrt{\Delta t}\,z\;,
\tag{10.1}\]</span></span></p>
<p>where <span class="math inline">\(\nu = r-q-\sigma^2/2\)</span> and <span class="math inline">\(z\)</span> is a standard normal. Given that there are <span class="math inline">\(N\)</span> time periods of length <span class="math inline">\(\Delta t\)</span>, we need to generate <span class="math inline">\(N\)</span> standard normals to generate a stock price path. If we generate <span class="math inline">\(M\)</span> paths to obtain a sample of <span class="math inline">\(M\)</span> option values, then we will need to generate <span class="math inline">\(MN\)</span> standard normals.</p>
<p>Consider for example a floating-strike lookback call. The formula for this option given in <a href="Chapter9.html#sec-s_lookbacks"><span>Section&nbsp;9.7</span></a> assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing <span class="math inline">\(\Delta t\)</span> to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting <span class="math inline">\(N\)</span> to be the number of weeks before the option matures.</p>
<p>Asian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks. We will discuss Asian options in <a href="#sec-s_controlvariates"><span>Section&nbsp;10.5</span></a>.</p>
</section>
<section id="sec-s_curse" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="sec-s_curse"><span class="header-section-number">10.2</span> Binomial Valuation of Basket and Spread Options</h2>
<p> By combining binomial models, we can value options or other derivatives on multiple assets. We will illustrate for an option on two assets. This is the most important case, and the extension to more than two assets is straightforward.</p>
<p>Consider two stocks with constant dividend yields <span class="math inline">\(q_i\)</span> and constant volatilities <span class="math inline">\(\sigma_i\)</span>. Suppose the two Brownian motions driving the two stocks have a constant correlation coefficient <span class="math inline">\(\rho\)</span>. We will denote the price of stock <span class="math inline">\(i\)</span> (<span class="math inline">\(i=1,2\)</span>) in the up state in each period by <span class="math inline">\(u_iS_i\)</span> and the price in the down state by <span class="math inline">\(d_iS_i\)</span>, where <span class="math inline">\(S_i\)</span> is the price at the beginning of the period, and <span class="math inline">\(u_i\)</span> and <span class="math inline">\(d_i\)</span> are parameters to be specified. In each period, there are four possible combinations of returns on the two stocks: up for both stocks, up for stock 1 and down for stock~2, down for stock 1 and up for stock 2, and down for both stocks. Denote the probabilities of these four combinations by <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span> respectively. Thus, there are eight parameters in the binomial model: the number <span class="math inline">\(N\)</span> of periods (which defines the length of each period as <span class="math inline">\(\Delta t=T/N\)</span> where <span class="math inline">\(T\)</span> is the option maturity), the up and down parameters <span class="math inline">\(u_i\)</span> and <span class="math inline">\(d_i\)</span> for each stock, and three probabilities (the fourth probability being determined by the condition that the probabilities sum to one).</p>
<p>Given the period length <span class="math inline">\(\Delta t\)</span>, we want to choose the up and down parameters and the probabilities to match (or approximately match in an appropriate sense) the means, variances and covariances of the returns <span class="math inline">\(\Delta S_i/S_i\)</span> or the continuously-compounded returns <span class="math inline">\(\Delta \log S_i\)</span>. There are two means, two variances and one covariance, so there are five restrictions to be satisfied and seven parameters. As in <a href="Chapter6.html"><span>Chapter&nbsp;6</span></a>, it is convenient to take <span class="math inline">\(d_i = 1/u_i\)</span>, leaving five restrictions and five free parameters.</p>
<p>As discussed in <a href="Chapter6.html#sec-s_binomialparameters"><span>Section&nbsp;6.4</span></a>, there are multiple ways to define the binomial model so that it converges to the continuous-time model as the number of periods is increased. As an example, we will describe here the suggestion of Trigeorgis <span class="citation" data-cites="Trigeorgis">(<a href="#ref-Trigeorgis" role="doc-biblioref">Trigeorgis 1991</a>)</span>, which matches the means, variances and covariance of the continuously-compounded returns. Letting <span class="math inline">\(p_i\)</span> denote the probability of the up state for stock <span class="math inline">\(i\)</span>, matching the means and variances implies, as in <a href="Chapter6.html#sec-s_binomialparameters"><span>Section&nbsp;6.4</span></a>, <span class="math display">\[\begin{align*}
\log u_i&amp;=\sqrt{\sigma_i^2\Delta t + \nu_i^2(\Delta t)^2}\; ,\\
p_i &amp;= \frac{1}{2}+\frac{\nu_i\Delta t}{2\log u_i}\;.
\end{align*}\]</span> where <span class="math inline">\(\nu_i=r-q_i-\sigma_i^2/2\)</span>. In terms of the notation <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span>, the probability of the up state for stock 1 is <span class="math inline">\(p_1=p_{uu}+p_{ud}\)</span> and the probability of the up state for stock 2 is <span class="math inline">\(p_2=p_{uu}+p_{du}\)</span>. Therefore,</p>
<p><span id="eq-prob1"><span class="math display">\[
p_{uu}+p_{ud} = \frac{1}{2}+\frac{\nu_1\Delta t}{2\log u_1}\;,
\tag{10.2}\]</span></span></p>
<p><span id="eq-prob2"><span class="math display">\[
p_{uu}+p_{du} = \frac{1}{2}+\frac{\nu_2\Delta t}{2\log u_2}\;.
\tag{10.3}\]</span></span></p>
<p>In the continuous time model, over a discrete time period <span class="math inline">\(\Delta t\)</span>, the covariance of <span class="math inline">\(\Delta \log S_1\)</span> and <span class="math inline">\(\Delta \log S_2\)</span> is <span class="math inline">\(\rho\sigma_1\sigma_2\Delta t\)</span>. In the binomial model, with <span class="math inline">\(d_i=1/u_i\)</span>, we have <span class="math display">\[E \big[\Delta \log S_1 \times \Delta \log S_2\big] = (p_{uu}-p_{ud}-p_{du}+p_{dd})\log u_1\log u_2\; .\]</span> Given that <span class="math inline">\(E[\Delta\log S_i] =\nu_i\Delta t\)</span>, this implies a covariance of <span class="math display">\[(p_{uu}-p_{ud}-p_{du}+p_{dd})\log u_1\log u_2 - \nu_1\nu_2(\Delta t)^2\; .\]</span> Matching the covariance in the binomial model to the covariance in the continuous-time model therefore implies <span id="eq-prob3"><span class="math display">\[
p_{uu}-p_{ud}-p_{du}+p_{dd} =\frac{\rho\sigma_1\sigma_2\Delta t + \nu_1\nu_2(\Delta t)^2}{\log u_1\log u_2}\;.
\tag{10.4}\]</span></span></p>
<p>We can solve the system <a href="#eq-prob1">Equation&nbsp;<span>10.2</span></a> - <a href="#eq-prob3">Equation&nbsp;<span>10.4</span></a>, together with the condition that the probabilities sum to one, to obtain the probabilities <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span>. This solution and a VBA function for valuing an American spread call option are given in <a href="#sec-s_montecarlo_matlab"><span>Section&nbsp;10.7</span></a>. This function operates much like the binomial valuation of American options described in <a href="Chapter6.html"><span>Chapter&nbsp;6</span></a>. The primary difference is that the value of the option at maturity depends on both stock prices, so we have to consider each possible combination of stock prices. In an <span class="math inline">\(N\)</span>–period model, there are <span class="math inline">\(N+1\)</span> nodes at the final date for each of the two stocks, and hence <span class="math inline">\((N+1)^2\)</span> possible combinations of nodes. In fact, at each date <span class="math inline">\(n\)</span> (<span class="math inline">\(n=0,\ldots,N\)</span>) there are <span class="math inline">\((n+1)^2\)</span> combinations of nodes to be considered.<br>
The computation time required for a spread call option is therefore roughly the square of the time required for a standard call.</p>
<p>Likewise, in an <span class="math inline">\(N\)</span>–period model for a basket option written on three assets, there are <span class="math inline">\((n+1)^3\)</span> combinations of nodes to be considered at date <span class="math inline">\(n\)</span>; if there are five assets, there are <span class="math inline">\((n+1)^5\)</span> combinations, etc. Thus, the computation time required increases exponentially with the number of assets. This can be a serious problem. For example, with five assets and <span class="math inline">\(N=99\)</span>, we would have <span class="math inline">\(100^5\)</span> (10 billion) combinations. As this suggests, problems with multiple assets quickly become intractable in a binomial framework. This is called the curse of dimensionality. </p>
</section>
<section id="sec-montecarlomultiple" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="sec-montecarlomultiple"><span class="header-section-number">10.3</span> Monte Carlo Valuation of Basket and Spread Options</h2>
<p> In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. As noted in <a href="Chapter9.html#sec-s_baskets"><span>Section&nbsp;9.8</span></a>, there are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.</p>
<p>The difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral measure). In an <span class="math inline">\(N\)</span>–period model, the binomial model produces <span class="math inline">\(N+1\)</span> values for the terminal price of each underlying asset. Letting <span class="math inline">\(k\)</span> denote the number of underlying assets, this produces <span class="math inline">\((N+1)^k\)</span> combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces <span class="math inline">\(M\)</span> combinations of terminal prices, where <span class="math inline">\(M\)</span> is the number of simulations. Each combination is given the same weight (<span class="math inline">\(1/M\)</span>) when estimating the expected value.</p>
<p>With a single underlying asset, the binomial model is more efficient, as discussed in <a href="Chapter6.html#sec-s_introbinomial"><span>Section&nbsp;6.2</span></a>, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the <span class="math inline">\((N+1)^k\)</span> combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.</p>
<p>To implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. As observed in <a href="Chapter5.html#sec-s_stochasticvolatility"><span>Section&nbsp;5.5</span></a>, we can simulate the changes in two Brownian motions <span class="math inline">\(B_1\)</span> and <span class="math inline">\(B_2\)</span> that have correlation <span class="math inline">\(\rho\)</span> by generating two independent standard normals <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> and defining <span class="math display">\[\Delta B_1 = \sqrt{\Delta t}\,Z_1\;, \qquad \text{and} \qquad \Delta B_2 = \sqrt{\Delta t}\,Z\; ,\]</span> where <span class="math inline">\(Z\)</span> is defined as <span class="math display">\[Z = \rho Z_1 + \sqrt{1-\rho^2}\,Z_2\; .\]</span> The random variable <span class="math inline">\(Z\)</span> is also a standard normal, and the correlation between <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z\)</span> is <span class="math inline">\(\rho\)</span>.<br>
Thus, we can simulate the changes in the logarithms of two correlated asset prices as <span class="math display">\[\begin{align*}
\Delta \log S_1 &amp;= \nu_1\Delta t + \sigma_1\sqrt{\Delta t}Z_1 \; ,\\
\Delta \log S_2 &amp;= \nu_2\Delta t + \sigma_2\rho\sqrt{\Delta t}Z_1 + \sigma_2\sqrt{1-\rho^2}\sqrt{\Delta t}Z_2\;,
\end{align*}\]</span> where <span class="math inline">\(\nu_i = r-q_1-\sigma_i^2/2\)</span> and the <span class="math inline">\(Z_i\)</span> are independent standard normals.</p>
<p>To generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as</p>
<p><span id="eq-mc_twoa"><span class="math display">\[
\Delta \log S_1 = \nu_1\Delta t + a_{11}\sqrt{\Delta t}Z_1 + a_{12}\sqrt{\Delta t}Z_2\;,
\tag{10.5}\]</span></span></p>
<p><span id="eq-mc_twob"><span class="math display">\[
\Delta \log S_2 = \nu_2\Delta t + a_{21}\sqrt{\Delta t}Z_1 + a_{22}\sqrt{\Delta t}Z_2\;,
\tag{10.6}\]</span></span></p>
<p>where <span class="math display">\[\begin{array}{rclcrcl}
a_{11}&amp;=&amp;\sigma_1\;, &amp;\qquad &amp; a_{12}&amp;=&amp;0\; ,\\
a_{21}&amp;=&amp;\sigma_2\rho\;, &amp;\qquad &amp; a_{22} &amp;= &amp;\sigma_2\sqrt{1-\rho^2}\;.
\end{array}\]</span> These are not the only possible choices for the constants <span class="math inline">\(a_{ij}\)</span>. Given that <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> are independent standard normals, the conditions the <span class="math inline">\(a_{ij}\)</span> must satisfy in order to match the variances <span class="math inline">\(\sigma_i^2\Delta t\)</span> and correlation <span class="math inline">\(\rho\)</span> of the changes in the logarithms are</p>
<p><span id="eq-a1"><span class="math display">\[
a_{11}^2+a_{12}^2 =\sigma_1^2\;,
\tag{10.7}\]</span></span></p>
<p><span id="eq-a2"><span class="math display">\[
a_{21}^2+a_{22}^2 =\sigma_2^2\;,
\tag{10.8}\]</span></span></p>
<p><span id="eq-a3"><span class="math display">\[
a_{11}a_{21}+a_{12}a_{22} = \sigma_1\sigma_2\rho\;.
\tag{10.9}\]</span></span></p>
<p>These three equations in the four coefficients <span class="math inline">\(a_{ij}\)</span> leave one degree of freedom. We choose to take <span class="math inline">\(a_{12}=0\)</span> and then solve for the other three.</p>
<p>In matrix notation, the system <a href="#eq-a1">Equation&nbsp;<span>10.7</span></a> - <a href="#eq-a3">Equation&nbsp;<span>10.9</span></a> plus the condition <span class="math inline">\(a_{12}=0\)</span> can be written as the equation <span class="math display">\[\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}^\top = \begin{pmatrix}\sigma_1^2 &amp; \rho\sigma_1\sigma_2 \\\rho\sigma_1\sigma_2 &amp; \sigma_2^2\end{pmatrix}\; ,\]</span> where <span class="math inline">\(^\top\)</span> denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the <span class="math inline">\(a_{ij}\)</span> so that the lower triangular matrix <span class="math display">\[A \equiv \begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}\]</span> satisfies <span class="math display">\[AA^\top = \text{covariance matrix}\]</span> is called the the Cholesky decomposition of the covariance matrix. Given any number <span class="math inline">\(L\)</span> of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the <span class="math inline">\(L\times L\)</span> covariance matrix always exists. An algorithm for computing the Cholesky decomposition is given in <a href="#sec-s_montecarlo_matlab"><span>Section&nbsp;10.7</span></a>.</p>
<p>We can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> If there were some path dependency in the option value, we would simulate the paths of the asset prices as in <a href="#eq-mc_twoa">Equation&nbsp;<span>10.5</span></a> - <a href="#eq-mc_twob">Equation&nbsp;<span>10.6</span></a>. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date <span class="math inline">\(T\)</span>, as in <a href="Chapter6.html#sec-s_mc_europeans"><span>Section&nbsp;6.1</span></a>. The value of a basket call option at its maturity <span class="math inline">\(T\)</span> is <span class="math display">\[\max\left(0,\;\sum_{i=1}^L w_iS_i(T)-K\right)\; ,\]</span> where <span class="math inline">\(L\)</span> is the number of assets in the basket (portfolio) and <span class="math inline">\(w_i\)</span> is the weight of the <span class="math inline">\(i\)</span>–th asset in the basket. The logarithm of the <span class="math inline">\(i\)</span>–th asset price at maturity is simulated as <span class="math display">\[\log S_i(T) = \log S_i(0) +\nu_iT + \sqrt{T} \sum_{j=1}^L a_{ij}Z_j\; ,\]</span> where the <span class="math inline">\(Z_j\)</span> are independent standard normals. Given the simulated values of the <span class="math inline">\(\log S_i(T)\)</span>, the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.</p>
</section>
<section id="antithetic-variates-in-monte-carlo" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="antithetic-variates-in-monte-carlo"><span class="header-section-number">10.4</span> Antithetic Variates in Monte Carlo</h2>
<p>In this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method. These are two of the simplest methods. They are used extensively, but there are other important methods that are also widely used. J"ackel <span class="citation" data-cites="Jackel">(<a href="#ref-Jackel" role="doc-biblioref">Jäckel 2002</a>)</span> and Glasserman <span class="citation" data-cites="Glasserman">(<a href="#ref-Glasserman" role="doc-biblioref">Glasserman 2004</a>)</span> provide a wealth of information on this topic.</p>
<p>The Monte Carlo method estimates the mean <span class="math inline">\(\mu\)</span> of a random variable <span class="math inline">\(x\)</span> as the sample average of randomly generated values of <span class="math inline">\(x\)</span>. An antithetic variate is a random variable <span class="math inline">\(y\)</span> with the same mean as <span class="math inline">\(x\)</span> and a negative correlation with <span class="math inline">\(x\)</span>. It follows that the random variable <span class="math inline">\(z=(x+y)/2\)</span> will have the same mean as <span class="math inline">\(x\)</span> and a lower variance. Therefore the sample mean of <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span> will be an unbiased estimate of <span class="math inline">\(\mu\)</span> and will have a lower standard error than the sample mean of <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(x\)</span>. Thus, we should obtain a more efficient estimator of <span class="math inline">\(\mu\)</span> by simulating <span class="math inline">\(z\)</span> instead of <span class="math inline">\(x\)</span>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>In the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent). The terminal value of the derivative written on the first asset serves as <span class="math inline">\(x\)</span> and the terminal value of the derivative written on the second serves as <span class="math inline">\(y\)</span>. Because both asset prices have the same distribution, the means of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> will be the same, and the discounted mean is the date–0 value of the derivative.</p>
<p>Consider for example a non-path-dependent option in a world with constant volatility. In each simulation <span class="math inline">\(i\)</span> (<span class="math inline">\(i=1,\ldots,M\)</span>), we would generate a standard normal <span class="math inline">\(Z_i\)</span> and compute <span class="math display">\[\begin{align*}
\log S_i(T) &amp;= \log S(0) + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma\sqrt{T}Z_i\; ,\\
\log S_i'(T) &amp;= \log S(0) + \left(r-q-\frac{1}{2}\sigma^2\right)T - \sigma\sqrt{T}Z_i\;.
\end{align*}\]</span> Given the first terminal price, the value of the derivative will be some number <span class="math inline">\(x_i\)</span> and given the second it will be some number <span class="math inline">\(y_i\)</span>. The date–0 value of the derivative is estimated as <span class="math display">\[\mathrm{e}^{-rT}\frac{1}{M}\sum_{i=1}^M\frac{x_i+y_i}{2}\; .\]</span> We will illustrate this method for the floating-strike lookback call in <a href="#sec-s_montecarlo_matlab"><span>Section&nbsp;10.7</span></a>.</p>
</section>
<section id="sec-s_controlvariates" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="sec-s_controlvariates"><span class="header-section-number">10.5</span> Control Variates in Monte Carlo</h2>
<p> Another approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable. We can explain this in terms of linear regression in statistics. Suppose we have a random sample <span class="math inline">\(\{x_1,\ldots,x_M\}\)</span> of a variable <span class="math inline">\(x\)</span> with unknown mean <span class="math inline">\(\mu\)</span>, and suppose we have a corresponding sample <span class="math inline">\(\{y_1,\ldots,y_M\}\)</span> of another variable <span class="math inline">\(y\)</span> with known mean <span class="math inline">\(\phi\)</span>. Then an efficient estimate of <span class="math inline">\(\mu\)</span> is <span class="math inline">\(\hat{\mu} = \bar{x} + \hat{\beta} (\phi-\bar{y})\)</span>, where <span class="math inline">\(\bar{x}\)</span> and <span class="math inline">\(\bar{y}\)</span> denote the sample means of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and where <span class="math inline">\(\hat{\beta}\)</span> is the coefficient of <span class="math inline">\(y\)</span> in the linear regression of <span class="math inline">\(x\)</span> on <span class="math inline">\(y\)</span> (i.e., the estimate of <span class="math inline">\(\beta\)</span> in the linear model <span class="math inline">\(x = \alpha +\beta y + \varepsilon\)</span>). The standard Monte Carlo method, which we have described thus far, simply estimates the mean of <span class="math inline">\(x\)</span> as <span class="math inline">\(\bar{x}\)</span>. The control variate method adjusts the estimate by adding <span class="math inline">\(\hat{\beta} (\phi-\bar{y})\)</span>. To understand this correction, assume for example that the true <span class="math inline">\(\beta\)</span> is positive. If the random sample is such that <span class="math inline">\(\bar{y}&lt;\phi\)</span>, then it must be that small values of <span class="math inline">\(y\)</span> were over-represented in the sample. Since <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> tend to move up and down together (this is the meaning of a positive <span class="math inline">\(\beta\)</span>) it is likely that small values of <span class="math inline">\(x\)</span> were also over-represented in the sample. Therefore, one should adjust the sample mean of <span class="math inline">\(x\)</span> upwards in order to estimate <span class="math inline">\(\mu\)</span>. The best adjustment will take into account the extent to which small values of <span class="math inline">\(y\)</span> were over-represented (i.e., the difference between <span class="math inline">\(\bar{y}\)</span> and <span class="math inline">\(\phi\)</span>) and the strength of the relation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> (which the estimate <span class="math inline">\(\hat{\beta}\)</span> represents). The efficient correction of this sort is also the simplest: just add <span class="math inline">\(\hat{\beta}(\phi-\bar{y})\)</span> to <span class="math inline">\(\bar{x}\)</span>. In practice, the estimation of <span class="math inline">\(\hat{\beta}\)</span> may be omitted and one may simply take <span class="math inline">\(\hat{\beta}=1\)</span>, if the relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be assumed to be one-for-one. If <span class="math inline">\(\beta\)</span> is to be estimated, the estimate (by ordinary least squares) is <span class="math display">\[\hat{\beta} = \frac{\sum_{i=1}^M x_iy_i - M\bar{x}\bar{y}}{\sum_{i=1}^M y_i^2 - M\bar{y}^2}\; .\]</span> In general, the correction term <span class="math inline">\(\hat{\beta}(\phi-\bar{y})\)</span> will have a nonzero mean, which introduces a bias in the estimate of <span class="math inline">\(\mu\)</span>. To eliminate the bias, one can compute <span class="math inline">\(\hat{\beta}\)</span> from a pre-sample of <span class="math inline">\(\{x,y\}\)</span> values.</p>
<p>As an example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let <span class="math inline">\(\tau\)</span> denote the amount of time that has elapsed since the call was issued and <span class="math inline">\(T\)</span> the amount of time remaining before maturity, so the total maturity of the call is <span class="math inline">\(T+\tau\)</span>. To simplify somewhat, assume date 0 is the beginning of a period between observations. Let <span class="math inline">\(t_1, \ldots, t_N\)</span> denote the remaining sampling dates, with <span class="math inline">\(t_1 = \Delta t\)</span>, <span class="math inline">\(t_i-t_{i-1}=\Delta t = T/N\)</span> for each <span class="math inline">\(i\)</span>, and <span class="math inline">\(t_N=T\)</span>. We will input the average price <span class="math inline">\(A(0)\)</span> computed up to date 0, assuming this average includes the price <span class="math inline">\(S(0)\)</span> at date 0. The average price at date <span class="math inline">\(T\)</span> will be <span class="math display">\[A(T) = \frac{\tau}{T+\tau}A(0) + \frac{T}{T+\tau}\left(\frac{\sum_{i=1}^N S(t_i)}{N}\right)\; .\]</span> The average-price call pays <span class="math inline">\(\max(0,A(T)-K)\)</span> at its maturity <span class="math inline">\(T\)</span>, and we can write this as <span class="math display">\[\begin{align*}
\max(A(T)-K,0) &amp;= \max\left(\frac{T}{T+\tau}\left( \frac{\sum_{i=1}^N S(t_i)}{N}\right) - \left(K - \frac{\tau}{T+\tau}A(0)\right), 0\right)\\
&amp;= \frac{T}{T+\tau} \max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\;,
\end{align*}\]</span> where <span class="math display">\[K^* = \frac{T+\tau}{T}K - \frac{\tau}{T}A(0)\; .\]</span> Therefore, the value at date 0 of the discretely-sampled average-price call is <span class="math display">\[\frac{T}{T+\tau} \,\mathrm{e}^{-rT} E^R\left[\max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\right]\; .\]</span> In terms of the discussion above, the random variable the mean of which we want to estimate is <span class="math display">\[x = \mathrm{e}^{-rT}\max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\; .\]</span> A random variable <span class="math inline">\(y\)</span> that will be closely correlated to <span class="math inline">\(x\)</span> is <span class="math display">\[y =\mathrm{e}^{-rT}\max \left(\mathrm{e}^{\sum_{i=1}^N \log S(t_i)/N} - K^*,0\right)\; .\]</span> The mean <span class="math inline">\(\phi\)</span> of <span class="math inline">\(y\)</span> under the risk-neutral measure is given in the pricing <a href="Chapter9.html#eq-disc_geom_avg_call">Equation&nbsp;<span>9.47</span></a>. We can use the sample mean of <span class="math inline">\(y\)</span> and its known mean <span class="math inline">\(\phi\)</span> to adjust the sample mean of <span class="math inline">\(x\)</span> as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient <span class="math inline">\(\hat{\beta}\)</span> will be quite close to 1.</p>
</section>
<section id="accelerating-binomial-convergence" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="accelerating-binomial-convergence"><span class="header-section-number">10.6</span> Accelerating Binomial Convergence</h2>
<p>Broadie and Detemple <span class="citation" data-cites="BD">(<a href="#ref-BD" role="doc-biblioref">Broadie and Detemple 1997</a>)</span> show that a modified binomial model is a quite efficient way to value American put options. They modify the binomial model as follows: (i) the Black-Scholes formula is used to value the option at the penultimate date, and (ii) Richardson extrapolation is used to estimate what the option value would be with an infinite number of periods.</p>
If an option is not exercised at date <span class="math inline">\(N-1\)</span> in an <span class="math inline">\(N\)</span>–period binomial model (i.e., one date from the end), then, because in the binomial model there are no further opportunities for early exercise, the American option at date <span class="math inline">\(N-1\)</span> is equivalent to a European option at that date. The value of a European option is given by the Black-Scholes formula. Therefore, the estimate of the option value can be improved by replacing
with
<p>at date <span class="math inline">\(N-1\)</span> (of course this also means that we do not need to compute the intrinsic value at date <span class="math inline">\(N\)</span>). This idea can be effectively used in binomial valuation of any option for which there is a closed-form solution (like the Black-Scholes formula) for the value of the corresponding European option in a continuous-time model.</p>
<p>Broadie and Detemple combine the use of the Black-Scholes formula at date <span class="math inline">\(N-1\)</span> with Richardson extrapolation. Richardson extrapolation is a method that may improve the efficiency of any algorithm by extrapolating to the limit. In the case of a binomial model, the idea is to extrapolate the values calculated for different numbers of periods (different <span class="math inline">\(N\)</span>’s) to try to estimate the value for <span class="math inline">\(N=\infty\)</span>.</p>
<p>It is easier to work with convergence to zero than convergence to infinity, so define <span class="math inline">\(x=1/N\)</span>. For any value of <span class="math inline">\(N\)</span>, the binomial model will return a value, which is an estimate of the option value and which we denote as <span class="math inline">\(y=f(x)\)</span>. We would like to know the value at <span class="math inline">\(N=\infty\)</span>, which in this notation is <span class="math inline">\(f(0)\)</span>. Of course, we cannot calculate <span class="math inline">\(f(0)\)</span>, because we do not know the function <span class="math inline">\(f\)</span>, but we can approximate <span class="math inline">\(f\)</span> by a known function <span class="math inline">\(g\)</span> and then estimate <span class="math inline">\(f(0)\)</span> by <span class="math inline">\(g(0)\)</span>.</p>
<p>A linear approximation is the simplest and is shown by Broadie and Detemple to be quite effective. For a linear approximation, we would take <span class="math display">\[g(x) = a + bx\]</span> for parameters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to be determined. We can input values <span class="math inline">\(N_1\)</span> and <span class="math inline">\(N_2 = 2N_1\)</span> for the number of periods, run the binomial model for each, set <span class="math inline">\(x_i=1/N_i\)</span>, and define <span class="math inline">\(y_i=f(x_i)\)</span> to be the value of the option returned by the binomial model when the number of periods is <span class="math inline">\(N_i\)</span>. Then we force <span class="math inline">\(g(x_i)=f(x_i)\)</span> for <span class="math inline">\(i=1,2\)</span> by solving the equations <span class="math display">\[y_i=a + bx_i\]</span> for <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Of course, <span class="math inline">\(g(0) = a\)</span>, so we will return the constant <span class="math inline">\(a\)</span> as our estimate of <span class="math inline">\(f(0)\)</span>. This is simpler than it may appear—we put <span class="math display">\[\begin{equation*}\begin{array}{rclcl}
y_1 &amp;= &amp;a + bx_1 &amp;= &amp;a+2bx_2\;,\\
y_2 &amp;= &amp; &amp;  &amp; a + bx_2 \;,
\end{array}\end{equation*}\]</span> and subtracting gives us <span class="math inline">\(y_1-y_2 = bx_2\)</span>, which implies from the bottom equation that <span class="math inline">\(a = 2y_2-y_1\)</span>. We can think of <span class="math inline">\(N_2\)</span> as being the number of periods we want to use in the binomial model, in which case <span class="math inline">\(y_2\)</span> would be our estimate of the option value. Richardson extrapolation here means also running the binomial model for half as many periods (<span class="math inline">\(N_1 = N_2/2\)</span>) and adding the difference of the estimates <span class="math inline">\(y_2-y_1\)</span> to the estimate <span class="math inline">\(y_2\)</span>.</p>
<p>Richardson extrapolation can be viewed as cancelling the first-order term in the Taylor series expansion of <span class="math inline">\(f\)</span>. We have <span class="math display">\[\begin{align*}
y_1 = f(x_1) &amp;= f(0) + f'(0)x_1 + \text{higher order terms} \\
&amp; = f(0) + 2f'(0)x_2 + \text{higher order terms}\;,\\
y_2 = f(x_2) &amp;= f(0) + f'(0)x_2 + \text{higher order terms}\;.
\end{align*}\]</span> This implies <span class="math display">\[2y_2-y_1 = f(0) + \text{difference of higher order terms}\;.\]</span> Having eliminated the first-order term, one can hope to obtain a closer approximation to <span class="math inline">\(f(0)\)</span>.</p>
</section>
<section id="sec-s_montecarlo_matlab" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="sec-s_montecarlo_matlab"><span class="header-section-number">10.7</span> Calculations in VBA</h2>
<section id="monte-carlo-valuation-of-path-dependent-options" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-valuation-of-path-dependent-options">Monte Carlo Valuation of Path-Dependent Options</h3>
<p>We will illustrate the valuation of path-dependent options by Monte Carlo by valuing a discretely-sampled floating-strike lookback call.<br>
The inputs of the following are the same as for the lookback-call pricing function in <a href="Chapter9.html#sec-s_lookbacks"><span>Section&nbsp;9.7</span></a>, plus the number of time periods and the number of simulations . The logarithm of the initial stock price and the logarithm of the historical minimum are calculated and stored at the beginning of the program. In each simulation <span class="math inline">\(i = 1,\ldots, M\)</span>, the variables and are initialized to equal the stored values. They are then updated at each time period <span class="math inline">\(j=1,\ldots N\)</span> in accord with <a href="#eq-pathdependent">Equation&nbsp;<span>10.1</span></a>, with being changed only when a new minimum is reached.</p>
</section>
<section id="binomial-valuation-of-american-spread-options" class="level3">
<h3 class="anchored" data-anchor-id="binomial-valuation-of-american-spread-options">Binomial Valuation of American Spread Options</h3>
To illustrate binomial valuation of basket and spread options, we will consider an American put written on a spread <span class="math inline">\(S_1 - S_2\)</span>. The value of the option at maturity is <span class="math display">\[\max\big(0,K-[S_1(T)-S_2(T)]\big) = \max\big(0,K-S_1(T)+S_2(T)\big)\; .\]</span> We input the stock parameters as vectors <span class="math inline">\(=\{S(1),S(2)\}\)</span>, <span class="math inline">\(= \{q(1),q(2)\}\)</span>, <span class="math inline">\(=\{\sigma(1),\sigma(2)\}\)</span>. This can be done by inputting a cell range (e.g., ) for each variable or by inputting the values enclosed in curly braces (e.g., <span class="math inline">\(\{50,40\}\)</span>). The following declares certain arrays and defines the binomial parameters.
In each of the two binomial models, there are <span class="math inline">\(N+1\)</span> nodes at the last date. This implies <span class="math inline">\((N+1)^2\)</span> possible combinations. We define the put values at the last date by looping over the <span class="math inline">\(N+1\)</span> possibilities for the second stock price, for each possible value for the first stock price. Rather than recalculating the <span class="math inline">\(N+1\)</span> values for the second stock price each time we loop over them, it is more efficient to store them in a vector. For the sake of simplicity, we will do the same for the first stock. We store all the prices in a <span class="math inline">\(2 \times (N\!+\!1)\)</span> array denoted . We store the put values in an <span class="math inline">\((N\!+\!1) \times (N\!+\!1)\)</span> array. is the put value when both stocks are at their bottom nodes, is the value when the first stock is at its bottom node and the second stock is one node up from the bottom, etc.
Now we back up <span class="math inline">\(N\)</span> times to get to the beginning of the tree, checking the early exercise condition at each date, and return the put value as .
</section>
<section id="cholesky-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="cholesky-decomposition">Cholesky Decomposition</h3>
<p>An algorithm for computing the decomposition is as follows. We assume the <span class="math inline">\(L\times L\)</span> matrix has been input as , with the interpretation that is <span class="math inline">\(\sigma_i\sigma_j\rho_{ij}\)</span> and is <span class="math inline">\(\sigma_i^2\)</span> for <span class="math inline">\(i, j = 1, \ldots, L\)</span>. We start the indices <span class="math inline">\(i,j\)</span> at 1 because this is the convention when inputting arrays from an Excel worksheet. The output matrix is also indexed <span class="math inline">\(i,j = 1, \ldots, L\)</span>.</p>
</section>
<section id="monte-carlo-valuation-of-european-basket-options" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-valuation-of-european-basket-options">Monte Carlo Valuation of European Basket Options</h3>
<p>We input as the vector of initial asset prices, as the vector of dividend yields, as the covariance matrix, as the vector of weights defining the basket option, and as the number of assets in the basket. The following function can also be used to value a spread option, by inputting <span class="math inline">\(=2\)</span> and =<span class="math inline">\([1, -1]\)</span>.</p>
</section>
<section id="monte-carlo-valuation-with-an-antithetic-variate" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-valuation-with-an-antithetic-variate">Monte Carlo Valuation with an Antithetic Variate</h3>
We will illustrate antithetic variates by modifying our previous valuation of a floating strike call. We denote <span class="math inline">\(\log S\)</span> by and <span class="math inline">\(\log S^*\)</span> by . We simulate <span class="math display">\[\Delta \,\text{LogS(1)} = \nu\,\Delta t + \sigma \Delta B\]</span> and <span class="math display">\[\Delta \,\text{LogS(2)} = \nu\,\Delta t - \sigma \Delta B\; .\]</span> We compute the minimums and of the logarithms of the two stock prices for each simulated path, and compute at the end of each simulated path the average call value <span class="math display">\[0.5 \times \max\left(0,\mathrm{e}^{\text{LogS(1)}} - \mathrm{e}^{\text{LogSMin(1)}}\right) + 0.5 \times \max\left(0,\mathrm{e}^{\text{LogS(2)}} - \mathrm{e}^{\text{LogSMin(2)}}\right)\; .\]</span>
</section>
<section id="monte-carlo-valuation-with-a-control-variate" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-valuation-with-a-control-variate">Monte Carlo Valuation with a Control Variate</h3>
<p>We use the geometric average as a control variate for the arithmetic average in an average-price call, using a pre-sample to estimate the beta. For pedagogic purposes, we return the beta in addition to the call value.</p>
</section>
<section id="accelerated-binomial-valuation-of-american-puts" class="level3">
<h3 class="anchored" data-anchor-id="accelerated-binomial-valuation-of-american-puts">Accelerated Binomial Valuation of American Puts</h3>
<p>First we create a binomial valuation program that replaces (i) calculation of the intrinsic value at maturity and (ii) calculation of the value at the penultimate date as the larger of intrinsic value and the discounted value at maturity with (iii) calculation of the value at the penultimate date as the larger of intrinsic value and the Black-Scholes value of a European option with one period to maturity.</p>
<p>Now we create a program that uses Richardson extrapolation from a binomial model with <span class="math inline">\(N\)</span> periods and a binomial model with <span class="math inline">\(N/2\)</span> periods to estimate the value from a binomial model with an infinite number of periods. We use the previous program as our binomial model.</p>
</section>
</section>
<section id="exercises" class="level2" data-number="10.8">
<h2 data-number="10.8" class="anchored" data-anchor-id="exercises"><span class="header-section-number">10.8</span> Exercises</h2>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.1 </strong></span>Create an Excel worksheet in which the user inputs <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(S_{\text{min}}\)</span>, <span class="math inline">\(T\)</span>, <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span>. Compute the value of a floating strike call by Monte Carlo with and without using an antithetic variate. Compare the standard errors.</p>
</div>
<div id="exr-e_richextrap" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.2 </strong></span>&nbsp;</p>
Create an Excel worksheet to compare the estimates of the value of an American put given by the functions
and
<p>for various values of <span class="math inline">\(N\)</span>. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(K\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, and <span class="math inline">\(T\)</span>. To assess the quality of the estimates, provide also the estimate given by the function with a large value of <span class="math inline">\(N\)</span> (say <span class="math inline">\(N = 1000\)</span>).</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.3 </strong></span>&nbsp;</p>
Estimate the value of option (c) in <a href="Chapter9.html#exr-e_averagehedge">Exercise&nbsp;<span>9.11</span></a> using the function
<p>Complete the simulations in <a href="Chapter9.html#exr-e_averagehedge2">Exercise&nbsp;<span>9.12</span></a> by including the cost of the options for hedge (c).</p>
</div>
<div id="exr-e_basketbinomial" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.4 </strong></span>Create a VBA function to value a basket option on two assets.</p>
</div>
<p>::: {#exr-nolabel} Create a VBA function that calls the function from <a href="#exr-e_basketbinomial">Exercise&nbsp;<span>10.4</span></a> and uses Richardson extrapolation to estimate the value of a basket call in a binomial model with <span class="math inline">\(N=\infty\)</span>.<br>
:::</p>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.5 </strong></span>Create a VBA function that uses Monte Carlo with an antithetic variate to value a basket call option. Create an Excel worksheet to compare the standard errors of the estimates from the functions and for a call on a basket of three assets. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(K\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\cov\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(w\)</span>, <span class="math inline">\(T\)</span>, and <span class="math inline">\(M\)</span>. Recall that <span class="math inline">\(S\)</span>, <span class="math inline">\(\cov\)</span>, <span class="math inline">\(q\)</span> and <span class="math inline">\(w\)</span> are arrays.</p>
</div>
<div id="exr-e_richextrap2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.6 </strong></span>Create an Excel worksheet to compare the estimates of the value of a basket call on two assets given by the binomial model (with and without Richardson extrapolation) and Monte Carlo (with and without an antithetic variate) for various values of <span class="math inline">\(N\)</span> and <span class="math inline">\(M\)</span>. To assess the quality of the estimates, provide also the estimate given by the binomial model without Richardson extrapolation with <span class="math inline">\(N=100\)</span>.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.7 </strong></span>Suppose you must purchase 100 units of each of two assets at the end of the quarter (<span class="math inline">\(T=0.25\)</span>). You want to hedge the cost at the beginning of the quarter. Use simulation in an Excel worksheet to compare the quality of the following hedges (assuming 100 contracts for each option in (a) and 200 contracts in (b) and (c)):</p>
<ol type="1">
<li>standard European calls for both assets,</li>
<li>a basket call written on both assets (with <span class="math inline">\(w_1 = w_2 = 0.5\)</span>),</li>
<li>a call on the maximum of the two asset prices</li>
</ol>
<p>Assume the two assets have the same initial price <span class="math inline">\(S\)</span> and the options are all at the money at the beginning of the quarter. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma_1\)</span>, <span class="math inline">\(\sigma_2\)</span>, <span class="math inline">\(\rho\)</span>, <span class="math inline">\(q_1\)</span>, and <span class="math inline">\(q_2\)</span>. Compare the quality of the hedges as in <a href="Chapter9.html#exr-e_standardknockout">Exercise&nbsp;<span>9.7</span></a>.</p>
</div>
<p>::: {#exr-nolabel} Compute the prices of the options in the previous exercise (using a binomial model or Monte Carlo for the basket option). Compare the hedges including the costs of the options as in <a href="Chapter9.html#exr-e_standardknockout2">Exercise&nbsp;<span>9.8</span></a>. :::</p>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.8 </strong></span>Create a VBA function that calls and uses Richardson extrapolation to estimate the value of an American spread put for <span class="math inline">\(N=\infty\)</span>. Create an Excel spreadsheet to compare the estimates of the functions as in <a href="#exr-e_richextrap2">Exercise&nbsp;<span>10.6</span></a>.</p>
</div>
<div id="exr-e_knockoutmc" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.9 </strong></span>Create a VBA function using Monte Carlo to value a discretely sampled down-and-out call option. The inputs should be <span class="math inline">\(S\)</span>, <span class="math inline">\(K\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(N\)</span>, <span class="math inline">\(M\)</span> and .</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10.10 </strong></span>Create a VBA function that uses Monte Carlo to value a discretely sampled down-and-out call option and that uses a standard European call as a control variate.</p>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-BD" class="csl-entry" role="listitem">
Broadie, M., and J. Detemple. 1997. <span>“American Option Valuation: New Bounds, Approximations, and a Comparison of Existing Methods.”</span> <em>Review of Financial Studies</em> 9: 1211–50.
</div>
<div id="ref-Glasserman" class="csl-entry" role="listitem">
Glasserman, P. 2004. <em>Monte Carlo Methods in Financial Engineering</em>. Springer, New York Berlin Heidelberg.
</div>
<div id="ref-Jackel" class="csl-entry" role="listitem">
Jäckel, P. 2002. <em>Monte Carlo Methods in Finance</em>. Wiley, New York.
</div>
<div id="ref-Trigeorgis" class="csl-entry" role="listitem">
Trigeorgis, A. 1991. <span>“A Log-Transformed Binomial Analysis Method for Valuing Complex Multi-Option Investments.”</span> <em>Journal of Financial and Quantitative Analysis</em> 26: 309–26.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>For a spread option, take <span class="math inline">\(L=2\)</span>, <span class="math inline">\(w_1=1\)</span> and <span class="math inline">\(w_2=-1\)</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p> The negative correlation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is essential for this method to generate a real gain in efficiency. To generate <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span>, one must generate <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(x\)</span> and <span class="math inline">\(M\)</span> of <span class="math inline">\(y\)</span>, which will generally require about as much computation time as generating <span class="math inline">\(2M\)</span> simulations of <span class="math inline">\(x\)</span>. If <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> were independent, the standard error from <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span> would be the same as the standard error from <span class="math inline">\(2M\)</span> simulations of <span class="math inline">\(x\)</span>, so using the antithetic variate would be no better than just doubling the sample size for <span class="math inline">\(x\)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter9.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exotic Options</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter11.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>