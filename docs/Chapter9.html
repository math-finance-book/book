<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; Exotic Options – Pricing and Hedging Derivative Securities: Theory and Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter10.html" rel="next">
<link href="./Chapter8.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter9.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exotic Options</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Pricing and Hedging Derivative Securities: Theory and Methods</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Calls and Puts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Binomial Model and Changes of Measure</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Continuous-Time Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Black-Scholes</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Estimating and Modeling Volatility</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Monte Carlo and Binomial Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter7.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Foreign Exchange</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter8.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Forward, Futures, and Exchange Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter9.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exotic Options</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Fixed Income Concepts</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to Fixed Income Derivatives</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Valuing Derivatives in the Extended Vasicek Model</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">A Brief Survey of Term Structure Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./AppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Miscellaneous Facts about Continuous-Time Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Chapter contents</h2>
   
  <ul class="collapse">
  <li><a href="#forward-start-options" id="toc-forward-start-options" class="nav-link active" data-scroll-target="#forward-start-options"><span class="header-section-number">9.1</span> Forward-Start Options</a></li>
  <li><a href="#compound-options" id="toc-compound-options" class="nav-link" data-scroll-target="#compound-options"><span class="header-section-number">9.2</span> Compound Options</a></li>
  <li><a href="#sec-s_discrete" id="toc-sec-s_discrete" class="nav-link" data-scroll-target="#sec-s_discrete"><span class="header-section-number">9.3</span> American Calls with Discrete Dividends</a></li>
  <li><a href="#sec-s_choosers" id="toc-sec-s_choosers" class="nav-link" data-scroll-target="#sec-s_choosers"><span class="header-section-number">9.4</span> Choosers</a></li>
  <li><a href="#options-on-the-max-or-min" id="toc-options-on-the-max-or-min" class="nav-link" data-scroll-target="#options-on-the-max-or-min"><span class="header-section-number">9.5</span> Options on the Max or Min</a></li>
  <li><a href="#sec-s_barriers" id="toc-sec-s_barriers" class="nav-link" data-scroll-target="#sec-s_barriers"><span class="header-section-number">9.6</span> Barrier Options</a></li>
  <li><a href="#sec-s_lookbacks" id="toc-sec-s_lookbacks" class="nav-link" data-scroll-target="#sec-s_lookbacks"><span class="header-section-number">9.7</span> Lookbacks</a></li>
  <li><a href="#sec-s_baskets" id="toc-sec-s_baskets" class="nav-link" data-scroll-target="#sec-s_baskets"><span class="header-section-number">9.8</span> Basket and Spread Options</a></li>
  <li><a href="#sec-s_asians" id="toc-sec-s_asians" class="nav-link" data-scroll-target="#sec-s_asians"><span class="header-section-number">9.9</span> Asian Options</a></li>
  <li><a href="#monte-carlo-models-for-path-dependent-options" id="toc-monte-carlo-models-for-path-dependent-options" class="nav-link" data-scroll-target="#monte-carlo-models-for-path-dependent-options"><span class="header-section-number">9.10</span> Monte Carlo Models for Path-Dependent Options</a></li>
  <li><a href="#sec-montecarlomultiple" id="toc-sec-montecarlomultiple" class="nav-link" data-scroll-target="#sec-montecarlomultiple"><span class="header-section-number">9.11</span> Monte Carlo Valuation of Basket and Spread Options</a></li>
  <li><a href="#sec-s_curse" id="toc-sec-s_curse" class="nav-link" data-scroll-target="#sec-s_curse"><span class="header-section-number">9.12</span> Binomial Valuation of Basket and Spread Options</a></li>
  <li><a href="#variance-swaps" id="toc-variance-swaps" class="nav-link" data-scroll-target="#variance-swaps"><span class="header-section-number">9.13</span> Variance Swaps</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">9.14</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-c_exotics" class="quarto-section-identifier"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Exotic Options</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>We will only discuss a few exotic options. The reason for studying the derivation of an option pricing formula is that it may better equip one to analyze new products. Hopefully, this chapter will be of some assistance in that regard. Of course, one cannot expect to derive a closed-form solution for the value of every product, and often numerical methods will be necessary. For a much more comprehensive presentation of exotic option pricing formulas, the book by Haug <span class="citation" data-cites="Haug">(<a href="#ref-Haug" role="doc-biblioref">Haug 1998</a>)</span> and the Excel software that accompanies it are highly recommended. Zhang <span class="citation" data-cites="Zhang">(<a href="#ref-Zhang" role="doc-biblioref">Zhang 1998</a>)</span> is also a comprehensive reference for exotics.</p>
<p>The valuation of an American call option on an asset paying a discrete cash dividend (rather than a continuous dividend) is considered in <a href="#sec-s_discrete" class="quarto-xref"><span>Section 9.3</span></a>. Under a particular assumption on the volatility, valuing this option is very similar to valuing a compound option. Except for the assumption of a discrete dividend in <a href="#sec-s_discrete" class="quarto-xref"><span>Section 9.3</span></a>, we will make the Black-Scholes assumptions throughout this chapter: there is a constant risk-free rate <span class="math inline">\(r\)</span> and the underlying asset has a constant volatility <span class="math inline">\(\sigma\)</span> and a constant dividend yield <span class="math inline">\(q\)</span>.</p>
<p>The order in which exotics are presented in this chapter is based on the simplicity of the analysis—the chapter begins with the easiest to analyze and works towards the more difficult. This order is roughly the inverse of importance, the most important exotics in practice being barriers, baskets, spreads and Asians. In the cases of Asian and basket options, we will explain why there are no simple closed-form formulas (sums of lognormally distributed random variables are not lognormal). We will use these cases and discretely-sampled barriers and lookbacks as examples in the next chapter.</p>
<section id="forward-start-options" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="forward-start-options"><span class="header-section-number">9.1</span> Forward-Start Options</h2>
<p>A forward-start option is an option for which the strike price is set equal to the stock price at some later date. In essence, it is issued at the later date, with the strike price set at the money. For example, an executive may know that he is to be given an option grant at some later date with the strike price set equal to the stock price at that date.</p>
<section id="forward-start-call-payoff" class="level3">
<h3 class="anchored" data-anchor-id="forward-start-call-payoff">Forward-Start Call Payoff</h3>
<p>A forward-start call is defined by its maturity date <span class="math inline">\(T'\)</span> and the date <span class="math inline">\(T&lt;T'\)</span> at which the strike price is set. The value of a forward-start call at maturity is <span class="math display">\[\max(0,S(T')-S(T))\; .\]</span> Let <span class="math display">\[x= \begin{cases} 1 &amp;\text{if $S(T')&gt;S(T)$\;,}\\
                               0 &amp; \text{otherwise\;.}
        \end{cases}
\]</span> Then, the value of the call at maturity can be written as <span class="math display">\[xS(T')-xS(T)\; .\]</span> ### Numeraires</p>
<ol type="1">
<li>Use <span class="math inline">\(V(t)=\mathrm{e}^{qt}S(t)\)</span> as numeraire to price the payoff <span class="math inline">\(xS(T')\)</span>. From the fundamental pricing <a href="Chapter2.html#eq-formula" class="quarto-xref">Equation&nbsp;<span>2.29</span></a>, the value at date~0 is <span class="math display">\[\mathrm{e}^{-qT'}S(0)E^V[x] = \mathrm{e}^{-qT'}S(0)\times \text{prob}^V\!(S(T')&gt;S(T))\; .\]</span></li>
<li>To price the payoff <span class="math inline">\(xS(T)\)</span>, use the following portfolio as numeraire:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>purchase <span class="math inline">\(\mathrm{e}^{-qT}\)</span> shares of the stock at date 0 and reinvest dividends until date <span class="math inline">\(T\)</span>. This will result in the ownership of one share at date <span class="math inline">\(T\)</span>, worth <span class="math inline">\(S(T)\)</span> dollars. At date <span class="math inline">\(T\)</span>, sell the share and invest the proceeds in the risk-free asset and hold this position until date <span class="math inline">\(T'\)</span>. At date <span class="math inline">\(T'\)</span>, the portfolio will be worth <span class="math inline">\(\mathrm{e}^{r(T'-T)}S(T)\)</span>. Let <span class="math inline">\(Z(t)\)</span> denote the value of this portfolio for each <span class="math inline">\(0\leq t\leq T'\)</span>. The fundamental pricing <a href="Chapter2.html#eq-formula" class="quarto-xref">Equation&nbsp;<span>2.29</span></a> implies that the value of receiving <span class="math inline">\(xS(T)\)</span> at date <span class="math inline">\(T'\)</span> is <span class="math display">\[\begin{align*}
Z(0)E^Z\left[ \frac{xS(T)}{Z(T')}\right] &amp;=
\mathrm{e}^{-qT}S(0)E^Z\left[ \frac{xS(T)}{\mathrm{e}^{r(T'-T)}S(T)}\right]\\&amp;= \mathrm{e}^{-qT-r(T'-T)}S(0)E^Z[x] \\&amp;= \mathrm{e}^{-qT-r(T'-T)}S(0) \times\text{prob}^Z(S(T')&gt;S(T))\;.
\end{align*}\]</span></li>
</ol>
</section>
<section id="calculating-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="calculating-probabilities">Calculating Probabilities</h3>
<ol type="1">
<li>As in the case of a share digital, we know that <span class="math display">\[
\log S(t) = \log S(0) + \left(r-q +\frac{1}{2}\sigma^2\right)t + \sigma B^*(t)
\]</span> for all <span class="math inline">\(t&gt;0\)</span>, where <span class="math inline">\(B^*\)</span> is a Brownian motion when <span class="math inline">\(V\)</span> is used as the numeraire. Taking <span class="math inline">\(t=T'\)</span> and <span class="math inline">\(t=T\)</span> and subtracting yields <span class="math display">\[\log S(T')-\log S(T) = \left(r-q +\frac{1}{2}\sigma^2\right)(T'-T) + \sigma \left[B^*(T')-B^*(T)\right]\; .\]</span> Hence, <span class="math inline">\(S(T')&gt;S(T)\)</span> if and only if <span class="math display">\[-\frac{B^*(T')-B^*(T)}{\sqrt{T'-T}} &lt; \frac{\left(r-q +\frac{1}{2}\sigma^2\right)(T'-T)}{\sigma\sqrt{T'-T}}\; .\]</span> The random variable on the left hand side is a standard normal, so <span class="math display">\[
\text{prob}^V\!(S(T')&gt;S(T)) = \mathrm{N}(d_1)\; ,
\]</span> where</li>
</ol>
<p><span id="eq-forwardstart_d1"><span class="math display">\[
d_1 = \frac{\left(r-q +\frac{1}{2}\sigma^2\right)(T'-T)}{\sigma\sqrt{T'-T}} =\frac{\left(r-q +\frac{1}{2}\sigma^2\right)\sqrt{T'-T}}{\sigma}\;.
\tag{9.1}\]</span></span></p>
<ol start="2" type="1">
<li>To calculate the probability <span class="math inline">\(\text{prob}^Z(S(T')&gt;S(T))\)</span>, note that between <span class="math inline">\(T\)</span> and <span class="math inline">\(T'\)</span>, the portfolio with price <span class="math inline">\(Z\)</span> earns the risk-free rate <span class="math inline">\(r\)</span>. The same argument presented in <a href="Chapter3.html#sec-s_girsanov" class="quarto-xref"><span>Section 3.10</span></a> shows that between <span class="math inline">\(T\)</span> and <span class="math inline">\(T'\)</span> we have <span class="math display">\[
\frac{\mathrm{d} S}{S} = (r-q)\,\mathrm{d} t + \sigma\,\mathrm{d} B^*\; ,
\]</span> where now <span class="math inline">\(B^*\)</span> denotes a Brownian motion when <span class="math inline">\(Z\)</span> is used as the numeraire. This implies as usual that <span class="math display">\[
\mathrm{d}\log S = \left(r-q-\frac{1}{2}\sigma^2\right)\,\mathrm{d} t + \sigma\,\mathrm{d} B^*\; ,
\]</span> which means that <span class="math display">\[
\log S(T') - \log S(T) = \left(r-q-\frac{1}{2}\sigma^2\right)(T'-T) + \sigma(B^*(T')-B^*(T))\; .
\]</span> Hence, <span class="math inline">\(S(T')&gt;S(T)\)</span> if and only if <span class="math display">\[
-\frac{B^*(T')-B^*(T)}{\sqrt{T'-T}} &lt; \frac{\left(r-q -\frac{1}{2}\sigma^2\right)(T'-T)}{\sigma\sqrt{T'-T}}\; .
\]</span> As before, the random variable on the left hand side is a standard normal, so <span class="math display">\[
\text{prob}^Z(S(T')&gt;S(T)) = \mathrm{N}(d_2)\; ,
\]</span> where <span id="eq-forwardstart_d2"><span class="math display">\[
d_2 = \frac{\left(r-q -\frac{1}{2}\sigma^2\right)\sqrt{T'-T}}{\sigma}=d_1-\sigma\sqrt{T'-T}\;.
\tag{9.2}\]</span></span></li>
</ol>
</section>
<section id="forward-start-call-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="forward-start-call-pricing-formula">Forward-Start Call Pricing Formula</h3>
<p>Combining these results, we have:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a forward-start call at date 0 is <span id="eq-fstrikecall"><span class="math display">\[
\mathrm{e}^{-qT'}S(0)\mathrm{N}(d_1) - \mathrm{e}^{-qT-r(T'-T)}S(0)\mathrm{N}(d_2)\;,
\tag{9.3}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> are defined in <a href="#eq-forwardstart_d1" class="quarto-xref">Equation&nbsp;<span>9.1</span></a> - <a href="#eq-forwardstart_d2" class="quarto-xref">Equation&nbsp;<span>9.2</span></a>.</p>
</div>
</div>
</section>
<section id="put-call-parity" class="level3">
<h3 class="anchored" data-anchor-id="put-call-parity">Put-Call Parity</h3>
<p>Forward-strike calls and puts satisfy a somewhat unusual form of put-call parity. The usual put-call parity is of the form: <span class="math display">\[
\text{Call} \;+\; \text{Cash} \quad = \quad \text{Put} \;+ \;\text{Underlying}\; .
\]</span></p>
<p>The amount of cash is the amount that will accumulate to the exercise price at maturity; i.e., it is <span class="math inline">\(\mathrm{e}^{-rT'}K\)</span>. For forward-start calls and puts, the effective exercise price is <span class="math inline">\(S(T)\)</span>, which is not known at date 0. However, the portfolio used as numeraire to value the second part of the payoff will be worth <span class="math inline">\(\mathrm{e}^{r(T'-T)}S(T)\)</span> at date <span class="math inline">\(T'\)</span>, and by following the same strategy but starting with <span class="math inline">\(\mathrm{e}^{-r(T'-T)-qT}\)</span> instead of <span class="math inline">\(\mathrm{e}^{-qT}\)</span> shares, we will have <span class="math inline">\(S(T)\)</span> dollars at date <span class="math inline">\(T'\)</span>. The date–0 value of this portfolio should replace Cash in the above. Thus:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Put-call parity for forward-start calls and puts is <span id="eq-fstrikeparity"><span class="math display">\[
\text{Call Price} \;+\; \mathrm{e}^{-r(T'-T)-qT}S(0) = \text{Put Price} \;+\; \mathrm{e}^{-qT'}S(0)\;.
\tag{9.4}\]</span></span></p>
<p>The new features in the option pricing formulas in this chapter are the use of the bivariate normal distribution function and sometimes the need to compute a critical (at-the-money) value of the underlying asset price. We will compute the critical values by bisection, in the same way that we computed implied volatilities for the Black-Scholes formula in <a href="Chapter4.html" class="quarto-xref"><span>Chapter 4</span></a>.</p>
<p>The following is a fast approximation of the bivariate cumulative normal distribution function, accurate to six decimal places, due to Drezner <span class="citation" data-cites="Drezner">(<a href="#ref-Drezner" role="doc-biblioref">Drezner 1978</a>)</span>). For given numbers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, this function gives the probability that <span class="math inline">\(\xi_1&lt;a\)</span> and <span class="math inline">\(\xi_2&lt;b\)</span> where <span class="math inline">\(\xi_1\)</span> and <span class="math inline">\(\xi_2\)</span> are standard normal random variables with a given correlation <span class="math inline">\(\rho\)</span>, which we must input.</p>
<div id="binormal_prob" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binormal_prob(a, b, rho):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.array([<span class="fl">0.24840615</span>, <span class="fl">0.39233107</span>, <span class="fl">0.21141819</span>, <span class="fl">0.03324666</span>, <span class="fl">0.00082485334</span>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array([<span class="fl">0.10024215</span>, <span class="fl">0.48281397</span>, <span class="fl">1.0609498</span>, <span class="fl">1.7797294</span>, <span class="fl">2.6697604</span>])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    a1 <span class="op">=</span> a <span class="op">/</span> np.sqrt(<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> rho <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    b1 <span class="op">=</span> b <span class="op">/</span> np.sqrt(<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> rho <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> b <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> rho <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        total_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                z1 <span class="op">=</span> a1 <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> y[i] <span class="op">-</span> a1)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                Z2 <span class="op">=</span> b1 <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> y[j] <span class="op">-</span> b1)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                z3 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> rho <span class="op">*</span> (y[i] <span class="op">-</span> a1) <span class="op">*</span> (y[j] <span class="op">-</span> b1)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                total_sum <span class="op">+=</span> x[i] <span class="op">*</span> x[j] <span class="op">*</span> np.exp(z1 <span class="op">+</span> Z2 <span class="op">+</span> z3)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total_sum <span class="op">*</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> rho <span class="op">**</span> <span class="dv">2</span>) <span class="op">/</span> np.pi</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> b <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> rho <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> norm.cdf(a) <span class="op">-</span> binormal_prob(a, <span class="op">-</span>b, <span class="op">-</span>rho)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> b <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">and</span> rho <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> norm.cdf(b) <span class="op">-</span> binormal_prob(<span class="op">-</span>a, b, <span class="op">-</span>rho)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> b <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> rho <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        total_sum <span class="op">=</span> norm.cdf(a) <span class="op">+</span> norm.cdf(b)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total_sum <span class="op">-</span> <span class="dv">1</span> <span class="op">+</span> binormal_prob(<span class="op">-</span>a, <span class="op">-</span>b, rho)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> a <span class="op">*</span> b <span class="op">*</span> rho <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        rho1 <span class="op">=</span> (rho <span class="op">*</span> a <span class="op">-</span> b) <span class="op">*</span> np.sign(a) <span class="op">/</span> np.sqrt(a <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> rho <span class="op">*</span> a <span class="op">*</span> b <span class="op">+</span> b <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        rho2 <span class="op">=</span> (rho <span class="op">*</span> b <span class="op">-</span> a) <span class="op">*</span> np.sign(b) <span class="op">/</span> np.sqrt(a <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> rho <span class="op">*</span> a <span class="op">*</span> b <span class="op">+</span> b <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        Delta <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> np.sign(a) <span class="op">*</span> np.sign(b)) <span class="op">/</span> <span class="dv">4</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> binormal_prob(a, <span class="dv">0</span>, rho1) <span class="op">+</span> binormal_prob(b, <span class="dv">0</span>, rho2) <span class="op">-</span> Delta</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"BiNormalProb:"</span>, binormal_prob(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>BiNormalProb: 0.3601084540357551</code></pre>
</div>
</div>
<p>Notice that this function calls itself. This is an example of recursion.</p>
<p>The forward-start call pricing formula is of the same form as the Black-Scholes, Margrabe, Black, and Merton formulas. We can compute it with our <code>Generic_Option</code> pricing function.</p>
<div id="forward_start_call" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generic_option(P1, P2, sigma, T):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    P1 = present value of asset to be received</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    P2 = present value of asset to be delivered</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma = volatility</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    T = time to maturity</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> (np.log(P1 <span class="op">/</span> P2) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    N1 <span class="op">=</span> norm.cdf(x)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(y)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P1 <span class="op">*</span> N1 <span class="op">-</span> P2 <span class="op">*</span> N2</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_start_call(S, r, sigma, q, Tset, TCall):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    P1 <span class="op">=</span> np.exp(<span class="op">-</span>q <span class="op">*</span> TCall) <span class="op">*</span> S</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    P2 <span class="op">=</span> np.exp(<span class="op">-</span>q <span class="op">*</span> Tset <span class="op">-</span> r <span class="op">*</span> (TCall <span class="op">-</span> Tset)) <span class="op">*</span> S</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> generic_option(P1, P2, sigma, TCall <span class="op">-</span> Tset)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>Div <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>TDiv <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>TCall <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Forward Start Call:"</span>, forward_start_call(S, r, sigma, q, <span class="fl">0.5</span>, TCall))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Forward Start Call: 6.244873136512808</code></pre>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="compound-options" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="compound-options"><span class="header-section-number">9.2</span> Compound Options</h2>
<p>A compound option is an option on an option, for example a call option on a call option or a call on a put. These options are useful for hedging when there is some uncertainty about the need for hedging which may be resolved by the exercise date of the compound option. As speculative trades, they have the benefit of higher leverage than ordinary options. These options were first discussed by Geske <span class="citation" data-cites="Geske">(<a href="#ref-Geske" role="doc-biblioref">Geske 1979</a>)</span>.</p>
<section id="call-on-a-call-payoff" class="level3">
<h3 class="anchored" data-anchor-id="call-on-a-call-payoff">Call-on-a-Call Payoff</h3>
<p>Let the underlying call option have exercise price <span class="math inline">\(K'\)</span> and maturity <span class="math inline">\(T'\)</span>. Consider an option maturing at <span class="math inline">\(T&lt;T'\)</span> to purchase the underlying call at price <span class="math inline">\(K\)</span>.</p>
Let <span class="math inline">\(C(t,S)\)</span> denote the value at date <span class="math inline">\(t\)</span> of the underlying call when the stock price is <span class="math inline">\(S\)</span> (i.e., <span class="math inline">\(C\)</span> is the Black-Scholes formula). It is of course rational to exercise the compound call at date <span class="math inline">\(T\)</span> if the value of the underlying call exceeds <span class="math inline">\(K\)</span>; i.e., if <span class="math inline">\(C(T,S(T))&gt;K\)</span>. Let <span class="math inline">\(S^*\)</span> denote the critical price such that <span class="math inline">\(C(T,S^*)=K\)</span>. To calculate <span class="math inline">\(S^*\)</span>, we need to solve
<p>for <span class="math inline">\(S^*\)</span>. We can do this by bisection or one of the other methods mentioned in <a href="Chapter4.html#sec-s_impliedvolatility" class="quarto-xref"><span>Section 4.7</span></a>. It is rational to exercise the compound option when <span class="math inline">\(S(T) &gt; S^*\)</span>.</p>
<p>When <span class="math inline">\(S(T) &gt; S^*\)</span>, exercise of the compound option generates a cash flow of <span class="math inline">\(-K\)</span> at date <span class="math inline">\(T\)</span>. There is a cash flow (of <span class="math inline">\(S(T')-K'\)</span>) at date <span class="math inline">\(T'\)</span> only if the compound call is exercised and the underlying call finishes in the money. This is equivalent to: <span id="eq-compound1"><span class="math display">\[
S(T) &gt; S^* \quad\text{and}\quad S(T')&gt;K'\;.
\tag{9.5}\]</span></span></p>
<p>Let <span class="math display">\[\begin{align*}
x&amp;= \begin{cases} 1 &amp;\text{if $S(T)&gt;S^*$\;,}\\
                               0 &amp; \text{otherwise\;,}
        \end{cases}\\
y&amp;= \begin{cases} 1 &amp;\text{if $S(T)&gt;S^*$ and $S(T')&gt;K'$\;,}\\
                               0 &amp; \text{otherwise\;.}
        \end{cases}
\end{align*}\]</span> The cash flows of the compound option are <span class="math inline">\(-xK\)</span> at date <span class="math inline">\(T\)</span> and <span class="math inline">\(yS(T')-yK'\)</span> at date <span class="math inline">\(T'\)</span>. We can value the compound option at date 0 by valuing these separate cash flows.</p>
<p>The cash flow <span class="math inline">\(-xK\)</span> is the cash flow from being short <span class="math inline">\(K\)</span> digital options on the underlying asset with strike price <span class="math inline">\(S^*\)</span> and maturity <span class="math inline">\(T\)</span>. Therefore the value at date 0 of this cash flow is <span class="math inline">\(-\mathrm{e}^{-rT}K\mathrm{N}(d_2)\)</span>, where <span id="eq-calloncalld1d2"><span class="math display">\[
d_1 = \frac{\log\left(\frac{S(0)}{S^*}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}},  \qquad d_2 = d_1-\sigma\sqrt{T}\;.
\tag{9.6}\]</span></span></p>
</section>
<section id="numeraires" class="level3">
<h3 class="anchored" data-anchor-id="numeraires">Numeraires</h3>
<p>The payoffs <span class="math inline">\(yS(T)\)</span> and <span class="math inline">\(yK'\)</span> are similar to share digitals and digitals, respectively, except that the event <span class="math inline">\(y=1\)</span> is more complex than we have previously encountered. However, we know from the analysis of share digitals and digitals that the values at date 0 of these payoffs are <span class="math display">\[
\mathrm{e}^{-q T'}S(0)\times\text{prob}^V\!(y=1) \quad \text{and}\quad \mathrm{e}^{-rT'}K'\times\text{prob}^R(y=1)\; ,
\]</span> where <span class="math inline">\(V(t)=\mathrm{e}^{qt}S(t)\)</span> and <span class="math inline">\(R(t)=\mathrm{e}^{rt}\)</span>.</p>
</section>
<section id="calculating-probabilities-1" class="level3">
<h3 class="anchored" data-anchor-id="calculating-probabilities-1">Calculating Probabilities</h3>
<p>We will calculate the two probabilities in terms of the bivariate normal distribution function.</p>
<ol type="1">
<li>The event <span class="math inline">\(y=1\)</span> is equivalent to <span class="math display">\[
\log S(0) + \left(r-q+\frac{1}{2}\sigma^2\right)T+\sigma B^*(T) &gt; \log S^*
\]</span> and <span class="math display">\[
\log S(0) + \left(r-q+\frac{1}{2}\sigma^2\right)T'+\sigma B^*(T') &gt; \log K'\; ,
\]</span> where <span class="math inline">\(B^*\)</span> is a Brownian motion when the underlying asset (<span class="math inline">\(V\)</span>) is used as the numeraire. These conditions can be rearranged as</li>
</ol>
<p><span id="eq-new10"><span class="math display">\[-\frac{B^*(T)}{\sqrt{T}}&lt;d_1 \quad \text{and} \quad - \frac{B^*(T')}{\sqrt{T'}}&lt;d_1'\;,
\tag{9.7}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> is defined in <a href="#eq-calloncalld1d2" class="quarto-xref">Equation&nbsp;<span>9.6</span></a>, and <span id="eq-callcallds"><span class="math display">\[
d_1' = \frac{\log\left(\frac{S(0)}{K'}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T'}{\sigma\sqrt{T'}}\;,
\qquad d_2'=d_1'-\sigma\sqrt{T'}\;.
\tag{9.8}\]</span></span></p>
<p>The two standard normal variables on the left-hand sides in <a href="#eq-new10" class="quarto-xref">Equation&nbsp;<span>9.7</span></a> have a covariance equal to <span class="math display">\[
\frac{1}{\sqrt{TT'}}\mathrm{cov}(B(T),B(T')) = \frac{1}{\sqrt{TT'}}\mathrm{cov}(B(T),B(T)) = \sqrt{\frac{T}{T'}}\; ,
\]</span></p>
<p>the first equality following from the fact that <span class="math inline">\(B(T)\)</span> is independent of <span class="math inline">\(B(T')-B(T)\)</span> and the second from the fact that the covariance of a random variable with itself is its variance. Hence, <span class="math inline">\(\text{prob}^V\!(y=1)\)</span> is the probability that <span class="math inline">\(a\leq d_1\)</span> and <span class="math inline">\(b\leq d_1'\)</span>, where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are standard normal random variables with covariance (= correlation coefficient) of <span class="math inline">\(\sqrt{T/T'}\)</span>. We will write this probability as <span class="math inline">\(\mathrm{M}\!\left(d_1,d_1',\sqrt{T/T'}\right)\)</span>. A program to approximate the bivariate normal distribution function <span class="math inline">\(\mathrm{M}\)</span> is provided later.</p>
<ol start="2" type="1">
<li>The calculation for <span class="math inline">\(\text{prob}^R(y=1)\)</span> is similar. The event <span class="math inline">\(y=1\)</span> is equivalent to <span class="math display">\[
\log S(0) + \left(r-q+\frac{1}{2}\sigma^2\right)T+\sigma B^*(T) &gt; \log S^*\;,
\]</span> and <span class="math display">\[
\log S(0) + \left(r-q+\frac{1}{2}\sigma^2\right)T'+\sigma B^*(T') &gt; \log K'\; ,
\]</span> where <span class="math inline">\(B^*\)</span> now denotes a Brownian motion under the risk-neutral measure. These are equivalent to <span id="eq-new11000"><span class="math display">\[
-\frac{B^*(T)}{\sqrt{T}}&lt;d_2 \quad \text{and} \quad - \frac{B^*(T')}{\sqrt{T'}} &lt; d_2'\;.
\tag{9.9}\]</span></span></li>
</ol>
<p>Hence, <span class="math inline">\(\text{prob}^R(y=1)=\mathrm{M}\!\left(d_2,d_2',\sqrt{T/T'}\right)\)</span>.</p>
</section>
<section id="call-on-a-call-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="call-on-a-call-pricing-formula">Call-on-a-Call Pricing Formula</h3>
<p>We conclude:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a call on a call is</p>
<p><span id="eq-marketmodel5"><span class="math display">\[
\begin{multline}
-\mathrm{e}^{-rT}K\mathrm{N}(d_2) + \mathrm{e}^{-q T'}S(0)\mathrm{M}\!\left(d_1,d_1',\sqrt{T/T'}\right)
\\- \mathrm{e}^{-rT'}K'\mathrm{M}\!\left(d_2,d_2',\sqrt{T/T'}\right)\;,
\end{multline}
\tag{9.10}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> are defined in <a href="#eq-calloncalld1d2" class="quarto-xref">Equation&nbsp;<span>9.6</span></a> and <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-callcallds" class="quarto-xref">Equation&nbsp;<span>9.8</span></a>.</p>
</div>
</div>
</section>
<section id="put-call-parity-1" class="level3">
<h3 class="anchored" data-anchor-id="put-call-parity-1">Put-Call Parity</h3>
<p>European compound options with the same underlyings and strikes satisfy put-call parity in the usual way: <span class="math display">\[
\text{Cash} + \text{Call} = \text{Underlying} + \text{Put}\; .
\]</span></p>
<p>The portfolio on each side of this equation gives the owner the maximum of the strike and the value of the underlying at the option maturity. In the case of options on calls, put-call parity is specifically <span class="math display">\[\begin{multline*}
\mathrm{e}^{-rT}K + \text{Value of call on call} \\= \text{Value of underlying call} + \text{Value of put on call}\; ,
\end{multline*}\]</span> where <span class="math inline">\(K\)</span> is the strike price of the compound options and <span class="math inline">\(T\)</span> is their maturity date. Likewise, for options on puts, we have <span class="math display">\[\begin{multline*}
\mathrm{e}^{-rT}K + \text{Value of call on put} \\= \text{Value of underlying put} + \text{Value of put on put}\; .
\end{multline*}\]</span> Thus, the value of a put on a call can be derived from the value of a call on a call. The value of a put on a put can be derived from the value of a call on a put, which we will now consider.</p>
</section>
<section id="call-on-a-put-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="call-on-a-put-pricing-formula">Call-on-a-Put Pricing Formula</h3>
<p>Consider a call option maturing at <span class="math inline">\(T\)</span> with strike <span class="math inline">\(K\)</span> with the underlying being a put option with strike <span class="math inline">\(K'\)</span> and maturity <span class="math inline">\(T'&gt;T\)</span>. The underlying of the put is the asset with price <span class="math inline">\(S\)</span> and constant volatility <span class="math inline">\(\sigma\)</span>. The call on the put will never be in the money at <span class="math inline">\(T\)</span> and hence is worthless if <span class="math inline">\(K&gt; \mathrm{e}^{-r(T'-T)}K'\)</span>, because the maximum possible value of the put option at date <span class="math inline">\(T\)</span> is <span class="math inline">\(\mathrm{e}^{-r(T'-T)}K'\)</span>. So assume <span class="math inline">\(K&lt; \mathrm{e}^{-r(T'-T)}K'\)</span>.</p>
Let <span class="math inline">\(S^*\)</span> again denote the critical value of the stock price such that the call is at the money at date <span class="math inline">\(T\)</span> when <span class="math inline">\(S(T)=S^*\)</span>. This means that <span class="math inline">\(S^*\)</span> solves
<p>We leave it as an exercise to confirm the following.</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a call on a put is</p>
<p><span id="eq-callonaput"><span class="math display">\[
\begin{multline}
-\mathrm{e}^{-rT}K\mathrm{N}(-d_2) + \mathrm{e}^{-rT'}K'\mathrm{M}\!\left(-d_2,-d_2',\sqrt{T/T'}\right) \\- \mathrm{e}^{-q T'}S(0)\mathrm{M}\!\left(-d_1,-d_1',\sqrt{T/T'}\right) \;,
\end{multline}
\tag{9.11}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> are defined in <a href="#eq-calloncalld1d2" class="quarto-xref">Equation&nbsp;<span>9.6</span></a> and <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-callcallds" class="quarto-xref">Equation&nbsp;<span>9.8</span></a>.</p>
</div>
</div>
<p>We will use bisection to find the critical price <span class="math inline">\(S^*\)</span>. We can use <span class="math inline">\(e^{q(T'-T)}(K+K')\)</span> as an upper bound for <span class="math inline">\(S^*\)</span> and 0 as a lower bound.^[We set the value of the call to be zero when the stock price is zero. The upper bound works because (by put-call parity and the fact that the put value is nonnegative) <span class="math inline">\(C(T,S) \geq e^{-q(T'-T)}S-e^{-r(T'-T)}K'\)</span>. Therefore, when <span class="math inline">\(S = e^{q(T'-T)}(K+K')\)</span>, we have <span class="math inline">\(C(T,S) \geq K + K' - e^{-r(T'-T)}K' &gt; K\)</span>. }<br>
The following uses <span class="math inline">\(10^{-6}\)</span> as the error tolerance in the bisection.</p>
<div id="call_on_call" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S, K, r, sigma, q, T):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    S = initial stock price</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    K = strike price</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    r = risk-free rate</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma = volatility</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    q = dividend yield</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    T = time to maturity</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sigma <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(<span class="dv">0</span>, np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        d1 <span class="op">=</span> (np.log(S <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> N1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">*</span> N2</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> np.exp(q <span class="op">*</span> (Tu <span class="op">-</span> Tc)) <span class="op">*</span> (Kc <span class="op">+</span> Ku)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    flower <span class="op">=</span> <span class="op">-</span>Kc</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    fupper <span class="op">=</span> black_scholes_call(upper, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    fguess <span class="op">=</span> black_scholes_call(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> upper <span class="op">-</span> lower <span class="op">&gt;</span> tol:</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fupper <span class="op">*</span> fguess <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> guess</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            flower <span class="op">=</span> fguess</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_call(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> guess</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            fupper <span class="op">=</span> fguess</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_call(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    Sstar <span class="op">=</span> guess</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S <span class="op">/</span> Sstar) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tc) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tc))</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tc)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    d1prime <span class="op">=</span> (np.log(S <span class="op">/</span> Ku) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tu) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tu))</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> d1prime <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tu)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.sqrt(Tc <span class="op">/</span> Tu)</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    M1 <span class="op">=</span> binormal_prob(d1, d1prime, rho)</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    M2 <span class="op">=</span> binormal_prob(d2, d2prime, rho)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.exp(<span class="op">-</span>r <span class="op">*</span> Tc) <span class="op">*</span> Kc <span class="op">*</span> N2 <span class="op">+</span> np.exp(<span class="op">-</span>q <span class="op">*</span> Tu) <span class="op">*</span> S <span class="op">*</span> M1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> Tu) <span class="op">*</span> Ku <span class="op">*</span> M2</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>Kc <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>Ku <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>Tc <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>Tu <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Call on Call:"</span>, call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Call on Call: 3.2568274676824167</code></pre>
</div>
</div>
<p>The implementation of the call-on-a-put formula is of course very similar to that of a call-on-a-call. One difference is that there is no obvious upper bound for <span class="math inline">\(S^*\)</span>, so we start with <span class="math inline">\(2K'\)</span> (= <code>2*K2</code>) and double this until the value of the put is below <span class="math inline">\(K\)</span>. We can take 0 again to be the lower bound. Recall that we assume <span class="math inline">\(K&lt;\mathrm{e}^{-r(T'-T)}K'\)</span> and the right-hand side of this is the value of the put at date <span class="math inline">\(T\)</span> when <span class="math inline">\(S(T)=0\)</span>.</p>
<div id="call_on_put" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_put(S, K, r, sigma, q, T):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    S = initial stock price</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">    K = strike price</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    r = risk-free rate</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma = volatility</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    q = dividend yield</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">    T = time to maturity</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sigma <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(<span class="dv">0</span>, np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">-</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        d1 <span class="op">=</span> (np.log(S <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        N1 <span class="op">=</span> norm.cdf(<span class="op">-</span>d1)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        N2 <span class="op">=</span> norm.cdf(<span class="op">-</span>d2)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">*</span> N2 <span class="op">-</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> N1</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu):</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    flower <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> (Tu <span class="op">-</span> Tc)) <span class="op">*</span> Ku <span class="op">-</span> Kc</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> Ku</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    fupper <span class="op">=</span> black_scholes_put(upper, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> fupper <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        upper <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        fupper <span class="op">=</span> black_scholes_put(upper, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    fguess <span class="op">=</span> black_scholes_put(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> upper <span class="op">-</span> lower <span class="op">&gt;</span> tol:</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fupper <span class="op">*</span> fguess <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> guess</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>            flower <span class="op">=</span> fguess</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_put(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> guess</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>            fupper <span class="op">=</span> fguess</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_put(guess, Ku, r, sigma, q, Tu <span class="op">-</span> Tc) <span class="op">-</span> Kc</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    Sstar <span class="op">=</span> guess</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S <span class="op">/</span> Sstar) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tc) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tc))</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tc)</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    d1prime <span class="op">=</span> (np.log(S <span class="op">/</span> Ku) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tu) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tu))</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> d1prime <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tu)</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.sqrt(Tc <span class="op">/</span> Tu)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(<span class="op">-</span>d2)</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    M1 <span class="op">=</span> binormal_prob(<span class="op">-</span>d1, <span class="op">-</span>d1prime, rho)</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    M2 <span class="op">=</span> binormal_prob(<span class="op">-</span>d2, <span class="op">-</span>d2prime, rho)</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.exp(<span class="op">-</span>r <span class="op">*</span> Tc) <span class="op">*</span> Kc <span class="op">*</span> N2 <span class="op">+</span> np.exp(<span class="op">-</span>r <span class="op">*</span> Tu) <span class="op">*</span> Ku <span class="op">*</span> M2 <span class="op">-</span> np.exp(<span class="op">-</span>q <span class="op">*</span> Tu) <span class="op">*</span> S <span class="op">*</span> M1</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>Kc <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>Ku <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>Tc <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>Tu <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Call on Put:"</span>, call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Call on Put: 1.2998205534006573</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-s_discrete" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="sec-s_discrete"><span class="header-section-number">9.3</span> American Calls with Discrete Dividends</h2>
<p>It can be optimal to exercise an American call option early if the underlying asset pays a dividend. The optimal exercise date will be immediately prior to the asset going ex-dividend. Consider a call option maturing at <span class="math inline">\(T'\)</span> on an asset that will pay a known cash dividend <span class="math inline">\(D\)</span> at a known date <span class="math inline">\(T&lt;T'\)</span>. We assume there is no continuous dividend payment, so <span class="math inline">\(q=0\)</span>. For simplicity, we assume that the date of the dividend payment is also the date that the asset goes ex-dividend; i.e., ownership of the asset at any date <span class="math inline">\(t&lt;T\)</span> entitles the owner to receive the dividend at date <span class="math inline">\(T\)</span>. Under this assumption, it is reasonable also to assume that the stock price drops by <span class="math inline">\(D\)</span> when the dividend is paid.</p>
<p>There is some ambiguity about how to define the asset price at the instant the dividend is paid—whether to include or exclude the dividend. We will let <span class="math inline">\(S(T)\)</span> denote the price including the dividend and denote the price excluding the dividend by <span class="math inline">\(Z(T)\)</span>, so <span class="math inline">\(Z(T) = S(T)-D\)</span>. In fact, it is convenient to let <span class="math inline">\(Z(t)\)</span> denote the price stripped of the dividend value at all dates <span class="math inline">\(t \leq T\)</span>, so we will define <span class="math display">\[
Z(t) = \begin{cases}S(t)-\mathrm{e}^{-r(T-t)}D &amp; \text{if $t \leq T$\;,}\\
S(t) &amp; \text{if $t &gt; T$\;.}
\end{cases}
\]</span></p>
<p>Note that <span class="math inline">\(Z\)</span> is the price of the following non-dividend-paying portfolio: buy one unit of the asset at date 0, borrow <span class="math inline">\(\mathrm{e}^{-rT}D\)</span> at date 0 to help finance the purchase, and use the dividend <span class="math inline">\(D\)</span> at date <span class="math inline">\(T\)</span> to retire the debt.</p>
<p>If we assume as usual that the asset price <span class="math inline">\(S\)</span> has a constant volatility, then, using <a href="Chapter3.html#eq-exponential1" class="quarto-xref">Equation&nbsp;<span>3.26</span></a> for a geometric Brownian motion and letting <span class="math inline">\(B^*\)</span> denote a Brownian motion under the risk-neutral measure, we have <span class="math display">\[\begin{align*}
S(T') &amp;= [S(T)-D]\exp\left\{(r-\sigma^2/2)(T'-T)+\sigma B^*(T')-\sigma B^*(T)\right\}\\
&amp;= \left[S(0)\exp\left\{(r-\sigma^2/2)T+\sigma B^*(T)\right\}-D\right]\\
&amp;\qquad \times \exp\left\{(r-\sigma^2/2)(T'-T)+\sigma B^*(T')-\sigma B^*(T)\right\}\\
&amp;=S(0)\exp\left\{(r-\sigma^2/2)T'+\sigma B^*(T')\right\} \\
&amp;\qquad - D\exp\left\{(r-\sigma^2/2)(T'-T)+\sigma B^*(T')-\sigma B^*(T)\right\}\;.
\end{align*}\]</span> Thus, <span class="math inline">\(S\)</span> will be a sum of lognormal random variables. A sum of lognormals is not itself lognormal, so <span class="math inline">\(S\)</span> will not be lognormal, and we are unable to calculate the option value in a simple way.</p>
<p>We will assume instead that <span class="math inline">\(Z\)</span> has a constant volatility <span class="math inline">\(\sigma\)</span>. Thus, <span class="math inline">\(Z\)</span> is the price of a non-dividend-paying portfolio, it satisfies the Black-Scholes assumptions, and we have <span class="math inline">\(S(T')=Z(T')\)</span>. To value a European option, we would simply use <span class="math inline">\(Z(0)=S(0)-\mathrm{e}^{-rT}D\)</span> as the initial asset price and <span class="math inline">\(\sigma\)</span> as the volatility.</p>
<section id="american-call-payoff" class="level3">
<h3 class="anchored" data-anchor-id="american-call-payoff">American Call Payoff</h3>
If the call is not exercised before the dividend is paid at date <span class="math inline">\(T\)</span>, then its value at date <span class="math inline">\(T\)</span> will be
where <code>Z</code> <span class="math inline">\(=Z(T)\)</span>. Hence, exercise is optimal when
<p>A lower bound for the Black-Scholes call value on the right-hand side is <span class="math inline">\(Z(T)-\mathrm{e}^{-r(T'-T)}K\)</span>. If <span class="math inline">\(Z(T)+D-K\)</span> is less than or equal to this lower bound, then exercise cannot be optimal. Thus, if <span class="math inline">\(D-K\)</span> is less than or equal to <span class="math inline">\(-\mathrm{e}^{-r(T'-T)}K\)</span>, then exercise will never be optimal. In this circumstance, the dividend is simply too small to offset the time value of money on the exercise price <span class="math inline">\(K\)</span>, and the value of the American call written on the asset with price <span class="math inline">\(S\)</span> is the same as the value of the European call written on the non-dividend-paying portfolio with price <span class="math inline">\(Z\)</span>.</p>
On the other hand, if <span class="math inline">\(D-K &gt; -\mathrm{e}^{-r(T'-T)}K\)</span>, then exercise will be optimal for sufficiently large <span class="math inline">\(Z(T)\)</span>. In this case, there is some <span class="math inline">\(Z^*\)</span> such that the owner of the call will be indifferent about exercise, and exercise will be optimal for all <span class="math inline">\(Z(T)&gt;Z^*\)</span>. This <span class="math inline">\(Z^*\)</span> is defined by
<p>As in the previous section, we can compute <span class="math inline">\(Z^*\)</span> by bisection.</p>
<p>Define <span class="math display">\[\begin{align*}
x&amp;= \begin{cases} 1 &amp;\text{if $Z(T)&gt;Z^*$\;,}\\
                               0 &amp; \text{otherwise\;,}
        \end{cases}\\
y&amp;= \begin{cases} 1 &amp;\text{if $Z(T)\leq Z^*$ and $Z(T')&gt;K$\;,}\\
                               0 &amp; \text{otherwise\;.}
        \end{cases}
\end{align*}\]</span> Then the American call option will pay <span class="math inline">\([Z(T)+D-K]x\)</span> at date <span class="math inline">\(T\)</span> (due to early exercise) and <span class="math inline">\([Z(T')-K]y\)</span> at date <span class="math inline">\(T'\)</span> (due to exercise at maturity), if <span class="math inline">\(D-K &gt; -\mathrm{e}^{-r(T'-T)}K\)</span>.</p>
</section>
<section id="numeraires-1" class="level3">
<h3 class="anchored" data-anchor-id="numeraires-1">Numeraires</h3>
<p>Assume for now that <span class="math inline">\(D-K &gt; -\mathrm{e}^{-r(T'-T)}K\)</span>. The payoff <span class="math inline">\((D-K)x\)</span> is the payoff of <span class="math inline">\(D-K\)</span> digital options maturing at <span class="math inline">\(T\)</span>, and the payoff <span class="math inline">\(Z(T)x\)</span> is the payoff of one share digital on the portfolio with price <span class="math inline">\(Z\)</span>. Therefore, the value of receiving <span class="math inline">\([Z(T)+D-K]x\)</span> at date <span class="math inline">\(T\)</span> is <span class="math display">\[
Z(0)\mathrm{N}(d_1) + \mathrm{e}^{-rT}(D-K)\mathrm{N}(d_2)\; ,
\]</span> where</p>
<p><span class="math display">\[
d_1 = \frac{\log\left(\frac{Z(0)}{Z^*}\right)+\left(r+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}
\]</span> <span id="eq-americancalld1star"><span class="math display">\[
= \frac{\log\left(\frac{S(0)-\mathrm{e}^{-rT}D}{Z^*}\right)+\left(r+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}} \;,
\tag{9.12}\]</span></span></p>
<p><span id="eq-americancalld2star"><span class="math display">\[
d_2=d_1-\sigma\sqrt{T}\;.
\tag{9.13}\]</span></span></p>
<p>As in the previous section,<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> the value of receiving <span class="math inline">\([Z(T)-K]y\)</span> at date <span class="math inline">\(T'\)</span> is <span class="math display">\[
Z(0)\times \text{prob}^Z(y=1) - \mathrm{e}^{-rT'}K\times \text{prob}^R(y=1)\; .
\]</span> ### Calculating Probabilities The calculations are very similar to the calculations we did for a call option on a call. In fact, they are exactly the same as we would do for a put option on a call.</p>
<ol type="1">
<li>The event <span class="math inline">\(y=1\)</span> is equivalent to <span class="math display">\[
\log Z(0) + \left(r+\frac{1}{2}\sigma^2\right)T+\sigma B^*(T) \leq \log Z^*
\]</span> and <span class="math display">\[
\log Z(0) + \left(r+\frac{1}{2}\sigma^2\right)T'+\sigma B^*(T') &gt; \log K\; ,
\]</span></li>
</ol>
<p>where <span class="math inline">\(B^*\)</span> is a Brownian motion when the underlying asset (with price <span class="math inline">\(Z\)</span>) is used as the numeraire. We can write this as <span id="eq-new100"><span class="math display">\[
\frac{B^*(T)}{\sqrt{T}}&lt;-d_1 \quad \text{and} \quad - \frac{B^*(T')}{\sqrt{T'}} &lt; d_1'\;,
\tag{9.14}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> is defined in <a href="#eq-americancalld1star" class="quarto-xref">Equation&nbsp;<span>9.12</span></a>,</p>
<p><span class="math display">\[
d_1' = \frac{\log\left(\frac{Z(0)}{K}\right)+\left(r+\frac{1}{2}\sigma^2\right)T'}{\sigma\sqrt{T'}}
\]</span> <span id="eq-americancalld1"><span class="math display">\[
= \frac{\log\left(\frac{S(0)-\mathrm{e}^{-rT}D}{K}\right)+\left(r+\frac{1}{2}\sigma^2\right)T'}{\sigma\sqrt{T'}}
\tag{9.15}\]</span></span></p>
<p><span id="eq-americancalld2"><span class="math display">\[
d_2'=d_1'-\sigma\sqrt{T'}\;.
\tag{9.16}\]</span></span></p>
<p>The two standard normal variables on the left-hand sides in <a href="#eq-new100" class="quarto-xref">Equation&nbsp;<span>9.14</span></a> have a covariance equal to <span class="math display">\[
-\frac{1}{\sqrt{TT'}}\mathrm{cov}(B(T),B(T')) = -\frac{1}{\sqrt{TT'}}\mathrm{cov}(B(T),B(T)) = -\sqrt{\frac{T}{T'}}\; .
\]</span></p>
<p>Hence, <span class="math inline">\(\text{prob}^Z(y=1)\)</span> is the probability that <span class="math inline">\(a\leq -d_1\)</span> and <span class="math inline">\(b\leq d_1'\)</span>, where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are standard normal random variables with covariance (= correlation coefficient) of <span class="math inline">\(-\sqrt{T/T'}\)</span>. We are writing this probability as <span class="math inline">\(\mathrm{M}\!\left(-d_1,d_1',-\sqrt{T/T'}\right)\)</span>.</p>
<ol start="2" type="1">
<li>The calculation for <span class="math inline">\(\text{prob}^R(y=1)\)</span> is similar. The event <span class="math inline">\(y=1\)</span> is equivalent to <span class="math display">\[
\log Z(0) + \left(r+\frac{1}{2}\sigma^2\right)T+\sigma B^*(T) \leq \log Z^*
\]</span> and <span class="math display">\[
\log Z(0) + \left(r+\frac{1}{2}\sigma^2\right)T'+\sigma B^*(T') &gt; \log K\; ,
\]</span> where <span class="math inline">\(B^*\)</span> now denotes a Brownian motion under the risk-neutral measure. These are equivalent to <span id="eq-new11"><span class="math display">\[
\frac{B^*(T)}{\sqrt{T}}\leq -d_2 \quad \text{and} \quad - \frac{B^*(T')}{\sqrt{T'}} &lt; d_2'\;.
\tag{9.17}\]</span></span></li>
</ol>
<p>Hence, <span class="math inline">\(\text{prob}^R(y=1)=\mathrm{M}\!\left(-d_2,d_2',-\sqrt{T/T'}\right)\)</span>.</p>
</section>
<section id="american-call-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="american-call-pricing-formula">American Call Pricing Formula</h3>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Under our assumptions, the value of an American call option maturing at <span class="math inline">\(T'\)</span> with a dividend payment of <span class="math inline">\(D\)</span> at date <span class="math inline">\(T&lt;T'\)</span> is as follows.<br>
If <span class="math display">\[
D-K \leq -\mathrm{e}^{-r(T'-T)}K\;,
\]</span> then the value of the call is given by the Black-Scholes formula <span class="math display">\[
[S(0)-\mathrm{e}^{-rT}D]\mathrm{N}(d_1')-\mathrm{e}^{-rT}K\mathrm{N}(d_2')\; ,
\]</span></p>
<p>where <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-americancalld1" class="quarto-xref">Equation&nbsp;<span>9.15</span></a> - <a href="#eq-americancalld2" class="quarto-xref">Equation&nbsp;<span>9.16</span></a>. On the other hand, if <span class="math display">\[
D-K &gt; -\mathrm{e}^{-r(T'-T)}K\;,
\]</span> then the value of the call is</p>
<p><span id="eq-americancall"><span class="math display">\[
\begin{multline}
[S(0)-\mathrm{e}^{-rT}D]\mathrm{N}(d_1) + \mathrm{e}^{-rT}(D-K)\mathrm{N}(d_2)\\ +[S(0)-\mathrm{e}^{-rT}D]\mathrm{M}\!\left(-d_1,d_1',-\sqrt{T/T'}\right) \\- \mathrm{e}^{-rT'}K\mathrm{M}\!\left(-d_2,d_2',-\sqrt{T/T'}\right)\;,
\end{multline}
\tag{9.18}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span> and <span class="math inline">\(d_2\)</span> are defined in <a href="#eq-americancalld1star" class="quarto-xref">Equation&nbsp;<span>9.12</span></a> - <a href="#eq-americancalld2star" class="quarto-xref">Equation&nbsp;<span>9.13</span></a> and <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-americancalld1" class="quarto-xref">Equation&nbsp;<span>9.15</span></a> - <a href="#eq-americancalld2" class="quarto-xref">Equation&nbsp;<span>9.16</span></a>.</p>
</div>
</div>
<p>To value an American call when there is one dividend payment before the option matures, we input the initial asset price <span class="math inline">\(S(0)\)</span> and then compute <span class="math inline">\(Z(0)=X(0)-\mathrm{e}^{-rT}D\)</span>. If <span class="math inline">\(D-K \leq -\mathrm{e}^{-r(T'-T)}K\)</span>, we return the Black-Scholes value of a European call written on <span class="math inline">\(Z\)</span>. Otherwise, we need to compute <span class="math inline">\(Z^*\)</span> and our bisection algorithm requires an upper bound for <span class="math inline">\(Z^*\)</span>, which would be any value of <span class="math inline">\(Z(T)\)</span> such that exercise at <span class="math inline">\(T\)</span> is optimal. It is not obvious what this should be, so we start with <span class="math inline">\(K\)</span> and keep doubling this until we obtain a value of <span class="math inline">\(Z(T)\)</span> at which exercise would be optimal. Then, we use the bisection algorithm to compute <span class="math inline">\(Z^*\)</span> and finally compute the option value <a href="#eq-americancall" class="quarto-xref">Equation&nbsp;<span>9.18</span></a>.</p>
<div id="american_call_dividend" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> american_call_dividend(S, K, r, sigma, Div, TDiv, TCall):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    LessDiv <span class="op">=</span> S <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> TDiv) <span class="op">*</span> Div</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Div <span class="op">/</span> K <span class="op">&lt;=</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> (TCall <span class="op">-</span> TDiv)):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> black_scholes_call(LessDiv, K, r, sigma, <span class="dv">0</span>, TCall)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> K</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> upper <span class="op">+</span> Div <span class="op">-</span> K <span class="op">&lt;</span> black_scholes_call(upper, K, r, sigma, <span class="dv">0</span>, TCall <span class="op">-</span> TDiv):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        upper <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    flower <span class="op">=</span> Div <span class="op">-</span> K</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    fupper <span class="op">=</span> upper <span class="op">+</span> Div <span class="op">-</span> K <span class="op">-</span> black_scholes_call(upper, K, r, sigma, <span class="dv">0</span>, TCall <span class="op">-</span> TDiv)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    fguess <span class="op">=</span> guess <span class="op">+</span> Div <span class="op">-</span> K <span class="op">-</span> black_scholes_call(guess, K, r, sigma, <span class="dv">0</span>, TCall <span class="op">-</span> TDiv)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> upper <span class="op">-</span> lower <span class="op">&gt;</span> tol:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fupper <span class="op">*</span> fguess <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> guess</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            flower <span class="op">=</span> fguess</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> guess <span class="op">+</span> Div <span class="op">-</span> K <span class="op">-</span> black_scholes_call(guess, K, r, sigma, <span class="dv">0</span>, TCall <span class="op">-</span> TDiv)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> guess</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            fupper <span class="op">=</span> fguess</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> guess <span class="op">+</span> Div <span class="op">-</span> K <span class="op">-</span> black_scholes_call(guess, K, r, sigma, <span class="dv">0</span>, TCall <span class="op">-</span> TDiv)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    LessDivStar <span class="op">=</span> guess</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(LessDiv <span class="op">/</span> LessDivStar) <span class="op">+</span> (r <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> TDiv) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(TDiv))</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(TDiv)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    d1prime <span class="op">=</span> (np.log(LessDiv <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> TCall) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(TCall))</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> d1prime <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(TCall)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> <span class="op">-</span>np.sqrt(TDiv <span class="op">/</span> TCall)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    M1 <span class="op">=</span> binormal_prob(<span class="op">-</span>d1, d1prime, rho)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    M2 <span class="op">=</span> binormal_prob(<span class="op">-</span>d2, d2prime, rho)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> LessDiv <span class="op">*</span> N1 <span class="op">+</span> np.exp(<span class="op">-</span>r <span class="op">*</span> TDiv) <span class="op">*</span> (Div <span class="op">-</span> K) <span class="op">*</span> N2 <span class="op">+</span> LessDiv <span class="op">*</span> M1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> TCall) <span class="op">*</span> K <span class="op">*</span> M2</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>Div <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>TDiv <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>TCall <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"American Call with Dividend:"</span>, american_call_dividend(S, K, r, sigma, Div, TDiv, TCall))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>American Call with Dividend: 13.983999456433198</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-s_choosers" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="sec-s_choosers"><span class="header-section-number">9.4</span> Choosers</h2>
<p>A chooser option allows the holder to choose whether the option will be a put or call at some fixed date before the option maturity. Let <span class="math inline">\(T\)</span> denote the date at which the choice is made, <span class="math inline">\(T_c\)</span> the date at which the call expires, <span class="math inline">\(T_p\)</span> the date at which the put expires, <span class="math inline">\(K_c\)</span> the exercise price of the call, and <span class="math inline">\(K_p\)</span> the exercise price of the put, where <span class="math inline">\(0&lt;T&lt;T_c\)</span> and <span class="math inline">\(0&lt;T&lt;T_p\)</span>. A simple chooser has <span class="math inline">\(T_c=T_p\)</span> and <span class="math inline">\(K_c=K_p\)</span>. A chooser is similar in spirit to a straddle: it is a bet on volatility without making a bet on direction. A simple chooser must be cheaper than a straddle with the same exercise price and maturity <span class="math inline">\(T'=T_c=T_p\)</span>, because a straddle is always in the money at maturity, whereas a simple chooser has the same value as the straddle if it is in the money but is only in the money at <span class="math inline">\(T'\)</span> when the choice made at <span class="math inline">\(T\)</span> turns out to have been the best one.</p>
<section id="chooser-payoff" class="level3">
<h3 class="anchored" data-anchor-id="chooser-payoff">Chooser Payoff</h3>
<p>The value of the chooser at date <span class="math inline">\(T\)</span> will be the larger of the call and put prices. Let <span class="math inline">\(S^*\)</span> denote the stock price at which the call and put have the same value. We can find <span class="math inline">\(S^*\)</span> by solving <code>Black\_Scholes\_Call(Sstar,Kc,r,sigma,q,Tc-T)                   \= Black\_Scholes\_Put(Sstar,Kp,r,sigma,q,Tp-T).</code></p>
<p>For a simple chooser with <span class="math inline">\(K_c=K_p=K\)</span> and <span class="math inline">\(T_c=T_p=T'\)</span>, we can find <span class="math inline">\(S^*\)</span> from the put-call parity relation at <span class="math inline">\(T\)</span>, leading to <span class="math inline">\(S^*=\mathrm{e}^{(q-r)(T'-T)}K.\)</span></p>
<p>The call will be chosen when <span class="math inline">\(S(T)&gt;S^*\)</span> and it finishes in the money if <span class="math inline">\(S(T_c)&gt;K_c\)</span> at date <span class="math inline">\(T_c\)</span>, so the payoff of the chooser is <span class="math inline">\(S(T_c)-K_c\)</span> when <span class="math display">\[S(T)&gt;S^* \quad \text{and}\quad S(T_c)&gt;K_c\;.
\]</span> The payoff is <span class="math inline">\(K_p-S(T_p)\)</span> at date <span class="math inline">\(T_p\)</span> when <span class="math display">\[
S(T)&lt;S^* \quad \text{and}\quad S(T_p)&lt;K_p\;.
\]</span> Let <span class="math display">\[\begin{align*}
x&amp;= \begin{cases} 1 &amp;\text{if $S(T)&gt;S^* $ and $S(T_c)&gt;K_c$\;,}\\
                               0 &amp; \text{otherwise\;.}
        \end{cases}\\
y&amp;= \begin{cases} 1 &amp;\text{if $S(T)&lt;S^*$ and $S(T_p)&lt;K_p$\;,}\\
                               0 &amp; \text{otherwise\;.}
        \end{cases}
\end{align*}\]</span> Then the payoff of the chooser is <span class="math inline">\(xS(T_c)-xK_c\)</span> at date <span class="math inline">\(T_c\)</span> and <span class="math inline">\(yK_p-yS(T_p)\)</span> at date <span class="math inline">\(T_p\)</span>.</p>
</section>
<section id="numeraires-2" class="level3">
<h3 class="anchored" data-anchor-id="numeraires-2">Numeraires</h3>
<p>As in the analysis of compound options, the value of the chooser at date 0 must be</p>
<p><span id="eq-chooser1"><span class="math display">\[
\begin{multline}
\mathrm{e}^{-q T_c}S(0)\times\text{prob}^V\!(x=1) \;- \;\mathrm{e}^{-rT_c}K_c\times\text{prob}^R(x=1)
\\+\; \mathrm{e}^{-rT_p}K_p\times\text{prob}^R(y=1) \;- \;\mathrm{e}^{-q T_p}S(0)\times\text{prob}^V\!(y=1)\;,
\end{multline}
\tag{9.19}\]</span></span></p>
<p>where we use <span class="math inline">\(V(t)=\mathrm{e}^{qt}S(t)\)</span> and <span class="math inline">\(R(t)=\mathrm{e}^{rt}\)</span> as numeraires.</p>
</section>
<section id="chooser-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="chooser-pricing-formula">Chooser Pricing Formula</h3>
<p>Equation <a href="#eq-chooser1" class="quarto-xref">Equation&nbsp;<span>9.19</span></a> and calculations similar to those of the previous two sections lead us to:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a chooser option is</p>
<p><span id="eq-chooser2"><span class="math display">\[
\begin{multline}
\mathrm{e}^{-q T_c}S(0)\mathrm{M}\!\left(d_1,d_{1c},\sqrt{T/T_c}\right) - \mathrm{e}^{-rT_c}K_c\mathrm{M}\!\left(d_2,d_{2c},\sqrt{T/T_c}\right)\\ +\mathrm{e}^{-rT_p}K_p\mathrm{M}\!\left(-d_2,-d_{2p} , \sqrt{T/T_p}\right) \\- \mathrm{e}^{-q T_p}S(0)\mathrm{M}\!\left(-d_1 ,-d_{1p} ,\sqrt{T/T_p}\right)\;,
\end{multline}
\tag{9.20}\]</span></span></p>
<p>where <span class="math display">\[\begin{equation*}
\begin{array}{ll}
d_1 = \frac{\log\left(\frac{S(0)}{S^*}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\;,
&amp; \qquad d_2=d_1-\sigma\sqrt{T}\;,\\
&amp;\\
d_{1c} = \frac{\log\left(\frac{S(0)}{K_c}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T_c}{\sigma\sqrt{T_c}}\;,
&amp; \qquad d_{2c}=d_{1c}-\sigma\sqrt{T_c}\;,\\
&amp;\\d_{1p} = \frac{\log\left(\frac{S(0)}{K_p}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T_p}{\sigma\sqrt{T_p}}\;,
&amp; \qquad d_{2p}=d_{1p}-\sigma\sqrt{T_p}\;.
\end{array}
\end{equation*}\]</span></p>
</div>
</div>
<p>To implement the bisection to compute <span class="math inline">\(S^*\)</span>, we can take zero as a lower bound and <span class="math inline">\(K_c+K_p\)</span> as an upper bound.^[We take the call value to be zero and the put value to be <span class="math inline">\(\mathrm{e}^{-r(T_p-T)}K_p\)</span> at date <span class="math inline">\(T\)</span> when the stock price is zero. To see why the upper bound works, note that when the stock price is <span class="math inline">\(S\)</span> at date <span class="math inline">\(T\)</span>, the call is worth at least <span class="math inline">\(S^*-K_c\)</span> and the put is worth no more than <span class="math inline">\(K_p\)</span>; i.e, <span class="math inline">\(C \geq S-K_c\)</span> and <span class="math inline">\(P \leq K_p\)</span>. Therefore, <span class="math inline">\(C-P \geq S-K_c-K_p\)</span>. Hence when <span class="math inline">\(S=K_c+K_p\)</span>, we have <span class="math inline">\(C-P\geq 0\)</span>. }</p>
<div id="choosers_option" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> np.exp(q <span class="op">*</span> Tc) <span class="op">*</span> (Kc <span class="op">+</span> Kp)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> Kc <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> Kp</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    flower <span class="op">=</span> <span class="op">-</span>np.exp(<span class="op">-</span>r <span class="op">*</span> (Tp <span class="op">-</span> T)) <span class="op">*</span> Kp</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    fupper <span class="op">=</span> black_scholes_call(upper, Kc, r, sigma, q, Tc <span class="op">-</span> T) <span class="op">-</span> black_scholes_put(upper, Kp, r, sigma, q, Tp <span class="op">-</span> T)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    fguess <span class="op">=</span> black_scholes_call(guess, Kc, r, sigma, q, Tc <span class="op">-</span> T) <span class="op">-</span> black_scholes_put(guess, Kp, r, sigma, q, Tp <span class="op">-</span> T)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> upper <span class="op">-</span> lower <span class="op">&gt;</span> tol:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fupper <span class="op">*</span> fguess <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            lower <span class="op">=</span> guess</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            flower <span class="op">=</span> fguess</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_call(guess, Kc, r, sigma, q, Tc <span class="op">-</span> T) <span class="op">-</span> black_scholes_put(guess, Kp, r, sigma, q, Tp <span class="op">-</span> T)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            upper <span class="op">=</span> guess</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            fupper <span class="op">=</span> fguess</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>            guess <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> lower <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> upper</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            fguess <span class="op">=</span> black_scholes_call(guess, Kc, r, sigma, q, Tc <span class="op">-</span> T) <span class="op">-</span> black_scholes_put(guess, Kp, r, sigma, q, Tp <span class="op">-</span> T)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    Sstar <span class="op">=</span> guess</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S <span class="op">/</span> Sstar) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    d1c <span class="op">=</span> (np.log(S <span class="op">/</span> Kc) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tc) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tc))</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    d2c <span class="op">=</span> d1c <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tc)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    d1p <span class="op">=</span> (np.log(S <span class="op">/</span> Kp) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> Tp) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(Tp))</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    d2p <span class="op">=</span> d1p <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(Tp)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    rhoc <span class="op">=</span> np.sqrt(T <span class="op">/</span> Tc)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    rhop <span class="op">=</span> np.sqrt(T <span class="op">/</span> Tp)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    M1c <span class="op">=</span> binormal_prob(d1, d1c, rhoc)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    M2c <span class="op">=</span> binormal_prob(d2, d2c, rhoc)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    M1p <span class="op">=</span> binormal_prob(<span class="op">-</span>d1, <span class="op">-</span>d1p, rhop)</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    M2p <span class="op">=</span> binormal_prob(<span class="op">-</span>d2, <span class="op">-</span>d2p, rhop)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> Tc) <span class="op">*</span> S <span class="op">*</span> M1c <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> Tc) <span class="op">*</span> Kc <span class="op">*</span> M2c <span class="op">+</span> np.exp(<span class="op">-</span>r <span class="op">*</span> Tp) <span class="op">*</span> Kp <span class="op">*</span> M2p <span class="op">-</span> np.exp(<span class="op">-</span>q <span class="op">*</span> Tp) <span class="op">*</span> S <span class="op">*</span> M1p</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>Kc <span class="op">=</span> <span class="dv">80</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>Kp <span class="op">=</span> <span class="dv">80</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>Tc <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>Tp <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>T<span class="op">=</span><span class="dv">1</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Chooser Option:"</span>, chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Chooser Option: 24.965320659540296</code></pre>
</div>
</div>
</section>
</section>
<section id="options-on-the-max-or-min" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="options-on-the-max-or-min"><span class="header-section-number">9.5</span> Options on the Max or Min</h2>
<p>We will consider here an option written on the maximum or minimum of two asset prices; for example, a call on the maximum pays <span class="math display">\[
\max(0,\max(S_1(T), S_2(T))-K) = \max(0,S_1(T)-K,S_2(T)-K)
\]</span> at maturity <span class="math inline">\(T\)</span>. There are also call options on <span class="math inline">\(\min(S_1(T), S_2(T))\)</span> and put options on the maximum and minimum of two (or more) asset prices. Pricing formulas for these options are due to Stulz <span class="citation" data-cites="Stulz">(<a href="#ref-Stulz" role="doc-biblioref">Stulz 1982</a>)</span>, who also discusses applications. We will assume the two assets have constant dividend yields <span class="math inline">\(q_i\)</span>, constant volatilities <span class="math inline">\(\sigma_i\)</span>, and a constant correlation <span class="math inline">\(\rho\)</span>.</p>
<section id="call-on-the-max-payoff" class="level3">
<h3 class="anchored" data-anchor-id="call-on-the-max-payoff">Call-on-the-Max Payoff</h3>
<p>To value the above option, define the random variables: <span class="math display">\[\begin{align*}
x&amp;= \begin{cases} 1 &amp; \text{if $S_1(T)&gt;S_2(T)$ and $S_1(T)&gt;K$}\; ,\\
0 &amp; \text{otherwise}\;, \end{cases}\\
y&amp;= \begin{cases} 1 &amp; \text{if $S_2(T)&gt; S_1(T)$ and $S_2(T)&gt;K$}\; ,\\
0 &amp; \text{otherwise}\;, \end{cases}\\
z&amp;= \begin{cases} 1 &amp; \text{if $S_1(T) &gt; K$ or $S_2(T)&gt; K$}\; ,\\
0 &amp; \text{otherwise}\;. \end{cases}
\end{align*}\]</span> Then the value of the option at maturity is <span class="math display">\[xS_1(T) + yS_2(T) - zK\; .\]</span> ### Numeraires Consider numeraires <span class="math inline">\(V_1(t) = \mathrm{e}^{q_1t}S_1(t)\)</span>, <span class="math inline">\(V_2(t)=\mathrm{e}^{q_2t}S_2(t)\)</span>, and <span class="math inline">\(R(t)=\mathrm{e}^{rt}\)</span>. By familiar arguments, the value of the option at date 0 is <span class="math display">\[\begin{multline*}
\mathrm{e}^{-q_1T}S_1(0)\times\text{prob}^{V_1}(x=1) + \mathrm{e}^{-q_2T}S_2(0)\times\text{prob}^{V_2}(y=1) \\- \mathrm{e}^{-rT}K\times\text{prob}^R(z=1)\; .
\end{multline*}\]</span></p>
</section>
<section id="calculating-probabilities-2" class="level3">
<h3 class="anchored" data-anchor-id="calculating-probabilities-2">Calculating Probabilities</h3>
<ol type="1">
<li>We will begin by calculating <span class="math inline">\(\text{prob}^{V_1}(x=1)\)</span>. From the second and third examples in <a href="Chapter3.html#sec-s_girsanov" class="quarto-xref"><span>Section 3.10</span></a>, the asset prices satisfy <span class="math display">\[\begin{align*}
\frac{\mathrm{d} S_1}{S_1} &amp;= (r-q_1+\sigma^2_1)\,\mathrm{d} t + \sigma_1\,\mathrm{d} B^*_{1}\; ,\\
\frac{\mathrm{d} S_2}{S_2} &amp;= (r-q_2+\rho\sigma_1\sigma_2)\,\mathrm{d} t + \sigma_2\,\mathrm{d} B^*_{2}\;,
\end{align*}\]</span> where <span class="math inline">\(B^*_{1}\)</span> and <span class="math inline">\(B^*_{2}\)</span> are Brownian motions when we use <span class="math inline">\(V_1\)</span> as the numeraire. Thus, <span class="math display">\[\begin{align*}
\log S_1(T) &amp;= \log S_1(0) + \left(r-q_1+\frac{1}{2}\sigma_1^2\right)T +\sigma_1B^*_{1}(T)\; ,\\
\log S_2(T) &amp;= \log S_2(0) + \left(r-q_2+\rho\sigma_1\sigma_2-\frac{1}{2}\sigma_2^2\right)T +\sigma_2B^*_{2}(T)\;.
\end{align*}\]</span> The condition <span class="math inline">\(\log S_1(T) &gt; \log K\)</span> is therefore equivalent to</li>
</ol>
<p><span id="eq-max1"><span class="math display">\[
  -\frac{1}{\sqrt{T}}B^*_{1}(T) &lt; d_{11}\;,
\tag{9.21}\]</span></span></p>
<p>and the condition <span class="math inline">\(\log S_1(T)&gt;\log S_2(T)\)</span> is equivalent to <span id="eq-max2"><span class="math display">\[
\frac{\sigma_2B^*_{2}(T)-\sigma_1B^*_{1}(T)}{\sigma\sqrt{T}} &lt; d_1\;,
\tag{9.22}\]</span></span></p>
<p>where <span id="eq-max2a"><span class="math display">\[
\sigma =\sqrt{\sigma_1^2-2\rho\sigma_1\sigma_2+\sigma_2^2}\;,
\tag{9.23}\]</span></span></p>
<p>and</p>
<p><span id="eq-max4"><span class="math display">\[
d_1 = \frac{\log\left(\frac{S_1(0)}{S_2(0)}\right)+\left(q_2-q_1+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\;, \qquad d_2 = d_1 - \sigma\sqrt{T}\;,
\tag{9.24}\]</span></span></p>
<p><span id="eq-max3"><span class="math display">\[
d_{11}=\frac{\log\left(\frac{S_1(0)}{K}\right)+\left(r-q_1+\frac{1}{2}\sigma_1^2\right)T}{\sigma_1\sqrt{T}}\;, \qquad d_{12} = d_{11} - \sigma_1\sqrt{T}\;.
\tag{9.25}\]</span></span></p>
<p>The random variables on the left-hand sides of <a href="#eq-max1" class="quarto-xref">Equation&nbsp;<span>9.21</span></a> - <a href="#eq-max2" class="quarto-xref">Equation&nbsp;<span>9.22</span></a> have standard normal distributions and their correlation is <span class="math display">\[
\rho_1 = \frac{\sigma_1-\rho\sigma_2}{\sigma}\; .
\]</span> Therefore, <span class="math display">\[\begin{equation*}
\text{prob}^{V_1}(x=1) = \mathrm{M}(d_{11},d_1,\rho_1)\;,
\end{equation*}\]</span> where <span class="math inline">\(\mathrm{M}\)</span> again denotes the bivariate normal distribution function.</p>
<ol start="2" type="1">
<li>The probability <span class="math inline">\(\text{prob}^{V_2}(y=1)\)</span> is exactly symmetric to <span class="math inline">\(\text{prob}^{V_1}(x=1)\)</span>, with the roles of <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span> interchanged. Note that the mirror image of <span class="math inline">\(d_1\)</span> defined in <a href="#eq-max4" class="quarto-xref">Equation&nbsp;<span>9.24</span></a> is <span class="math display">\[
\frac{\log\left(\frac{S_2(0)}{S_1(0)}\right)+\left(q_1-q_2+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\; ,
\]</span> which equals <span class="math inline">\(-d_2\)</span>. Therefore, <span class="math display">\[\begin{equation*}
\text{prob}^{V_2}(y=1) = \mathrm{M}(d_{21},-d_2,\rho_2)\;,
\end{equation*}\]</span> where <span id="eq-max31"><span class="math display">\[
d_{21}=\frac{\log\left(\frac{S_2(0)}{K}\right)+\left(r-q_2+\frac{1}{2}\sigma_2^2\right)T}{\sigma_2\sqrt{T}},\qquad d_{22} = d_{21}-\sigma_2\sqrt{T}\;,
\tag{9.26}\]</span></span></li>
</ol>
<p>and <span class="math display">\[
\rho_2 = \frac{\sigma_2-\rho\sigma_1}{\sigma}\; .
\]</span> 3. As usual, we have <span class="math display">\[\begin{align*}
\log S_1(T) &amp;= \log S_1(0) + \left(r-q_1-\frac{1}{2}\sigma_1^2\right)T +\sigma_1B^*_{1}(T)\; ,\\
\log S_2(T) &amp;= \log S_2(0) + \left(r-q_2-\frac{1}{2}\sigma_2^2\right)T +\sigma_2B^*_{2}(T)\;,
\end{align*}\]</span> where <span class="math inline">\(B^*_{1}\)</span> and <span class="math inline">\(B^*_{2}\)</span> now denote Brownian motions under the risk-neutral measure. The event <span class="math inline">\(z=1\)</span> is the complement of the event <span class="math display">\[
S_1(T)\leq K \quad \text{and} \quad S_2(T)\leq K\; ,
\]</span> which is equivalent to</p>
<p><span id="eq-max32"><span class="math display">\[
\frac{1}{\sqrt{T}}B^*_{1}(T) &lt; -d_{12}\;,
\tag{9.27}\]</span></span></p>
<p>and <span id="eq-max42"><span class="math display">\[
\frac{1}{\sqrt{T}}B^*_{2}(T) &lt; -d_{22}\;.
\tag{9.28}\]</span></span></p>
<p>The random variables on the left-hand sides of <a href="#eq-max32" class="quarto-xref">Equation&nbsp;<span>9.27</span></a> and <a href="#eq-max42" class="quarto-xref">Equation&nbsp;<span>9.28</span></a> are standard normals and have correlation <span class="math inline">\(\rho\)</span>. Therefore, <span class="math display">\[\begin{equation*}
\text{prob}^{R}(z=1) = 1- \mathrm{M}(-d_{12},-d_{22},\rho)\;.
\end{equation*}\]</span></p>
</section>
<section id="call-on-the-max-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="call-on-the-max-pricing-formula">Call-on-the-Max Pricing Formula</h3>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a call option on the maximum of two risky asset prices with volatilities <span class="math inline">\(\sigma_1\)</span> and <span class="math inline">\(\sigma_2\)</span> and correlation <span class="math inline">\(\rho\)</span> is</p>
<p><span id="eq-callonmaxformula"><span class="math display">\[
\begin{multline}
\mathrm{e}^{-q_1T}S_1(0)\mathrm{M}\!\left(d_{11},d_1,\frac{\sigma_1-\rho\sigma_2}{\sigma}\right) + \mathrm{e}^{-q_2T}S_2(0)\mathrm{M}\!\left(d_{21},-d_2,\frac{\sigma_2-\rho\sigma_1}{\sigma}\right)\\+ \mathrm{e}^{-rT}K\mathrm{M}(-d_{12},-d_{22},\rho) - \mathrm{e}^{-rT}K\;,
\end{multline}
\tag{9.29}\]</span></span></p>
<p>where <span class="math inline">\(\sigma\)</span> is defined in <a href="#eq-max2a" class="quarto-xref">Equation&nbsp;<span>9.23</span></a> and <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, <span class="math inline">\(d_{11}\)</span>, <span class="math inline">\(d_{12}\)</span>, <span class="math inline">\(d_{21}\)</span> and <span class="math inline">\(d_{22}\)</span> are defined in <a href="#eq-max4" class="quarto-xref">Equation&nbsp;<span>9.24</span></a> - <a href="#eq-max3" class="quarto-xref">Equation&nbsp;<span>9.25</span></a>.</p>
</div>
</div>
<p>The following code shows how to compute the price of a Call on the Max.</p>
<div id="call_on_max" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> call_on_max(S1, S2, K, r, sig1, sig2, rho, q1, q2, T):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.sqrt(sig2 <span class="op">**</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> rho <span class="op">*</span> sig1 <span class="op">*</span> sig2 <span class="op">+</span> sig1 <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S1 <span class="op">/</span> S2) <span class="op">+</span> (q2 <span class="op">-</span> q1 <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    d11 <span class="op">=</span> (np.log(S1 <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q1 <span class="op">+</span> sig1 <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sig1 <span class="op">*</span> np.sqrt(T))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    d12 <span class="op">=</span> d11 <span class="op">-</span> sig1 <span class="op">*</span> np.sqrt(T)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    d21 <span class="op">=</span> (np.log(S2 <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q2 <span class="op">+</span> sig2 <span class="op">**</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sig2 <span class="op">*</span> np.sqrt(T))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    d22 <span class="op">=</span> d21 <span class="op">-</span> sig2 <span class="op">*</span> np.sqrt(T)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    rho1 <span class="op">=</span> (sig1 <span class="op">-</span> rho <span class="op">*</span> sig2) <span class="op">/</span> sigma</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    rho2 <span class="op">=</span> (sig2 <span class="op">-</span> rho <span class="op">*</span> sig1) <span class="op">/</span> sigma</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    M1 <span class="op">=</span> binormal_prob(d11, d1, rho1)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    M2 <span class="op">=</span> binormal_prob(d21, <span class="op">-</span>d2, rho2)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    M3 <span class="op">=</span> binormal_prob(<span class="op">-</span>d12, <span class="op">-</span>d22, rho)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>q1 <span class="op">*</span> T) <span class="op">*</span> S1 <span class="op">*</span> M1 <span class="op">+</span> np.exp(<span class="op">-</span>q2 <span class="op">*</span> T) <span class="op">*</span> S2 <span class="op">*</span> M2 <span class="op">+</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">*</span> M3 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>S2<span class="op">=</span> <span class="dv">100</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>sigma1 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>sigma2 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>q1 <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>q2<span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>T<span class="op">=</span><span class="dv">1</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>rho<span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Call on Max:"</span>, call_on_max(S1, S2, K, r, sigma1, sigma2, rho, q1, q2, T))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Call on Max: 15.890779319201613</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-s_barriers" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="sec-s_barriers"><span class="header-section-number">9.6</span> Barrier Options</h2>
<p> A down-and-out call pays the usual call value at maturity if and only if the stock price does not hit a specified lower bound during the lifetime of the option. If it does breach the lower barrier, then it is out. Conversely, a down-and-in call pays off only if the stock price hit the lower bound. Up-and-out and up-and-in calls are defined similarly, and there are also put options of this sort. The out versions are called knock-outs and the in versions are called knock-ins.</p>
<p>Knock-ins can be priced from knock-outs and vice-versa. For example, the combination of a down-and-out call and a down-and-in call creates a standard European call, so the value of a down-and-in can be obtained by subtracting the value of a down-and-out from the value of a standard European call. Likewise, up-and-in calls can be valued by subtracting the value of an up-and-out from the value of a standard European call. Both knock-outs and knock-ins are of course less expensive than comparable standard options.</p>
<p>We will describe the pricing of a down-and-out call. The pricing of up-and-out calls and knock-out puts is similar. Often there are rebates associated with the knocking-out of a barrier option, but we will not include that feature here (see <a href="Chapter10.html#sec-s_finitedifferencebarriers" class="quarto-xref"><span>Section 10.7</span></a> however).</p>
<p>A down-and-out call provides a hedge against an increase in an asset price, just as does a standard call, for someone who is short the asset. The difference is that the down-and-out is knocked out when the asset price falls sufficiently. Presumably this is acceptable to the buyer because the need to hedge against high prices diminishes when the price falls. In fact, in this circumstance the buyer may want to establish a new hedge at a lower strike. However, absent re-hedging at a lower strike, the buyer of a knock-out call obviously faces the risk that the price may reverse course after falling to the knock-out boundary, leading to regret that the option was knocked out. The rationale for accepting this risk is that the knock-out is cheaper than a standard call. Thus, compared to a standard call, a down-and-out call provides cheaper but incomplete insurance.</p>
<p>The combination of a knock-out call and a knock-in call (or knock-out puts) with the same barrier and different strikes creates an option with a strike that is reset when the barrier is hit. This is a hedge that adjusts automatically to the market. An example is given in Probs.~<span class="math inline">\(\ref{e_standardknockout3}\)</span> and~<span class="math inline">\(\ref{e_standardknockout4}\)</span>.</p>
<section id="down-and-out-call-payoff" class="level3">
<h3 class="anchored" data-anchor-id="down-and-out-call-payoff">Down-and-Out Call Payoff</h3>
<p>Let <span class="math inline">\(L\)</span> denote the lower barrier for the down-and-out call and assume it has not yet been breached at the valuation date, which we are calling date 0. Denote the minimum stock price realized during the remaining life of the contract by <span class="math inline">\(z = \min_{0\leq t\leq T} S(t)\)</span>. In practice, this minimum is calculated at discrete dates (for example, based on daily closing prices), but we will assume here that the stock price is monitored continuously for the purpose of calculating the minimum.</p>
<p>The down-and-out call will pay <span class="math inline">\(\max(0,S(T)-K)\)</span> if <span class="math inline">\(z &gt; L\)</span> and 0 otherwise, at its maturity T.<br>
Let <span class="math display">\[
x = \begin{cases} 1 &amp; \text{if $S(T)&gt;K$ and $z &gt; L$\;,}\\
0 &amp; \text{otherwise\;.} \end{cases}
\]</span> Then the value of the down-and-out call at maturity is <span class="math display">\[
xS(T) - xK\; .
\]</span> ### Numeraires As in other cases, the value at date 0 can be written as <span class="math display">\[
\mathrm{e}^{-qT}S(0)\times\text{prob}^{V}(x=1) - \mathrm{e}^{-rT}K\times\text{prob}^{R}(x=1)\; ,
\]</span></p>
<p>where <span class="math inline">\(V(t) = \mathrm{e}^{qt}S(t)\)</span> and <span class="math inline">\(R(t)=\mathrm{e}^{rt}\)</span>.</p>
</section>
<section id="calculating-probabilities-3" class="level3">
<h3 class="anchored" data-anchor-id="calculating-probabilities-3">Calculating Probabilities</h3>
<p>To calculate <span class="math inline">\(\text{prob}^{V}(x=1)\)</span> and <span class="math inline">\(\text{prob}^{R}(x=1)\)</span>, we consider two cases.</p>
<ol type="1">
<li>Suppose <span class="math inline">\(K&gt;L\)</span>. Define <span class="math display">\[
y = \begin{cases} 1 &amp; \text{if $S(T)&gt;K$ and $z \leq L$}\\
0 &amp; \text{otherwise\;.} \end{cases}
\]</span></li>
</ol>
<p>The event <span class="math inline">\(S(T)&gt;K\)</span> is equal to the union of the disjoint events <span class="math inline">\(x=1\)</span> and <span class="math inline">\(y=1\)</span>. Therefore, <span class="math display">\[\begin{align*}
\text{prob}^{V}(x=1) &amp;= \text{prob}^{V}(S(T)\!&gt;\!K) - \text{prob}^{V}(y=1)\; ,\\
\text{prob}^{R}(x=1) &amp;= \text{prob}^{R}(S(T)\!&gt;\!K) - \text{prob}^{R}(y=1)\;.
\end{align*}\]</span></p>
<p>As in the derivation of the Black-Scholes formula, we have <span id="eq-casea2"><span class="math display">\[
\text{prob}^{V}(S(T)\!&gt;\!K) = \mathrm{N}(d_1) \quad \text{and} \quad \text{prob}^{R}(S(T)\!&gt;\!K) = \mathrm{N}(d_2)\;,
\tag{9.30}\]</span></span></p>
<p>where</p>
<p><span id="eq-casea3"><span class="math display">\[
d_1= \frac{\log\left(\frac{S(0)}{K}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\; ,\qquad  d_2 = d_1-\sigma\sqrt{T}\;.
\tag{9.31}\]</span></span></p>
<p>Furthermore , defining <span id="eq-casea5"><span class="math display">\[
d_1' = \frac{\log\left(\frac{L^2}{KS(0)}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\;, \qquad d_2' = d_1'-\sigma\sqrt{T}\;,
\tag{9.32}\]</span></span></p>
<p>it can be shown (see Appendix~<span class="math inline">\(\ref{a_minimum}\)</span>) that</p>
<p><span id="eq-casea4"><span class="math display">\[
\text{prob}^{V}(y=1) = \left(\frac{L}{S(0)}\right)^{2\left(r-q+\frac{1}{2}\sigma^2\right)/\sigma^2}\mathrm{N}(d_1')\;,
\tag{9.33}\]</span></span></p>
<p><span id="eq-casea41"><span class="math display">\[
\text{prob}^{R}(y=1) = \left(\frac{L}{S(0)}\right)^{2\left(r-q-\frac{1}{2}\sigma^2\right)/\sigma^2}\mathrm{N}(d_2')\;.
\tag{9.34}\]</span></span></p>
<ol start="2" type="1">
<li>Suppose <span class="math inline">\(K \leq L\)</span>. Then the condition <span class="math inline">\(S(T)&gt;K\)</span> in the definition of the event <span class="math inline">\(x=1\)</span> is redundant: if <span class="math inline">\(z &gt; L \geq K\)</span>, then it is necessarily true that <span class="math inline">\(S(T)&gt;K\)</span>. Therefore, the probability (under either numeraire) of the event <span class="math inline">\(x=1\)</span> is the probability that <span class="math inline">\(z &gt; L\)</span>. Define <span class="math display">\[y = \begin{cases} 1 &amp; \text{if $S(T)&gt;L$ and $z \leq L$\;,}\\
0 &amp; \text{otherwise\;.} \end{cases}
\]</span></li>
</ol>
<p>The event <span class="math inline">\(S(T)&gt;L\)</span> is the union of the disjoint events <span class="math inline">\(x=1\)</span> and <span class="math inline">\(y=1\)</span>. Therefore, as in the previous case (but now with <span class="math inline">\(K\)</span> replaced by <span class="math inline">\(L\)</span>), <span class="math display">\[\begin{align*}
\text{prob}^{V}(x=1) &amp;= \text{prob}^{V}(S(T)\!&gt;\!L) - \text{prob}^{V}(y=1)\; ,\\
\text{prob}^{R}(x=1) &amp;= \text{prob}^{R}(S(T)\!&gt;\!L) - \text{prob}^{R}(y=1)\;.
\end{align*}\]</span> Also as before, we know that <span id="eq-caseb2"><span class="math display">\[
\text{prob}^{V}(S(T)\!&gt;\!L) = \mathrm{N}(d_1) \quad \text{and} \quad \text{prob}^{R}(S(T)\!&gt;\!L) = \mathrm{N}(d_2)\;,
\tag{9.35}\]</span></span></p>
<p>where now</p>
<p><span id="eq-caseb3"><span class="math display">\[
d_1= \frac{\log\left(\frac{S(0)}{L}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\; ,\qquad  d_2 = d_1-\sigma\sqrt{T}\;.
\tag{9.36}\]</span></span></p>
<p>Moreover, <span class="math inline">\(\text{prob}^{V}(y=1)\)</span> and <span class="math inline">\(\text{prob}^{R}(y=1)\)</span> are given by <a href="#eq-casea4" class="quarto-xref">Equation&nbsp;<span>9.33</span></a> - <a href="#eq-casea41" class="quarto-xref">Equation&nbsp;<span>9.34</span></a> but with <span class="math inline">\(K\)</span> replaced by <span class="math inline">\(L\)</span>, which means that <span id="eq-caseb5"><span class="math display">\[
d_1' = \frac{\log\left(\frac{L}{S(0)}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\;, \qquad d_2'= d_1' - \sigma\sqrt{T}\;.
\tag{9.37}\]</span></span></p>
</section>
<section id="down-and-out-call-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="down-and-out-call-pricing-formula">Down-and-Out Call Pricing Formula</h3>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value of a continuously-sampled down-and-out call option with barrier <span class="math inline">\(L\)</span> is</p>
<p><span id="eq-downout100"><span class="math display">\[
\begin{multline}
\mathrm{e}^{-qT}S(0)\left[\mathrm{N}(d_1)-\left(\frac{L}{S(0)}\right)^{2\left(r-q+\frac{1}{2}\sigma^2\right)/\sigma^2}\mathrm{N}(d_1')\right]\\ - \mathrm{e}^{-rT}K\left[\mathrm{N}(d_2) - \left(\frac{L}{S(0)}\right)^{2\left(r-q-\frac{1}{2}\sigma^2\right)/\sigma^2}\mathrm{N}(d_2')\right]\;,
\end{multline}
\tag{9.38}\]</span></span></p>
<p>where</p>
<ol type="1">
<li>if <span class="math inline">\(K&gt;L\)</span>, <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span> , <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-casea3" class="quarto-xref">Equation&nbsp;<span>9.31</span></a> - <a href="#eq-casea5" class="quarto-xref">Equation&nbsp;<span>9.32</span></a>,</li>
<li>if <span class="math inline">\(K\leq L\)</span>, <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, <span class="math inline">\(d_1'\)</span> and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-caseb3" class="quarto-xref">Equation&nbsp;<span>9.36</span></a> - <a href="#eq-caseb5" class="quarto-xref">Equation&nbsp;<span>9.37</span></a>.</li>
</ol>
</div>
</div>
<p>The following code computes the price of a down and out call option.</p>
<div id="down-and_out_call" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> down_and_out_call(S, K, r, sigma, q, T, Barrier):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> K <span class="op">&gt;</span> Barrier:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> S <span class="op">/</span> K</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Barrier <span class="op">*</span> Barrier <span class="op">/</span> (K <span class="op">*</span> S)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> S <span class="op">/</span> Barrier</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> Barrier <span class="op">/</span> S</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(a) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    d1prime <span class="op">=</span> (np.log(b) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> d1prime <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    N1prime <span class="op">=</span> norm.cdf(d1prime)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    N2prime <span class="op">=</span> norm.cdf(d2prime)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> (r <span class="op">-</span> q) <span class="op">/</span> (sigma <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x <span class="op">-</span> <span class="dv">2</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    q1 <span class="op">=</span> N1 <span class="op">-</span> (Barrier <span class="op">/</span> S) <span class="op">**</span> x <span class="op">*</span> N1prime</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    q2 <span class="op">=</span> N2 <span class="op">-</span> (Barrier <span class="op">/</span> S) <span class="op">**</span> y <span class="op">*</span> N2prime</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> q1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">*</span> q2</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Down and Out Call:"</span>, down_and_out_call(S, K, r, sigma, q, T, <span class="dv">80</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Down and Out Call: 9.133306436498117</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-s_lookbacks" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="sec-s_lookbacks"><span class="header-section-number">9.7</span> Lookbacks</h2>
<p> A floating-strike lookback call pays the difference between the asset price at maturity and the minimum price realized during the life of the contract. A floating-strike lookback put pays the difference between the maximum price over the life of the contract and the price at maturity. Thus, the floating-strike lookback call allows one to buy the asset at its minimum price, and the floating-strike lookback put allows one to sell the asset at its maximum price. Of course, one pays upfront for this opportunity to time the market. These options were first discussed by Goldman, Sosin and Gatto <span class="citation" data-cites="GSG">(<a href="#ref-GSG" role="doc-biblioref">Goldman, Sosin, and Gatto 1979</a>)</span>.</p>
<p>A fixed-strike lookback put pays the difference between a fixed strike price and the minimum price during the lifetime of the contract. Thus, a fixed-strike lookback put and a floating-strike lookback call are similar in one respect: both enable one to buy the asset at its minimum price. However, the put allows one to sell the asset at a fixed price whereas the call allows one to sell it at the terminal asset price. A fixed-strike lookback call pays the difference between the maximum price and a fixed strike price and is similar to a floating-strike lookback put in the sense that both enable one to sell the asset at its maximum price. Fixed-strike lookback options were first discussed by Conze and Viswanathan <span class="citation" data-cites="CV">(<a href="#ref-CV" role="doc-biblioref">Conze and Viswanathan 1991</a>)</span>. We will discuss the valuation of floating-strike lookback calls. As in the discussion of barrier options, we will assume that the price is continuously sampled for the purpose of computing the minimum.</p>
<section id="floating-strike-lookback-call-payoff" class="level3">
<h3 class="anchored" data-anchor-id="floating-strike-lookback-call-payoff">Floating-Strike Lookback Call Payoff</h3>
<p>As in the previous section, let <span class="math inline">\(z\)</span> denote the minimum stock price realized over the . This is not necessarily the minimum stock price realized during the entire lifetime of the contract. Let <span class="math inline">\(S_{\min}\)</span> denote the minimum stock price realized during the lifetime of the contract up to and including date 0, which is the date at which we are valuing the contract. The minimum stock price during the will be the smaller of <span class="math inline">\(z\)</span> and <span class="math inline">\(S_{\text{min}}\)</span>. The payoff of the floating strike lookback call is <span class="math inline">\(S(T) - \min\left(z, S_{\text{min}}\right)\)</span>.</p>
</section>
<section id="calculations" class="level3">
<h3 class="anchored" data-anchor-id="calculations">Calculations</h3>
<p>The value at date 0 of the piece <span class="math inline">\(S(T)\)</span> is simply <span class="math inline">\(\mathrm{e}^{-qT}S(0)\)</span>. Using the result in Appendix~<span class="math inline">\(\ref{a_minimum}\)</span> on the distribution of <span class="math inline">\(z\)</span>, it can be shown (see, e.g., Musiela and Rutkowski <span class="citation" data-cites="MR">(<a href="#ref-MR" role="doc-biblioref">Musiela and Rutkowski 1997</a>)</span> for the details) that the value at date 0 of receiving <span class="math display">\[
\min(z, S_{\text{min}})
\]</span> at date <span class="math inline">\(T\)</span> is <span class="math display">\[\begin{multline*}
\mathrm{e}^{-rT}S_{\text{min}}\mathrm{N}(d_2) -\frac{\sigma^2}{2(r-q)}\left(\frac{S_{\text{min}}}{S(0)}\right)^{2(r-q)/\sigma^2}\mathrm{e}^{-rT}S(0)\mathrm{N}(d_2') \\
+\left(1+ \frac{\sigma^2}{2(r-q)}\right)\mathrm{e}^{-qT}S(0)\mathrm{N}(-d_1)\;.
\end{multline*}\]</span> where</p>
<p><span id="eq-fslc100a"><span class="math display">\[
d_1 = \frac{\log\left(\frac{S(0)}{S_{\text{min}}}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\; , \qquad d_2 = d_1 - \sigma\sqrt{T}\;,
\tag{9.39}\]</span></span></p>
<p><span id="eq-fslc100c"><span class="math display">\[
d_1' = \frac{\log\left(\frac{S_{\text{min}}}{S(0)}\right)+\left(r-q+\frac{1}{2}\sigma^2\right)T}{\sigma\sqrt{T}}\;, \qquad d_2'=d_1' - \sigma\sqrt{T} \;.
\tag{9.40}\]</span></span></p>
<p>Using the fact that <span class="math inline">\([1-\mathrm{N}(-d_1)]\mathrm{e}^{-qT}S(0)=\mathrm{e}^{-qT}S(0)\mathrm{N}(d_1)\)</span>, this implies:</p>
</section>
<section id="floating-strike-lookback-call-pricing-formula" class="level3">
<h3 class="anchored" data-anchor-id="floating-strike-lookback-call-pricing-formula">Floating-Strike Lookback Call Pricing Formula</h3>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value at date 0 of a continuously-sampled floating-strike lookback call, given that the minimum price during the lifetime of the contract through date 0 is <span class="math inline">\(S_{\text{min}}\)</span> and the remaining time to maturity is <span class="math inline">\(T\)</span>, is</p>
<p><span id="eq-fslc100"><span class="math display">\[
\begin{multline}
\mathrm{e}^{-qT}S(0)\mathrm{N}(d_1)-\mathrm{e}^{-rT}S_{\text{min}}\mathrm{N}(d_2) \\+\frac{\sigma^2}{2(r-q)}\left(\frac{S_{\text{min}}}{S(0)}\right)^{2(r-q)/\sigma^2}\mathrm{e}^{-rT}S(0)\mathrm{N}(d_2') \\
-\frac{\sigma^2}{2(r-q)}\mathrm{e}^{-qT}S(0)\mathrm{N}(-d_1)\;,
\end{multline}
\tag{9.41}\]</span></span></p>
<p>where <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>, and <span class="math inline">\(d_2'\)</span> are defined in <a href="#eq-fslc100a" class="quarto-xref">Equation&nbsp;<span>9.39</span></a> - <a href="#eq-fslc100c" class="quarto-xref">Equation&nbsp;<span>9.40</span></a>.</p>
</div>
</div>
<p>The following program calculates the price of a floating strike lookback option.</p>
<div id="floating_strike_lookback" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> floating_strike_call(S, r, sigma, q, T, SMin):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S <span class="op">/</span> SMin) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> (np.log(SMin <span class="op">/</span> S) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    N2prime <span class="op">=</span> norm.cdf(d2prime)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (r <span class="op">-</span> q) <span class="op">/</span> (sigma <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> N1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> SMin <span class="op">*</span> N2 <span class="op">+</span> (<span class="dv">1</span> <span class="op">/</span> x) <span class="op">*</span> (SMin <span class="op">/</span> S) <span class="op">**</span> x <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> SMin <span class="op">*</span> N2prime <span class="op">-</span> (<span class="dv">1</span> <span class="op">/</span> x) <span class="op">*</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> N1)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>T<span class="op">=</span><span class="dv">1</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Floating Strike Call:"</span>, floating_strike_call(S, r, sigma, q, T, <span class="dv">90</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Floating Strike Call: 16.27191861732918</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-s_baskets" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="sec-s_baskets"><span class="header-section-number">9.8</span> Basket and Spread Options</h2>
<p>A spread option is a call or a put written on the difference of two asset prices. For example, a spread call will pay at maturity <span class="math inline">\(T\)</span> the larger of zero and <span class="math inline">\(S_1(T)-S_2(T)-K\)</span>, where the <span class="math inline">\(S_i\)</span> are the asset prices and <span class="math inline">\(K\)</span> is the strike price of the call. Spread options can be used by producers to hedge the difference between an input price and an output price. They are also useful for hedging basis risk. For example, someone may want to hedge an asset by selling a futures contract on a closely related but not identical asset. This exposes the hedger to basis risk: the difference in value between the asset and the underlying asset on the futures contract. A spread call can hedge the basis risk: take <span class="math inline">\(S_1\)</span> to be the value of the asset underlying the futures contract and <span class="math inline">\(S_2\)</span> the value of the asset being hedged.</p>
<p>A spread option is actually an exchange option. Assuming constant dividend yields <span class="math inline">\(q_1\)</span> and <span class="math inline">\(q_2\)</span>, we can take the assets underlying the exchange option to be as follows</p>
<ol type="1">
<li>At date 0, purchase <span class="math inline">\(\mathrm{e}^{-q_1T}\)</span> units of the asset with price <span class="math inline">\(S_1\)</span> and reinvest dividends, leading to a value of <span class="math inline">\(S_1(T)\)</span> at date <span class="math inline">\(T\)</span>,</li>
<li>At date 0, purchase <span class="math inline">\(\mathrm{e}^{-q_2T}\)</span> units of the asset with price <span class="math inline">\(S_2\)</span> and invest <span class="math inline">\(\mathrm{e}^{-rT}K\)</span> in the risk-free asset. Reinvesting dividends and accumulating interest means that we will have <span class="math inline">\(S_2(T)+K\)</span> dollars at date <span class="math inline">\(T\)</span>.</li>
</ol>
<p>However, we cannot apply Margrabe’s formula to price spread options, because the second portfolio described above will have a stochastic volatility. To see this, note that if the price <span class="math inline">\(S_2(t)\)</span> falls to a low level, then the portfolio will consist primarily of the risk-free asset, so the portfolio volatility will be near the volatility of the risk-free asset, which is zero. On the other hand, if <span class="math inline">\(S_2(t)\)</span> becomes very high, then the portfolio will be weighted very heavily on the stock investment, and its volatility will approach the volatility of <span class="math inline">\(S_2\)</span>.</p>
<p>A basket option is an option written on a portfolio of assets. For example, someone may want to hedge the change in the value of the dollar relative to a basket of currencies. A basket option is an alternative to purchasing separate options on each currency. Generally, the basket option would have a lower premium than the separate options, because an option on a portfolio is cheaper (and pays less at maturity) than a portfolio of options.</p>
<p>Letting <span class="math inline">\(S_1\)</span>, , <span class="math inline">\(S_n\)</span> denote the asset prices and <span class="math inline">\(w_1\)</span>, , <span class="math inline">\(w_n\)</span> the weights specified by the contract, a basket call would pay <span class="math display">\[\max\left(0,\;\sum_{i=1}^n w_iS_i(T) - K\right)\]</span> at maturity <span class="math inline">\(T\)</span>. A spread option is actually a special case of a basket option, with <span class="math inline">\(n=2\)</span>, <span class="math inline">\(w_1=1\)</span>, and <span class="math inline">\(w_2=-1\)</span>. The difficulty in valuing basket options is the same as that encountered in valuing spread options. The volatility of the basket price <span class="math inline">\(\sum_{i=1}^nw_iS_i(t)\)</span> will vary over time, depending on the relative volatilities of the assets and the price changes in the assets. For example, consider the case <span class="math inline">\(n=2\)</span> and write <span class="math inline">\(S(t)\)</span> for the basket price <span class="math inline">\(w_1S_1(t)+w_2S_2(t)\)</span>. Then <span class="math display">\[\begin{align*}
\frac{\mathrm{d} S}{S} &amp;= \frac{w_1\,\mathrm{d} S_1}{S} + \frac{w_2\,\mathrm{d} S_2}{S}\\
&amp;=\frac{w_1S_1}{S}\times \frac{\mathrm{d} S_1}{S_1} + \frac{w_2S_2}{S}\times \frac{\mathrm{d} S_2}{S_2}\;.
\end{align*}\]</span> Let <span class="math inline">\(x_i(t)=w_iS_i(t)/S(t)\)</span>. This is the fraction of the portfolio value that the <span class="math inline">\(i\)</span>–th asset contributes. It will vary randomly over time as the prices change. Letting <span class="math inline">\(\sigma_i\)</span> denote the volatilities of the individual assets and <span class="math inline">\(\rho\)</span> their correlation, the formula just given for <span class="math inline">\(\mathrm{d} S/S\)</span> shows that the instantaneous volatility of the basket price at any date <span class="math inline">\(t\)</span> is <span class="math display">\[
\sqrt{x_1^2(t)\sigma_1^2 + 2x_1(t)x_2(t)\rho\sigma_1\sigma_2 + x_2^2(t)\sigma_2^2}\; .
\]</span></p>
<p>Hence, the volatility will vary randomly over time as the <span class="math inline">\(x_i\)</span> change. As in the case of spread options, there is no simple closed-form solution for the value of a basket option.</p>
</section>
<section id="sec-s_asians" class="level2" data-number="9.9">
<h2 data-number="9.9" class="anchored" data-anchor-id="sec-s_asians"><span class="header-section-number">9.9</span> Asian Options</h2>
<p>An Asian option is an option the value of which depends on the average underlying asset price during the lifetime of the option. Average-price calls and puts are defined like standard calls and puts but with the final asset price replaced by the average price. Average-strike calls and puts are defined like standard calls and puts but with the exercise price replaced by the average asset price. A firm that must purchase an input at frequent intervals or will sell a product in a foreign currency at frequent intervals can use an average price option as an alternative to buying multiple options with different maturity dates. The average-price option will generally be both less expensive and a better hedge than purchasing multiple options.</p>
<p>In practice, the average price is computed by averaging over the prices sampled at a finite number of discrete dates. First, we consider the case of continuous sampling. With continuous sampling, the average price at date <span class="math inline">\(T\)</span> for an option written at date 0 will be denoted by <span class="math inline">\(A(T)\)</span> and is defined as <span class="math display">\[
A(T) = \frac{1}{T}\int_0^T S(t)\,\mathrm{d} t\; .
\]</span> To obtain a closed-form solution for the value of an option on the average price, we face essentially the same problem as for basket and spread options: a sum of lognormally distributed variables is not itself lognormally distributed. In this case, the integral, which is essentially a continuous sum of the prices at different dates, is not lognormally distributed.</p>
<p>An alternative contract would replace the average price with the geometric average. This is defined as the exponential of the average logarithm. We will denote this by <span class="math inline">\(A_\text{g}(T)\)</span>. The average logarithm is <span class="math display">\[
\frac{1}{T}\int_0^T \log S(t)\,\mathrm{d} t\; ,
\]</span> and the geometric average is <span class="math display">\[
A_\text{g}(T) = \exp\left(\frac{1}{T}\int_0^T \log S(t)\,\mathrm{d} t\right)\; .
\]</span> The concavity of the logarithm function guarantees that <span class="math display">\[
\log \frac{1}{T}\int_0^T S(t) &gt; \frac{1}{T}\int_0^T \log S(t)\,\mathrm{d} t \; .
\]</span> Therefore, <span class="math display">\[\begin{align*}
A(T) &amp;= \exp\left(\log \frac{1}{T}\int_0^T S(t)\right)\\
&amp;&gt; \exp\left(\frac{1}{T}\int_0^T \log S(t)\,\mathrm{d} t\right) \\
&amp;= A_\text{g}(T)\; .
\end{align*}\]</span> Consequently, approximating the value of an average-price or average-strike option by substituting <span class="math inline">\(A_\text{g}(T)\)</span> for <span class="math inline">\(A(T)\)</span> will produce a biased estimate of the value. Nevertheless, the geometric average<span class="math inline">\(A_\text{g}(T)\)</span> and the arithmetic average <span class="math inline">\(A(T)\)</span> will be highly correlated, so <span class="math inline">\(A_\text{g}(T)\)</span> forms a very useful for Monte-Carlo valuation of average-price and average-strike options, as will be discussed later. To implement the idea, we need a valuation formula for options written on <span class="math inline">\(A_\text{g}(T)\)</span>. We will derive this for an average-price call, in which <span class="math inline">\(A_\text{g}(T)\)</span> substitutes for <span class="math inline">\(A(T)\)</span>.</p>
<p>Specifically, consider a contract that pays <span class="math display">\[
\max(0,A_\text{g}(T)-K)
\]</span> at its maturity <span class="math inline">\(T\)</span>. This is a geometric-average-price call,, and we will analyze it in the same way that we analyzed quanto options in <a href="Chapter7.html" class="quarto-xref"><span>Chapter 7</span></a>. Let <span class="math inline">\(V(t)\)</span> denote the value at date <span class="math inline">\(t\)</span> of receiving <span class="math inline">\(A_\text{g}(T)\)</span> at date <span class="math inline">\(T\)</span>. This can be calculated, and the result will be given below. <span class="math inline">\(V(t)\)</span> is the value of a non-dividend-paying portfolio, and, by definition, <span class="math inline">\(V(T)=A_\text{g}(T)\)</span>, so the geometric-average-price call is equivalent to a standard call with <span class="math inline">\(V\)</span> being the price of the underlying. We will show that <span class="math inline">\(V\)</span> has a time-varying but non-random volatility. Therefore, we can apply the Black-Scholes formula, inputting the average volatility as described in <a href="Chapter4.html#sec-s_timevaryingvolatility" class="quarto-xref"><span>Section 4.8</span></a>, to value the geometric-average-price call. We could attempt the same route to price average-price options, but we would find that the volatility of the corresponding value <span class="math inline">\(V\)</span> would vary randomly, just as we found the basket portfolio to have a random volatility in the previous section.</p>
<p>The value <span class="math inline">\(V(t)\)</span> can be calculated as <span class="math display">\[
V(t)= \mathrm{e}^{-r(T-t)}E^R_t\big[A_\text{g}(T)\big]\; .
\]</span> Define <span class="math display">\[
A_g(t) = \exp\left(\frac{1}{t}\int_0^t \log S(u)\,du\right)\;.
\]</span></p>
<p>We will verify at the end of this section that <span id="eq-geometricaveragev1"><span class="math display">\[
V(t) = \mathrm{e}^{-r(T-t)}A_g(t)^{\frac{t}{T}}S(t)^{\frac{T-t}{T}}\exp\left(\frac{(r-q-\sigma^2/2)(T-t)^2}{2T} + \frac{\sigma^2(T-t)^3}{6T^2}\right)\;.
\tag{9.42}\]</span></span></p>
<p>Two points are noteworthy. First, the value at date 0 is</p>
<p><span class="math display">\[
V(0) = \mathrm{e}^{-rT}S(0)\exp\left(\frac{(r-q-\sigma^2/2)T}{2} + \frac{\sigma^2T}{6}\right)
\]</span> <span id="eq-asianV0"><span class="math display">\[
=\exp\left(-\frac{6r+6q + \sigma^2}{12}T\right)S(0)\;.
\tag{9.43}\]</span></span></p>
<p>Second, the volatility comes from the factor <span class="math display">\[
S(t)^{\frac{T-t}{T}}\;,
\]</span> and, by Ito’s formula, <span class="math display">\[
\frac{ \mathrm{d} S^{\frac{T-t}{T}}}{S^{\frac{T-t}{T}}} = \text{something}\,\,\mathrm{d} t + \left(\frac{T-t}{T}\right)\sigma\,\mathrm{d} B\;.
\]</span> This implies that the average volatility, in the sense of <a href="Chapter4.html#sec-s_timevaryingvolatility" class="quarto-xref"><span>Section 4.8</span></a>, is <span class="math display">\[
\sigma_{\text{avg}} = \sqrt{\frac{1}{T}\int_0^T \left(\frac{T-t}{T}\right)^2\sigma^2\,\mathrm{d} t}
=\frac{\sigma}{\sqrt{3}}\;.
\]</span> Applying the Black-Scholes formula yields:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value at date 0 of a continuously-sampled geometric-average-price call written at date~0 and having <span class="math inline">\(T\)</span> years to maturity is <span class="math display">\[
V(0)\mathrm{N}(d_1)-\mathrm{e}^{-rT}K\mathrm{N}(d_2)\; ,
\]</span> where <span class="math display">\[
d_1 = \frac{\log\left(\frac{V(0)}{K}\right)+\left(r+\frac{1}{2}\sigma_{\text{avg}}^2\right)T}{\sigma_{\text{avg}}\sqrt{T}}, \qquad d_2 = d_1 - \sigma_{\text{avg}}\sqrt{T}\; ,
\]</span> <span class="math inline">\(V(0)\)</span> is defined in <a href="#eq-asianV0" class="quarto-xref">Equation&nbsp;<span>9.43</span></a>, and <span class="math inline">\(\sigma_{\text{avg}}=\sigma/\sqrt{3}\)</span>.</p>
</div>
</div>
<p>We can also value a discretely-sampled geometric-average-price call by the same arguments. Consider dates <span class="math inline">\(0&lt;t_0&lt; t_1 &lt; \cdots t_N=T\)</span>, where <span class="math inline">\(t_i-t_{i-1}=\Delta t\)</span> for each <span class="math inline">\(i\)</span> and suppose the price is to be sampled at the dates <span class="math inline">\(t_1,\ldots,t_N\)</span>. Now let <span class="math inline">\(V(t)\)</span> denote the value at date <span class="math inline">\(t\)</span> of the contract that pays <span id="eq-geometricaveragev0"><span class="math display">\[
\exp\left(\frac{1}{N} \sum_{i=1}^N \log S(t_i)\right) = \left(\prod_{i=1}^N S(t_i)\right)^{1/N}
\tag{9.44}\]</span></span></p>
<p>at date <span class="math inline">\(T\)</span>. The call option will pay <span class="math inline">\(\max(0,V(T)-K)\)</span> at date <span class="math inline">\(T\)</span>. Let <span class="math inline">\(k\)</span> denote the integer such that <span class="math inline">\(t_{N-k-1} \leq t &lt; t_{N-k}\)</span>. This means that we have already observed the prices <span class="math inline">\(S(t_1), \ldots, S(t_{N-k-1})\)</span> and we have yet to observe the <span class="math inline">\(k+1\)</span> prices <span class="math inline">\(S(t_{N-k}), \ldots ,S(t_N)\)</span>. Define <span class="math inline">\(\varepsilon = (t_{N\!-k}-t)/\Delta t\)</span>, which is fraction of the interval <span class="math inline">\(\Delta t\)</span> that must pass before we reach the next sampling date <span class="math inline">\(t_{N\!-k}\)</span>. We will show at the end of this section that</p>
<p><span id="eq-geometricaveragev2"><span class="math display">\[
\begin{multline}
V(t) = \mathrm{e}^{-r(T-t)}S(t)^{\frac{k+1}{N}}\prod_{i=1}^{N-k-1}S(t_i)^{\frac{1}{N}}\\
\times\,\exp\left(\left[ \frac{(k+1)\varepsilon\nu}{N}\!+\! \frac{k(k+1)\nu}{2N}\! +\! \frac{(k+1)^2\sigma^2\varepsilon}{2N^2}\!+\!\frac{k(k+1)(2k+1)\sigma^2}{12N^2} \right]\Delta t\right)\;,
\end{multline}
\tag{9.45}\]</span></span></p>
<p>where <span class="math inline">\(\nu = r-q-\sigma^2/2\)</span></p>
<p>Again, two points are noteworthy. Assume the call was written at date 0 and the first observation date <span class="math inline">\(t_1\)</span> is <span class="math inline">\(\Delta t\)</span> years away. Then, we have <span class="math inline">\(k+1=N\)</span> and <span class="math inline">\(\varepsilon=1\)</span> so <span id="eq-asianV02"><span class="math display">\[
V(0) = \mathrm{e}^{-rT}S(0)\exp\left( \frac{(N+1)\nu\Delta t}{2} + \frac{(N+1)(2N+1)\sigma^2\Delta t}{12N} \right)\;.
\tag{9.46}\]</span></span></p>
<p>Second, the volatility of <span class="math inline">\(V(t)\)</span> comes from the factor <span class="math inline">\(S(t)^{(k+1)/N}\)</span>, and <span class="math display">\[
\frac{ \mathrm{d} S^{\frac{k+1}{N}}}{S^{\frac{k+1}{N}}} = \text{something}\,\,\mathrm{d} t + \left(\frac{k+1}{N}\right)\sigma\,\mathrm{d} B\;.
\]</span> This implies that the average volatility, in the sense of <a href="Chapter4.html#sec-s_timevaryingvolatility" class="quarto-xref"><span>Section 4.8</span></a>, is</p>
<p><span class="math display">\[
\sigma_{\text{avg}} = \sqrt{\frac{1}{N}\sum_{k=0}^{N-1} \left(\frac{k+1}{N}\right)^2\sigma^2\,\mathrm{d} t}
\]</span> <span id="eq-asiansigmaavg"><span class="math display">\[
=\frac{\sigma}{N^{3/2}}\sqrt{\frac{N(N+1)(2N+1)}{6}}\;,
\tag{9.47}\]</span></span></p>
<p>where we have used the fact that <span class="math inline">\(\sum_{i=1}^N i^2 = N(N+1)(2N+1)/6\)</span> to obtain the second equality. Thus, the Black-Scholes formula implies:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The value at date 0 of a discretely-sampled geometric-average-price call written at date~0 and having <span class="math inline">\(T\)</span> years to maturity is <span id="eq-disc_geom_avg_call"><span class="math display">\[
V(0)\mathrm{N}(d_1)-\mathrm{e}^{-rT}K\mathrm{N}(d_2)\;,
\tag{9.48}\]</span></span></p>
<p>where <span class="math display">\[
d_1 = \frac{\log\left(\frac{V(0)}{K}\right)+\left(r+\frac{1}{2}\sigma_{\text{avg}}^2\right)T}{\sigma_{\text{avg}}\sqrt{T}}, \qquad d_2 = d_1 - \sigma_{\text{avg}}\sqrt{T}\; ,
\]</span> <span class="math inline">\(V(0)\)</span> is defined in <a href="#eq-asianV02" class="quarto-xref">Equation&nbsp;<span>9.46</span></a>, and <span class="math inline">\(\sigma_{\text{avg}}\)</span> is defined in <a href="#eq-asiansigmaavg" class="quarto-xref">Equation&nbsp;<span>9.47</span></a>.</p>
</div>
</div>
<p>This formula will be used in <a href="Chapter6.html#sec-s_controlvariates" class="quarto-xref"><span>Section 6.2</span></a> as a control variate for pricing discretely-sampled average-price calls (even average-price calls that were written before the date of valuation).</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>##</p>
<p>We will now derive equations <a href="#eq-geometricaveragev1" class="quarto-xref">Equation&nbsp;<span>9.42</span></a> and <a href="#eq-geometricaveragev2" class="quarto-xref">Equation&nbsp;<span>9.45</span></a>. We will begin with <a href="#eq-geometricaveragev1" class="quarto-xref">Equation&nbsp;<span>9.42</span></a>. The random variable <span class="math inline">\(A_g(T)\)</span> is normally distributed under the risk-neutral measure given information at time <span class="math inline">\(t\)</span>. To establish this, and to calculate the mean and variance of <span class="math inline">\(A_g(T)\)</span>, the key is to change the order of integration in the integral in the second line below to obtain the third line: <span class="math display">\[\begin{align*}
\int_t^T \log S(u)\,du &amp;= \int_t^T \left\{\log S(t) + \left(r-q-\frac{1}{2}\sigma^2\right)(u-t) + \sigma [B(u)-B(t)]\right\}\,du\\
&amp;= (T-t)\log S(t) + \left(r-q-\frac{1}{2}\sigma^2\right)\frac{(T-t)^2}{2} + \sigma\int_t^T \int_t^u \mathrm{d} B(s)\,du\\
&amp;= (T-t)\log S(t) + \left(r-q-\frac{1}{2}\sigma^2\right)\frac{(T-t)^2}{2} + \sigma\int_t^T \int_s^T du\,\mathrm{d} B(s)\\
&amp;= (T-t)\log S(t) + \left(r-q-\frac{1}{2}\sigma^2\right)\frac{(T-t)^2}{2} + \sigma\int_t^T (T-s)\,\mathrm{d} B(s)
\end{align*}\]</span> and then to note that <span class="math inline">\(\int_t^T (T-s)\,\mathrm{d} B(s)\)</span> is normally distributed with mean zero and variance equal to <span class="math display">\[
\int_t^T (T-s)^2\,ds =\frac{(T-t)^3}{3}\;.
\]</span> Therefore <span class="math inline">\(E^R_t\left[A_g(T)\right]\)</span> is the expectation of the exponential of a normally distributed random variable. Equation~<a href="#eq-geometricaveragev1" class="quarto-xref">Equation&nbsp;<span>9.42</span></a> now follows from the fact that if <span class="math inline">\(x\)</span> is normally distributed with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span> then <span class="math inline">\(E\left[\mathrm{e}^x\right] = \mathrm{e}^{\mu+\sigma^2/2}\)</span>.</p>
<p>To establish <a href="#eq-geometricaveragev2" class="quarto-xref">Equation&nbsp;<span>9.45</span></a>, note that the discounted risk-neutral expectation of <a href="#eq-geometricaveragev0" class="quarto-xref">Equation&nbsp;<span>9.44</span></a>, conditional on having observed <span class="math inline">\(S(t_1), \ldots, S(t_{N-k-1})\)</span>, is</p>
<p><span class="math display">\[
V(t) = \mathrm{e}^{-r(T-t)}E^R_t \left[\exp\left(\frac{1}{N} \sum_{i=1}^N \log S(t_i)\right)\right]
\]</span> <span class="math display">\[
= \mathrm{e}^{-r(T-t)}\exp\left(\frac{1}{N}\sum_{i=1}^{N-k-1} \log S(t_i)\right)\times E^R_t \left[\exp\left(\frac{1}{N} \sum_{i=N-k}^N \log S(t_i)\right)\right]
\]</span> <span id="eq-geometricaveragev3"><span class="math display">\[
=\left(\prod_{i=1}^{N-k-1}S(t_i)^{\frac{1}{N}}\right)\times \mathrm{e}^{-r(T-t)}E^R_t \left[\exp\left(\frac{1}{N} \sum_{i=N-k}^N \log S(t_i)\right)\right]\;.
\tag{9.49}\]</span></span></p>
<p>Let <span class="math inline">\(\Delta_0B = B(t_{N-k})-B(t)\)</span> and <span class="math inline">\(\Delta_iB = B(t_{N\!-k+i})-B(t_{N\!-k+i-1})\)</span> for <span class="math inline">\(i \geq 1\)</span>. We can write the sum of logarithms inside the expectation above as <span class="math display">\[\begin{multline*}
\sum_{i=0}^{k}\big\{[\log S(t) + (t_{N-k+i}-t)\nu + \sigma [B(t_{N-k+i})-B(t)]\big\}\\
=(k+1)\log S(t) + \sum_{i=0}^{k} (\varepsilon + i)\nu\Delta t + \sigma\sum_{i=0}^{k} [\Delta_0B + \Delta_1B + \cdots + \Delta_iB] \\
=(k+1)\log S(t) + (k+1)\varepsilon\nu\Delta t + \frac{k(k+1)}{2}\nu\Delta t + \sigma\sum_{i=0}^{k} (k+1-i)\Delta_iB\;,
\end{multline*}\]</span> where to obtain the last equality we used the fact that <span class="math inline">\(\sum_{i=0}^k i = k(k+1)/2\)</span>. The random variables <span class="math inline">\(\Delta_iB\)</span> are normally distributed with mean zero and variance <span class="math inline">\(\Delta t\)</span> (the variance is <span class="math inline">\(\varepsilon \Delta t\)</span> for <span class="math inline">\(i=0\)</span>). Thus, the sum of logarithms is a normally distributed random variable with mean <span class="math display">\[
(k+1)\log S(t) + (k+1)\varepsilon\nu\Delta t + \frac{k(k+1)}{2}\nu\Delta t
\]</span> and variance <span class="math display">\[
(k+1)^2\sigma^2\varepsilon\Delta t + \sigma^2\sum_{i=1}^{k} (k+1-i)^2\Delta t = (k+1)^2\sigma^2\varepsilon\Delta t +\frac{k(k+1)(2k+1)\sigma^2}{6}\; ,
\]</span> using the fact that <span class="math inline">\(\sum_{i=1}^k i^2 = k(k+1)(2k+1)/6\)</span>. The expectation of the exponential of a normally distributed random variable equals the exponential of its mean plus one-half of its variance, and the exponential of <span class="math inline">\((k+1)\log S(t)/N\)</span> is <span class="math inline">\(S(t)^{(k+1)/N}\)</span>. Therefore the conditional expectation in <a href="#eq-geometricaveragev3" class="quarto-xref">Equation&nbsp;<span>9.49</span></a> is <span class="math display">\[S(t)^{\frac{k+1}{N}}\exp\left(\left[ \frac{(k+1)\varepsilon\nu}{N}+ \frac{k(k+1)\nu}{2N} + \frac{(k+1)^2\sigma^2\varepsilon}{2N^2}+\frac{k(k+1)(2k+1)\sigma^2}{12N^2} \right]\Delta t\right)\; ,
\]</span> which implies <a href="#eq-geometricaveragev2" class="quarto-xref">Equation&nbsp;<span>9.45</span></a>.</p>
</div>
</div>
<p>The following code computes the price of a geometric-average-price call.</p>
<div id="geometric_average_price_calls" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> discrete_geom_average_price_call(S, K, r, sigma, q, T, N):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    nu <span class="op">=</span> r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> N <span class="op">*</span> (N <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">6</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> np.exp(((N <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> nu <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> sigma <span class="op">**</span> <span class="dv">2</span> <span class="op">*</span> a <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">**</span> <span class="dv">2</span>)) <span class="op">*</span> dt)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    sigavg <span class="op">=</span> sigma <span class="op">*</span> np.sqrt(a) <span class="op">/</span> (N <span class="op">**</span> <span class="fl">1.5</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> black_scholes_call(V, K, r, sigavg, q, T)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Discrete Geometric Average Price Call:"</span>, discrete_geom_average_price_call(S, K, r, sigma, q, T, N))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Discrete Geometric Average Price Call: 4.375035678935298</code></pre>
</div>
</div>
</section>
<section id="monte-carlo-models-for-path-dependent-options" class="level2" data-number="9.10">
<h2 data-number="9.10" class="anchored" data-anchor-id="monte-carlo-models-for-path-dependent-options"><span class="header-section-number">9.10</span> Monte Carlo Models for Path-Dependent Options</h2>
<p>A derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length <span class="math inline">\(\Delta t = T/N\)</span> for some integer <span class="math inline">\(N\)</span>. Under the risk-neutral measure, the logarithm of the stock price changes over such a time period by <span id="eq-pathdependent"><span class="math display">\[
\Delta \log S = \nu\,\Delta t + \sigma\sqrt{\Delta t}\,z\;,
\tag{9.50}\]</span></span></p>
<p>where <span class="math inline">\(\nu = r-q-\sigma^2/2\)</span> and <span class="math inline">\(z\)</span> is a standard normal. Given that there are <span class="math inline">\(N\)</span> time periods of length <span class="math inline">\(\Delta t\)</span>, we need to generate <span class="math inline">\(N\)</span> standard normals to generate a stock price path. If we generate <span class="math inline">\(M\)</span> paths to obtain a sample of <span class="math inline">\(M\)</span> option values, then we will need to generate <span class="math inline">\(MN\)</span> standard normals.</p>
<p>Consider for example a floating-strike lookback call. The formula for this option given in <a href="#sec-s_lookbacks" class="quarto-xref"><span>Section 9.7</span></a> assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing <span class="math inline">\(\Delta t\)</span> to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting <span class="math inline">\(N\)</span> to be the number of weeks before the option matures.</p>
<p>For most path dependent options, a possible starting point is to generate an array of <span class="math inline">\(n\)</span> paths but since we want the entire path we choose the number of time steps that is appropriate for our application. We can use the same code as in Section @#sec-s_mc_europeans if we are working in a Black Scholes setting.</p>
<div id="14e644fe" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Geometric Brownian Motion</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">#number of divisions</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Interest rate (We set the drift equal to the interest rate for the risk neutral measure)</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividend yield</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>q<span class="op">=</span><span class="fl">0.0</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Stock Price</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturity</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Strike Price</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>K<span class="op">=</span><span class="dv">40</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta t</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T<span class="op">/</span>m</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Drift</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>drift <span class="op">=</span> (r<span class="op">-</span>q<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>sig<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> sig <span class="op">*</span> np.sqrt(dt)</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>,m <span class="op">+</span> <span class="dv">1</span>,<span class="dv">1</span>)) <span class="op">*</span> dt</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co"># seed for random generator</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>seed<span class="op">=</span> <span class="dv">2024</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co"># define a random generator</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>inc[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> vol,size <span class="op">=</span> (n,m)))</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> S0 <span class="op">*</span> np.exp(np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As before this code generates two samples the original and the antithetic. The output is an array of <span class="math inline">\(n\)</span> sample paths with <span class="math inline">\(m\)</span> time steps. The sample can also be used to find the value of a floating strike lookback call.</p>
<div id="c9b77558" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>Stmin<span class="op">=</span>St[m:]<span class="op">-</span>np.minimum(np.<span class="bu">min</span>(St,axis<span class="op">=</span><span class="dv">0</span>),S0)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>St1min<span class="op">=</span>St1[m:]<span class="op">-</span>np.minimum(np.<span class="bu">min</span>(St1,axis<span class="op">=</span><span class="dv">0</span>),S0)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>floatlkbk<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(Stmin)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>floatlkbk1<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(St1min)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first estimate is='</span>,floatlkbk)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second estimate is='</span>,floatlkbk1)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average estimate is='</span>,(floatlkbk<span class="op">+</span>floatlkbk1)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The exact formula is='</span>,floating_strike_call(S0, r, sigma, <span class="dv">0</span>, T, S0))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 5.45244209168367
The second estimate is= 5.468030697490039
The average estimate is= 5.460236394586854
The exact formula is= 5.5418069098303775</code></pre>
</div>
</div>
<p>To value the fixed strike lookback call option with time <span class="math inline">\(T\)</span> payoff <span class="math inline">\(\max(\max_{0\le t \le T} S_t.0)\)</span>, we simply add the following</p>
<div id="847f39a1" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>Stmax<span class="op">=</span>np.maximum(np.<span class="bu">max</span>(St,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>St1max<span class="op">=</span>np.maximum(np.<span class="bu">max</span>(St1,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>lookbck <span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T) <span class="op">*</span>np.mean(Stmax)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>lookbck1<span class="op">=</span>np.exp(<span class="op">-</span>r <span class="op">*</span> T)<span class="op">*</span>np.mean(St1max)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first estimate is='</span>,lookbck)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second estimate is='</span>,lookbck1)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average estimate is='</span>, (lookbck <span class="op">+</span> lookbck1)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 7.716467940991822
The second estimate is= 7.769558237964809
The average estimate is= 7.743013089478316</code></pre>
</div>
</div>
<p>Asian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks.</p>
<p>As another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let <span class="math inline">\(\tau\)</span> denote the amount of time that has elapsed since the call was issued and <span class="math inline">\(T\)</span> the amount of time remaining before maturity, so the total maturity of the call is <span class="math inline">\(T+\tau\)</span>. To simplify somewhat, assume date 0 is the beginning of a period between observations. Let <span class="math inline">\(t_1, \ldots, t_N\)</span> denote the remaining sampling dates, with <span class="math inline">\(t_1 = \Delta t\)</span>, <span class="math inline">\(t_i-t_{i-1}=\Delta t = T/N\)</span> for each <span class="math inline">\(i\)</span>, and <span class="math inline">\(t_N=T\)</span>. We will input the average price <span class="math inline">\(A(0)\)</span> computed up to date 0, assuming this average includes the price <span class="math inline">\(S(0)\)</span> at date 0. The average price at date <span class="math inline">\(T\)</span> will be <span class="math display">\[
A(T) = \frac{\tau}{T+\tau}A(0) + \frac{T}{T+\tau}\left(\frac{\sum_{i=1}^N S(t_i)}{N}\right)\;.
\]</span> The average-price call pays <span class="math inline">\(\max(0,A(T)-K)\)</span> at its maturity <span class="math inline">\(T\)</span>, and we can write this as <span class="math display">\[\begin{align*}
\max(A(T)-K,0) &amp;= \max\left(\frac{T}{T+\tau}\left( \frac{\sum_{i=1}^N S(t_i)}{N}\right) - \left(K - \frac{\tau}{T+\tau}A(0)\right), 0\right)\\
&amp;= \frac{T}{T+\tau} \max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\;,
\end{align*}\]</span> where <span class="math display">\[
K^* = \frac{T+\tau}{T}K - \frac{\tau}{T}A(0)\;.
\]</span> Therefore, the value at date 0 of the discretely-sampled average-price call is <span class="math display">\[
\frac{T}{T+\tau} \,\mathrm{e}^{-rT} E^R\left[\max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\right]\;.
\]</span> In terms of the discussion above, the random variable the mean of which we want to estimate is <span class="math display">\[
x = \mathrm{e}^{-rT}\max \left(\frac{\sum_{i=1}^N S(t_i)}{N} - K^*,0\right)\;.
\]</span> A random variable <span class="math inline">\(y\)</span> that will be closely correlated to <span class="math inline">\(x\)</span> is <span class="math display">\[
y =\mathrm{e}^{-rT}\max \left(\mathrm{e}^{\sum_{i=1}^N \log S(t_i)/N} - K^*,0\right)\;.
\]</span> The mean <span class="math inline">\(\phi\)</span> of <span class="math inline">\(y\)</span> under the risk-neutral measure is given in the pricing <a href="#eq-disc_geom_avg_call" class="quarto-xref">Equation&nbsp;<span>9.48</span></a>. We can use the sample mean of <span class="math inline">\(y\)</span> and its known mean <span class="math inline">\(\phi\)</span> to adjust the sample mean of <span class="math inline">\(x\)</span> as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient <span class="math inline">\(\hat{\beta}\)</span> will be quite close to 1.</p>
<p>Again we can get a sample of payoffs using our stock price samples.</p>
<div id="01f1002f" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>average <span class="op">=</span> np.mean(St,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>average1 <span class="op">=</span> np.mean(St1,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>dpayoff<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(np.maximum(average<span class="op">-</span>K,<span class="dv">0</span>))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>dpayoff1<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(np.maximum(average1<span class="op">-</span>K,<span class="dv">0</span>))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first estimate is='</span>,dpayoff)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second estimate is='</span>,dpayoff1)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average of the estimates='</span>,(dpayoff<span class="op">+</span>dpayoff1)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 3.231154315344899
The second estimate is= 3.296876297130776
The average of the estimates= 3.2640153062378374</code></pre>
</div>
</div>
<p>We now construct a control variate, the geometric asian option which has a known formula for its value.</p>
<div id="90069645" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>geom<span class="op">=</span>np.exp((np.mean(np.log(St),axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>geom1<span class="op">=</span>np.exp((np.mean(np.log(St1),axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>geomavgpo<span class="op">=</span>np.maximum(geom<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>geomavg1po<span class="op">=</span>np.maximum(geom1<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>value<span class="op">=</span>np.mean(geomavgpo)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>value1<span class="op">=</span>np.mean(geomavg1po)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>tga<span class="op">=</span>discrete_geom_average_price_call(S0, K, r, sigma, q, T, m)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span>tga<span class="op">-</span>value</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>error1<span class="op">=</span>tga<span class="op">-</span>value1</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The estimate from the first sample='</span>,value)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The estimate from the second sample='</span>,value1)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average of the two estimates is='</span>,(value<span class="op">+</span>value1)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The value from the exact formula='</span>,tga)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The error in the first estimate='</span>,error)</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The error in the second estimate='</span>,error1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The estimate from the first sample= 3.172076049997697
The estimate from the second sample= 3.236566795172543
The average of the two estimates is= 3.20432142258512
The value from the exact formula= 3.1804170589762464
The error in the first estimate= 0.00834100897854917
The error in the second estimate= -0.05614973619629682</code></pre>
</div>
</div>
<p>Next we estimate the beta. As discussed before, we could simply set beta=1. Alternatively, if we estimate beta from the simulated sample, then our update could be biased. Instead we compute an independent sample from which we estimate beta. We then estimate the updated estimate for both samples from the formula <span class="math display">\[
\text{new estimate} = \text{original estimate} + \beta * \text{error}
\]</span></p>
<div id="e41ae2eb" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>incpre <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>incpre[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> vol,size <span class="op">=</span> (n,m)))</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>Stpre <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>St1pre<span class="op">=</span>np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>Stpre <span class="op">=</span> S0 <span class="op">*</span> np.exp(np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>St1pre <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>amean<span class="op">=</span>np.mean(Stpre,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>amean1<span class="op">=</span>np.mean(St1pre,axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>apo <span class="op">=</span> np.maximum(amean<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>a1po<span class="op">=</span>np.maximum(amean1<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>gmean<span class="op">=</span>np.exp(np.mean(np.log(St),axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>g1mean<span class="op">=</span>np.exp(np.mean(np.log(St1),axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>gpo<span class="op">=</span>np.maximum(gmean<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>g1po<span class="op">=</span>np.maximum(g1mean<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>beta<span class="op">=</span>np.cov(gpo,apo)[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">/</span>np.cov(gpo,apo)[<span class="dv">1</span>,<span class="dv">1</span>]</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>beta1<span class="op">=</span>np.cov(g1po,a1po)[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">/</span>np.cov(g1po,a1po)[<span class="dv">1</span>,<span class="dv">1</span>]</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>update<span class="op">=</span>dpayoff <span class="op">+</span>beta<span class="op">*</span>error</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>update1<span class="op">=</span>dpayoff1<span class="op">+</span>beta1<span class="op">*</span>error1</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The updated estimate for the first sample='</span>,update)</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The updated value for the second sample='</span>,update1)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average of the updated values is='</span>,(update <span class="op">+</span>update1)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The updated estimate for the first sample= 3.239338189254849
The updated value for the second sample= 3.24174435394373
The average of the updated values is= 3.2405412715992896</code></pre>
</div>
</div>
</section>
<section id="sec-montecarlomultiple" class="level2" data-number="9.11">
<h2 data-number="9.11" class="anchored" data-anchor-id="sec-montecarlomultiple"><span class="header-section-number">9.11</span> Monte Carlo Valuation of Basket and Spread Options</h2>
<p> In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. As noted in <a href="#sec-s_baskets" class="quarto-xref"><span>Section 9.8</span></a>, there are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.</p>
<p>The difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral measure). In an <span class="math inline">\(N\)</span>–period model, the binomial model produces <span class="math inline">\(N+1\)</span> values for the terminal price of each underlying asset. Letting <span class="math inline">\(k\)</span> denote the number of underlying assets, this produces <span class="math inline">\((N+1)^k\)</span> combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces <span class="math inline">\(M\)</span> combinations of terminal prices, where <span class="math inline">\(M\)</span> is the number of simulations. Each combination is given the same weight (<span class="math inline">\(1/M\)</span>) when estimating the expected value.</p>
<p>With a single underlying asset, the binomial model is more efficient, as discussed in <a href="Chapter6.html#sec-s_introbinomial" class="quarto-xref"><span>Section 6.5</span></a>, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the <span class="math inline">\((N+1)^k\)</span> combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.</p>
<p>To implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. As observed in <a href="Chapter5.html#sec-s_stochasticvolatility" class="quarto-xref"><span>Section 5.5</span></a>, we can simulate the changes in two Brownian motions <span class="math inline">\(B_1\)</span> and <span class="math inline">\(B_2\)</span> that have correlation <span class="math inline">\(\rho\)</span> by generating two independent standard normals <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> and defining <span class="math display">\[
\Delta B_1 = \sqrt{\Delta t}\,Z_1\;, \qquad \text{and} \qquad \Delta B_2 = \sqrt{\Delta t}\,Z\; ,
\]</span> where <span class="math inline">\(Z\)</span> is defined as <span class="math display">\[
Z = \rho Z_1 + \sqrt{1-\rho^2}\,Z_2\;.
\]</span> The random variable <span class="math inline">\(Z\)</span> is also a standard normal, and the correlation between <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z\)</span> is <span class="math inline">\(\rho\)</span>.</p>
<div id="418d8b85" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate 2 Geometric Brownian Motions</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">#number of divisions</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Interest rate (We set the drift equal to the interest rate for the risk neutral measure)</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividend yield</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>q1<span class="op">=</span><span class="fl">0.0</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>q2<span class="op">=</span><span class="dv">0</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>sig1 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>sig2<span class="op">=</span><span class="fl">.3</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>rho<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Stock Price</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>V0 <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturity</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta t</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T<span class="op">/</span>m</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Drift</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>drift1 <span class="op">=</span> (r<span class="op">-</span>q1<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>sig1<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>drift2 <span class="op">=</span> (r<span class="op">-</span>q2<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>sig2<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> np.sqrt(dt)</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>,m <span class="op">+</span> <span class="dv">1</span>,<span class="dv">1</span>)) <span class="op">*</span> dt</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="co"># seed for random generator</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>seed<span class="op">=</span> <span class="dv">2024</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="co"># define a random generator</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>inc[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> vol,size <span class="op">=</span> (n,m)))</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>inc1 <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>inc1[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> vol,size <span class="op">=</span> (n,m)))</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> rho<span class="op">*</span>inc <span class="op">+</span> np.sqrt(<span class="dv">1</span><span class="op">-</span>rho<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>inc1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Thus, we can simulate the changes in the logarithms of two correlated asset prices as <span class="math display">\[\begin{align*}
\Delta \log S_1 &amp;= \nu_1\Delta t + \sigma_1\sqrt{\Delta t}Z_1 \; ,\\
\Delta \log S_2 &amp;= \nu_2\Delta t + \sigma_2\rho\sqrt{\Delta t}Z_1 + \sigma_2\sqrt{1-\rho^2}\sqrt{\Delta t}Z_2\;,
\end{align*}\]</span> where <span class="math inline">\(\nu_i = r-q_1-\sigma_i^2/2\)</span> and the <span class="math inline">\(Z_i\)</span> are independent standard normals.</p>
<div id="48e20315" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>St2 <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(sig1<span class="op">*</span>np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift1 <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>St2 <span class="op">=</span> V0 <span class="op">*</span> np.exp(sig2<span class="op">*</span>np.cumsum(incr,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift2 <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can also construct antithetic variables.</p>
<div id="60b8757f" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>St1a <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>St2a <span class="op">=</span> np.zeros(shape <span class="op">=</span> (m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>St1a <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>sig1<span class="op">*</span>np.cumsum(inc,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift1 <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>St2a <span class="op">=</span> V0 <span class="op">*</span> np.exp(<span class="op">-</span>sig2<span class="op">*</span>np.cumsum(incr,axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift2 <span class="op">*</span> t[<span class="dv">0</span>:m <span class="op">+</span> <span class="dv">1</span>])[:,<span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Given this sample, we can estimate the value of a best of 2 option with payoff <span class="math inline">\(\max(S_{1T},S_{2T})\)</span>.</p>
<div id="6534faaf" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>payoff <span class="op">=</span> np.maximum(St1[m,:],St2[m,:])</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>payoffa <span class="op">=</span> np.maximum(St1a[m,:],St2a[m,:])</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>value<span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(payoff)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>valuea<span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(payoffa)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first estmate is ='</span>,value)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second estimate is ='</span>,valuea)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The avergae of the estimates is='</span>,(value<span class="op">+</span>valuea)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estmate is = 50.11374784508302
The second estimate is = 51.46596027225067
The avergae of the estimates is= 50.78985405866685</code></pre>
</div>
</div>
<p>To generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as</p>
<p><span id="eq-mc_twoa"><span class="math display">\[
\Delta \log S_1 = \nu_1\Delta t + a_{11}\sqrt{\Delta t}Z_1 + a_{12}\sqrt{\Delta t}Z_2\;,
\tag{9.51}\]</span></span></p>
<p><span id="eq-mc_twob"><span class="math display">\[
\Delta \log S_2 = \nu_2\Delta t + a_{21}\sqrt{\Delta t}Z_1 + a_{22}\sqrt{\Delta t}Z_2\;,
\tag{9.52}\]</span></span></p>
<p>where <span class="math display">\[\begin{array}{rclcrcl}
a_{11}&amp;=&amp;\sigma_1\;, &amp;\qquad &amp; a_{12}&amp;=&amp;0\; ,\\
a_{21}&amp;=&amp;\sigma_2\rho\;, &amp;\qquad &amp; a_{22} &amp;= &amp;\sigma_2\sqrt{1-\rho^2}\;.
\end{array}
\]</span></p>
<p>These are not the only possible choices for the constants <span class="math inline">\(a_{ij}\)</span>. Given that <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> are independent standard normals, the conditions the <span class="math inline">\(a_{ij}\)</span> must satisfy in order to match the variances <span class="math inline">\(\sigma_i^2\Delta t\)</span> and correlation <span class="math inline">\(\rho\)</span> of the changes in the logarithms are</p>
<p><span id="eq-a1"><span class="math display">\[
a_{11}^2+a_{12}^2 =\sigma_1^2\;,
\tag{9.53}\]</span></span></p>
<p><span id="eq-a2"><span class="math display">\[
a_{21}^2+a_{22}^2 =\sigma_2^2\;,
\tag{9.54}\]</span></span></p>
<p><span id="eq-a3"><span class="math display">\[
a_{11}a_{21}+a_{12}a_{22} = \sigma_1\sigma_2\rho\;.
\tag{9.55}\]</span></span></p>
<p>These three equations in the four coefficients <span class="math inline">\(a_{ij}\)</span> leave one degree of freedom. We choose to take <span class="math inline">\(a_{12}=0\)</span> and then solve for the other three.</p>
<p>In matrix notation, the system <a href="#eq-a1" class="quarto-xref">Equation&nbsp;<span>9.53</span></a> - <a href="#eq-a3" class="quarto-xref">Equation&nbsp;<span>9.55</span></a> plus the condition <span class="math inline">\(a_{12}=0\)</span> can be written as the equation <span class="math display">\[
\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}^\top = \begin{pmatrix}\sigma_1^2 &amp; \rho\sigma_1\sigma_2 \\\rho\sigma_1\sigma_2 &amp; \sigma_2^2\end{pmatrix}\; ,
\]</span> where <span class="math inline">\(^\top\)</span> denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the <span class="math inline">\(a_{ij}\)</span> so that the lower triangular matrix <span class="math display">\[
A \equiv \begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}
\]</span> satisfies <span class="math display">\[
AA^\top = \text{covariance matrix}
\]</span> is called the the Cholesky decomposition of the covariance matrix. Given any number <span class="math inline">\(L\)</span> of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the <span class="math inline">\(L\times L\)</span> covariance matrix always exists. An algorithm for computing the Cholesky decomposition in numpy is np.linalg.cholesky.</p>
<p>We can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> If there were some path dependency in the option value, we would simulate the paths of the asset prices as in <a href="#eq-mc_twoa" class="quarto-xref">Equation&nbsp;<span>9.51</span></a> - <a href="#eq-mc_twob" class="quarto-xref">Equation&nbsp;<span>9.52</span></a>. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date <span class="math inline">\(T\)</span>, as in <a href="Chapter6.html#sec-s_mc_europeans" class="quarto-xref"><span>Section 6.1</span></a>. The value of a basket call option at its maturity <span class="math inline">\(T\)</span> is <span class="math display">\[
\max\left(0,\;\sum_{i=1}^L w_iS_i(T)-K\right)\; ,
\]</span> where <span class="math inline">\(L\)</span> is the number of assets in the basket (portfolio) and <span class="math inline">\(w_i\)</span> is the weight of the <span class="math inline">\(i\)</span>–th asset in the basket. The logarithm of the <span class="math inline">\(i\)</span>–th asset price at maturity is simulated as <span class="math display">\[
\log S_i(T) = \log S_i(0) +\nu_iT + \sqrt{T} \sum_{j=1}^L a_{ij}Z_j\; ,
\]</span> where the <span class="math inline">\(Z_j\)</span> are independent standard normals. Given the simulated values of the <span class="math inline">\(\log S_i(T)\)</span>, the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.</p>
<p>For our two asset example we compute the value of a call opttion on an equally weighted porfotlio.</p>
<div id="15880e30" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>w<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>K<span class="op">=</span><span class="dv">45</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>basketpo<span class="op">=</span>np.maximum(w<span class="op">*</span>St1[m,:]<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>w)<span class="op">*</span>St2[m,:]<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>basketpoa<span class="op">=</span>np.maximum(w<span class="op">*</span>St1a[m,:]<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>w)<span class="op">*</span>St2a[m,:]<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>estimate<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(basketpo)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>estimatea<span class="op">=</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(basketpoa)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first estimate is ='</span>,estimate)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second estimate is ='</span>,estimatea)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average of the estimates='</span>,(estimate<span class="op">+</span>estimatea)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is = 4.4030641748675095
The second estimate is = 4.945665333101932
The average of the estimates= 4.674364753984721</code></pre>
</div>
</div>
<p>Below is a three asset basket option whihc uses the numpy cholesky decomposition. In contrast to the above routine, this routine is does not have the option to generate the entire path, although this can be easily modeified.</p>
<div id="e71c941b" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">#risk free rate</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>r<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># number of assets</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>k<span class="op">=</span><span class="dv">3</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100000</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Horizon</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>T<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial price</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>S0<span class="op">=</span>[<span class="dv">42</span>,<span class="dv">50</span>,<span class="dv">45</span>]</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Basket Weights</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>w<span class="op">=</span>[<span class="fl">.25</span>,<span class="fl">.5</span>,<span class="fl">.25</span>]</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="co">#Strike Price</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>K<span class="op">=</span><span class="dv">45</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="co">#  put in volatilities</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>sig1<span class="op">=</span><span class="fl">.2</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>sig2<span class="op">=</span><span class="fl">.3</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>sig3<span class="op">=</span><span class="fl">.4</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a><span class="co">#create diagonal</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>sig<span class="op">=</span>[sig1,sig2,sig3]</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>S<span class="op">=</span>np.diag(sig)</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a><span class="co"># drift of log returns</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>drift<span class="op">=</span> r<span class="op">*</span>np.ones(k) <span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>np.dot(S<span class="op">@</span>S,np.ones(k))</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation matrix</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>rho<span class="op">=</span>np.array([[<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>],</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>                  [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>],</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>                  [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">1.0</span>]])</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a><span class="co"># covariance matrix</span></span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> S<span class="op">@</span>rho<span class="op">@</span>S</span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a><span class="co"># generate uniform n*k normal uncorrelated random variables</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>seed<span class="op">=</span><span class="dv">2024</span></span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>inc1<span class="op">=</span>np.transpose(np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> np.sqrt(T),size <span class="op">=</span> (n,k)))</span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a><span class="co"># create correlated random variables</span></span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>Z<span class="op">=</span>np.linalg.cholesky(V)</span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a>incr<span class="op">=</span>np.dot(Z,inc1)</span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The sample correlation matrix ='</span>,np.corrcoef(incr))</span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The input correlation matrix ='</span>,rho)</span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-65"><a href="#cb39-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-66"><a href="#cb39-66" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> S0 <span class="op">*</span> np.exp(drift <span class="op">*</span>T <span class="op">+</span> np.transpose(incr))</span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a><span class="co">#antithetic sample</span></span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp( drift <span class="op">*</span> T <span class="op">-</span> np.transpose(incr))</span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a>estimate<span class="op">=</span>np.mean(St,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a>estimate1<span class="op">=</span>np.mean(St1,axis<span class="op">=</span><span class="dv">0</span>)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average discounted stock price averaged over both samples='</span>,(estimate<span class="op">+</span>estimate1)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The initial Srock Price input ='</span>,S0)</span>
<span id="cb39-74"><a href="#cb39-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-75"><a href="#cb39-75" aria-hidden="true" tabindex="-1"></a>basketpo<span class="op">=</span>np.maximum(w<span class="op">@</span>np.transpose(St)<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb39-76"><a href="#cb39-76" aria-hidden="true" tabindex="-1"></a>basketpo1<span class="op">=</span>np.maximum(w<span class="op">@</span>np.transpose(St1)<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb39-77"><a href="#cb39-77" aria-hidden="true" tabindex="-1"></a>value<span class="op">=</span>np.mean(basketpo)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb39-78"><a href="#cb39-78" aria-hidden="true" tabindex="-1"></a>value1<span class="op">=</span>np.mean(basketpo1)<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)</span>
<span id="cb39-79"><a href="#cb39-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The first sample estimate of the basket option value='</span>,value)</span>
<span id="cb39-80"><a href="#cb39-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The second sample estimate of the basket option value='</span>,value1)</span>
<span id="cb39-81"><a href="#cb39-81" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average estimate of the basket option value='</span>,(value<span class="op">+</span>value1)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The sample correlation matrix = [[1.         0.50356746 0.30497838]
 [0.50356746 1.         0.20383175]
 [0.30497838 0.20383175 1.        ]]
The input correlation matrix = [[1.  0.5 0.3]
 [0.5 1.  0.2]
 [0.3 0.2 1. ]]
The average discounted stock price averaged over both samples= [42.00560021 50.00484037 45.01680115]
The initial Srock Price input = [42, 50, 45]
The first sample estimate of the basket option value= 5.335894164783821
The second sample estimate of the basket option value= 5.289353051200051
The average estimate of the basket option value= 5.312623607991936</code></pre>
</div>
</div>
<p>We can generate the entire path of multiple assets to value, for example, lookback options on a basket. The code below values the same European basket option as above only it calculates <span class="math inline">\(m=2\)</span> time steps; a lookback can be created by changing the payoffs and increasing <span class="math inline">\(m\)</span>.</p>
<div id="1bd413ce" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">#number of time steps</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>m<span class="op">=</span><span class="dv">2</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># number of assets</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>k<span class="op">=</span><span class="dv">3</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"># number of sample paths</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span><span class="dv">100000</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co">#risk free rate</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>r<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Horizon</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>T<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a><span class="co"># delta t</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>dt<span class="op">=</span>T<span class="op">/</span>m</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial price</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>S0<span class="op">=</span>[<span class="dv">42</span>,<span class="dv">50</span>,<span class="dv">45</span>]</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a><span class="co">#Strike Price</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>K<span class="op">=</span><span class="dv">45</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a><span class="co">#  put in volatilities</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>sig1<span class="op">=</span><span class="fl">.2</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>sig2<span class="op">=</span><span class="fl">.3</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>sig3<span class="op">=</span><span class="fl">.4</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a><span class="co">#create diagonal</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>sig<span class="op">=</span>[sig1,sig2,sig3]</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>S<span class="op">=</span>np.diag(sig)</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation matrix</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>rho<span class="op">=</span>np.array([[<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>],</span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>                  [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>],</span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>                  [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">1.0</span>]])</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a><span class="co"># covariance matrix</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> S<span class="op">@</span>rho<span class="op">@</span>S</span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a><span class="co"># drift of log returns</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>drift<span class="op">=</span> np.array(r<span class="op">*</span>np.ones(k) <span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>np.dot(S<span class="op">@</span>S,np.ones(k)))<span class="op">*</span>dt</span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a><span class="co"># times vector</span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>t<span class="op">=</span>np.array(<span class="bu">range</span>(<span class="dv">1</span>,m <span class="op">+</span> <span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a>driftv <span class="op">=</span> np.transpose(np.kron(drift,t).reshape(<span class="dv">3</span>,m))</span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a><span class="co"># generate uniform n(paths)*k(assets)*m(time steps) normal uncorrelated random variables</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a>seed<span class="op">=</span><span class="dv">2024</span></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>inc<span class="op">=</span>np.random.normal(loc <span class="op">=</span> <span class="dv">0</span>, scale <span class="op">=</span> np.sqrt(dt),size <span class="op">=</span> (n,k,m))</span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a><span class="co">#create correlated random increments</span></span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a>Z<span class="op">=</span>np.linalg.cholesky(V)</span>
<span id="cb41-65"><a href="#cb41-65" aria-hidden="true" tabindex="-1"></a><span class="co"># numpy matmul assumes last two define matrix multiplication</span></span>
<span id="cb41-66"><a href="#cb41-66" aria-hidden="true" tabindex="-1"></a>incr<span class="op">=</span>np.matmul(Z,inc)</span>
<span id="cb41-67"><a href="#cb41-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-68"><a href="#cb41-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-69"><a href="#cb41-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-70"><a href="#cb41-70" aria-hidden="true" tabindex="-1"></a>SSt<span class="op">=</span>S0<span class="op">*</span>np.exp(driftv)</span>
<span id="cb41-71"><a href="#cb41-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-72"><a href="#cb41-72" aria-hidden="true" tabindex="-1"></a><span class="co"># generate returns along path and antithetic path</span></span>
<span id="cb41-73"><a href="#cb41-73" aria-hidden="true" tabindex="-1"></a><span class="co"># first e^{cumsum(increments)} gives e^sigma B_t for different t</span></span>
<span id="cb41-74"><a href="#cb41-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-75"><a href="#cb41-75" aria-hidden="true" tabindex="-1"></a>Stb <span class="op">=</span> np.exp(np.cumsum(incr[:,:,],axis<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb41-76"><a href="#cb41-76" aria-hidden="true" tabindex="-1"></a>Stb1 <span class="op">=</span> np.exp(<span class="op">-</span>np.cumsum(incr[:,:,],axis<span class="op">=</span><span class="dv">2</span>))</span>
<span id="cb41-77"><a href="#cb41-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-78"><a href="#cb41-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-79"><a href="#cb41-79" aria-hidden="true" tabindex="-1"></a><span class="co">#Multiply by S0 e^drift for each t</span></span>
<span id="cb41-80"><a href="#cb41-80" aria-hidden="true" tabindex="-1"></a>St<span class="op">=</span>np.multiply(Stb,np.transpose(SSt))</span>
<span id="cb41-81"><a href="#cb41-81" aria-hidden="true" tabindex="-1"></a>St1<span class="op">=</span>np.multiply(Stb1,np.transpose(SSt))</span>
<span id="cb41-82"><a href="#cb41-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-83"><a href="#cb41-83" aria-hidden="true" tabindex="-1"></a><span class="co">#Last date returns</span></span>
<span id="cb41-84"><a href="#cb41-84" aria-hidden="true" tabindex="-1"></a>Stm<span class="op">=</span>St[:,:,m<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb41-85"><a href="#cb41-85" aria-hidden="true" tabindex="-1"></a>Stm1<span class="op">=</span>St1[:,:,m<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb41-86"><a href="#cb41-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-87"><a href="#cb41-87" aria-hidden="true" tabindex="-1"></a><span class="co">#define payoff</span></span>
<span id="cb41-88"><a href="#cb41-88" aria-hidden="true" tabindex="-1"></a><span class="co"># Basket Weights</span></span>
<span id="cb41-89"><a href="#cb41-89" aria-hidden="true" tabindex="-1"></a>w<span class="op">=</span>[<span class="fl">.25</span>,<span class="fl">.5</span>,<span class="fl">.25</span>]</span>
<span id="cb41-90"><a href="#cb41-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-91"><a href="#cb41-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-92"><a href="#cb41-92" aria-hidden="true" tabindex="-1"></a>payoff<span class="op">=</span> np.maximum(np.matmul(Stm,np.transpose(w))<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb41-93"><a href="#cb41-93" aria-hidden="true" tabindex="-1"></a>payoff1<span class="op">=</span> np.maximum(np.matmul(Stm1,np.transpose(w))<span class="op">-</span>K,<span class="dv">0</span>)</span>
<span id="cb41-94"><a href="#cb41-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-95"><a href="#cb41-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-96"><a href="#cb41-96" aria-hidden="true" tabindex="-1"></a>value<span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(payoff)</span>
<span id="cb41-97"><a href="#cb41-97" aria-hidden="true" tabindex="-1"></a>value1<span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.mean(payoff1)</span>
<span id="cb41-98"><a href="#cb41-98" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The estimate for the first sample value='</span>,value)</span>
<span id="cb41-99"><a href="#cb41-99" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The estimate for the second sample value='</span>,value1)</span>
<span id="cb41-100"><a href="#cb41-100" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'The average estimate for the value='</span>,(value<span class="op">+</span>value1)<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The estimate for the first sample value= 5.310173600480473
The estimate for the second sample value= 5.287928240443306
The average estimate for the value= 5.299050920461889</code></pre>
</div>
</div>
</section>
<section id="sec-s_curse" class="level2" data-number="9.12">
<h2 data-number="9.12" class="anchored" data-anchor-id="sec-s_curse"><span class="header-section-number">9.12</span> Binomial Valuation of Basket and Spread Options</h2>
<p> By combining binomial models, we can value options or other derivatives on multiple assets. We will illustrate for an option on two assets. This is the most important case, and the extension to more than two assets is straightforward.</p>
<p>Consider two stocks with constant dividend yields <span class="math inline">\(q_i\)</span> and constant volatilities <span class="math inline">\(\sigma_i\)</span>. Suppose the two Brownian motions driving the two stocks have a constant correlation coefficient <span class="math inline">\(\rho\)</span>. We will denote the price of stock <span class="math inline">\(i\)</span> (<span class="math inline">\(i=1,2\)</span>) in the up state in each period by <span class="math inline">\(u_iS_i\)</span> and the price in the down state by <span class="math inline">\(d_iS_i\)</span>, where <span class="math inline">\(S_i\)</span> is the price at the beginning of the period, and <span class="math inline">\(u_i\)</span> and <span class="math inline">\(d_i\)</span> are parameters to be specified. In each period, there are four possible combinations of returns on the two stocks: up for both stocks, up for stock 1 and down for stock~2, down for stock 1 and up for stock 2, and down for both stocks. Denote the probabilities of these four combinations by <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span> respectively. Thus, there are eight parameters in the binomial model: the number <span class="math inline">\(N\)</span> of periods (which defines the length of each period as <span class="math inline">\(\Delta t=T/N\)</span> where <span class="math inline">\(T\)</span> is the option maturity), the up and down parameters <span class="math inline">\(u_i\)</span> and <span class="math inline">\(d_i\)</span> for each stock, and three probabilities (the fourth probability being determined by the condition that the probabilities sum to one).</p>
<p>Given the period length <span class="math inline">\(\Delta t\)</span>, we want to choose the up and down parameters and the probabilities to match (or approximately match in an appropriate sense) the means, variances and covariances of the returns <span class="math inline">\(\Delta S_i/S_i\)</span> or the continuously-compounded returns <span class="math inline">\(\Delta \log S_i\)</span>. There are two means, two variances and one covariance, so there are five restrictions to be satisfied and seven parameters. As in <a href="Chapter6.html" class="quarto-xref"><span>Chapter 6</span></a>, it is convenient to take <span class="math inline">\(d_i = 1/u_i\)</span>, leaving five restrictions and five free parameters.</p>
<p>As discussed in <a href="Chapter6.html#sec-s_binomialparameters" class="quarto-xref"><span>Section 6.6</span></a>, there are multiple ways to define the binomial model so that it converges to the continuous-time model as the number of periods is increased. As an example, we will describe here the suggestion of Trigeorgis <span class="citation" data-cites="Trigeorgis">(<a href="#ref-Trigeorgis" role="doc-biblioref">Trigeorgis 1991</a>)</span>, which matches the means, variances and covariance of the continuously-compounded returns. Letting <span class="math inline">\(p_i\)</span> denote the probability of the up state for stock <span class="math inline">\(i\)</span>, matching the means and variances implies, as in <a href="Chapter6.html#sec-s_binomialparameters" class="quarto-xref"><span>Section 6.6</span></a>, <span class="math display">\[\begin{align*}
\log u_i&amp;=\sqrt{\sigma_i^2\Delta t + \nu_i^2(\Delta t)^2}\; ,\\
p_i &amp;= \frac{1}{2}+\frac{\nu_i\Delta t}{2\log u_i}\;.
\end{align*}\]</span> where <span class="math inline">\(\nu_i=r-q_i-\sigma_i^2/2\)</span>. In terms of the notation <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span>, the probability of the up state for stock 1 is <span class="math inline">\(p_1=p_{uu}+p_{ud}\)</span> and the probability of the up state for stock 2 is <span class="math inline">\(p_2=p_{uu}+p_{du}\)</span>. Therefore,</p>
<p><span id="eq-prob1"><span class="math display">\[
p_{uu}+p_{ud} = \frac{1}{2}+\frac{\nu_1\Delta t}{2\log u_1}\;,
\tag{9.56}\]</span></span></p>
<p><span id="eq-prob2"><span class="math display">\[
p_{uu}+p_{du} = \frac{1}{2}+\frac{\nu_2\Delta t}{2\log u_2}\;.
\tag{9.57}\]</span></span></p>
<p>In the continuous time model, over a discrete time period <span class="math inline">\(\Delta t\)</span>, the covariance of <span class="math inline">\(\Delta \log S_1\)</span> and <span class="math inline">\(\Delta \log S_2\)</span> is <span class="math inline">\(\rho\sigma_1\sigma_2\Delta t\)</span>. In the binomial model, with <span class="math inline">\(d_i=1/u_i\)</span>, we have <span class="math display">\[
E \big[\Delta \log S_1 \times \Delta \log S_2\big] = (p_{uu}-p_{ud}-p_{du}+p_{dd})\log u_1\log u_2\;.
\]</span> Given that <span class="math inline">\(E[\Delta\log S_i] =\nu_i\Delta t\)</span>, this implies a covariance of <span class="math display">\[
(p_{uu}-p_{ud}-p_{du}+p_{dd})\log u_1\log u_2 - \nu_1\nu_2(\Delta t)^2\;.
\]</span> Matching the covariance in the binomial model to the covariance in the continuous-time model therefore implies <span id="eq-prob3"><span class="math display">\[
p_{uu}-p_{ud}-p_{du}+p_{dd} =\frac{\rho\sigma_1\sigma_2\Delta t + \nu_1\nu_2(\Delta t)^2}{\log u_1\log u_2}\;.
\tag{9.58}\]</span></span></p>
<p>We can solve the system <a href="#eq-prob1" class="quarto-xref">Equation&nbsp;<span>9.56</span></a> - <a href="#eq-prob3" class="quarto-xref">Equation&nbsp;<span>9.58</span></a>, together with the condition that the probabilities sum to one, to obtain the probabilities <span class="math inline">\(p_{uu}\)</span>, <span class="math inline">\(p_{ud}\)</span>, <span class="math inline">\(p_{du}\)</span>, and <span class="math inline">\(p_{dd}\)</span>. This solution and a Python function for valuing an American spread call option are given later. This function operates much like the binomial valuation of American options described in <a href="Chapter6.html" class="quarto-xref"><span>Chapter 6</span></a>. The primary difference is that the value of the option at maturity depends on both stock prices, so we have to consider each possible combination of stock prices. In an <span class="math inline">\(N\)</span>–period model, there are <span class="math inline">\(N+1\)</span> nodes at the final date for each of the two stocks, and hence <span class="math inline">\((N+1)^2\)</span> possible combinations of nodes. In fact, at each date <span class="math inline">\(n\)</span> (<span class="math inline">\(n=0,\ldots,N\)</span>) there are <span class="math inline">\((n+1)^2\)</span> combinations of nodes to be considered.<br>
The computation time required for a spread call option is therefore roughly the square of the time required for a standard call.</p>
<p>Likewise, in an <span class="math inline">\(N\)</span>–period model for a basket option written on three assets, there are <span class="math inline">\((n+1)^3\)</span> combinations of nodes to be considered at date <span class="math inline">\(n\)</span>; if there are five assets, there are <span class="math inline">\((n+1)^5\)</span> combinations, etc. Thus, the computation time required increases exponentially with the number of assets. This can be a serious problem. For example, with five assets and <span class="math inline">\(N=99\)</span>, we would have <span class="math inline">\(100^5\)</span> (10 billion) combinations. As this suggests, problems with multiple assets quickly become intractable in a binomial framework. This is called the curse of dimensionality. </p>
</section>
<section id="variance-swaps" class="level2" data-number="9.13">
<h2 data-number="9.13" class="anchored" data-anchor-id="variance-swaps"><span class="header-section-number">9.13</span> Variance Swaps</h2>
<p>Variance swaps are a type of futures contracts that allows investors to trade future realized volatility against current option implied variance. Unlike traditional futures, which provide a payoff based on the difference between the underlying asset’s price and the futures price, variance swaps provide a payoff based on the difference between the realized variance of the underlying asset and the predetermined variance level (termed ``Strike’’ in practice), which is the futures price in variance unit.</p>
<p>Variance swaps have gained popularity due to their ability to provide pure exposure to the volatility of an underlying asset, independent of its price movements. Unlike traditional options, variance swaps allow investors to speculate on or hedge against changes in volatility without the need for constant delta hedging. This makes them an effective tool for managing volatility risk and for executing volatility arbitrage strategies, as they simplify the trading of variance and offer a more straightforward payoff structure based on realized versus implied volatility.</p>
<section id="payoff-of-a-variance-swap" class="level3">
<h3 class="anchored" data-anchor-id="payoff-of-a-variance-swap">Payoff of a Variance Swap</h3>
<p>A variance swap is a future contract on future realized variance. Its main components include:</p>
<ul>
<li><strong>Notional Amount</strong>: Specifies the amount of money to be paid for each unit of variance difference.</li>
<li><strong>Strike</strong>: The predetermined level of variance agreed upon at the inception of the swap.</li>
<li><strong>Realized Variance</strong>: Calculated from the returns of the underlying asset over the life of the swap.</li>
</ul>
<p>The payoff of a variance swap is given by:</p>
<p><span class="math display">\[
\text{Payoff} = \text{Notional} \times (\text{Realized Variance} - \text{Strike})
\]</span></p>
<p>Where:</p>
<ul>
<li><strong>Realized Variance</strong> is typically calculated using the formula:</li>
</ul>
<p><span class="math display">\[
\text{Realized Variance} = \frac{252}{N} \sum_{i=1}^{N} \left( \log\left(\frac{S_i}{S_{i-1}}\right) \right)^2
\]</span></p>
<p>Here, <span class="math inline">\(S_i\)</span> represents the price of the underlying asset at time <span class="math inline">\(i\)</span>, and <span class="math inline">\(N\)</span> is the number of trading days over the contract period.</p>
<p><strong>Example</strong>: Suppose an investor enters into a variance swap with a notional amount of $100,000 and a strike of 0.04 (implying a volatility strike of 20%). If the realized variance over the swap’s life is 0.06 (implying a realized volatility of 24.5%), the payoff would be:</p>
<p><span class="math display">\[
\text{Payoff} = 100,000 \times (0.06 - 0.04) = 100,000 \times 0.02 = 2,000
\]</span></p>
<p>This means the investor would receive $2,000 at the end of the swap period.</p>
<p>As all futures constracts, variance swaps are marked to market on each trading day.</p>
<p>Variance swaps can be used to hedge against volatility risk. For example, a portfolio manager concerned about increasing market volatility can buy variance swaps to protect the portfolio’s value.</p>
<p>Traders can also use variance swaps to speculate or arbitrage on future volatility. For example, If a trader believes that future volatility will be higher than the current implied volatility, they can enter a variance swap to profit from this view.</p>
</section>
<section id="pricing-of-a-variance-swap-for-stocks-with-geometric-brownian-motion-prices" class="level3">
<h3 class="anchored" data-anchor-id="pricing-of-a-variance-swap-for-stocks-with-geometric-brownian-motion-prices">Pricing of a Variance Swap for Stocks with Geometric Brownian Motion Prices</h3>
<p>Similor the pricing of a futures, we need find the fair swap strike such that the initial value of the swap is zero. For simplicity, consider a stock whose price <span class="math inline">\(S_t\)</span> follows a geometric Brownian motion process:</p>
<p><span class="math display">\[ \frac{dS_t}{S_t} = \mu \, dt + \sigma \, dZ_t
\]</span></p>
<p>Applying Ito’s Lemma to <span class="math inline">\(\log(S_t)\)</span>:</p>
<p><span class="math display">\[ d(\log S_t) = \left( \mu - \frac{\sigma^2}{2} \right) \, dt + \sigma \, dZ_t
\]</span></p>
<p>Rearranging terms, we get:</p>
<p><span class="math display">\[ \frac{dS_t}{S_t} - d(\log S_t) = \frac{\sigma^2}{2} \, dt
\]</span></p>
<p>Integrating over the life of the swap ( [0, T] ):</p>
<p><span class="math display">\[ \text{Total Variance} = \frac{1}{T} \int_0^T \sigma^2 \, dt = \frac{2}{T} \left( \int_0^T \frac{dS_t}{S_t} - \log \left( \frac{S_T}{S_0} \right) \right),  
\]</span> which implies that the total variance can be replicated by continuously rebalancing the stock position with weight <span class="math inline">\(1/S_t\)</span> and shorting one unit of the security which pays the <span class="math inline">\(\log\)</span> return of the stock. However, this <span class="math inline">\(\log\)</span> return secutiry is not traded in the market. Fortunately, we can synthesize this security with a forward and options, because</p>
<p><span class="math display">\[
-ln (\frac{S_T}{S^*})=-\frac{S-S^*}{S^*}+\int_0^{S^*}\frac{(K-S)^+}{K^2}dK+\int_{S^*}^\infty\frac{(S-K)^+}{K^2}dK,
\]</span> where <span class="math inline">\(S^*\)</span> is an arbitrary cut-off strike for calls and puts, the first term on the right hand side represents a short position in the forward contract on the stock, the second term represents a continuum of put options with strike prices from 0 to <span class="math inline">\(S^*\)</span>, and the third term represents a continuum of call options with strike prices above <span class="math inline">\(S^*\)</span>. Taking expectation under the risk neutral measure, we have that the fair swap strike <span class="math inline">\(K_{\text{var}}\)</span> is equal to:</p>
<p><span class="math display">\[ K_{\text{var}} = \frac{2}{T} \left( rT - \left( \frac{S_0}{S^*} e^{rT} - 1 \right) - \log \left( \frac{S^*}{S_0} \right) + e^{rT} \int_0^{S^*} \frac{1}{K^2} P(K) \, dK + e^{rT} \int_{S^*}^\infty \frac{1}{K^2} C(K) \, dK \right)
\]</span></p>
<p>Choosing <span class="math inline">\(S^*\)</span> to be the current forward price <span class="math inline">\(F_0=S_0 e^{rT}\)</span>:</p>
<p><span class="math display">\[ K_{\text{var}} = \frac{2 e^{rT}}{T} \left( \int_0^{F_0} \frac{P(K)}{K^2} \, dK + \int_{F_0}^\infty \frac{C(K)}{K^2} \, dK \right)
\]</span></p>
<p>This formula allows us to compute the fair strike price of a variance swap using the prices of European call and put options. The following code provides an example of this computation using data from Yahoo finance for Apple.</p>
<div id="variance_swap_pricing" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> indicator_function(condition):</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> condition <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_variance_swap_strike(S, r, T, options_data):</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract call and put prices</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    call_data <span class="op">=</span> options_data[options_data[<span class="st">'Type'</span>] <span class="op">==</span> <span class="st">'call'</span>].copy()</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    put_data <span class="op">=</span> options_data[options_data[<span class="st">'Type'</span>] <span class="op">==</span> <span class="st">'put'</span>].copy()</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolate call and put prices</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    strikes <span class="op">=</span> np.unique(options_data[<span class="st">'Strike'</span>])</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    call_interp <span class="op">=</span> interp1d(call_data[<span class="st">'Strike'</span>], call_data[<span class="st">'Price'</span>], fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    put_interp <span class="op">=</span> interp1d(put_data[<span class="st">'Strike'</span>], put_data[<span class="st">'Price'</span>], fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Integrate using numerical methods (trapezoidal rule)</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>    K_min, K_max <span class="op">=</span> strikes.<span class="bu">min</span>(), strikes.<span class="bu">max</span>()</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> np.linspace(K_min, S<span class="op">*</span>np.exp(r<span class="op">*</span>T), <span class="dv">500</span>)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>    integral1 <span class="op">=</span> np.trapezoid(put_interp(K) <span class="op">/</span> K<span class="op">**</span><span class="dv">2</span>, K)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> np.linspace(S<span class="op">*</span>np.exp(r<span class="op">*</span>T),K_max, <span class="dv">500</span>)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    integral2 <span class="op">=</span> np.trapezoid(call_interp(K) <span class="op">/</span> K<span class="op">**</span><span class="dv">2</span>, K)</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the variance swap strike</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>    variance_swap_strike <span class="op">=</span> np.sqrt(<span class="dv">2</span> <span class="op">*</span> (integral1<span class="op">+</span>integral2) <span class="op">/</span> T)</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> variance_swap_strike</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>ticker <span class="op">=</span> <span class="st">"AAPL"</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="fl">150.0</span>  <span class="co"># Current stock price</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.01</span>  <span class="co"># Risk-free rate</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span>  <span class="co"># Time to maturity (6 months)</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch options data from Yahoo Finance</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>stock <span class="op">=</span> yf.Ticker(ticker)</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>expiry <span class="op">=</span> stock.options[<span class="dv">0</span>]</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>opt_chain <span class="op">=</span> stock.option_chain(expiry)</span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a>calls <span class="op">=</span> opt_chain.calls[[<span class="st">'strike'</span>, <span class="st">'lastPrice'</span>]].copy()</span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>puts <span class="op">=</span> opt_chain.puts[[<span class="st">'strike'</span>, <span class="st">'lastPrice'</span>]].copy()</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a>calls.columns <span class="op">=</span> [<span class="st">'Strike'</span>, <span class="st">'Price'</span>]</span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>puts.columns <span class="op">=</span> [<span class="st">'Strike'</span>, <span class="st">'Price'</span>]</span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>calls[<span class="st">'Type'</span>] <span class="op">=</span> <span class="st">'call'</span></span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>puts[<span class="st">'Type'</span>] <span class="op">=</span> <span class="st">'put'</span></span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>options_data <span class="op">=</span> pd.concat([calls, puts])</span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the variance swap strike</span></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a>variance_swap_strike <span class="op">=</span> calculate_variance_swap_strike(S, r, T, options_data)</span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variance Swap Strike: </span><span class="sc">{</span>variance_swap_strike<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Variance Swap Strike: 0.6310</code></pre>
</div>
</div>
</section>
</section>
<section id="exercises" class="level2" data-number="9.14">
<h2 data-number="9.14" class="anchored" data-anchor-id="exercises"><span class="header-section-number">9.14</span> Exercises</h2>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.1</strong></span> Intuitively, the value of a forward-start call option should be lower the closer is the date <span class="math inline">\(T\)</span> at which the strike is set to the date <span class="math inline">\(T'\)</span> at which the option matures, because then the option has less time to maturity after being created at <span class="math inline">\(T\)</span>. Create an Excel worksheet to confirm this. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, and <span class="math inline">\(T'\)</span>. Compute and plot the value of the option for <span class="math inline">\(T=0.1T'\)</span>, <span class="math inline">\(T=0.2T'\)</span>, , <span class="math inline">\(T=0.9T'\)</span>.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.2</strong></span> Create an Excel worksheet to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, and <span class="math inline">\(T'\)</span>. Use the <code>Black-Scholes_Call</code> function to compute and output the value <span class="math inline">\(C\)</span> of a European call with strike <span class="math inline">\(K'=S\)</span> (i.e., the call is at the money) and maturity <span class="math inline">\(T'\)</span>. Use the <code>Call_on_Call</code> function to compute and output the value of a call option on the call with strike <span class="math inline">\(K=C\)</span> (i.e., the call-on-a-call is at the money) and maturity <span class="math inline">\(T=0.5T'\)</span>. Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price <span class="math inline">\(S\)</span> instantaneously increased by 10%.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.3</strong></span> Create an Excel worksheet to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, and <span class="math inline">\(T'\)</span>. Take the date of the dividend payment to be <span class="math inline">\(T=0.5T'\)</span> and take the strike price to be <span class="math inline">\(K=S\)</span>. As discussed in <a href="#sec-s_discrete" class="quarto-xref"><span>Section 9.3</span></a>, the value of a European call is given by the Black-Scholes formula with <span class="math inline">\(S-\mathrm{e}^{-rT}D\)</span> being the initial asset price and <span class="math inline">\(q=0\)</span> being the constant dividend yield. Use the function <code>American_Call_Dividend</code> to compute the value of an American call for dividends <span class="math inline">\(D=.1S\)</span>, <span class="math inline">\(D=.9S\)</span>. Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend <span class="math inline">\(D\)</span>.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.4</strong></span> Create a Python function to value a simple chooser (a chooser option in which <span class="math inline">\(K_c=K_p\)</span> and <span class="math inline">\(T_c=T_p\)</span>) using put-call parity to compute <span class="math inline">\(S^*\)</span> as mentioned in <a href="#sec-s_choosers" class="quarto-xref"><span>Section 9.4</span></a>. Verify that the function gives the same result as the function <code>Chooser</code>.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.5</strong></span> Create a Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span>, <span class="math inline">\(q\)</span>, and <span class="math inline">\(T'\)</span>. Take the time to maturity of the underlying call and put to be <span class="math inline">\(T'\)</span> for both the chooser and the straddle. Take the strike prices to be <span class="math inline">\(K=S\)</span>. Take the time the choice must be made for the chooser to be <span class="math inline">\(T=0.5T'\)</span>. Compute the cost of the chooser and the cost of the straddle.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.6</strong></span> A stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in <a href="#sec-s_lookbacks" class="quarto-xref"><span>Section 9.7</span></a>.) Create an Excel worksheet allowing the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, and <span class="math inline">\(\sigma\)</span> and computing the minimum fee.</p>
</div>
<div id="exr-e_standardknockout" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.7</strong></span> Suppose you must purchase 100 units of an asset at the end of a year. Create an Excel worksheet simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):</p>
<ol type="1">
<li>a standard European call,</li>
<li>a down-and-out call in which the knock-out barrier is 10% below the current price of the asset.</li>
</ol>
<p>Take both options to be at the money at the beginning of the year. Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(q\)</span>. Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).</p>
</div>
<div id="exr-e_standardknockout2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.8</strong></span> Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.</p>
</div>
<div id="exr-e_standardknockout3" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.9</strong></span> Modify <a href="#exr-e_standardknockout" class="quarto-xref">Exercise&nbsp;<span>9.7</span></a> by including a third hedge: a combination of a down-and-out call as in part (b) of <a href="#exr-e_standardknockout" class="quarto-xref">Exercise&nbsp;<span>9.7</span></a> and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.</p>
</div>
<div id="exr-e_standardknockout4" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.10</strong></span> Modify <a href="#exr-e_standardknockout2" class="quarto-xref">Exercise&nbsp;<span>9.8</span></a> by including the hedge in <a href="#exr-e_standardknockout3" class="quarto-xref">Exercise&nbsp;<span>9.9</span></a>. Value the down-and-in call using the function <code>Down_And_Out_Call</code> and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.</p>
</div>
<div id="exr-e_averagehedge" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.11</strong></span> Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create an Excel worksheet simulating the asset price and comparing the quality of the following hedges:</p>
<ol type="1">
<li>a standard European call maturing at the end of the quarter (<span class="math inline">\(T=0.25\)</span>) on 1300 units of the asset,</li>
<li>13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and</li>
<li>a discretely sampled average-price call with maturity <span class="math inline">\(T=0.25\)</span> written on 1300 units of the asset, where the sampling is at the end of each week.<br>
</li>
<li>a discretely sampled geometric-average-price call with maturity <span class="math inline">\(T=0.25\)</span> written on 1300 units of the asset, where the sampling is at the end of each week.</li>
</ol>
<p>Allow the user to input <span class="math inline">\(S\)</span>, <span class="math inline">\(r\)</span>, <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(q\)</span>. Assume all of the options are at the money at the beginning of the quarter (<span class="math inline">\(K=S\)</span>). Compare the hedges as in <a href="#exr-e_standardknockout" class="quarto-xref">Exercise&nbsp;<span>9.7</span></a>.</p>
</div>
<div id="exr-e_averagehedge2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.12</strong></span> In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.13</strong></span> Using the put-call parity relation, derive a formula for the value of a forward-start put.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.14</strong></span> Derive <a href="#eq-callonaput" class="quarto-xref">Equation&nbsp;<span>9.11</span></a> for the value of a call on a put.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.15</strong></span> Complete the derivation of <a href="#eq-chooser2" class="quarto-xref">Equation&nbsp;<span>9.20</span></a> for the value of a chooser option.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.16</strong></span> Derive a formula for the value of a put option on the maximum of two risky asset prices.</p>
</div>
<div id="exr-nolabel" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9.17</strong></span> Using the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike <span class="math inline">\(K\)</span> and maturity <span class="math inline">\(T\)</span>) on the maximum of two risky asset prices satisfy the following put-call parity relation: <span class="math display">\[\begin{multline*}
\mathrm{e}^{-rT}K + \text{Value of call on max} \\
= \mathrm{e}^{-q_2T}S_2(0) + \text{Value of option to exchange asset 2 for asset 1} \\+ \text{Value of put on max}\;.
\end{multline*}\]</span></p>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-CV" class="csl-entry" role="listitem">
Conze, A., and Viswanathan. 1991. <span>“Path Dependent Options: The Case of Lookback Options.”</span> <em>Journal of Finance</em> 46: 1893–1907.
</div>
<div id="ref-Drezner" class="csl-entry" role="listitem">
Drezner, Z. 1978. <span>“Computation of the Bivariate Normal Integral.”</span> <em>Mathematics of Computation</em> 32: 277–79.
</div>
<div id="ref-Geske" class="csl-entry" role="listitem">
Geske, R. 1979. <span>“The Valuation of Compound Options.”</span> <em>Journal of Financial Economics</em> 7: 63–81.
</div>
<div id="ref-GSG" class="csl-entry" role="listitem">
Goldman, M., H. Sosin, and M. Gatto. 1979. <span>“Path Dependent Options: ‘Buy at the Low, Sell at the High.”</span> <em>’ Journal of Finance</em> 34: 1111–27.
</div>
<div id="ref-Haug" class="csl-entry" role="listitem">
Haug, E. G. 1998. <em>The Complete Guide to Option Pricing Formulas</em>. McGraw-Hill, New York.
</div>
<div id="ref-MR" class="csl-entry" role="listitem">
Musiela, M., and M. Rutkowski. 1997. <em>Martingale Methods in Financial Modeling</em>. Springer, Berlin Heidelberg New York.
</div>
<div id="ref-Stulz" class="csl-entry" role="listitem">
Stulz, R. 1982. <span>“Options on the Minimum or Maximum of Two Risky Assets: Analysis and Applications.”</span> <em>Journal of Financial Economics</em> 10: 161–85.
</div>
<div id="ref-Trigeorgis" class="csl-entry" role="listitem">
Trigeorgis, A. 1991. <span>“A Log-Transformed Binomial Analysis Method for Valuing Complex Multi-Option Investments.”</span> <em>Journal of Financial and Quantitative Analysis</em> 26: 309–26.
</div>
<div id="ref-Zhang" class="csl-entry" role="listitem">
Zhang, P. G. 1998. <em>Exotic Options</em>. A Guide to Second Generation Options, 2nd ed., World Scientific Publishing, Singapore.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>We are going to use equation~<a href="Chapter2.html#eq-probSnumeraire" class="quarto-xref">Equation&nbsp;<span>2.23</span></a> at date <span class="math inline">\(T'\)</span> to define the probabilities, because it will not be known until date <span class="math inline">\(T'\)</span> whether the event <span class="math inline">\(S(T')&gt;S(T)\)</span> is true. Thus, we need the price of a numeraire asset at date <span class="math inline">\(T'\)</span>. We would like this price to be a constant times <span class="math inline">\(S(T)\)</span>, which is what we will obtain. An equivalent numeraire is to make a smaller investment in the same portfolio: start with <span class="math inline">\(\mathrm{e}^{-r(T'-T)-qT}\)</span> shares. This results in a final value of <span class="math inline">\(S(T)\)</span> at date <span class="math inline">\(T'\)</span>. As will be seen, this is useful for deriving the put-call parity relation for forward-start options.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The only difference is that here <span class="math inline">\(Z\)</span> is the price of a non-dividend-paying portfolio, so, in the notation of the previous section, we have <span class="math inline">\(V(t)=Z(t)\)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>For a spread option, take <span class="math inline">\(L=2\)</span>, <span class="math inline">\(w_1=1\)</span> and <span class="math inline">\(w_2=-1\)</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter8.html" class="pagination-link" aria-label="Forward, Futures, and Exchange Options">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Forward, Futures, and Exchange Options</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter10.html" class="pagination-link" aria-label="Finite Difference Methods">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Finite Difference Methods</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>