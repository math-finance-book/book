<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>12&nbsp; Monte Carlo Methods – Pricing and Hedging Derivative Securities</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter_Binomial.html" rel="next">
<link href="./Chapter_Exotics.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-933f24a0c1e0be8a62c2179459603458.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-217607b4065b1a3128a07792af3f8e33.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>



<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

<script type="text/javascript">

window.PlotlyConfig = {MathJaxConfig: 'local'};

if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: "STIX-Web"}});}

if (typeof require !== 'undefined') {

require.undef("plotly");

requirejs.config({

    paths: {

        'plotly': ['https://cdn.plot.ly/plotly-2.12.1.min']

    }

});

require(['plotly'], function(Plotly) {

    window._Plotly = Plotly;

});

}

</script>



<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet">
<style>
div.callout-Extra.callout {
  border-left-color: #a1bced;
}
div.callout-Extra.callout-style-default > .callout-header {
  background-color: rgba(161, 188, 237, 0.13);
}
div.callout-Extra .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-Extra.callout-style-default .callout-icon::before, div.callout-Extra.callout-titled .callout-icon::before {
  font-family: 'Font Awesome 6 Free';
  content: '\f48b';
  background-image: none;
}
div.callout-Example.callout {
  border-left-color: #a1bced;
}
div.callout-Example.callout-style-default > .callout-header {
  background-color: rgba(161, 188, 237, 0.13);
}
div.callout-Example .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-Example.callout-style-default .callout-icon::before, div.callout-Example.callout-titled .callout-icon::before {
  font-family: 'Font Awesome 6 Free';
  content: '\f185';
  background-image: none;
}
div.callout-Principle.callout {
  border-left-color: #eb4034;
}
div.callout-Principle.callout-style-default > .callout-header {
  background-color: rgba(235, 64, 52, 0.13);
}
div.callout-Principle .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-Principle.callout-style-default .callout-icon::before, div.callout-Principle.callout-titled .callout-icon::before {
  font-family: 'Font Awesome 6 Free';
  content: '\f06a';
  background-image: none;
}
div.callout-Rule.callout {
  border-left-color: #12801f;
}
div.callout-Rule.callout-style-default > .callout-header {
  background-color: rgba(18, 128, 31, 0.13);
}
div.callout-Rule .callout-toggle::before {  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgb(33, 37, 41)" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');}
div.callout-Rule.callout-style-default .callout-icon::before, div.callout-Rule.callout-titled .callout-icon::before {
  font-family: 'Font Awesome 6 Free';
  content: '\f164';
  background-image: none;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter_MonteCarlo.html">Part 5: Numerical Methods</a></li><li class="breadcrumb-item"><a href="./Chapter_MonteCarlo.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Monte Carlo Methods</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Pricing and Hedging Derivative Securities</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/math-finance-book/book-published-code.git" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 1: Introduction</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Intro_Derivatives.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Derivative Securities</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 2: Mathematical Tools</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Brownian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Brownian Motion</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Ito.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Ito Processes and Ito’s Formula</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_GBM.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Geometric Brownian Motion</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 3: Arbitrage Pricing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Arbitrage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Fundamentals of Arbitrage Pricing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Deltas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Delta Hedges, Replication, and PDEs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Girsanov.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">“No Arbitrage” in Continuous Time</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 4: Black-Scholes and Extensions</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_BlackScholes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Black-Scholes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Merton.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Merton, Black, and Margrabe</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Asians.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Asians, Baskets, and Spreads</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Exotics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Other Exotics</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Part 5: Numerical Methods</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_MonteCarlo.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Monte Carlo Methods</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter_Binomial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Binomial and Trinomial Models</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix_Binomial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Introduction to Binomial Tree Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Appendix_MonteCarlo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Introduction to Monte Carlo Simulations</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter_MonteCarlo.html">Part 5: Numerical Methods</a></li><li class="breadcrumb-item"><a href="./Chapter_MonteCarlo.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Monte Carlo Methods</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-c:montecarlo" class="quarto-section-identifier"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Monte Carlo Methods</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div id="4605b7a3" class="cell" data-execution_count="1">
<div class="cell-output cell-output-display">
<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG"></script>
</div>
</div>
<p>In this chapter, we will introduce a principal numerical method for valuing derivative securities: Monte Carlo. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.</p>
<section id="sec-s:mc_europeans" class="level2" data-number="12.1">
<h2 data-number="12.1" class="anchored" data-anchor-id="sec-s:mc_europeans"><span class="header-section-number">12.1</span> Introduction to Monte Carlo</h2>
<p>According to our risk-neutral pricing <a href="Chapter_Arbitrage.html#eq-riskneutralformula" class="quarto-xref">Equation&nbsp;<span>5.29</span></a>, the value of a security paying an amount <span class="math inline">\(x\)</span> at date <span class="math inline">\(T\)</span> is <span id="eq-montecarlo1"><span class="math display">\[
\mathrm{e}^{-rT}\\E^R[x]\;.
\qquad(12.1)\]</span></span></p>
<p>To estimate this by Monte-Carlo means to simulate a sample of values for the random variable <span class="math inline">\(x\)</span> and to estimate the expectation by averaging the sample values.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Of course, for this to work, the sample must be generated from a population having a distribution consistent with the risk-neutral probabilities.</p>
<p>The simplest example is valuing a European option under the Black-Scholes assumptions. Of course, for calls and puts, this is redundant, because we already have the Black-Scholes formulas. Nevertheless, we will describe how to do this for the sake of introducing the Monte Carlo method. In the case of a call option, the random variable <span class="math inline">\(x\)</span> in <a href="#eq-montecarlo1" class="quarto-xref">Equation&nbsp;<span>12.1</span></a> is <span class="math inline">\(\max(0,S_T-K)\)</span>. To simulate a sample of values for this random variable, we need to simulate the terminal stock price <span class="math inline">\(S_T\)</span>. This is easy to do, because, under the Black-Scholes assumptions, the logarithm of <span class="math inline">\(S_T\)</span> is normally distributed under the risk-neutral probability with mean <span class="math inline">\(\log S_0+\nu T\)</span> and variance <span class="math inline">\(\sigma^2T\)</span>, where <span class="math inline">\(\nu=r-q-\sigma^2/2\)</span>. Thus, we can simulate values for <span class="math inline">\(\log S_T\)</span> as <span class="math inline">\(\log S_0+\nu T + \sigma\sqrt{T}z\)</span>, where <span class="math inline">\(z\)</span> is a standard normal. We can average the simulated values of <span class="math inline">\(\max(0,S_T-K)\)</span>, or whatever the payoff of the derivative is, and then discount at the risk-free rate to compute the date–0 value of the derivative. This means that we generate some number <span class="math inline">\(M\)</span> of standard normals <span class="math inline">\(z_i\)</span> and estimate the option value as <span class="math inline">\(\mathrm{e}^{-rT}\bar{x}\)</span>, where <span class="math inline">\(\bar{x}\)</span> is the mean of <span class="math display">\[x_i = \max\left(0,\mathrm{e}^{\log S_0+\nu T + \sigma\sqrt{T}z_i}-K\right)\; .\]</span> To value options that are path-dependent we need to simulate the path of the underlying asset price.</p>
<p>There are two main drawbacks to Monte-Carlo methods. First, it is difficult (though not impossible) to value early-exercise features.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> To value early exercise, we need to know the value at each date if not exercised, to compare to the intrinsic value. One could consider performing a simulation at each date to calculate the value if not exercised, but this value depends on the option to exercise early at later dates, which cannot be calculated without knowing the value of being able to exercise early at even later dates, etc. In contrast, the binomial model can easily handle early exercise but cannot easily handle path dependencies.</p>
<p>The second drawback of Monte Carlo methods is that they can be quite inefficient in terms of computation time (though, as will be explained later, they may be faster than alternative methods for derivatives written on multiple assets). As in statistics, the standard error of the estimate depends on the sample size. Specifically, given a random sample <span class="math inline">\(\{x_1,\ldots,x_M\}\)</span> of size <span class="math inline">\(M\)</span> from a population with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>, the best estimate of <span class="math inline">\(\mu\)</span> is the sample mean <span class="math inline">\(\bar{x}\)</span>, and the standard error of <span class="math inline">\(\bar{x}\)</span> (which means the standard deviation of <span class="math inline">\(\bar{x}\)</span> in repeated samples) is best estimated by <span id="eq-standarderror"><span class="math display">\[
\sqrt{\frac{1}{M(M-1)}\left(\sum_{i=1}^{M} x_i^2-M\bar{x}^2\right)}\;.
\qquad(12.2)\]</span></span> Recall that <span class="math inline">\(\bar{x}\)</span> plus or minus 1.96 standard errors is a 95% confidence interval for <span class="math inline">\(\mu\)</span> when the <span class="math inline">\(x_i\)</span> are normally distributed. In the context of European option valuation, the expression <a href="#eq-standarderror" class="quarto-xref">Equation&nbsp;<span>12.2</span></a> gives the standard error of the estimated option value at maturity, and multiplication of <a href="#eq-standarderror" class="quarto-xref">Equation&nbsp;<span>12.2</span></a> by <span class="math inline">\(\mathrm{e}^{-rT}\)</span> gives the standard error of the estimated date–0 option value.</p>
<p>To obtain an estimate with an acceptably small standard error may require a large sample size and hence a relatively large amount of computation time. The complexities of Monte Carlo methods arise from trying to reduce the required sample size. Later, we will describe two such methods (antithetic variates and control variates). For those who want to engage in a more detailed study of Monte Carlo methods, the book of Glasserman <span class="citation" data-cites="Glasserman">(<a href="#ref-Glasserman" role="doc-biblioref">Glasserman 2004</a>)</span> is highly recommended. J<span class="math inline">\(\ddot{\text{a}}\)</span>ckel <span class="citation" data-cites="Jackel">(<a href="#ref-Jackel" role="doc-biblioref">Jäckel 2002</a>)</span> is useful for more advanced readers, and Clewlow and Strickland <span class="citation" data-cites="CS">(<a href="#ref-CS" role="doc-biblioref">Clewlow and Strickland 1998</a>)</span> and Brandimarte <span class="citation" data-cites="Brandimarte">(<a href="#ref-Brandimarte" role="doc-biblioref">Brandimarte 2002</a>)</span> are useful references that include computer code.</p>
<section id="monte-carlo-valuation-of-a-european-call" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-valuation-of-a-european-call">Monte Carlo Valuation of a European Call</h3>
<p>We will illustrate Monte Carlo by valuing a European call under the Black-Scholes assumptions. We will also estimate the delta by each of the methods described in <a href="#sec-s:montecarlogreeks1" class="quarto-xref"><span>Section 12.4</span></a> and <a href="#sec-s:montecarlogreeks2" class="quarto-xref"><span>Section 12.5</span></a>. Of course, we know the call value and its delta from the Black-Scholes formulas, and they can be used to evaluate the accuracy of the Monte Carlo estimates. In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process. Therefore we set <span class="math inline">\(m=1\)</span>. However, we use a large number of paths, <span class="math inline">\(n=10,000\)</span> to get a large sample of terminal stock prices.</p>
<div id="c7367fea" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="c7367fea"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="c7367fea-1"><a href="#c7367fea-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Geometric Brownian Motion</span></span>
<span id="c7367fea-2"><a href="#c7367fea-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="c7367fea-3"><a href="#c7367fea-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="c7367fea-4"><a href="#c7367fea-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="c7367fea-5"><a href="#c7367fea-5" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="c7367fea-6"><a href="#c7367fea-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10000</span></span>
<span id="c7367fea-7"><a href="#c7367fea-7" aria-hidden="true" tabindex="-1"></a><span class="co"># number of divisions</span></span>
<span id="c7367fea-8"><a href="#c7367fea-8" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1</span></span>
<span id="c7367fea-9"><a href="#c7367fea-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)</span></span>
<span id="c7367fea-10"><a href="#c7367fea-10" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="c7367fea-11"><a href="#c7367fea-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="c7367fea-12"><a href="#c7367fea-12" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="c7367fea-13"><a href="#c7367fea-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Stock Price</span></span>
<span id="c7367fea-14"><a href="#c7367fea-14" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">42</span></span>
<span id="c7367fea-15"><a href="#c7367fea-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturity</span></span>
<span id="c7367fea-16"><a href="#c7367fea-16" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="c7367fea-17"><a href="#c7367fea-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Strike Price</span></span>
<span id="c7367fea-18"><a href="#c7367fea-18" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">40</span></span>
<span id="c7367fea-19"><a href="#c7367fea-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividend Yield</span></span>
<span id="c7367fea-20"><a href="#c7367fea-20" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="c7367fea-21"><a href="#c7367fea-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta t</span></span>
<span id="c7367fea-22"><a href="#c7367fea-22" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> m</span>
<span id="c7367fea-23"><a href="#c7367fea-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Drift (nu)</span></span>
<span id="c7367fea-24"><a href="#c7367fea-24" aria-hidden="true" tabindex="-1"></a>drift <span class="op">=</span> r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig<span class="op">**</span><span class="dv">2</span></span>
<span id="c7367fea-25"><a href="#c7367fea-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="c7367fea-26"><a href="#c7367fea-26" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> sig <span class="op">*</span> np.sqrt(dt)</span>
<span id="c7367fea-27"><a href="#c7367fea-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="c7367fea-28"><a href="#c7367fea-28" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>, m <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">*</span> dt</span>
<span id="c7367fea-29"><a href="#c7367fea-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="c7367fea-30"><a href="#c7367fea-30" aria-hidden="true" tabindex="-1"></a><span class="co"># seed for random generator</span></span>
<span id="c7367fea-31"><a href="#c7367fea-31" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">2020</span></span>
<span id="c7367fea-32"><a href="#c7367fea-32" aria-hidden="true" tabindex="-1"></a><span class="co"># define a random generator</span></span>
<span id="c7367fea-33"><a href="#c7367fea-33" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="c7367fea-34"><a href="#c7367fea-34" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="c7367fea-35"><a href="#c7367fea-35" aria-hidden="true" tabindex="-1"></a>inc[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>vol, size<span class="op">=</span>(n, m)))</span>
<span id="c7367fea-36"><a href="#c7367fea-36" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="c7367fea-37"><a href="#c7367fea-37" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> S0 <span class="op">*</span> np.exp(np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="c7367fea-38"><a href="#c7367fea-38" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As before, this code generates two samples <span class="math inline">\(St\)</span>, which adds the simulated standard (zero mean) normal random variable, and <span class="math inline">\(St1\)</span> which subtracts the simulated (zero mean) standard normal random variable. Each sample produces and estimate for the Black-Scholes European call option.</p>
<div id="9355950d" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="9355950d"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="9355950d-1"><a href="#9355950d-1" aria-hidden="true" tabindex="-1"></a>cc <span class="op">=</span> np.maximum(St[m, :] <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="9355950d-2"><a href="#9355950d-2" aria-hidden="true" tabindex="-1"></a>cp <span class="op">=</span> np.mean(cc) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="9355950d-3"><a href="#9355950d-3" aria-hidden="true" tabindex="-1"></a>cc1 <span class="op">=</span> np.maximum(St1[m, :] <span class="op">-</span> K, <span class="dv">0</span>) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="9355950d-4"><a href="#9355950d-4" aria-hidden="true" tabindex="-1"></a>cp1 <span class="op">=</span> np.mean(np.maximum(St1[m, :] <span class="op">-</span> K, <span class="dv">0</span>)) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="9355950d-5"><a href="#9355950d-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="9355950d-6"><a href="#9355950d-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first sample gives an estimated call price="</span>, cp)</span>
<span id="9355950d-7"><a href="#9355950d-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second sample gives an estimated call price="</span>, cp1)</span>
<span id="9355950d-8"><a href="#9355950d-8" aria-hidden="true" tabindex="-1"></a>bsc <span class="op">=</span> (cp <span class="op">+</span> cp1) <span class="op">/</span> <span class="dv">2</span></span>
<span id="9355950d-9"><a href="#9355950d-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the two estimates="</span>, bsc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first sample gives an estimated call price= 4.791646287615179
The second sample gives an estimated call price= 4.687624646438364
The average of the two estimates= 4.739635467026771</code></pre>
</div>
</div>
<p>The true call price is given by</p>
<div id="0344d20e" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="0344d20e"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="0344d20e-1"><a href="#0344d20e-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="0344d20e-2"><a href="#0344d20e-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="0344d20e-3"><a href="#0344d20e-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize, minimize_scalar</span>
<span id="0344d20e-4"><a href="#0344d20e-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-5"><a href="#0344d20e-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-6"><a href="#0344d20e-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> blackscholes(S0, K, r, q, sig, T, call<span class="op">=</span><span class="va">True</span>):</span>
<span id="0344d20e-7"><a href="#0344d20e-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Calculate option price using B-S formula.</span></span>
<span id="0344d20e-8"><a href="#0344d20e-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-9"><a href="#0344d20e-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="0344d20e-10"><a href="#0344d20e-10" aria-hidden="true" tabindex="-1"></a><span class="co">        S0 (num): initial price of underlying asset.</span></span>
<span id="0344d20e-11"><a href="#0344d20e-11" aria-hidden="true" tabindex="-1"></a><span class="co">        K (num): strick price.</span></span>
<span id="0344d20e-12"><a href="#0344d20e-12" aria-hidden="true" tabindex="-1"></a><span class="co">        r (num): risk free rate</span></span>
<span id="0344d20e-13"><a href="#0344d20e-13" aria-hidden="true" tabindex="-1"></a><span class="co">        q (num): dividend yield</span></span>
<span id="0344d20e-14"><a href="#0344d20e-14" aria-hidden="true" tabindex="-1"></a><span class="co">        sig (num): Black-Scholes volatility.</span></span>
<span id="0344d20e-15"><a href="#0344d20e-15" aria-hidden="true" tabindex="-1"></a><span class="co">        T (num): maturity.</span></span>
<span id="0344d20e-16"><a href="#0344d20e-16" aria-hidden="true" tabindex="-1"></a><span class="co">        call (bool): True returns call price, False returns put price.</span></span>
<span id="0344d20e-17"><a href="#0344d20e-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-18"><a href="#0344d20e-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="0344d20e-19"><a href="#0344d20e-19" aria-hidden="true" tabindex="-1"></a><span class="co">        num</span></span>
<span id="0344d20e-20"><a href="#0344d20e-20" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="0344d20e-21"><a href="#0344d20e-21" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S0 <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sig<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sig <span class="op">*</span> np.sqrt(T))</span>
<span id="0344d20e-22"><a href="#0344d20e-22" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sig <span class="op">*</span> np.sqrt(T)</span>
<span id="0344d20e-23"><a href="#0344d20e-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> call:</span>
<span id="0344d20e-24"><a href="#0344d20e-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S0 <span class="op">*</span> norm.cdf(d1, <span class="dv">0</span>, <span class="dv">1</span>) <span class="op">-</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> norm.cdf(</span>
<span id="0344d20e-25"><a href="#0344d20e-25" aria-hidden="true" tabindex="-1"></a>            d2, <span class="dv">0</span>, <span class="dv">1</span></span>
<span id="0344d20e-26"><a href="#0344d20e-26" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="0344d20e-27"><a href="#0344d20e-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="0344d20e-28"><a href="#0344d20e-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S0 <span class="op">*</span> norm.cdf(<span class="op">-</span>d1, <span class="dv">0</span>, <span class="dv">1</span>) <span class="op">+</span> K <span class="op">*</span> np.exp(</span>
<span id="0344d20e-29"><a href="#0344d20e-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">-</span>r <span class="op">*</span> T</span>
<span id="0344d20e-30"><a href="#0344d20e-30" aria-hidden="true" tabindex="-1"></a>        ) <span class="op">*</span> norm.cdf(<span class="op">-</span>d2, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="0344d20e-31"><a href="#0344d20e-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-32"><a href="#0344d20e-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="0344d20e-33"><a href="#0344d20e-33" aria-hidden="true" tabindex="-1"></a>truebsc <span class="op">=</span> blackscholes(S0, K, r, q, sig, T, call<span class="op">=</span><span class="va">True</span>)</span>
<span id="0344d20e-34"><a href="#0344d20e-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The black scholes fromula="</span>, truebsc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The black scholes fromula= 4.759422392871532</code></pre>
</div>
</div>
<p>Notice that even with 10,000 data points for each sample the individual estimates are not very accurate compared to the exact Black Scoles price. This is a well known problem that is difficult to estimate the mean, even with a lot of data and is a drawback to Monte Carlo as discussed earlier. However, the average of the two prices is sgnificantly more accurate. This is an example of an antithetic variable which is discussed later. One simple intution is the two samples yield negatively correlated errors; if the plus sample is two high, then the minus sample will be too low. Combined, the simulation error will cancel out. Another intution is that each individual sample has a wrong estimate of the mean. However, the combined sample has zero mean by construction. Therefore combining the samples give the right mean of the simulated standard normal random variable. Nevertheless, there is still sampling error since we are estimating the mean of the discounted call payoffs, not the mean of the standard normal. This method and other methods to reduce sampling error are discussed next.</p>
</section>
</section>
<section id="antithetic-variates-in-monte-carlo" class="level2" data-number="12.2">
<h2 data-number="12.2" class="anchored" data-anchor-id="antithetic-variates-in-monte-carlo"><span class="header-section-number">12.2</span> Antithetic Variates in Monte Carlo</h2>
<p>In this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method. These are two of the simplest methods. They are used extensively, but there are other important methods that are also widely used. J<span class="math inline">\(\ddot{\text{a}}\)</span>ckel <span class="citation" data-cites="Jackel">(<a href="#ref-Jackel" role="doc-biblioref">Jäckel 2002</a>)</span> and Glasserman <span class="citation" data-cites="Glasserman">(<a href="#ref-Glasserman" role="doc-biblioref">Glasserman 2004</a>)</span> provide a wealth of information on this topic.</p>
<p>The Monte Carlo method estimates the mean <span class="math inline">\(\mu\)</span> of a random variable <span class="math inline">\(x\)</span> as the sample average of randomly generated values of <span class="math inline">\(x\)</span>. An antithetic variate is a random variable <span class="math inline">\(y\)</span> with the same mean as <span class="math inline">\(x\)</span> and a negative correlation with <span class="math inline">\(x\)</span>. It follows that the random variable <span class="math inline">\(z=(x+y)/2\)</span> will have the same mean as <span class="math inline">\(x\)</span> and a lower variance. Therefore the sample mean of <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span> will be an unbiased estimate of <span class="math inline">\(\mu\)</span> and will have a lower standard error than the sample mean of <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(x\)</span>. Thus, we should obtain a more efficient estimator of <span class="math inline">\(\mu\)</span> by simulating <span class="math inline">\(z\)</span> instead of <span class="math inline">\(x\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>In the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent). The terminal value of the derivative written on the first asset serves as <span class="math inline">\(x\)</span> and the terminal value of the derivative written on the second serves as <span class="math inline">\(y\)</span>. Because both asset prices have the same distribution, the means of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> will be the same, and the discounted mean is the date–0 value of the derivative.</p>
<p>Consider for example a non-path-dependent option in a world with constant volatility. In each simulation <span class="math inline">\(i\)</span> (<span class="math inline">\(i=1,\ldots,M\)</span>), we would generate a standard normal <span class="math inline">\(Z_i\)</span> and compute <span class="math display">\[
\begin{align*}
\log S_i(T) &amp;= \log S_0 + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma\sqrt{T}Z_i\; ,\\
\log S_i'(T) &amp;= \log S_0 + \left(r-q-\frac{1}{2}\sigma^2\right)T - \sigma\sqrt{T}Z_i\;.
\end{align*}
\]</span> Given the first terminal price, the value of the derivative will be some number <span class="math inline">\(x_i\)</span> and given the second it will be some number <span class="math inline">\(y_i\)</span>. The date–0 value of the derivative is estimated as <span class="math display">\[
\mathrm{e}^{-rT}\frac{1}{M}\sum_{i=1}^M\frac{x_i+y_i}{2}\; .
\]</span></p>
</section>
<section id="sec-s:controlvariates" class="level2" data-number="12.3">
<h2 data-number="12.3" class="anchored" data-anchor-id="sec-s:controlvariates"><span class="header-section-number">12.3</span> Control Variates in Monte Carlo</h2>
<p> Another approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable. We can explain this in terms of linear regression in statistics. Suppose we have a random sample <span class="math inline">\(\{x_1,\ldots,x_M\}\)</span> of a variable <span class="math inline">\(x\)</span> with unknown mean <span class="math inline">\(\mu\)</span>, and suppose we have a corresponding sample <span class="math inline">\(\{y_1,\ldots,y_M\}\)</span> of another variable <span class="math inline">\(y\)</span> with known mean <span class="math inline">\(\phi\)</span>. Then an efficient estimate of <span class="math inline">\(\mu\)</span> is <span class="math inline">\(\hat{\mu} = \bar{x} + \hat{\beta} (\phi-\bar{y})\)</span>, where <span class="math inline">\(\bar{x}\)</span> and <span class="math inline">\(\bar{y}\)</span> denote the sample means of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and where <span class="math inline">\(\hat{\beta}\)</span> is the coefficient of <span class="math inline">\(y\)</span> in the linear regression of <span class="math inline">\(x\)</span> on <span class="math inline">\(y\)</span> (i.e., the estimate of <span class="math inline">\(\beta\)</span> in the linear model <span class="math inline">\(x = \alpha +\beta y + \varepsilon\)</span>). The standard Monte Carlo method, which we have described thus far, simply estimates the mean of <span class="math inline">\(x\)</span> as <span class="math inline">\(\bar{x}\)</span>. The control variate method adjusts the estimate by adding <span class="math inline">\(\hat{\beta} (\phi-\bar{y})\)</span>. To understand this correction, assume for example that the true <span class="math inline">\(\beta\)</span> is positive. If the random sample is such that <span class="math inline">\(\bar{y}&lt;\phi\)</span>, then it must be that small values of <span class="math inline">\(y\)</span> were over-represented in the sample. Since <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> tend to move up and down together (this is the meaning of a positive <span class="math inline">\(\beta\)</span>) it is likely that small values of <span class="math inline">\(x\)</span> were also over-represented in the sample. Therefore, one should adjust the sample mean of <span class="math inline">\(x\)</span> upwards in order to estimate <span class="math inline">\(\mu\)</span>. The best adjustment will take into account the extent to which small values of <span class="math inline">\(y\)</span> were over-represented (i.e., the difference between <span class="math inline">\(\bar{y}\)</span> and <span class="math inline">\(\phi\)</span>) and the strength of the relation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> (which the estimate <span class="math inline">\(\hat{\beta}\)</span> represents). The efficient correction of this sort is also the simplest: just add <span class="math inline">\(\hat{\beta}(\phi-\bar{y})\)</span> to <span class="math inline">\(\bar{x}\)</span>. In practice, the estimation of <span class="math inline">\(\hat{\beta}\)</span> may be omitted and one may simply take <span class="math inline">\(\hat{\beta}=1\)</span>, if the relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be assumed to be one-for-one. If <span class="math inline">\(\beta\)</span> is to be estimated, the estimate (by ordinary least squares) is <span class="math display">\[\hat{\beta} = \frac{\sum_{i=1}^M x_iy_i - M\bar{x}\bar{y}}{\sum_{i=1}^M y_i^2 - M\bar{y}^2}\; .\]</span> In general, the correction term <span class="math inline">\(\hat{\beta}(\phi-\bar{y})\)</span> will have a nonzero mean, which introduces a bias in the estimate of <span class="math inline">\(\mu\)</span>. To eliminate the bias, one can compute <span class="math inline">\(\hat{\beta}\)</span> from a pre-sample of <span class="math inline">\(\{x,y\}\)</span> values.</p>
<p>As an example of a control variate, in our simulation code to estimate the Black Scholes price for a call option we can use the stock price itself. The known stock price is the input price <span class="math inline">\(S_0\)</span>. The simulation also produces an estimate for the stock price as the dicsounted expected value of the terminal stock price <span class="math inline">\(\hat{S}=\sum_{i=1}^{n} e^{- r T } S_t(m,i)\)</span> where <span class="math inline">\(S_t(m,i)\)</span> is the <span class="math inline">\(i\)</span>th simulated stock price at time <span class="math inline">\(T\)</span>. Theoretically these should be the same umber, but due to error they typically wil not be the same.</p>
<div id="cb1be49f" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1be49f"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1be49f-1"><a href="#cb1be49f-1" aria-hidden="true" tabindex="-1"></a>SS <span class="op">=</span> np.mean(St[m, :]) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="cb1be49f-2"><a href="#cb1be49f-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The Estimated Stock Price for the first sample is ="</span>, SS)</span>
<span id="cb1be49f-3"><a href="#cb1be49f-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The actual stock price should be="</span>, S0)</span>
<span id="cb1be49f-4"><a href="#cb1be49f-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The error is ="</span>, S0 <span class="op">-</span> SS)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The Estimated Stock Price for the first sample is = 42.05899999577932
The actual stock price should be= 42
The error is = -0.058999995779316805</code></pre>
</div>
</div>
<p>The error is <span class="math inline">\(S_0-\hat{S}\)</span> which corresponds to <span class="math inline">\(\phi-y\)</span> above. We then compute <span class="math inline">\(\hat{\beta}\)</span> and comute the improved estimate <span class="math display">\[ \text{new estimate}= \text{original estimate} +\hat{\beta}(S0-\hat{S}) \]</span> In the code below we do this procedure for both samples and average the updates.</p>
<div id="25d1efed" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="25d1efed"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="25d1efed-1"><a href="#25d1efed-1" aria-hidden="true" tabindex="-1"></a>hatbeta <span class="op">=</span> np.cov(St[m, :], cc)[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">/</span> np.cov(St[m,], cc)[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="25d1efed-2"><a href="#25d1efed-2" aria-hidden="true" tabindex="-1"></a>hatbeta1 <span class="op">=</span> np.cov(St1[m, :], cc1)[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">/</span> np.cov(St1[m,], cc1)[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="25d1efed-3"><a href="#25d1efed-3" aria-hidden="true" tabindex="-1"></a>correction <span class="op">=</span> hatbeta <span class="op">*</span> (S0 <span class="op">-</span> SS)</span>
<span id="25d1efed-4"><a href="#25d1efed-4" aria-hidden="true" tabindex="-1"></a>update <span class="op">=</span> cp <span class="op">+</span> correction</span>
<span id="25d1efed-5"><a href="#25d1efed-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"hatbeta="</span>, hatbeta)</span>
<span id="25d1efed-6"><a href="#25d1efed-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The original estimate for the call price from the first sample="</span>, cp)</span>
<span id="25d1efed-7"><a href="#25d1efed-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The original estimate for the call price from the second sample="</span>, cp1)</span>
<span id="25d1efed-8"><a href="#25d1efed-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The updated estimate from the first sample is="</span>, update)</span>
<span id="25d1efed-9"><a href="#25d1efed-9" aria-hidden="true" tabindex="-1"></a>SS1 <span class="op">=</span> np.mean(St1[m, :]) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="25d1efed-10"><a href="#25d1efed-10" aria-hidden="true" tabindex="-1"></a>update1 <span class="op">=</span> cp1 <span class="op">+</span> hatbeta1 <span class="op">*</span> (S0 <span class="op">-</span> SS1)</span>
<span id="25d1efed-11"><a href="#25d1efed-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The updated estimate from the second sample is="</span>, update1)</span>
<span id="25d1efed-12"><a href="#25d1efed-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the updated estimates ="</span>, (update <span class="op">+</span> update1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>hatbeta= 1.1541186403411752
The original estimate for the call price from the first sample= 4.791646287615179
The original estimate for the call price from the second sample= 4.687624646438364
The updated estimate from the first sample is= 4.723553292706218
The updated estimate from the second sample is= 4.780385012196883
The average of the updated estimates = 4.751969152451551</code></pre>
</div>
</div>
<p>We can compare this to the exact Black Scholes formula from before.</p>
<div id="25c412b3" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="25c412b3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="25c412b3-1"><a href="#25c412b3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The exact Black Scholes Price is="</span>, truebsc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The exact Black Scholes Price is= 4.759422392871532</code></pre>
</div>
</div>
<p>As another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let <span class="math inline">\(\tau\)</span> denote the amount of time that has elapsed since the call was issued and <span class="math inline">\(T\)</span> the amount of time remaining before maturity, so the total maturity of the call is <span class="math inline">\(T+\tau\)</span>. To simplify somewhat, assume date <span class="math inline">\(0\)</span> is the beginning of a period between observations. Let <span class="math inline">\(t_1, \ldots, t_N\)</span> denote the remaining sampling dates, with <span class="math inline">\(t_1 = \Delta t\)</span>, <span class="math inline">\(t_i-t_{i-1}=\Delta t = T/N\)</span> for each <span class="math inline">\(i\)</span>, and <span class="math inline">\(t_N=T\)</span>. We will input the average price <span class="math inline">\(A_0\)</span> computed up to date <span class="math inline">\(0\)</span>, assuming this average includes the price <span class="math inline">\(S_0\)</span> at date <span class="math inline">\(0\)</span>. The average price at date <span class="math inline">\(T\)</span> will be <span class="math display">\[A_T = \frac{\tau}{T+\tau}A_0 + \frac{T}{T+\tau}\left(\frac{\sum_{i=1}^N S_{t_i}}{N}\right)\; .\]</span> The average-price call pays <span class="math inline">\(\max(0,A_T-K)\)</span> at its maturity <span class="math inline">\(T\)</span>, and we can write this as <span class="math display">\[\begin{align*}
\max(A_T-K,0) &amp;= \max\left(\frac{T}{T+\tau}\left( \frac{\sum_{i=1}^N S_{t_i}}{N}\right) - \left(K - \frac{\tau}{T+\tau}A_0\right), 0\right)\\
&amp;= \frac{T}{T+\tau} \max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\;,
\end{align*}\]</span> where <span class="math display">\[K^* = \frac{T+\tau}{T}K - \frac{\tau}{T}A_0\; .\]</span> Therefore, the value at date <span class="math inline">\(0\)</span> of the discretely-sampled average-price call is <span class="math display">\[\frac{T}{T+\tau} \,\mathrm{e}^{-rT} \\E^R\left[\max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\right]\; .\]</span> In terms of the discussion above, the random variable the mean of which we want to estimate is <span class="math display">\[x = \mathrm{e}^{-rT}\max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\; .\]</span> A random variable <span class="math inline">\(y\)</span> that will be closely correlated to <span class="math inline">\(x\)</span> is <span class="math display">\[y =\mathrm{e}^{-rT}\max \left(\mathrm{e}^{\sum_{i=1}^N \log S_{t_i}/N} - K^*,0\right)\; .\]</span> The mean <span class="math inline">\(\phi\)</span> of <span class="math inline">\(y\)</span> under the risk-neutral probability is given in the pricing <a href="Chapter_Asians.html#eq-disc_geom_avg_call" class="quarto-xref">Equation&nbsp;<span>10.7</span></a>. We can use the sample mean of <span class="math inline">\(y\)</span> and its known mean <span class="math inline">\(\phi\)</span> to adjust the sample mean of <span class="math inline">\(x\)</span> as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient <span class="math inline">\(\hat{\beta}\)</span> will be quite close to 1.</p>
</section>
<section id="sec-s:montecarlogreeks1" class="level2" data-number="12.4">
<h2 data-number="12.4" class="anchored" data-anchor-id="sec-s:montecarlogreeks1"><span class="header-section-number">12.4</span> Monte Carlo Greeks I: Difference Ratios</h2>
<p>Greeks can be calculated by Monte Carlo by running the valuation program twice and computing a difference ratio, for example <span class="math inline">\((C_u-C_d)/(S_u-S_d)\)</span> to estimate a delta. However, to minimize the error, and minimize the number of computations required, one should use the same set of random draws to estimate the derivative value for different values of the parameter. For path-independent options (e.g., European puts and calls) under the Black-Scholes assumptions, we only need to generate <span class="math inline">\(S_T\)</span> and then we can compute <span class="math inline">\(S_u(T)\)</span> as <span class="math inline">\([S_u(0)/S_0] \times S_T\)</span> and <span class="math inline">\(S_d(T)\)</span> as <span class="math inline">\([S_u(0)/S_0] \times S_T\)</span>. We can estimate standard errors for the Greeks in the same way that we estimate the standard error of the derivative value.</p>
<p>Actually, there is often a better method available that is just as simple. This is called pathwise calculation. We will explain this in the next section. Here we will describe how to estimate the delta and gamma of a derivative as sample means of difference ratios.</p>
<p>Consider initial prices for the underlying <span class="math inline">\(S_u&gt;S&gt;S_d\)</span>. Denote the underlying price at the option maturity in a given simulation by <span class="math inline">\(S_u(T)\)</span> when the initial underlying price is <span class="math inline">\(S_u\)</span>, by <span class="math inline">\(S_T\)</span> when the initial underlying price is <span class="math inline">\(S\)</span>, and by <span class="math inline">\(S_d(T)\)</span> when the initial underlying price is <span class="math inline">\(S_d\)</span>. Under the Black-Scholes assumptions, the logarithm of the stock price at date <span class="math inline">\(T\)</span> starting from the three initial prices <span class="math inline">\(S_d\)</span>, <span class="math inline">\(S\)</span> and <span class="math inline">\(S_u\)</span> is</p>
<p><span class="math display">\[
\begin{align*}
\log S_d(T) &amp;= \log S_d + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B_T\; ,\\
\log S_T &amp;= \log S + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B_T\; ,\\
\log S_u(T) &amp;= \log S_u + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B_T\;,
\end{align*}
\]</span> so <span class="math display">\[\log S_d(T) = \log S_T + \log S_d - \log S\Longrightarrow S_d(T) = \left(\frac{S_d}{S}\right) S_T\; ,\]</span> and <span class="math display">\[\log S_u(T) = \log S_T + \log S_u - \log S \Longrightarrow S_u(T) = \left(\frac{S_u}{S}\right) S_T\; .\]</span> Therefore, under the Black-Scholes assumptions, we only need to simulate <span class="math inline">\(S_T\)</span> and then perform the multiplications indicated above to obtain <span class="math inline">\(S_d(T)\)</span> and <span class="math inline">\(S_u(T)\)</span>.</p>
<p>Consider a particular simulation and let <span class="math inline">\(C_d(T)\)</span> denote the value of the derivative at maturity when the initial asset price is <span class="math inline">\(S_d\)</span>, let <span class="math inline">\(C_T\)</span> denote the value of the derivative at maturity when the initial asset price is <span class="math inline">\(S\)</span>, and let <span class="math inline">\(C_u(T)\)</span> denote the value of the derivative at maturity when the initial asset price is <span class="math inline">\(S_u\)</span>. For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of <span class="math inline">\(S_T\)</span> as just described. However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).</p>
<p>The estimates <span class="math inline">\(C_d\)</span>, <span class="math inline">\(C\)</span> and <span class="math inline">\(C_u\)</span> of the date–0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the <span class="math inline">\(C_d(T)\)</span>, <span class="math inline">\(C_T\)</span> and <span class="math inline">\(C_u(T)\)</span>. One way to estimate the delta is <span class="math inline">\((C_u-C_d)/(S_u-S_d)\)</span>. This is a difference of discounted sample means, multiplied by the reciprocal of <span class="math inline">\(S_u-S_d\)</span>. Equivalently, it is the sample mean of the differences <span class="math inline">\(C_u(T)-C_d(T)\)</span>, multiplied by <span class="math inline">\(\mathrm{e}^{-rT}/(S_u-S_d)\)</span>. The standard error is <span class="math display">\[
\frac{\mathrm{e}^{-rT}}{S_u-S_d}\sqrt{\frac{1}{M(M-1)}\left(\sum_{i=1}^M \left[C_{ui}(T)-C_{di}(T)\right]^2 - M\left[\overline{C_{u}(T)}-\overline{C_{d}(T)}\right]^2\right)}\; ,
\]</span> where the overline denotes the sample mean and where <span class="math inline">\(C_{ui}(T)\)</span> [respectively, <span class="math inline">\(C_{di}(T)\)</span>] denotes the value of the derivative at maturity in simulation <span class="math inline">\(i\)</span> when the initial asset price is <span class="math inline">\(S_u\)</span> [respectively, <span class="math inline">\(S_d\)</span>].</p>
<p>The corresponding Monte Carlo estimate of the gamma is also a sample mean. Simple algebra shows that <a href="Chapter_Binomial.html#eq-binomialgamma100" class="quarto-xref">Equation&nbsp;<span>13.15</span></a> is equivalent to <span id="eq-binomialgamma200"><span class="math display">\[
\Gamma = \frac{2}{(S_u-S)(S_u-S_d)}C_u - \frac{2}{(S_u-S)(S-S_d)}C +\frac{2}{(S-S_d)(S_u-S_d)}C_d\;.
\qquad(12.3)\]</span></span></p>
<p>Normally one would take <span class="math inline">\(S_u=(1+\alpha)S\)</span> and <span class="math inline">\(S_d = (1-\alpha)S\)</span> for some <span class="math inline">\(\alpha\)</span> (e.g., <span class="math inline">\(\alpha=0.01\)</span>). In this case <a href="#eq-binomialgamma200" class="quarto-xref">Equation&nbsp;<span>12.3</span></a> simplifies to <span id="eq-binomialgamma300"><span class="math display">\[
\Gamma = \frac{C_u - 2C + C_d}{\alpha^2S^2}\;,
\qquad(12.4)\]</span></span></p>
<p>and the standard error of the gamma is</p>
<p><span class="math display">\[
\begin{multline*}\frac{\mathrm{e}^{-rT}}{\alpha^2S^2}\sqrt{\frac{1}{M(M-1)}}\\
\times \sqrt{\sum_{i=1}^M \left[C_{ui}(T)-2C_i(T)+C_{di}(T)\right]^2 -M\left[\overline{C_{u}(T)}-2\overline{C_T}+\overline{C_{d}(T)}\right]^2}\; .
\end{multline*}
\]</span></p>
</section>
<section id="sec-s:montecarlogreeks2" class="level2" data-number="12.5">
<h2 data-number="12.5" class="anchored" data-anchor-id="sec-s:montecarlogreeks2"><span class="header-section-number">12.5</span> Monte Carlo Greeks II: Pathwise Estimates</h2>
<p>We will examine the bias in the Monte Carlo delta estimate discussed in the preceding section and explain pathwise estimation of Greeks. By biased, we mean that the expected value of an estimate is different from the true value. It is important to recognize that if a Monte Carlo estimate is biased, then, even if a large number of simulations is used and the standard error is nearly zero, the answer provided by the Monte Carlo method will be incorrect. For simplicity, consider a European call under the Black-Scholes assumptions.</p>
<p>The delta estimate we have considered is the discounted sample mean of <span id="eq-montecarlodelta2"><span class="math display">\[
\frac{C_u(T) - C_d(T)}{S_u-S_d}\;.
\qquad(12.5)\]</span></span></p>
<p>This ratio takes on one of three values, depending on <span class="math inline">\(S_T\)</span>:</p>
<ul>
<li>If <span class="math inline">\(S_u(T) \leq K\)</span> then the option is out of the money in both the up and down cases; i.e., <span class="math display">\[C_u(T) = C_d(T) = 0\; ,\]</span> so the ratio <a href="#eq-montecarlodelta2" class="quarto-xref">Equation&nbsp;<span>12.5</span></a> is zero.</li>
<li>If <span class="math inline">\(S_d(T) \geq K\)</span> then the option is in the money in both the up and down cases; i.e.,</li>
</ul>
<p><span class="math display">\[
\begin{align*} C_u(T) &amp;= S_u(T) - K =\left(\frac{S_u}{S}\right)S_T - K\; ,\\
C_d(T) &amp;= S_d(T) - K = \left(\frac{S_d}{S}\right)S_T - K\;,
\end{align*}
\]</span></p>
<p>so the ratio <a href="#eq-montecarlodelta2" class="quarto-xref">Equation&nbsp;<span>12.5</span></a> equals <span class="math inline">\(S_T/S\)</span>. - If <span class="math inline">\(S_u(T) &gt; K &gt; S_d(T)\)</span>, then the option is in the money in only the up case; i.e., <span class="math display">\[
\begin{align*}
C_u(T) &amp;= S_u(T) - K = \left(\frac{S_u}{S}\right)S_T - K\; ,\\
C_d(T) &amp;= 0\;,
\end{align*}
\]</span> so the ratio <a href="#eq-montecarlodelta2" class="quarto-xref">Equation&nbsp;<span>12.5</span></a> equals <span class="math display">\[
\frac{\left(\frac{S_u}{S}\right)S_T - K}{S_u-S_d} &lt; \frac{S_T}{S}\; .
\]</span></p>
<p>The bias is induced by the third case above. We can see this as follows. We are trying to estimate <span id="eq-montecarlodelta4"><span class="math display">\[
\frac{\partial }{\partial S} \mathrm{e}^{-rT}\\E^R \big[\max(0,S_T-K)\big] = \mathrm{e}^{-rT}\\E^R  \left[ \frac{\partial }{\partial S} \max(0,S_T-K)\right]\;.
\qquad(12.6)\]</span></span></p>
<p>The delta estimate <span class="math inline">\((C_u-C_d)/(S_u-S_d)\)</span> replaces the mean <span class="math inline">\(\\E^R\)</span> with the sample mean and replaces <span id="eq-montecarlodelta3"><span class="math display">\[
\frac{\partial }{\partial S} \max(0,S_T-K)
\qquad(12.7)\]</span></span></p>
<p>with the ratio <a href="#eq-montecarlodelta2" class="quarto-xref">Equation&nbsp;<span>12.5</span></a>. The derivative <a href="#eq-montecarlodelta3" class="quarto-xref">Equation&nbsp;<span>12.7</span></a> takes on two possible values, depending on <span class="math inline">\(S_T\)</span>—we can ignore the case <span class="math inline">\(S_T=K\)</span> because it occurs with zero probability:</p>
<ul>
<li>If <span class="math inline">\(S_T &lt; K\)</span>, then <span class="math inline">\(\max(0,S_T-K) = 0\)</span> and the derivative is zero.</li>
<li>If <span class="math inline">\(S_T&gt;K\)</span>, then <span class="math inline">\(\max(0,S_T-K) = S_T-K\)</span> and the derivative equals <span class="math display">\[\frac{\partial S_T}{\partial S}=\mathrm{e}^{(r-q-\sigma^2/2)T + \sigma B_T} = \frac{S_T}{S}\; .\]</span></li>
</ul>
<p>Therefore, the true delta—the expectation <a href="#eq-montecarlodelta4" class="quarto-xref">Equation&nbsp;<span>12.6</span></a>—equals<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> <span id="eq-montecarlodelta5"><span class="math display">\[
\mathrm{e}^{-rT}\\E^R\left[\frac{S_T}{S} x\right]\;,
\qquad(12.8)\]</span></span></p>
<p>where <span class="math inline">\(x\)</span> is the random variable defined as <span class="math display">\[\begin{equation*}
x =  \begin{cases} 1 &amp; \text{if $S_T&gt;K$}\; ,\\
0 &amp; \text{otherwise}\;.
\end{cases}
\end{equation*}\]</span> On the other hand, our analysis of the ratio <a href="#eq-montecarlodelta2" class="quarto-xref">Equation&nbsp;<span>12.5</span></a> shows that the expected value of the delta estimate <span class="math inline">\((C_u-C_d)/(S_u-S_d)\)</span> is <span id="eq-montecarlodelta6"><span class="math display">\[
\mathrm{e}^{-rT}\\E^R\left[\frac{S_T}{S} y\right] + \mathrm{e}^{-rT}\\E^R\left[\frac{S_uS_T-SK}{S(S_u-S_d)}z\right]\;,
\qquad(12.9)\]</span></span></p>
<p>where <span class="math display">\[
\begin{align*}
y &amp;=  \begin{cases} 1 &amp; \text{if} S_d(T)&gt;K\; ,\\
0 &amp; \text{otherwise}\;.
\end{cases}
\end{align*}
\]</span> and <span class="math display">\[
\begin{align*}
z &amp;=  \begin{cases} 1 &amp; \text{if} S_u(T)&gt;K&gt;S_d(T)\; ,\\
0 &amp; \text{otherwise}\;.
\end{cases}
\end{align*}
\]</span> To contrast <a href="#eq-montecarlodelta5" class="quarto-xref">Equation&nbsp;<span>12.8</span></a> and <a href="#eq-montecarlodelta6" class="quarto-xref">Equation&nbsp;<span>12.9</span></a>, note that if <span class="math inline">\(y=1\)</span> then <span class="math inline">\(x=1\)</span>, so the term <span class="math inline">\(\\E^R\left[\frac{S_T}{S} y\right]\)</span> in <a href="#eq-montecarlodelta6" class="quarto-xref">Equation&nbsp;<span>12.9</span></a> is part of <a href="#eq-montecarlodelta5" class="quarto-xref">Equation&nbsp;<span>12.8</span></a>. However, there are two partially offsetting errors in <a href="#eq-montecarlodelta6" class="quarto-xref">Equation&nbsp;<span>12.9</span></a>: <span class="math inline">\(z\)</span> sometimes equals one when <span class="math inline">\(x\)</span> is zero, and when both <span class="math inline">\(z\)</span> and <span class="math inline">\(x\)</span> are one, then the factor multiplying <span class="math inline">\(z\)</span> is smaller than the factor multiplying <span class="math inline">\(x\)</span>. In any case, the expected value <a href="#eq-montecarlodelta6" class="quarto-xref">Equation&nbsp;<span>12.9</span></a> is not the same as the true delta <a href="#eq-montecarlodelta5" class="quarto-xref">Equation&nbsp;<span>12.8</span></a>. As noted before, this implies that the delta estimate will be incorrect even if its standard error is zero. The bias can be made as small as one wishes by taking the magnitude <span class="math inline">\(S_u-S_d\)</span> of the perturbation to be small, but taking the perturbation to be very small will introduce unacceptable roundoff error.</p>
<p>The obvious way to estimate the delta in this situation is simply to compute the discounted sample average of <span class="math inline">\([S_T/S]x\)</span>. This is called a pathwise estimate of the delta, because it only uses the sample paths of <span class="math inline">\(S_t\)</span> rather than considering up and down perturbations. This method is due to Broadie and Glasserman <span class="citation" data-cites="bg2">(<a href="#ref-bg2" role="doc-biblioref">Broadie and Glasserman 1996</a>)</span>. Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.</p>
<p>To compute pathwise estimates in other models and for other Greeks, we need the Greek to be an expectation as on the right-hand side of <a href="#eq-montecarlodelta4" class="quarto-xref">Equation&nbsp;<span>12.6</span></a>. Additional examples can be found in Glasserman <span class="citation" data-cites="Glasserman">(<a href="#ref-Glasserman" role="doc-biblioref">Glasserman 2004</a>)</span> and J<span class="math inline">\(\ddot{\text{a}}\)</span>ckel <span class="citation" data-cites="Jackel">(<a href="#ref-Jackel" role="doc-biblioref">Jäckel 2002</a>)</span>.</p>
</section>
<section id="monte-carlo-models-for-path-dependent-options" class="level2" data-number="12.6">
<h2 data-number="12.6" class="anchored" data-anchor-id="monte-carlo-models-for-path-dependent-options"><span class="header-section-number">12.6</span> Monte Carlo Models for Path-Dependent Options</h2>
<p>A derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length <span class="math inline">\(\Delta t = T/N\)</span> for some integer <span class="math inline">\(N\)</span>. Under the risk-neutral probability, the logarithm of the stock price changes over such a time period by <span id="eq-pathdependent"><span class="math display">\[
\Delta \log S = \nu\,\Delta t + \sigma\sqrt{\Delta t}\,z\;,
\qquad(12.10)\]</span></span></p>
<p>where <span class="math inline">\(\nu = r-q-\sigma^2/2\)</span> and <span class="math inline">\(z\)</span> is a standard normal. Given that there are <span class="math inline">\(N\)</span> time periods of length <span class="math inline">\(\Delta t\)</span>, we need to generate <span class="math inline">\(N\)</span> standard normals to generate a stock price path. If we generate <span class="math inline">\(M\)</span> paths to obtain a sample of <span class="math inline">\(M\)</span> option values, then we will need to generate <span class="math inline">\(MN\)</span> standard normals.</p>
<p>Consider for example a floating-strike lookback call. The formula for this option given in <a href="Chapter_Exotics.html#sec-s:lookbacks" class="quarto-xref"><span>Section 11.2</span></a> assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing <span class="math inline">\(\Delta t\)</span> to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting <span class="math inline">\(N\)</span> to be the number of weeks before the option matures.</p>
<p>For most path dependent options, a possible starting point is to generate an array of <span class="math inline">\(n\)</span> paths but since we want the entire path we choose the number of time steps that is appropriate for our application. We can use the same code as in @#sec-s:mc_europeans if we are working in a Black Scholes setting.</p>
<div id="bedf9bd1" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="bedf9bd1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="bedf9bd1-1"><a href="#bedf9bd1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate Geometric Brownian Motion</span></span>
<span id="bedf9bd1-2"><a href="#bedf9bd1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="bedf9bd1-3"><a href="#bedf9bd1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="bedf9bd1-4"><a href="#bedf9bd1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="bedf9bd1-5"><a href="#bedf9bd1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="bedf9bd1-6"><a href="#bedf9bd1-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="bedf9bd1-7"><a href="#bedf9bd1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># number of divisions</span></span>
<span id="bedf9bd1-8"><a href="#bedf9bd1-8" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1000</span></span>
<span id="bedf9bd1-9"><a href="#bedf9bd1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)</span></span>
<span id="bedf9bd1-10"><a href="#bedf9bd1-10" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="bedf9bd1-11"><a href="#bedf9bd1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividend yield</span></span>
<span id="bedf9bd1-12"><a href="#bedf9bd1-12" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="bedf9bd1-13"><a href="#bedf9bd1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="bedf9bd1-14"><a href="#bedf9bd1-14" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="bedf9bd1-15"><a href="#bedf9bd1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Stock Price</span></span>
<span id="bedf9bd1-16"><a href="#bedf9bd1-16" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">42</span></span>
<span id="bedf9bd1-17"><a href="#bedf9bd1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturity</span></span>
<span id="bedf9bd1-18"><a href="#bedf9bd1-18" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="bedf9bd1-19"><a href="#bedf9bd1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Strike Price</span></span>
<span id="bedf9bd1-20"><a href="#bedf9bd1-20" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">40</span></span>
<span id="bedf9bd1-21"><a href="#bedf9bd1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta t</span></span>
<span id="bedf9bd1-22"><a href="#bedf9bd1-22" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> m</span>
<span id="bedf9bd1-23"><a href="#bedf9bd1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Drift</span></span>
<span id="bedf9bd1-24"><a href="#bedf9bd1-24" aria-hidden="true" tabindex="-1"></a>drift <span class="op">=</span> r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig<span class="op">**</span><span class="dv">2</span></span>
<span id="bedf9bd1-25"><a href="#bedf9bd1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="bedf9bd1-26"><a href="#bedf9bd1-26" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> sig <span class="op">*</span> np.sqrt(dt)</span>
<span id="bedf9bd1-27"><a href="#bedf9bd1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="bedf9bd1-28"><a href="#bedf9bd1-28" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>, m <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">*</span> dt</span>
<span id="bedf9bd1-29"><a href="#bedf9bd1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="bedf9bd1-30"><a href="#bedf9bd1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># seed for random generator</span></span>
<span id="bedf9bd1-31"><a href="#bedf9bd1-31" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">2024</span></span>
<span id="bedf9bd1-32"><a href="#bedf9bd1-32" aria-hidden="true" tabindex="-1"></a><span class="co"># define a random generator</span></span>
<span id="bedf9bd1-33"><a href="#bedf9bd1-33" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="bedf9bd1-34"><a href="#bedf9bd1-34" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="bedf9bd1-35"><a href="#bedf9bd1-35" aria-hidden="true" tabindex="-1"></a>inc[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>vol, size<span class="op">=</span>(n, m)))</span>
<span id="bedf9bd1-36"><a href="#bedf9bd1-36" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="bedf9bd1-37"><a href="#bedf9bd1-37" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> S0 <span class="op">*</span> np.exp(np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="bedf9bd1-38"><a href="#bedf9bd1-38" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As before this code generates two samples the original and the antithetic. The output is an array of <span class="math inline">\(n\)</span> sample paths with <span class="math inline">\(m\)</span> time steps. The sample can also be used to find the value of a floating strike lookback call.</p>
<div id="2829c41c" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="2829c41c"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="2829c41c-1"><a href="#2829c41c-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> floating_strike_call(S, r, sigma, q, T, SMin):</span>
<span id="2829c41c-2"><a href="#2829c41c-2" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S <span class="op">/</span> SMin) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="2829c41c-3"><a href="#2829c41c-3" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="2829c41c-4"><a href="#2829c41c-4" aria-hidden="true" tabindex="-1"></a>    d2prime <span class="op">=</span> (np.log(SMin <span class="op">/</span> S) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="2829c41c-5"><a href="#2829c41c-5" aria-hidden="true" tabindex="-1"></a>    N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="2829c41c-6"><a href="#2829c41c-6" aria-hidden="true" tabindex="-1"></a>    N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="2829c41c-7"><a href="#2829c41c-7" aria-hidden="true" tabindex="-1"></a>    N2prime <span class="op">=</span> norm.cdf(d2prime)</span>
<span id="2829c41c-8"><a href="#2829c41c-8" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (r <span class="op">-</span> q) <span class="op">/</span> (sigma<span class="op">**</span><span class="dv">2</span>)</span>
<span id="2829c41c-9"><a href="#2829c41c-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="2829c41c-10"><a href="#2829c41c-10" aria-hidden="true" tabindex="-1"></a>        np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> N1</span>
<span id="2829c41c-11"><a href="#2829c41c-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> SMin <span class="op">*</span> N2</span>
<span id="2829c41c-12"><a href="#2829c41c-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> (<span class="dv">1</span> <span class="op">/</span> x) <span class="op">*</span> (SMin <span class="op">/</span> S) <span class="op">**</span> x <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> SMin <span class="op">*</span> N2prime</span>
<span id="2829c41c-13"><a href="#2829c41c-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span> (<span class="dv">1</span> <span class="op">/</span> x) <span class="op">*</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> N1)</span>
<span id="2829c41c-14"><a href="#2829c41c-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="2829c41c-15"><a href="#2829c41c-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="2829c41c-16"><a href="#2829c41c-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="2829c41c-17"><a href="#2829c41c-17" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="dv">100</span></span>
<span id="2829c41c-18"><a href="#2829c41c-18" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="2829c41c-19"><a href="#2829c41c-19" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="2829c41c-20"><a href="#2829c41c-20" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="2829c41c-21"><a href="#2829c41c-21" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">1</span></span>
<span id="2829c41c-22"><a href="#2829c41c-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="2829c41c-23"><a href="#2829c41c-23" aria-hidden="true" tabindex="-1"></a>Stmin <span class="op">=</span> St[m:] <span class="op">-</span> np.minimum(np.<span class="bu">min</span>(St, axis<span class="op">=</span><span class="dv">0</span>), S0)</span>
<span id="2829c41c-24"><a href="#2829c41c-24" aria-hidden="true" tabindex="-1"></a>St1min <span class="op">=</span> St1[m:] <span class="op">-</span> np.minimum(np.<span class="bu">min</span>(St1, axis<span class="op">=</span><span class="dv">0</span>), S0)</span>
<span id="2829c41c-25"><a href="#2829c41c-25" aria-hidden="true" tabindex="-1"></a>floatlkbk <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(Stmin)</span>
<span id="2829c41c-26"><a href="#2829c41c-26" aria-hidden="true" tabindex="-1"></a>floatlkbk1 <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(St1min)</span>
<span id="2829c41c-27"><a href="#2829c41c-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="2829c41c-28"><a href="#2829c41c-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first estimate is="</span>, floatlkbk)</span>
<span id="2829c41c-29"><a href="#2829c41c-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second estimate is="</span>, floatlkbk1)</span>
<span id="2829c41c-30"><a href="#2829c41c-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average estimate is="</span>, (floatlkbk <span class="op">+</span> floatlkbk1) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="2829c41c-31"><a href="#2829c41c-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The exact formula is="</span>, floating_strike_call(S0, r, sigma, <span class="dv">0</span>, T, S0))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 5.45244209168367
The second estimate is= 5.468030697490039
The average estimate is= 5.460236394586854
The exact formula is= 7.231056939691567</code></pre>
</div>
</div>
<p>To value the fixed strike lookback call option with time <span class="math inline">\(T\)</span> payoff <span class="math inline">\(\max(\max_{0\le t \le T} S_t.0)\)</span>, we simply add the following</p>
<div id="b5a7166a" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="b5a7166a"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="b5a7166a-1"><a href="#b5a7166a-1" aria-hidden="true" tabindex="-1"></a>Stmax <span class="op">=</span> np.maximum(np.<span class="bu">max</span>(St, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="b5a7166a-2"><a href="#b5a7166a-2" aria-hidden="true" tabindex="-1"></a>St1max <span class="op">=</span> np.maximum(np.<span class="bu">max</span>(St1, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="b5a7166a-3"><a href="#b5a7166a-3" aria-hidden="true" tabindex="-1"></a>lookbck <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(Stmax)</span>
<span id="b5a7166a-4"><a href="#b5a7166a-4" aria-hidden="true" tabindex="-1"></a>lookbck1 <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(St1max)</span>
<span id="b5a7166a-5"><a href="#b5a7166a-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first estimate is="</span>, lookbck)</span>
<span id="b5a7166a-6"><a href="#b5a7166a-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second estimate is="</span>, lookbck1)</span>
<span id="b5a7166a-7"><a href="#b5a7166a-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average estimate is="</span>, (lookbck <span class="op">+</span> lookbck1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 7.716467940991822
The second estimate is= 7.769558237964809
The average estimate is= 7.743013089478316</code></pre>
</div>
</div>
<p>Asian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks.</p>
<p>As another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let <span class="math inline">\(\tau\)</span> denote the amount of time that has elapsed since the call was issued and <span class="math inline">\(T\)</span> the amount of time remaining before maturity, so the total maturity of the call is <span class="math inline">\(T+\tau\)</span>. To simplify somewhat, assume date <span class="math inline">\(0\)</span> is the beginning of a period between observations. Let <span class="math inline">\(t_1, \ldots, t_N\)</span> denote the remaining sampling dates, with <span class="math inline">\(t_1 = \Delta t\)</span>, <span class="math inline">\(t_i-t_{i-1}=\Delta t = T/N\)</span> for each <span class="math inline">\(i\)</span>, and <span class="math inline">\(t_N=T\)</span>. We will input the average price <span class="math inline">\(A_0\)</span> computed up to date <span class="math inline">\(0\)</span>, assuming this average includes the price <span class="math inline">\(S_0\)</span> at date <span class="math inline">\(0\)</span>. The average price at date <span class="math inline">\(T\)</span> will be <span class="math display">\[
A_T = \frac{\tau}{T+\tau}A_0 + \frac{T}{T+\tau}\left(\frac{\sum_{i=1}^N S_{t_i}}{N}\right)\;.
\]</span> The average-price call pays <span class="math inline">\(\max(0,A_T-K)\)</span> at its maturity <span class="math inline">\(T\)</span>, and we can write this as <span class="math display">\[\begin{align*}
\max(A_T-K,0) &amp;= \max\left(\frac{T}{T+\tau}\left( \frac{\sum_{i=1}^N S_{t_i}}{N}\right) - \left(K - \frac{\tau}{T+\tau}A_0\right), 0\right)\\
&amp;= \frac{T}{T+\tau} \max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\;,
\end{align*}\]</span> where <span class="math display">\[
K^* = \frac{T+\tau}{T}K - \frac{\tau}{T}A_0\;.
\]</span> Therefore, the value at date <span class="math inline">\(0\)</span> of the discretely-sampled average-price call is <span class="math display">\[
\frac{T}{T+\tau} \,\mathrm{e}^{-rT} \\E^R\left[\max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\right]\;.
\]</span> In terms of the discussion above, the random variable the mean of which we want to estimate is <span class="math display">\[
x = \mathrm{e}^{-rT}\max \left(\frac{\sum_{i=1}^N S_{t_i}}{N} - K^*,0\right)\;.
\]</span> A random variable <span class="math inline">\(y\)</span> that will be closely correlated to <span class="math inline">\(x\)</span> is <span class="math display">\[
y =\mathrm{e}^{-rT}\max \left(\mathrm{e}^{\sum_{i=1}^N \log S_{t_i}/N} - K^*,0\right)\;.
\]</span> The mean <span class="math inline">\(\phi\)</span> of <span class="math inline">\(y\)</span> under the risk-neutral probability is given in the pricing <a href="Chapter_Asians.html#eq-disc_geom_avg_call" class="quarto-xref">Equation&nbsp;<span>10.7</span></a>. We can use the sample mean of <span class="math inline">\(y\)</span> and its known mean <span class="math inline">\(\phi\)</span> to adjust the sample mean of <span class="math inline">\(x\)</span> as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient <span class="math inline">\(\hat{\beta}\)</span> will be quite close to 1.</p>
<p>Again we can get a sample of payoffs using our stock price samples.</p>
<div id="b02eb289" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="b02eb289"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="b02eb289-1"><a href="#b02eb289-1" aria-hidden="true" tabindex="-1"></a>average <span class="op">=</span> np.mean(St, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="b02eb289-2"><a href="#b02eb289-2" aria-hidden="true" tabindex="-1"></a>average1 <span class="op">=</span> np.mean(St1, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="b02eb289-3"><a href="#b02eb289-3" aria-hidden="true" tabindex="-1"></a>dpayoff <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(np.maximum(average <span class="op">-</span> K, <span class="dv">0</span>))</span>
<span id="b02eb289-4"><a href="#b02eb289-4" aria-hidden="true" tabindex="-1"></a>dpayoff1 <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(np.maximum(average1 <span class="op">-</span> K, <span class="dv">0</span>))</span>
<span id="b02eb289-5"><a href="#b02eb289-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first estimate is="</span>, dpayoff)</span>
<span id="b02eb289-6"><a href="#b02eb289-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second estimate is="</span>, dpayoff1)</span>
<span id="b02eb289-7"><a href="#b02eb289-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the estimates="</span>, (dpayoff <span class="op">+</span> dpayoff1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is= 3.231154315344899
The second estimate is= 3.296876297130776
The average of the estimates= 3.2640153062378374</code></pre>
</div>
</div>
<p>We now construct a control variate, the geometric asian option which has a known formula for its value.</p>
<div id="03f2c372" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="03f2c372"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="03f2c372-1"><a href="#03f2c372-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S, K, r, sigma, q, T):</span>
<span id="03f2c372-2"><a href="#03f2c372-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="03f2c372-3"><a href="#03f2c372-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="03f2c372-4"><a href="#03f2c372-4" aria-hidden="true" tabindex="-1"></a><span class="co">    S = initial stock price</span></span>
<span id="03f2c372-5"><a href="#03f2c372-5" aria-hidden="true" tabindex="-1"></a><span class="co">    K = strike price</span></span>
<span id="03f2c372-6"><a href="#03f2c372-6" aria-hidden="true" tabindex="-1"></a><span class="co">    r = risk-free rate</span></span>
<span id="03f2c372-7"><a href="#03f2c372-7" aria-hidden="true" tabindex="-1"></a><span class="co">    sigma = volatility</span></span>
<span id="03f2c372-8"><a href="#03f2c372-8" aria-hidden="true" tabindex="-1"></a><span class="co">    q = dividend yield</span></span>
<span id="03f2c372-9"><a href="#03f2c372-9" aria-hidden="true" tabindex="-1"></a><span class="co">    T = time to maturity</span></span>
<span id="03f2c372-10"><a href="#03f2c372-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="03f2c372-11"><a href="#03f2c372-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sigma <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="03f2c372-12"><a href="#03f2c372-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(<span class="dv">0</span>, np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K)</span>
<span id="03f2c372-13"><a href="#03f2c372-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="03f2c372-14"><a href="#03f2c372-14" aria-hidden="true" tabindex="-1"></a>        d1 <span class="op">=</span> (np.log(S <span class="op">/</span> K) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T) <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="03f2c372-15"><a href="#03f2c372-15" aria-hidden="true" tabindex="-1"></a>        d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="03f2c372-16"><a href="#03f2c372-16" aria-hidden="true" tabindex="-1"></a>        N1 <span class="op">=</span> norm.cdf(d1)</span>
<span id="03f2c372-17"><a href="#03f2c372-17" aria-hidden="true" tabindex="-1"></a>        N2 <span class="op">=</span> norm.cdf(d2)</span>
<span id="03f2c372-18"><a href="#03f2c372-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>q <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> N1 <span class="op">-</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> K <span class="op">*</span> N2</span>
<span id="03f2c372-19"><a href="#03f2c372-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="03f2c372-20"><a href="#03f2c372-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="03f2c372-21"><a href="#03f2c372-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> discrete_geom_average_price_call(S, K, r, sigma, q, T, N):</span>
<span id="03f2c372-22"><a href="#03f2c372-22" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="03f2c372-23"><a href="#03f2c372-23" aria-hidden="true" tabindex="-1"></a>    nu <span class="op">=</span> r <span class="op">-</span> q <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span></span>
<span id="03f2c372-24"><a href="#03f2c372-24" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> N <span class="op">*</span> (N <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">6</span></span>
<span id="03f2c372-25"><a href="#03f2c372-25" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> S <span class="op">*</span> np.exp(((N <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> nu <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> a <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> N<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span> dt)</span>
<span id="03f2c372-26"><a href="#03f2c372-26" aria-hidden="true" tabindex="-1"></a>    sigavg <span class="op">=</span> sigma <span class="op">*</span> np.sqrt(a) <span class="op">/</span> (N<span class="op">**</span><span class="fl">1.5</span>)</span>
<span id="03f2c372-27"><a href="#03f2c372-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> black_scholes_call(V, K, r, sigavg, q, T)</span>
<span id="03f2c372-28"><a href="#03f2c372-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="03f2c372-29"><a href="#03f2c372-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="03f2c372-30"><a href="#03f2c372-30" aria-hidden="true" tabindex="-1"></a>geom <span class="op">=</span> np.exp((np.mean(np.log(St), axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="03f2c372-31"><a href="#03f2c372-31" aria-hidden="true" tabindex="-1"></a>geom1 <span class="op">=</span> np.exp((np.mean(np.log(St1), axis<span class="op">=</span><span class="dv">0</span>)))</span>
<span id="03f2c372-32"><a href="#03f2c372-32" aria-hidden="true" tabindex="-1"></a>geomavgpo <span class="op">=</span> np.maximum(geom <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="03f2c372-33"><a href="#03f2c372-33" aria-hidden="true" tabindex="-1"></a>geomavg1po <span class="op">=</span> np.maximum(geom1 <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="03f2c372-34"><a href="#03f2c372-34" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> np.mean(geomavgpo) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="03f2c372-35"><a href="#03f2c372-35" aria-hidden="true" tabindex="-1"></a>value1 <span class="op">=</span> np.mean(geomavg1po) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="03f2c372-36"><a href="#03f2c372-36" aria-hidden="true" tabindex="-1"></a>tga <span class="op">=</span> discrete_geom_average_price_call(S0, K, r, sigma, q, T, m)</span>
<span id="03f2c372-37"><a href="#03f2c372-37" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> tga <span class="op">-</span> value</span>
<span id="03f2c372-38"><a href="#03f2c372-38" aria-hidden="true" tabindex="-1"></a>error1 <span class="op">=</span> tga <span class="op">-</span> value1</span>
<span id="03f2c372-39"><a href="#03f2c372-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The estimate from the first sample="</span>, value)</span>
<span id="03f2c372-40"><a href="#03f2c372-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The estimate from the second sample="</span>, value1)</span>
<span id="03f2c372-41"><a href="#03f2c372-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the two estimates is="</span>, (value <span class="op">+</span> value1) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="03f2c372-42"><a href="#03f2c372-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The value from the exact formula="</span>, tga)</span>
<span id="03f2c372-43"><a href="#03f2c372-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The error in the first estimate="</span>, error)</span>
<span id="03f2c372-44"><a href="#03f2c372-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The error in the second estimate="</span>, error1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The estimate from the first sample= 3.1720760499976968
The estimate from the second sample= 3.2365667951725428
The average of the two estimates is= 3.20432142258512
The value from the exact formula= 2.6835589764289125
The error in the first estimate= -0.48851707356878427
The error in the second estimate= -0.5530078187436303</code></pre>
</div>
</div>
<p>Next we estimate the beta. As discussed before, we could simply set beta=1. Alternatively, if we estimate beta from the simulated sample, then our update could be biased. Instead we compute an independent sample from which we estimate beta. We then estimate the updated estimate for both samples from the formula <span class="math display">\[
\text{new estimate} = \text{original estimate} + \beta * \text{error}
\]</span></p>
<div id="a8e6f3c4" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="a8e6f3c4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="a8e6f3c4-1"><a href="#a8e6f3c4-1" aria-hidden="true" tabindex="-1"></a>incpre <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="a8e6f3c4-2"><a href="#a8e6f3c4-2" aria-hidden="true" tabindex="-1"></a>incpre[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>vol, size<span class="op">=</span>(n, m)))</span>
<span id="a8e6f3c4-3"><a href="#a8e6f3c4-3" aria-hidden="true" tabindex="-1"></a>Stpre <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="a8e6f3c4-4"><a href="#a8e6f3c4-4" aria-hidden="true" tabindex="-1"></a>St1pre <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="a8e6f3c4-5"><a href="#a8e6f3c4-5" aria-hidden="true" tabindex="-1"></a>Stpre <span class="op">=</span> S0 <span class="op">*</span> np.exp(np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="a8e6f3c4-6"><a href="#a8e6f3c4-6" aria-hidden="true" tabindex="-1"></a>St1pre <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="a8e6f3c4-7"><a href="#a8e6f3c4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="a8e6f3c4-8"><a href="#a8e6f3c4-8" aria-hidden="true" tabindex="-1"></a>amean <span class="op">=</span> np.mean(Stpre, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="a8e6f3c4-9"><a href="#a8e6f3c4-9" aria-hidden="true" tabindex="-1"></a>amean1 <span class="op">=</span> np.mean(St1pre, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="a8e6f3c4-10"><a href="#a8e6f3c4-10" aria-hidden="true" tabindex="-1"></a>apo <span class="op">=</span> np.maximum(amean <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="a8e6f3c4-11"><a href="#a8e6f3c4-11" aria-hidden="true" tabindex="-1"></a>a1po <span class="op">=</span> np.maximum(amean1 <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="a8e6f3c4-12"><a href="#a8e6f3c4-12" aria-hidden="true" tabindex="-1"></a>gmean <span class="op">=</span> np.exp(np.mean(np.log(St), axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="a8e6f3c4-13"><a href="#a8e6f3c4-13" aria-hidden="true" tabindex="-1"></a>g1mean <span class="op">=</span> np.exp(np.mean(np.log(St1), axis<span class="op">=</span><span class="dv">0</span>))</span>
<span id="a8e6f3c4-14"><a href="#a8e6f3c4-14" aria-hidden="true" tabindex="-1"></a>gpo <span class="op">=</span> np.maximum(gmean <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="a8e6f3c4-15"><a href="#a8e6f3c4-15" aria-hidden="true" tabindex="-1"></a>g1po <span class="op">=</span> np.maximum(g1mean <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="a8e6f3c4-16"><a href="#a8e6f3c4-16" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> np.cov(gpo, apo)[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">/</span> np.cov(gpo, apo)[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="a8e6f3c4-17"><a href="#a8e6f3c4-17" aria-hidden="true" tabindex="-1"></a>beta1 <span class="op">=</span> np.cov(g1po, a1po)[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">/</span> np.cov(g1po, a1po)[<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="a8e6f3c4-18"><a href="#a8e6f3c4-18" aria-hidden="true" tabindex="-1"></a>update <span class="op">=</span> dpayoff <span class="op">+</span> beta <span class="op">*</span> error</span>
<span id="a8e6f3c4-19"><a href="#a8e6f3c4-19" aria-hidden="true" tabindex="-1"></a>update1 <span class="op">=</span> dpayoff1 <span class="op">+</span> beta1 <span class="op">*</span> error1</span>
<span id="a8e6f3c4-20"><a href="#a8e6f3c4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="a8e6f3c4-21"><a href="#a8e6f3c4-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The updated estimate for the first sample="</span>, update)</span>
<span id="a8e6f3c4-22"><a href="#a8e6f3c4-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The updated value for the second sample="</span>, update1)</span>
<span id="a8e6f3c4-23"><a href="#a8e6f3c4-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the updated values is="</span>, (update <span class="op">+</span> update1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The updated estimate for the first sample= 2.7518403446698487
The updated value for the second sample= 2.753892523558269
The average of the updated values is= 2.752866434114059</code></pre>
</div>
</div>
</section>
<section id="sec-montecarlomultiple" class="level2" data-number="12.7">
<h2 data-number="12.7" class="anchored" data-anchor-id="sec-montecarlomultiple"><span class="header-section-number">12.7</span> Monte Carlo Valuation of Basket and Spread Options</h2>
<p> In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. There are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.</p>
<p>The difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral probability). In an <span class="math inline">\(N\)</span>–period model, the binomial model produces <span class="math inline">\(N+1\)</span> values for the terminal price of each underlying asset. Letting <span class="math inline">\(k\)</span> denote the number of underlying assets, this produces <span class="math inline">\((N+1)^k\)</span> combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces <span class="math inline">\(M\)</span> combinations of terminal prices, where <span class="math inline">\(M\)</span> is the number of simulations. Each combination is given the same weight (<span class="math inline">\(1/M\)</span>) when estimating the expected value.</p>
<p>With a single underlying asset, the binomial model is more efficient, as discussed in <a href="Chapter_Binomial.html#sec-s:introbinomial" class="quarto-xref"><span>Section 13.1</span></a>, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the <span class="math inline">\((N+1)^k\)</span> combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.</p>
<p>To implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. We can simulate the changes in two Brownian motions <span class="math inline">\(B_1\)</span> and <span class="math inline">\(B_2\)</span> that have correlation <span class="math inline">\(\rho\)</span> by generating two independent standard normals <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> and defining <span class="math display">\[
\Delta B_1 = \sqrt{\Delta t}\,Z_1\;, \qquad \text{and} \qquad \Delta B_2 = \sqrt{\Delta t}\,Z\; ,
\]</span> where <span class="math inline">\(Z\)</span> is defined as <span class="math display">\[
Z = \rho Z_1 + \sqrt{1-\rho^2}\,Z_2\;.
\]</span> The random variable <span class="math inline">\(Z\)</span> is also a standard normal, and the correlation between <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z\)</span> is <span class="math inline">\(\rho\)</span>.</p>
<div id="3dfdd99e" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="3dfdd99e"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="3dfdd99e-1"><a href="#3dfdd99e-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate 2 Geometric Brownian Motions</span></span>
<span id="3dfdd99e-2"><a href="#3dfdd99e-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="3dfdd99e-3"><a href="#3dfdd99e-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="3dfdd99e-4"><a href="#3dfdd99e-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="3dfdd99e-5"><a href="#3dfdd99e-5" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="3dfdd99e-6"><a href="#3dfdd99e-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">1000</span></span>
<span id="3dfdd99e-7"><a href="#3dfdd99e-7" aria-hidden="true" tabindex="-1"></a><span class="co"># number of divisions</span></span>
<span id="3dfdd99e-8"><a href="#3dfdd99e-8" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1000</span></span>
<span id="3dfdd99e-9"><a href="#3dfdd99e-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)</span></span>
<span id="3dfdd99e-10"><a href="#3dfdd99e-10" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="3dfdd99e-11"><a href="#3dfdd99e-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Dividend yield</span></span>
<span id="3dfdd99e-12"><a href="#3dfdd99e-12" aria-hidden="true" tabindex="-1"></a>q1 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="3dfdd99e-13"><a href="#3dfdd99e-13" aria-hidden="true" tabindex="-1"></a>q2 <span class="op">=</span> <span class="dv">0</span></span>
<span id="3dfdd99e-14"><a href="#3dfdd99e-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="3dfdd99e-15"><a href="#3dfdd99e-15" aria-hidden="true" tabindex="-1"></a>sig1 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="3dfdd99e-16"><a href="#3dfdd99e-16" aria-hidden="true" tabindex="-1"></a>sig2 <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="3dfdd99e-17"><a href="#3dfdd99e-17" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation</span></span>
<span id="3dfdd99e-18"><a href="#3dfdd99e-18" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="3dfdd99e-19"><a href="#3dfdd99e-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial Stock Price</span></span>
<span id="3dfdd99e-20"><a href="#3dfdd99e-20" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">42</span></span>
<span id="3dfdd99e-21"><a href="#3dfdd99e-21" aria-hidden="true" tabindex="-1"></a>V0 <span class="op">=</span> <span class="dv">50</span></span>
<span id="3dfdd99e-22"><a href="#3dfdd99e-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturity</span></span>
<span id="3dfdd99e-23"><a href="#3dfdd99e-23" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="3dfdd99e-24"><a href="#3dfdd99e-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="3dfdd99e-25"><a href="#3dfdd99e-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Delta t</span></span>
<span id="3dfdd99e-26"><a href="#3dfdd99e-26" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> m</span>
<span id="3dfdd99e-27"><a href="#3dfdd99e-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Drift</span></span>
<span id="3dfdd99e-28"><a href="#3dfdd99e-28" aria-hidden="true" tabindex="-1"></a>drift1 <span class="op">=</span> r <span class="op">-</span> q1 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig1<span class="op">**</span><span class="dv">2</span></span>
<span id="3dfdd99e-29"><a href="#3dfdd99e-29" aria-hidden="true" tabindex="-1"></a>drift2 <span class="op">=</span> r <span class="op">-</span> q2 <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sig2<span class="op">**</span><span class="dv">2</span></span>
<span id="3dfdd99e-30"><a href="#3dfdd99e-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Volatility</span></span>
<span id="3dfdd99e-31"><a href="#3dfdd99e-31" aria-hidden="true" tabindex="-1"></a>vol <span class="op">=</span> np.sqrt(dt)</span>
<span id="3dfdd99e-32"><a href="#3dfdd99e-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="3dfdd99e-33"><a href="#3dfdd99e-33" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">0</span>, m <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">*</span> dt</span>
<span id="3dfdd99e-34"><a href="#3dfdd99e-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="3dfdd99e-35"><a href="#3dfdd99e-35" aria-hidden="true" tabindex="-1"></a><span class="co"># seed for random generator</span></span>
<span id="3dfdd99e-36"><a href="#3dfdd99e-36" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">2024</span></span>
<span id="3dfdd99e-37"><a href="#3dfdd99e-37" aria-hidden="true" tabindex="-1"></a><span class="co"># define a random generator</span></span>
<span id="3dfdd99e-38"><a href="#3dfdd99e-38" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="3dfdd99e-39"><a href="#3dfdd99e-39" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="3dfdd99e-40"><a href="#3dfdd99e-40" aria-hidden="true" tabindex="-1"></a>inc[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>vol, size<span class="op">=</span>(n, m)))</span>
<span id="3dfdd99e-41"><a href="#3dfdd99e-41" aria-hidden="true" tabindex="-1"></a>inc1 <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="3dfdd99e-42"><a href="#3dfdd99e-42" aria-hidden="true" tabindex="-1"></a>inc1[<span class="dv">1</span>:] <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>vol, size<span class="op">=</span>(n, m)))</span>
<span id="3dfdd99e-43"><a href="#3dfdd99e-43" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="3dfdd99e-44"><a href="#3dfdd99e-44" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> rho <span class="op">*</span> inc <span class="op">+</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> rho<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> inc1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Thus, we can simulate the changes in the logarithms of two correlated asset prices as <span class="math display">\[\begin{align*}
\Delta \log S_1 &amp;= \nu_1\Delta t + \sigma_1\sqrt{\Delta t}Z_1 \; ,\\
\Delta \log S_2 &amp;= \nu_2\Delta t + \sigma_2\rho\sqrt{\Delta t}Z_1 + \sigma_2\sqrt{1-\rho^2}\sqrt{\Delta t}Z_2\;,
\end{align*}\]</span> where <span class="math inline">\(\nu_i = r-q_1-\sigma_i^2/2\)</span> and the <span class="math inline">\(Z_i\)</span> are independent standard normals.</p>
<div id="c6d5f256" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="c6d5f256"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="c6d5f256-1"><a href="#c6d5f256-1" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="c6d5f256-2"><a href="#c6d5f256-2" aria-hidden="true" tabindex="-1"></a>St2 <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="c6d5f256-3"><a href="#c6d5f256-3" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(sig1 <span class="op">*</span> np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift1 <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="c6d5f256-4"><a href="#c6d5f256-4" aria-hidden="true" tabindex="-1"></a>St2 <span class="op">=</span> V0 <span class="op">*</span> np.exp(sig2 <span class="op">*</span> np.cumsum(incr, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift2 <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We can also construct antithetic variables.</p>
<div id="5351eecb" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="5351eecb"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="5351eecb-1"><a href="#5351eecb-1" aria-hidden="true" tabindex="-1"></a>St1a <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="5351eecb-2"><a href="#5351eecb-2" aria-hidden="true" tabindex="-1"></a>St2a <span class="op">=</span> np.zeros(shape<span class="op">=</span>(m <span class="op">+</span> <span class="dv">1</span>, n))</span>
<span id="5351eecb-3"><a href="#5351eecb-3" aria-hidden="true" tabindex="-1"></a>St1a <span class="op">=</span> S0 <span class="op">*</span> np.exp(<span class="op">-</span>sig1 <span class="op">*</span> np.cumsum(inc, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift1 <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span>
<span id="5351eecb-4"><a href="#5351eecb-4" aria-hidden="true" tabindex="-1"></a>St2a <span class="op">=</span> V0 <span class="op">*</span> np.exp(<span class="op">-</span>sig2 <span class="op">*</span> np.cumsum(incr, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">+</span> (drift2 <span class="op">*</span> t[<span class="dv">0</span> : m <span class="op">+</span> <span class="dv">1</span>])[:, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Given this sample, we can estimate the value of a best of 2 option with payoff <span class="math inline">\(\max(S_{1T},S_{2T})\)</span>.</p>
<div id="7c487e8b" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="7c487e8b"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="7c487e8b-1"><a href="#7c487e8b-1" aria-hidden="true" tabindex="-1"></a>payoff <span class="op">=</span> np.maximum(St1[m, :], St2[m, :])</span>
<span id="7c487e8b-2"><a href="#7c487e8b-2" aria-hidden="true" tabindex="-1"></a>payoffa <span class="op">=</span> np.maximum(St1a[m, :], St2a[m, :])</span>
<span id="7c487e8b-3"><a href="#7c487e8b-3" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(payoff)</span>
<span id="7c487e8b-4"><a href="#7c487e8b-4" aria-hidden="true" tabindex="-1"></a>valuea <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(payoffa)</span>
<span id="7c487e8b-5"><a href="#7c487e8b-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="7c487e8b-6"><a href="#7c487e8b-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first estmate is ="</span>, value)</span>
<span id="7c487e8b-7"><a href="#7c487e8b-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second estimate is ="</span>, valuea)</span>
<span id="7c487e8b-8"><a href="#7c487e8b-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The avergae of the estimates is="</span>, (value <span class="op">+</span> valuea) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estmate is = 50.11374784508302
The second estimate is = 51.46596027225067
The avergae of the estimates is= 50.78985405866685</code></pre>
</div>
</div>
<p>To generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as</p>
<p><span id="eq-mc_twoa"><span class="math display">\[
\Delta \log S_1 = \nu_1\Delta t + a_{11}\sqrt{\Delta t}Z_1 + a_{12}\sqrt{\Delta t}Z_2\;,
\qquad(12.11)\]</span></span></p>
<p><span id="eq-mc_twob"><span class="math display">\[
\Delta \log S_2 = \nu_2\Delta t + a_{21}\sqrt{\Delta t}Z_1 + a_{22}\sqrt{\Delta t}Z_2\;,
\qquad(12.12)\]</span></span></p>
<p>where <span class="math display">\[\begin{array}{rclcrcl}
a_{11}&amp;=&amp;\sigma_1\;, &amp;\qquad &amp; a_{12}&amp;=&amp;0\; ,\\
a_{21}&amp;=&amp;\sigma_2\rho\;, &amp;\qquad &amp; a_{22} &amp;= &amp;\sigma_2\sqrt{1-\rho^2}\;.
\end{array}
\]</span></p>
<p>These are not the only possible choices for the constants <span class="math inline">\(a_{ij}\)</span>. Given that <span class="math inline">\(Z_1\)</span> and <span class="math inline">\(Z_2\)</span> are independent standard normals, the conditions the <span class="math inline">\(a_{ij}\)</span> must satisfy in order to match the variances <span class="math inline">\(\sigma_i^2\Delta t\)</span> and correlation <span class="math inline">\(\rho\)</span> of the changes in the logarithms are</p>
<p><span id="eq-a1"><span class="math display">\[
a_{11}^2+a_{12}^2 =\sigma_1^2\;,
\qquad(12.13)\]</span></span></p>
<p><span id="eq-a2"><span class="math display">\[
a_{21}^2+a_{22}^2 =\sigma_2^2\;,
\qquad(12.14)\]</span></span></p>
<p><span id="eq-a3"><span class="math display">\[
a_{11}a_{21}+a_{12}a_{22} = \sigma_1\sigma_2\rho\;.
\qquad(12.15)\]</span></span></p>
<p>These three equations in the four coefficients <span class="math inline">\(a_{ij}\)</span> leave one degree of freedom. We choose to take <span class="math inline">\(a_{12}=0\)</span> and then solve for the other three.</p>
<p>In matrix notation, the system <a href="#eq-a1" class="quarto-xref">Equation&nbsp;<span>12.13</span></a> - <a href="#eq-a3" class="quarto-xref">Equation&nbsp;<span>12.15</span></a> plus the condition <span class="math inline">\(a_{12}=0\)</span> can be written as the equation <span class="math display">\[
\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}\begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}^\top = \begin{pmatrix}\sigma_1^2 &amp; \rho\sigma_1\sigma_2 \\\rho\sigma_1\sigma_2 &amp; \sigma_2^2\end{pmatrix}\; ,
\]</span> where <span class="math inline">\(^\top\)</span> denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the <span class="math inline">\(a_{ij}\)</span> so that the lower triangular matrix <span class="math display">\[
A \equiv \begin{pmatrix}a_{11} &amp; 0 \\a_{21} &amp; a_{22}\end{pmatrix}
\]</span> satisfies <span class="math display">\[
AA^\top = \text{covariance matrix}
\]</span> is called the the Cholesky decomposition of the covariance matrix. Given any number <span class="math inline">\(L\)</span> of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the <span class="math inline">\(L\times L\)</span> covariance matrix always exists. An algorithm for computing the Cholesky decomposition in numpy is <a href="https://numpy.org/doc/2.2/reference/generated/numpy.linalg.cholesky.html">np.linalg.cholesky</a>.</p>
<p>We can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> If there were some path dependency in the option value, we would simulate the paths of the asset prices as in <a href="#eq-mc_twoa" class="quarto-xref">Equation&nbsp;<span>12.11</span></a> - <a href="#eq-mc_twob" class="quarto-xref">Equation&nbsp;<span>12.12</span></a>. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date <span class="math inline">\(T\)</span>, as in <a href="#sec-s:mc_europeans" class="quarto-xref"><span>Section 12.1</span></a>. The value of a basket call option at its maturity <span class="math inline">\(T\)</span> is <span class="math display">\[
\max\left(0,\;\sum_{i=1}^L w_iS_i(T)-K\right)\; ,
\]</span> where <span class="math inline">\(L\)</span> is the number of assets in the basket (portfolio) and <span class="math inline">\(w_i\)</span> is the weight of the <span class="math inline">\(i\)</span>–th asset in the basket. The logarithm of the <span class="math inline">\(i\)</span>–th asset price at maturity is simulated as <span class="math display">\[
\log S_i(T) = \log S_i(0) +\nu_iT + \sqrt{T} \sum_{j=1}^L a_{ij}Z_j\; ,
\]</span> where the <span class="math inline">\(Z_j\)</span> are independent standard normals. Given the simulated values of the <span class="math inline">\(\log S_i(T)\)</span>, the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.</p>
<p>For our two asset example we compute the value of a call opttion on an equally weighted porfotlio.</p>
<div id="48eddc4f" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="48eddc4f"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="48eddc4f-1"><a href="#48eddc4f-1" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="48eddc4f-2"><a href="#48eddc4f-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">45</span></span>
<span id="48eddc4f-3"><a href="#48eddc4f-3" aria-hidden="true" tabindex="-1"></a>basketpo <span class="op">=</span> np.maximum(w <span class="op">*</span> St1[m, :] <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> St2[m, :] <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="48eddc4f-4"><a href="#48eddc4f-4" aria-hidden="true" tabindex="-1"></a>basketpoa <span class="op">=</span> np.maximum(w <span class="op">*</span> St1a[m, :] <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> w) <span class="op">*</span> St2a[m, :] <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="48eddc4f-5"><a href="#48eddc4f-5" aria-hidden="true" tabindex="-1"></a>estimate <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(basketpo)</span>
<span id="48eddc4f-6"><a href="#48eddc4f-6" aria-hidden="true" tabindex="-1"></a>estimatea <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(basketpoa)</span>
<span id="48eddc4f-7"><a href="#48eddc4f-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first estimate is ="</span>, estimate)</span>
<span id="48eddc4f-8"><a href="#48eddc4f-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second estimate is ="</span>, estimatea)</span>
<span id="48eddc4f-9"><a href="#48eddc4f-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average of the estimates="</span>, (estimate <span class="op">+</span> estimatea) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The first estimate is = 4.4030641748675095
The second estimate is = 4.945665333101932
The average of the estimates= 4.674364753984721</code></pre>
</div>
</div>
<p>Below is a three asset basket option whihc uses the numpy cholesky decomposition. In contrast to the above routine, this routine is does not have the option to generate the entire path, although this can be easily modeified.</p>
<div id="22ca9ec3" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="22ca9ec3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="22ca9ec3-1"><a href="#22ca9ec3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="22ca9ec3-2"><a href="#22ca9ec3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-3"><a href="#22ca9ec3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># risk free rate</span></span>
<span id="22ca9ec3-4"><a href="#22ca9ec3-4" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="22ca9ec3-5"><a href="#22ca9ec3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># number of assets</span></span>
<span id="22ca9ec3-6"><a href="#22ca9ec3-6" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="22ca9ec3-7"><a href="#22ca9ec3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-8"><a href="#22ca9ec3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># number of paths</span></span>
<span id="22ca9ec3-9"><a href="#22ca9ec3-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100000</span></span>
<span id="22ca9ec3-10"><a href="#22ca9ec3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Horizon</span></span>
<span id="22ca9ec3-11"><a href="#22ca9ec3-11" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="22ca9ec3-12"><a href="#22ca9ec3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-13"><a href="#22ca9ec3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial price</span></span>
<span id="22ca9ec3-14"><a href="#22ca9ec3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-15"><a href="#22ca9ec3-15" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> [<span class="dv">42</span>, <span class="dv">50</span>, <span class="dv">45</span>]</span>
<span id="22ca9ec3-16"><a href="#22ca9ec3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-17"><a href="#22ca9ec3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Basket Weights</span></span>
<span id="22ca9ec3-18"><a href="#22ca9ec3-18" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.25</span>]</span>
<span id="22ca9ec3-19"><a href="#22ca9ec3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-20"><a href="#22ca9ec3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Strike Price</span></span>
<span id="22ca9ec3-21"><a href="#22ca9ec3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-22"><a href="#22ca9ec3-22" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">45</span></span>
<span id="22ca9ec3-23"><a href="#22ca9ec3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-24"><a href="#22ca9ec3-24" aria-hidden="true" tabindex="-1"></a><span class="co">#  put in volatilities</span></span>
<span id="22ca9ec3-25"><a href="#22ca9ec3-25" aria-hidden="true" tabindex="-1"></a>sig1 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="22ca9ec3-26"><a href="#22ca9ec3-26" aria-hidden="true" tabindex="-1"></a>sig2 <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="22ca9ec3-27"><a href="#22ca9ec3-27" aria-hidden="true" tabindex="-1"></a>sig3 <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="22ca9ec3-28"><a href="#22ca9ec3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-29"><a href="#22ca9ec3-29" aria-hidden="true" tabindex="-1"></a><span class="co"># create diagonal</span></span>
<span id="22ca9ec3-30"><a href="#22ca9ec3-30" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> [sig1, sig2, sig3]</span>
<span id="22ca9ec3-31"><a href="#22ca9ec3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-32"><a href="#22ca9ec3-32" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.diag(sig)</span>
<span id="22ca9ec3-33"><a href="#22ca9ec3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-34"><a href="#22ca9ec3-34" aria-hidden="true" tabindex="-1"></a><span class="co"># drift of log returns</span></span>
<span id="22ca9ec3-35"><a href="#22ca9ec3-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-36"><a href="#22ca9ec3-36" aria-hidden="true" tabindex="-1"></a>drift <span class="op">=</span> r <span class="op">*</span> np.ones(k) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.dot(S <span class="op">@</span> S, np.ones(k))</span>
<span id="22ca9ec3-37"><a href="#22ca9ec3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-38"><a href="#22ca9ec3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-39"><a href="#22ca9ec3-39" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation matrix</span></span>
<span id="22ca9ec3-40"><a href="#22ca9ec3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-41"><a href="#22ca9ec3-41" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> np.array([[<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>], [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">1.0</span>]])</span>
<span id="22ca9ec3-42"><a href="#22ca9ec3-42" aria-hidden="true" tabindex="-1"></a><span class="co"># covariance matrix</span></span>
<span id="22ca9ec3-43"><a href="#22ca9ec3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-44"><a href="#22ca9ec3-44" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> S <span class="op">@</span> rho <span class="op">@</span> S</span>
<span id="22ca9ec3-45"><a href="#22ca9ec3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-46"><a href="#22ca9ec3-46" aria-hidden="true" tabindex="-1"></a><span class="co"># generate uniform n*k normal uncorrelated random variables</span></span>
<span id="22ca9ec3-47"><a href="#22ca9ec3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-48"><a href="#22ca9ec3-48" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">2024</span></span>
<span id="22ca9ec3-49"><a href="#22ca9ec3-49" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="22ca9ec3-50"><a href="#22ca9ec3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-51"><a href="#22ca9ec3-51" aria-hidden="true" tabindex="-1"></a>inc1 <span class="op">=</span> np.transpose(np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>np.sqrt(T), size<span class="op">=</span>(n, k)))</span>
<span id="22ca9ec3-52"><a href="#22ca9ec3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-53"><a href="#22ca9ec3-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-54"><a href="#22ca9ec3-54" aria-hidden="true" tabindex="-1"></a><span class="co"># create correlated random variables</span></span>
<span id="22ca9ec3-55"><a href="#22ca9ec3-55" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.linalg.cholesky(V)</span>
<span id="22ca9ec3-56"><a href="#22ca9ec3-56" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> np.dot(Z, inc1)</span>
<span id="22ca9ec3-57"><a href="#22ca9ec3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-58"><a href="#22ca9ec3-58" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The sample correlation matrix ="</span>, np.corrcoef(incr))</span>
<span id="22ca9ec3-59"><a href="#22ca9ec3-59" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The input correlation matrix ="</span>, rho)</span>
<span id="22ca9ec3-60"><a href="#22ca9ec3-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-61"><a href="#22ca9ec3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-62"><a href="#22ca9ec3-62" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> S0 <span class="op">*</span> np.exp(drift <span class="op">*</span> T <span class="op">+</span> np.transpose(incr))</span>
<span id="22ca9ec3-63"><a href="#22ca9ec3-63" aria-hidden="true" tabindex="-1"></a><span class="co"># antithetic sample</span></span>
<span id="22ca9ec3-64"><a href="#22ca9ec3-64" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> S0 <span class="op">*</span> np.exp(drift <span class="op">*</span> T <span class="op">-</span> np.transpose(incr))</span>
<span id="22ca9ec3-65"><a href="#22ca9ec3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-66"><a href="#22ca9ec3-66" aria-hidden="true" tabindex="-1"></a>estimate <span class="op">=</span> np.mean(St, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="22ca9ec3-67"><a href="#22ca9ec3-67" aria-hidden="true" tabindex="-1"></a>estimate1 <span class="op">=</span> np.mean(St1, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="22ca9ec3-68"><a href="#22ca9ec3-68" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="22ca9ec3-69"><a href="#22ca9ec3-69" aria-hidden="true" tabindex="-1"></a>    <span class="st">"The average discounted stock price averaged over both samples="</span>,</span>
<span id="22ca9ec3-70"><a href="#22ca9ec3-70" aria-hidden="true" tabindex="-1"></a>    (estimate <span class="op">+</span> estimate1) <span class="op">/</span> <span class="dv">2</span>,</span>
<span id="22ca9ec3-71"><a href="#22ca9ec3-71" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="22ca9ec3-72"><a href="#22ca9ec3-72" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The initial Srock Price input ="</span>, S0)</span>
<span id="22ca9ec3-73"><a href="#22ca9ec3-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="22ca9ec3-74"><a href="#22ca9ec3-74" aria-hidden="true" tabindex="-1"></a>basketpo <span class="op">=</span> np.maximum(w <span class="op">@</span> np.transpose(St) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="22ca9ec3-75"><a href="#22ca9ec3-75" aria-hidden="true" tabindex="-1"></a>basketpo1 <span class="op">=</span> np.maximum(w <span class="op">@</span> np.transpose(St1) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="22ca9ec3-76"><a href="#22ca9ec3-76" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> np.mean(basketpo) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="22ca9ec3-77"><a href="#22ca9ec3-77" aria-hidden="true" tabindex="-1"></a>value1 <span class="op">=</span> np.mean(basketpo1) <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T)</span>
<span id="22ca9ec3-78"><a href="#22ca9ec3-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The first sample estimate of the basket option value="</span>, value)</span>
<span id="22ca9ec3-79"><a href="#22ca9ec3-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The second sample estimate of the basket option value="</span>, value1)</span>
<span id="22ca9ec3-80"><a href="#22ca9ec3-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average estimate of the basket option value="</span>, (value <span class="op">+</span> value1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The sample correlation matrix = [[1.         0.50356746 0.30497838]
 [0.50356746 1.         0.20383175]
 [0.30497838 0.20383175 1.        ]]
The input correlation matrix = [[1.  0.5 0.3]
 [0.5 1.  0.2]
 [0.3 0.2 1. ]]
The average discounted stock price averaged over both samples= [42.00560021 50.00484037 45.01680115]
The initial Srock Price input = [42, 50, 45]
The first sample estimate of the basket option value= 5.335894164783821
The second sample estimate of the basket option value= 5.289353051200051
The average estimate of the basket option value= 5.312623607991936</code></pre>
</div>
</div>
<p>We can generate the entire path of multiple assets to value, for example, lookback options on a basket. The code below values the same European basket option as above only it calculates <span class="math inline">\(m=2\)</span> time steps; a lookback can be created by changing the payoffs and increasing <span class="math inline">\(m\)</span>.</p>
<div id="5c53d185" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="5c53d185"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="5c53d185-1"><a href="#5c53d185-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="5c53d185-2"><a href="#5c53d185-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-3"><a href="#5c53d185-3" aria-hidden="true" tabindex="-1"></a><span class="co"># number of time steps</span></span>
<span id="5c53d185-4"><a href="#5c53d185-4" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">2</span></span>
<span id="5c53d185-5"><a href="#5c53d185-5" aria-hidden="true" tabindex="-1"></a><span class="co"># number of assets</span></span>
<span id="5c53d185-6"><a href="#5c53d185-6" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="5c53d185-7"><a href="#5c53d185-7" aria-hidden="true" tabindex="-1"></a><span class="co"># number of sample paths</span></span>
<span id="5c53d185-8"><a href="#5c53d185-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">100000</span></span>
<span id="5c53d185-9"><a href="#5c53d185-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-10"><a href="#5c53d185-10" aria-hidden="true" tabindex="-1"></a><span class="co"># risk free rate</span></span>
<span id="5c53d185-11"><a href="#5c53d185-11" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="5c53d185-12"><a href="#5c53d185-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-13"><a href="#5c53d185-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-14"><a href="#5c53d185-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Horizon</span></span>
<span id="5c53d185-15"><a href="#5c53d185-15" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="5c53d185-16"><a href="#5c53d185-16" aria-hidden="true" tabindex="-1"></a><span class="co"># delta t</span></span>
<span id="5c53d185-17"><a href="#5c53d185-17" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span> m</span>
<span id="5c53d185-18"><a href="#5c53d185-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial price</span></span>
<span id="5c53d185-19"><a href="#5c53d185-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-20"><a href="#5c53d185-20" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> [<span class="dv">42</span>, <span class="dv">50</span>, <span class="dv">45</span>]</span>
<span id="5c53d185-21"><a href="#5c53d185-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-22"><a href="#5c53d185-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Strike Price</span></span>
<span id="5c53d185-23"><a href="#5c53d185-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-24"><a href="#5c53d185-24" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">45</span></span>
<span id="5c53d185-25"><a href="#5c53d185-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-26"><a href="#5c53d185-26" aria-hidden="true" tabindex="-1"></a><span class="co">#  put in volatilities</span></span>
<span id="5c53d185-27"><a href="#5c53d185-27" aria-hidden="true" tabindex="-1"></a>sig1 <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="5c53d185-28"><a href="#5c53d185-28" aria-hidden="true" tabindex="-1"></a>sig2 <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="5c53d185-29"><a href="#5c53d185-29" aria-hidden="true" tabindex="-1"></a>sig3 <span class="op">=</span> <span class="fl">0.4</span></span>
<span id="5c53d185-30"><a href="#5c53d185-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-31"><a href="#5c53d185-31" aria-hidden="true" tabindex="-1"></a><span class="co"># create diagonal</span></span>
<span id="5c53d185-32"><a href="#5c53d185-32" aria-hidden="true" tabindex="-1"></a>sig <span class="op">=</span> [sig1, sig2, sig3]</span>
<span id="5c53d185-33"><a href="#5c53d185-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-34"><a href="#5c53d185-34" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.diag(sig)</span>
<span id="5c53d185-35"><a href="#5c53d185-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-36"><a href="#5c53d185-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-37"><a href="#5c53d185-37" aria-hidden="true" tabindex="-1"></a><span class="co"># correlation matrix</span></span>
<span id="5c53d185-38"><a href="#5c53d185-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-39"><a href="#5c53d185-39" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> np.array([[<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>], [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>], [<span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">1.0</span>]])</span>
<span id="5c53d185-40"><a href="#5c53d185-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-41"><a href="#5c53d185-41" aria-hidden="true" tabindex="-1"></a><span class="co"># covariance matrix</span></span>
<span id="5c53d185-42"><a href="#5c53d185-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-43"><a href="#5c53d185-43" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> S <span class="op">@</span> rho <span class="op">@</span> S</span>
<span id="5c53d185-44"><a href="#5c53d185-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-45"><a href="#5c53d185-45" aria-hidden="true" tabindex="-1"></a><span class="co"># drift of log returns</span></span>
<span id="5c53d185-46"><a href="#5c53d185-46" aria-hidden="true" tabindex="-1"></a>drift <span class="op">=</span> np.array(r <span class="op">*</span> np.ones(k) <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> np.dot(S <span class="op">@</span> S, np.ones(k))) <span class="op">*</span> dt</span>
<span id="5c53d185-47"><a href="#5c53d185-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-48"><a href="#5c53d185-48" aria-hidden="true" tabindex="-1"></a><span class="co"># times vector</span></span>
<span id="5c53d185-49"><a href="#5c53d185-49" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.array(<span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="5c53d185-50"><a href="#5c53d185-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-51"><a href="#5c53d185-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-52"><a href="#5c53d185-52" aria-hidden="true" tabindex="-1"></a>driftv <span class="op">=</span> np.transpose(np.kron(drift, t).reshape(<span class="dv">3</span>, m))</span>
<span id="5c53d185-53"><a href="#5c53d185-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-54"><a href="#5c53d185-54" aria-hidden="true" tabindex="-1"></a><span class="co"># generate uniform n(paths)*k(assets)*m(time steps) normal uncorrelated random variables</span></span>
<span id="5c53d185-55"><a href="#5c53d185-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-56"><a href="#5c53d185-56" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">2024</span></span>
<span id="5c53d185-57"><a href="#5c53d185-57" aria-hidden="true" tabindex="-1"></a>np.random.seed(seed)</span>
<span id="5c53d185-58"><a href="#5c53d185-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-59"><a href="#5c53d185-59" aria-hidden="true" tabindex="-1"></a>inc <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span>np.sqrt(dt), size<span class="op">=</span>(n, k, m))</span>
<span id="5c53d185-60"><a href="#5c53d185-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-61"><a href="#5c53d185-61" aria-hidden="true" tabindex="-1"></a><span class="co"># create correlated random increments</span></span>
<span id="5c53d185-62"><a href="#5c53d185-62" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> np.linalg.cholesky(V)</span>
<span id="5c53d185-63"><a href="#5c53d185-63" aria-hidden="true" tabindex="-1"></a><span class="co"># numpy matmul assumes last two define matrix multiplication</span></span>
<span id="5c53d185-64"><a href="#5c53d185-64" aria-hidden="true" tabindex="-1"></a>incr <span class="op">=</span> np.matmul(Z, inc)</span>
<span id="5c53d185-65"><a href="#5c53d185-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-66"><a href="#5c53d185-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-67"><a href="#5c53d185-67" aria-hidden="true" tabindex="-1"></a>SSt <span class="op">=</span> S0 <span class="op">*</span> np.exp(driftv)</span>
<span id="5c53d185-68"><a href="#5c53d185-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-69"><a href="#5c53d185-69" aria-hidden="true" tabindex="-1"></a><span class="co"># generate returns along path and antithetic path</span></span>
<span id="5c53d185-70"><a href="#5c53d185-70" aria-hidden="true" tabindex="-1"></a><span class="co"># first e^{cumsum(increments)} gives e^sigma B_t for different t</span></span>
<span id="5c53d185-71"><a href="#5c53d185-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-72"><a href="#5c53d185-72" aria-hidden="true" tabindex="-1"></a>Stb <span class="op">=</span> np.exp(</span>
<span id="5c53d185-73"><a href="#5c53d185-73" aria-hidden="true" tabindex="-1"></a>    np.cumsum(</span>
<span id="5c53d185-74"><a href="#5c53d185-74" aria-hidden="true" tabindex="-1"></a>        incr[</span>
<span id="5c53d185-75"><a href="#5c53d185-75" aria-hidden="true" tabindex="-1"></a>            :,</span>
<span id="5c53d185-76"><a href="#5c53d185-76" aria-hidden="true" tabindex="-1"></a>            :,</span>
<span id="5c53d185-77"><a href="#5c53d185-77" aria-hidden="true" tabindex="-1"></a>        ],</span>
<span id="5c53d185-78"><a href="#5c53d185-78" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">2</span>,</span>
<span id="5c53d185-79"><a href="#5c53d185-79" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="5c53d185-80"><a href="#5c53d185-80" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="5c53d185-81"><a href="#5c53d185-81" aria-hidden="true" tabindex="-1"></a>Stb1 <span class="op">=</span> np.exp(</span>
<span id="5c53d185-82"><a href="#5c53d185-82" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span>np.cumsum(</span>
<span id="5c53d185-83"><a href="#5c53d185-83" aria-hidden="true" tabindex="-1"></a>        incr[</span>
<span id="5c53d185-84"><a href="#5c53d185-84" aria-hidden="true" tabindex="-1"></a>            :,</span>
<span id="5c53d185-85"><a href="#5c53d185-85" aria-hidden="true" tabindex="-1"></a>            :,</span>
<span id="5c53d185-86"><a href="#5c53d185-86" aria-hidden="true" tabindex="-1"></a>        ],</span>
<span id="5c53d185-87"><a href="#5c53d185-87" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">2</span>,</span>
<span id="5c53d185-88"><a href="#5c53d185-88" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="5c53d185-89"><a href="#5c53d185-89" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="5c53d185-90"><a href="#5c53d185-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-91"><a href="#5c53d185-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-92"><a href="#5c53d185-92" aria-hidden="true" tabindex="-1"></a><span class="co"># Multiply by S0 e^drift for each t</span></span>
<span id="5c53d185-93"><a href="#5c53d185-93" aria-hidden="true" tabindex="-1"></a>St <span class="op">=</span> np.multiply(Stb, np.transpose(SSt))</span>
<span id="5c53d185-94"><a href="#5c53d185-94" aria-hidden="true" tabindex="-1"></a>St1 <span class="op">=</span> np.multiply(Stb1, np.transpose(SSt))</span>
<span id="5c53d185-95"><a href="#5c53d185-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-96"><a href="#5c53d185-96" aria-hidden="true" tabindex="-1"></a><span class="co"># Last date returns</span></span>
<span id="5c53d185-97"><a href="#5c53d185-97" aria-hidden="true" tabindex="-1"></a>Stm <span class="op">=</span> St[:, :, m <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="5c53d185-98"><a href="#5c53d185-98" aria-hidden="true" tabindex="-1"></a>Stm1 <span class="op">=</span> St1[:, :, m <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="5c53d185-99"><a href="#5c53d185-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-100"><a href="#5c53d185-100" aria-hidden="true" tabindex="-1"></a><span class="co"># define payoff</span></span>
<span id="5c53d185-101"><a href="#5c53d185-101" aria-hidden="true" tabindex="-1"></a><span class="co"># Basket Weights</span></span>
<span id="5c53d185-102"><a href="#5c53d185-102" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.25</span>]</span>
<span id="5c53d185-103"><a href="#5c53d185-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-104"><a href="#5c53d185-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-105"><a href="#5c53d185-105" aria-hidden="true" tabindex="-1"></a>payoff <span class="op">=</span> np.maximum(np.matmul(Stm, np.transpose(w)) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="5c53d185-106"><a href="#5c53d185-106" aria-hidden="true" tabindex="-1"></a>payoff1 <span class="op">=</span> np.maximum(np.matmul(Stm1, np.transpose(w)) <span class="op">-</span> K, <span class="dv">0</span>)</span>
<span id="5c53d185-107"><a href="#5c53d185-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-108"><a href="#5c53d185-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="5c53d185-109"><a href="#5c53d185-109" aria-hidden="true" tabindex="-1"></a>value <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(payoff)</span>
<span id="5c53d185-110"><a href="#5c53d185-110" aria-hidden="true" tabindex="-1"></a>value1 <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.mean(payoff1)</span>
<span id="5c53d185-111"><a href="#5c53d185-111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The estimate for the first sample value="</span>, value)</span>
<span id="5c53d185-112"><a href="#5c53d185-112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The estimate for the second sample value="</span>, value1)</span>
<span id="5c53d185-113"><a href="#5c53d185-113" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The average estimate for the value="</span>, (value <span class="op">+</span> value1) <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The estimate for the first sample value= 5.310173600480473
The estimate for the second sample value= 5.287928240443306
The average estimate for the value= 5.299050920461889</code></pre>
</div>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-boyle" class="csl-entry" role="listitem">
Boyle, P. 1977. <span>“Options: A Monte Carlo Approach.”</span> <em>Journal of Financial Economics</em> 4: 323–38.
</div>
<div id="ref-Brandimarte" class="csl-entry" role="listitem">
Brandimarte, P. 2002. <em>Numerical Methods in Finance: A MATLAB-Based Introduction</em>. Wiley, New York.
</div>
<div id="ref-bg2" class="csl-entry" role="listitem">
Broadie, M., and P. Glasserman. 1996. <span>“Estimating Security Price Derivatives Using Simulation.”</span> <em>Management Science</em> 42: 269–85.
</div>
<div id="ref-BG" class="csl-entry" role="listitem">
———. 1997. <span>“Pricing American-Style Securities Using Simulation.”</span> <em>Journal of Economic Dynamics and Control</em> 21: 1323–52.
</div>
<div id="ref-CS" class="csl-entry" role="listitem">
Clewlow, L., and C. Strickland. 1998. <em>Implementing Derivatives Models</em>. Wiley, New York.
</div>
<div id="ref-Glasserman" class="csl-entry" role="listitem">
Glasserman, P. 2004. <em>Monte Carlo Methods in Financial Engineering</em>. Springer, New York Berlin Heidelberg.
</div>
<div id="ref-Jackel" class="csl-entry" role="listitem">
Jäckel, P. 2002. <em>Monte Carlo Methods in Finance</em>. Wiley, New York.
</div>
<div id="ref-LS01" class="csl-entry" role="listitem">
Longstaff, F., and E. Schwartz. 2001. <span>“Valuing American Options by Simulation: A Simple Least-Squares Approach.”</span> <em>Review of Financial Studies</em> 14: 113–47.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Boyle~<span class="citation" data-cites="boyle">(<a href="#ref-boyle" role="doc-biblioref">Boyle 1977</a>)</span> introduced Monte-Carlo methods for derivative valuation, including the variance-reduction methods of control variates and antithetic variates to be discussed later<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Monte-Carlo methods for valuing early exercise include the stochastic mesh method of Broadie and Glasserman <span class="citation" data-cites="BG">(<a href="#ref-BG" role="doc-biblioref">Broadie and Glasserman 1997</a>)</span> and the regression method of Longstaff and Schwartz <span class="citation" data-cites="LS01">(<a href="#ref-LS01" role="doc-biblioref">Longstaff and Schwartz 2001</a>)</span>. Glasserman <span class="citation" data-cites="Glasserman">(<a href="#ref-Glasserman" role="doc-biblioref">Glasserman 2004</a>)</span> provides a good discussion of these methods and the relation between them.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p> The negative correlation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is essential for this method to generate a real gain in efficiency. To generate <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span>, one must generate <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(x\)</span> and <span class="math inline">\(M\)</span> of <span class="math inline">\(y\)</span>, which will generally require about as much computation time as generating <span class="math inline">\(2M\)</span> simulations of <span class="math inline">\(x\)</span>. If <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> were independent, the standard error from <span class="math inline">\(M\)</span> simulations of <span class="math inline">\(z\)</span> would be the same as the standard error from <span class="math inline">\(2M\)</span> simulations of <span class="math inline">\(x\)</span>, so using the antithetic variate would be no better than just doubling the sample size for <span class="math inline">\(x\)</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>By changing numeraires, we can show that <a href="#eq-montecarlodelta5" class="quarto-xref">Equation&nbsp;<span>12.8</span></a> equals <span class="math inline">\(\mathrm{e}^{-qT}\\E^V[x] = \mathrm{e}^{-qT}\mathrm{N}(d_1)\)</span>, as we know from <a href="Chapter_BlackScholes.html" class="quarto-xref"><span>Chapter 8</span></a> is the delta of a European call in the Black-Scholes model (here, as in <a href="Chapter_BlackScholes.html" class="quarto-xref"><span>Chapter 8</span></a>, <span class="math inline">\(V_t=\mathrm{e}^{qt}S_t\)</span> denotes the value of the dividend-reinvested portfolio created from the stock).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>For a spread option, take <span class="math inline">\(L=2\)</span>, <span class="math inline">\(w_1=1\)</span> and <span class="math inline">\(w_2=-1\)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter_Exotics.html" class="pagination-link" aria-label="Other Exotics">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Other Exotics</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter_Binomial.html" class="pagination-link" aria-label="Binomial and Trinomial Models">
        <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Binomial and Trinomial Models</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions"><ul><li><a href="https://github.com/math-finance-book/book-published-code.git/blob/main/Chapter_MonteCarlo.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li></ul></div></div></div></footer></body></html>