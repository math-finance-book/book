[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pricing and Hedging Derivative Securities",
    "section": "",
    "text": "Preface\nThis is a partial draft of a python-based introduction to derivative security pricing.\nThe chat icon below the book title on the top left is a link to a chatbot that can answer questions using the book as a source. Like any chatbot, it can make mistakes, so check its answers with the sources in the book that it should provide. The Github icon next to the chat icon is a link to a Github repository of Jupyter notebooks. The notebooks contain all of the code in the book and include  buttons. The notebooks can be opened in Colab or downloaded from the Github repo (or you can clone the repo). The icon to the right of the Github icon enables toggling between light and dark modes.\nFigures in the text are interactive. Hover your cursor over plot elements to see additional data. Also, hover over footnote numbers to see footnotes.\nThe book is Hypothesis enabled. Click the icons at the top right to log in or sign up and to create annotations or to highlight text. The annotations and highlights will be visible to you in subsequent visits to the book once you log in to your Hypothesis account. We prefer that you do not post annotations or highlights to the Public account.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Chapter_Intro_Derivatives.html",
    "href": "Chapter_Intro_Derivatives.html",
    "title": "1  Derivative Securities",
    "section": "",
    "text": "1.1 Types of Derivative Securities\nDerivative securities are financial instruments whose value is derived from an underlying asset, index, or rate. These instruments are used for hedging risks and for speculation. The underlying assets can be stocks, bonds, commodities, currencies, interest rates, or market indices. The fundamental characteristic of derivatives is that their values fluctuate based on changes in the price of the underlying assets.\nDerivatives play a significant role in financial markets by allowing investors to manage risk exposures and take speculative positions with a relatively small amount of capital. They are also widely used by corporations and financial institutions to hedge against fluctuations in interest rates, currency values, and commodity prices. The rapid growth of the derivatives market over the past few decades has made these instruments an essential part of global financial markets.\nOne of the key advantages of derivatives is their ability to provide leverage. Investors can control large positions with relatively small amounts of capital, amplifying potential gains. However, this also increases the risk of substantial losses. Furthermore, derivatives facilitate price discovery, enhance market efficiency, and contribute to overall liquidity by allowing market participants to express diverse opinions about future asset prices.\nMajor derivative securities can be broadly classified into four main types:",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Derivatives.html#types-of-derivative-securities",
    "href": "Chapter_Intro_Derivatives.html#types-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "",
    "text": "Forwards\nForwards are customized contracts between two parties to buy or sell an asset at a predetermined future date and price. Unlike standardized contracts, forwards are traded over-the-counter (OTC), making them more flexible but less liquid. Forwards are commonly used in the foreign exchange and commodities markets to hedge against price fluctuations.\nOne key feature of forward contracts is that they are non-standardized, meaning that the terms, such as contract size, expiration date, and settlement procedure, are determined by the parties involved. However, this flexibility also increases counterparty risk, as the default risk is not mitigated through a clearinghouse. Another drawback is the potential for price manipulation due to the lack of regulatory oversight in OTC markets.\n\n\nFutures\nFutures are standardized contracts traded on exchanges, obligating the buyer to purchase and the seller to sell an underlying asset at a specific price on a future date. Futures markets are highly liquid and regulated, reducing counterparty risk. They are used extensively for hedging and speculative purposes across various asset classes, including commodities, equities, interest rates, and foreign exchange.\nA key advantage of futures contracts is that they are cleared through centralized clearinghouses, reducing default risk. Additionally, futures contracts require margin deposits, which serve as collateral and help maintain market stability. The presence of daily mark-to-market settlements ensures that gains and losses are realized continuously, preventing excessive accumulation of risk.\nFutures markets are crucial for global trade and investment. For example, agricultural futures help farmers lock in prices for their crops, ensuring financial stability amid unpredictable market conditions. Similarly, crude oil futures allow energy companies to hedge against fluctuations in oil prices.\n\n\nOptions\nOptions give the holder the right, but not the obligation, to buy (call option) or sell (put option) an asset at a predetermined price before or at expiration. They are widely used for hedging and speculative purposes. Options are traded both on exchanges and in OTC markets.\nOptions provide strategic flexibility for investors, as they allow for various trading strategies, including covered calls, protective puts, straddles, and spreads. The pricing of options depends on several factors, including the price of the underlying asset, volatility, time to expiration, interest rates, and dividends. The Black-Scholes model and binomial tree model are widely used for option pricing.\nThe versatility of options allows investors to construct positions that range from conservative hedging strategies to highly speculative trades. For example, covered call strategies can generate income in sideways markets, while long straddles can profit from significant price swings in either direction.\n\n\nSwaps\nSwaps involve the exchange of cash flows based on different financial instruments. The most common types include interest rate swaps, currency swaps, and credit default swaps (CDS). Swaps are mainly traded in OTC markets and are primarily used for hedging risks associated with fluctuating interest rates and currency values.\nInterest rate swaps, for instance, allow two parties to exchange fixed and floating interest rate payments, enabling companies to manage interest rate exposure. Currency swaps help multinational corporations hedge against exchange rate fluctuations. Credit default swaps played a crucial role in the 2008 financial crisis, as they were used to transfer credit risk between financial institutions.\nSwaps have evolved to become sophisticated financial tools, providing tailored risk management solutions. However, their complexity also necessitates rigorous risk assessment and regulatory oversight to prevent systemic risks.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Derivatives.html#historical-evolution-of-derivative-securities",
    "href": "Chapter_Intro_Derivatives.html#historical-evolution-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "1.2 Historical Evolution of Derivative Securities",
    "text": "1.2 Historical Evolution of Derivative Securities\nThe origins of derivative securities date back to ancient civilizations. The first recorded derivatives can be traced to Mesopotamian grain contracts and ancient Greek olive oil options. Modern derivatives markets evolved significantly in the 20th century:\n\nChicago Board of Trade (CBOT) was established in 1848, marking the beginning of organized futures trading.\nChicago Mercantile Exchange (CME) introduced financial futures in the 1970s, expanding the scope of derivatives markets.\nBlack-Scholes Model (1973) provided a theoretical framework for option pricing, revolutionizing derivatives trading and making options more accessible.\nGrowth of OTC Markets in the late 20th and early 21st centuries expanded the use of swaps and structured derivatives, allowing institutions to tailor risk management solutions.\n\nThe rapid expansion of derivatives markets has been driven by advancements in financial engineering, technology, and increased globalization. However, the complexity of these instruments has also led to significant regulatory challenges and financial crises, necessitating increased oversight and risk management practices.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Derivatives.html#trading-of-derivative-securities",
    "href": "Chapter_Intro_Derivatives.html#trading-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "1.3 Trading of Derivative Securities",
    "text": "1.3 Trading of Derivative Securities\n\nExchange-Traded Derivatives\nThese derivatives are traded on regulated exchanges such as the CME, NYSE Euronext, and Intercontinental Exchange (ICE). Exchange-traded derivatives are standardized and cleared through central counterparties, reducing counterparty risk. The standardization ensures price transparency and facilitates liquidity, making these markets highly efficient.\n\n\nOver-the-Counter (OTC) Derivatives\nOTC derivatives are privately negotiated contracts between two parties, offering greater customization but higher counterparty risk. Common OTC derivatives include forward contracts, swaps, and exotic options. The flexibility of OTC markets allows financial institutions to create tailored risk management solutions, but the lack of centralized clearing increases default risk.\nThe growth of electronic trading platforms and regulatory reforms has transformed the OTC derivatives market, improving transparency and reducing systemic risks.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Derivatives.html#size-of-the-derivatives-market",
    "href": "Chapter_Intro_Derivatives.html#size-of-the-derivatives-market",
    "title": "1  Derivative Securities",
    "section": "1.4 Size of the Derivatives Market",
    "text": "1.4 Size of the Derivatives Market\nThe global derivatives market is one of the largest financial markets. According to estimates from the Bank for International Settlements (BIS), the notional value of outstanding derivatives contracts exceeded $667 trillion at the end of 2023, with interest rate derivatives accounting for approximately $530 trillion and foreign exchange derivatives reaching $118 trillion. (BIS Report)\nThe rapid expansion of derivatives markets highlights their importance in global finance, but it also underscores the need for sound risk management practices.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html",
    "href": "Chapter_Intro_Options.html",
    "title": "2  Options",
    "section": "",
    "text": "2.1 Option Basics\nOptions are among the most actively traded financial instruments in the world, with billions of contracts changing hands annually across global exchanges. These versatile contracts provide investors with tools for speculation, hedging, and income generation that are impossible to replicate with stocks and bonds alone.\nThis chapter provides an introduction to the mechanics and motives for trading options. Recall from Chapter 1 that a call option is the right to buy an underlying asset at a fixed price called the strike or strike price. Symmetrically, a put option is the right to sell an underlying asset at the strike price. The underlying asset can be a stock, index, exchange-traded fund (ETF), commodity, or other financial instrument. The buyer of an option pays the seller upfront for the right to exercise the option later, at the buyer’s discretion.\nOptions have a finite lifetime, with the contract specifying an expiration date. Most exchange-traded options can be exercised at any time prior to expiration (American options), while others can only be exercised at the expiration date (European options). Despite their names, both types trade on exchanges worldwide.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#option-basics",
    "href": "Chapter_Intro_Options.html#option-basics",
    "title": "2  Options",
    "section": "",
    "text": "Key Options Terminology\n\n\n\n\nPremium: The price paid to buy an option (like an insurance premium)\nStrike Price: The fixed price at which the option can be exercised\nExpiration Date: When the option contract ends\nExercise: Using the right granted by the option\nUnderlying Asset: The financial instrument (stock, index, etc.) that the option is based on\nContract Size: Most equity options represent 100 shares of the underlying stock\n\n\n\n\nMoneyness and Time Value\nOptions are often described according to their relationship to the current price of the underlying asset:\n\nIn-the-money (ITM): Options with intrinsic value (calls with strike &lt; current price, puts with strike &gt; current price)\n\nExample: call with strike = 50 when underlying asset is trading at 60. Intrinsic value is 60 - 50 = 10.\nExample: put with strike = 80 when underlying asset is trading at 60. Intrinsic value is 80 - 60 = 20.\n\nAt-the-money (ATM): Options with strike price equal or very close to the current underlying price\n\nOut-of-the-money (OTM): Options with no intrinsic value (calls with strike &gt; current price, puts with strike &lt; current price)\n\nExample: call with strike of 50 when underlying is trading at 40. Intrinsic value is zero.\nExample: put with strike of 30 when underlying is trading at 40. Intrinsic value is zero.\n\n\nThe time value of an option is defined to be the excess of the option premium above its intrinsic value. As time passes and expiration approaches, options lose time value, called time decay.\n\n\nRights, Obligations, and Motivations\nOption buyers pay the premium upfront. Subsequently they have rights - they can choose whether to exercise the option - but no obligations. The maximum loss of an option buyer is the option premium. On the other hand, option sellers receive the premium upfront but subsequently they have obligations: they must fulfill the contract if the option is exercised. They face potentially unlimited losses (especially for calls). The motivation for buying an option can be to speculate on the underlying asset price or it can be to hedge an existing risk. The motivation for selling an option is always to receive the option premium.\nIn summary, the motivations for trading options are:\n\nSpeculation and Leverage: One motive for buying options is to speculate on price movements with higher leverage than direct stock ownership. A small price change in the underlying can produce large percentage changes in option value, amplifying both potential gains and losses.\nHedging and Insurance: Options serve as insurance contracts for existing positions. For example, owning a protective put on your stock holdings limits downside risk, much like buying car insurance protects against accident costs. The option premium represents the “insurance cost” for this protection.\nIncome Generation: Option sellers collect premiums upfront, similar to insurance companies collecting policy premiums. However, this income comes with obligations and potential risks if the market moves against the seller’s position.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#trading-options-on-exchanges",
    "href": "Chapter_Intro_Options.html#trading-options-on-exchanges",
    "title": "2  Options",
    "section": "2.2 Trading Options on Exchanges",
    "text": "2.2 Trading Options on Exchanges\nOptions are actively traded on organized exchanges and also arranged as private contracts (called over-the-counter or OTC). Exchange-traded options offer standardized contracts with transparent pricing, while OTC options can be customized but involve counterparty risk.\nMost option positions on exchanges are closed before expiration through offsetting trades rather than exercise. This allows traders to capture profits, limit losses, or adjust strategies as market conditions change.\n\nStrikes and Maturities\nExchanges determine which strike prices and expiration dates are available for trading. As time passes and options expire, new expiration cycles are introduced. New strike prices are added when the underlying price moves, ensuring strikes bracket the current market price. The number of available strikes and expirations depends on trading interest and exchange policies.\n\n\nOrder Types and Execution\nTraders can submit either market orders or limit orders. Market orders execute immediately “at market.” Limit buy orders specify a maximum price the trader is willing to pay and limit sell orders specify a minimum price the trader is willing to accept. A limit order can execute immediately if someone else is willing to take the other side. Otherwise, it joins the queue of limit orders and will eventually execute against an incoming market order when and if the limit price becomes the best available price for the counterparty (the highest price among limit buy orders or the lowest price among limit sell orders) and when it achieves time priority among other limit orders at the same price (i.e., it was the first to arrive).\nFor an option sell order, trading “at market” means trading at the highest limit buy price in the market. This is the best price, from the seller’s point of view, that other traders are bidding for the option, and it is called the bid price. For an option buy order, trading at market means trading at the lowest limit sell price in the market. This is the best price that other traders are asking for the option, and it is called the ask price. In summary,\n\nMarket Orders execute immediately at the best available price:\n\nMarket buy order → executes at the ask price\nMarket sell order → executes at the bid price\nGuaranteed execution but uncertain price\n\nLimit Orders specify a maximum buy price or minimum sell price:\n\nLimit buy at $2.40 when ask is $2.60 → order waits in queue\nMay get better execution price but risks non-execution\nProvides price control but no execution guarantee\n\nExample: If you want to buy a call option with bid $2.50 / ask $2.60:\n\nMarket order: Pay $2.60 immediately\n\nLimit order at $2.55: Wait for seller willing to accept $2.55 (may never happen)\nLimit order at $2.40: Less likely to execute than a limit order at $2.55\n\n\n\n\nOpen Interest and Contract Creation\nUnlike stocks, options have no pre-existing supply. When a new option series (specific strike/expiration combination) is introduced, open interest starts at zero. Options are created through trading activity:\n\nFirst trade: 1 buyer + 1 seller → Open interest = 1\nNew position created: New buyer + New seller → Open interest increases\n\nPosition closed: Existing holder sells to new buyer → Open interest unchanged\nBoth parties close: Existing buyer and seller offset → Open interest decreases\n\nAt any time, the number of long positions exactly equals the number of short positions, and this total is called open interest.\n\n\nThe Role of the Clearinghouse\nExchange clearinghouses serve as the counterparty to every options trade, providing several crucial functions:\n\nCounterparty Guarantee:\n\nLong call holders have the right to buy from the clearinghouse (not from the original seller)\nShort call writers have an obligation to deliver to the clearinghouse (if assigned)\nThis eliminates counterparty risk for traders\n\nExercise and Assignment Process:\n\nOption holder notifies broker of exercise decision\nBroker notifies clearinghouse\n\nClearinghouse randomly selects a short position for assignment\nUnderlying shares and strike payment flow through clearinghouse\n\nMargin: Option sellers must post collateral (margin) to ensure they can meet their obligations. This protects the clearinghouse and, ultimately, option buyers from default risk.\nBenefits of the Clearinghouse System:\n\nAnonymous trading without knowing your counterparty\nAbility to close positions with different traders than your original counterparty\n\nStandardized contract terms and settlement procedures\nReduced counterparty risk for all market participants",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#patterns-in-option-prices",
    "href": "Chapter_Intro_Options.html#patterns-in-option-prices",
    "title": "2  Options",
    "section": "2.3 Patterns in Option Prices",
    "text": "2.3 Patterns in Option Prices\nFigure 2.1 allows us to browse current market data for exchange-traded options. The columns of the table are:\n\nStrike: the price at which the owner of a call (put) has the right to buy (sell) the underlying asset.\nBid price: the price that a market sell order will pay (it is the best price that limit orders are bidding for the option)\nAsk price: the price that a price buy order will pay (it is the best price that limit orders are asking for the option)\nLast price: the last price at which the option traded.\nTime of last trade: the day and time at which the option last traded.\nVolume: the number of contracts traded during the day. Each contract is for 100 shares of the underlying asset.\nOpen interest: The number of contracts for which there are currently outstanding positions.\n\n\n\n\n\n\n\n\nFigure 2.1: Options market data courtesy of Yahoo Finance.  The left sidebar has user controls for ticker, call versus put, and maturity. If it is not visible, use the  icon at the top of the figure to open it. To move around the table, first hover over it to bring up an inner vertical slider.\n\n\n\nExperimenting with Figure 2.1 reveals consistent patterns in how options are priced relative to each other. Understanding these patterns helps build intuition about option values. We should see the following.\n\nStrike Price Effects\n\nCall Options: Prices decrease as strike prices increase\n\nA call with strike $50 is worth more than a call with strike $100, so it trades at a higher premium\nExample: If AAPL trades at $150, a $140 call is more valuable than a $160 call\n\nPut Options: Prices increase as strike prices increase\n\nA put with strike $100 is worth more than a put with strike $50, so it trades at a higher price\nExample: If AAPL trades at $150, a $160 put is more valuable than a $140 put\n\n\n\n\nTime to Expiration Effects\nLonger-dated options cost more because they provide:\n\nMore time for favorable price movements\nGreater flexibility (American options can be exercised over a longer period)\n\n\n\nArbitrage Bounds\nAmerican option prices must respect certain minimum values to prevent arbitrage:\n\nCall Option Lower Bound: \\(C \\geq \\max(S - K, 0)\\)\n\nA call must be worth at least its immediate exercise value\nExample: If AAPL = $150 and call strike = $140, then call price ≥ $10\n\nPut Option Lower Bound: \\(P \\geq \\max(K - S, 0)\\)\n\nA put must be worth at least its immediate exercise value\nExample: If AAPL = $140 and put strike = $150, then put price ≥ $10\n\nWhy These Bounds Hold: If violated, an arbitrageur could:\n\nBuy the underpriced option\nImmediately exercise it\n\nTrade the underlying asset in the opposite direction\nLock in risk-free profit\n\n\nThese arbitrage bounds mean that option prices equal their intrinsic value with additional time value on top.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#payoff-diagrams",
    "href": "Chapter_Intro_Options.html#payoff-diagrams",
    "title": "2  Options",
    "section": "2.4 Payoff Diagrams",
    "text": "2.4 Payoff Diagrams\nUnderstanding option payoffs is fundamental to options trading. A payoff diagram shows the profit or loss from an option position at expiration as a function of the underlying asset price. These diagrams help visualize the risk-reward profile of different option strategies.\nAt expiration, an option’s value equals its intrinsic value - the amount by which it is “in the money.” For a call option with strike price \\(K\\), the payoff is \\(\\max(S_T - K, 0)\\) where \\(S_T\\) is the underlying asset price at expiration. For a put option, the payoff is \\(\\max(K - S_T, 0)\\).\nThe profit from an option position also accounts for the premium paid (for long positions) or received (for short positions). Let’s examine the four basic option positions:\n\nLong Call\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\n\n# Parameters\nK = 100  # Strike price\npremium = 5  # Option premium\nS = np.linspace(80, 120, 100)  # Range of stock prices\n\n# Long call payoff and profit\ncall_payoff = np.maximum(S - K, 0)\ncall_profit = call_payoff - premium\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=call_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=call_profit,\n    mode='lines',\n    name='Profit/Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n# Add breakeven line\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=\"Breakeven\")\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\n# Formatting\nfig.update_layout(\n    title=\"Long Call Option\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Payoff/Profit ($)\",\n    template=\"plotly_white\",\n    width=600,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.2: Payoff diagram for a long call option\n\n\n\n\nA long call position benefits from rising stock prices. The maximum loss is limited to the premium paid ($5), while the potential profit is unlimited. The breakeven point is at the strike price plus the premium ($105).\n\n\nLong Put\n\n\nCode\n# Long put payoff and profit\nput_payoff = np.maximum(K - S, 0)\nput_profit = put_payoff - premium\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=put_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=put_profit,\n    mode='lines',\n    name='Profit/Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n# Add breakeven line\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=\"Breakeven\")\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    title=\"Long Put Option\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Payoff/Profit ($)\",\n    template=\"plotly_white\",\n    width=600,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.3: Payoff diagram for a long put option\n\n\n\n\nA long put position benefits from falling stock prices. Like the long call, the maximum loss is the premium paid, but the maximum profit is limited (the stock price cannot fall below zero). The breakeven point is at the strike price minus the premium ($95).\n\n\nShort Call\n\n\nCode\n# Short call payoff and profit (opposite of long call)\nshort_call_payoff = -call_payoff\nshort_call_profit = premium - call_payoff\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=short_call_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=short_call_profit,\n    mode='lines',\n    name='Profit/Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n# Add breakeven line\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=\"Breakeven\")\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    title=\"Short Call Option\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Payoff/Profit ($)\",\n    template=\"plotly_white\",\n    width=600,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.4: Payoff diagram for a short call option\n\n\n\n\nA short call position (writing a call) benefits from falling or stable stock prices. The maximum profit is the premium received ($5), while the potential loss is unlimited if the stock price rises significantly.\n\n\nShort Put\n\n\nCode\n# Short put payoff and profit (opposite of long put)\nshort_put_payoff = -put_payoff\nshort_put_profit = premium - put_payoff\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=short_put_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=short_put_profit,\n    mode='lines',\n    name='Profit/Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n# Add breakeven line\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=\"Breakeven\")\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    title=\"Short Put Option\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Payoff/Profit ($)\",\n    template=\"plotly_white\",\n    width=600,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.5: Payoff diagram for a short put option\n\n\n\n\nA short put position (writing a put) benefits from rising or stable stock prices. The maximum profit is the premium received, while the maximum loss occurs if the stock price falls to zero (loss = strike price - premium).\n\n\nSummary of Basic Option Positions\nThe four basic option positions can be summarized as follows:\n\n\n\n\n\n\n\n\n\n\nPosition\nMarket View\nMax Profit\nMax Loss\nBreakeven\n\n\n\n\nLong Call\nBullish\nUnlimited\nPremium paid\nStrike + Premium\n\n\nLong Put\nBearish\nStrike - Premium\nPremium paid\nStrike - Premium\n\n\nShort Call\nBearish/Neutral\nPremium received\nUnlimited\nStrike + Premium\n\n\nShort Put\nBullish/Neutral\nPremium received\nStrike - Premium\nStrike - Premium\n\n\n\nThese basic positions form the building blocks for more complex option strategies such as spreads, straddles, and collars.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#option-portfolios",
    "href": "Chapter_Intro_Options.html#option-portfolios",
    "title": "2  Options",
    "section": "2.5 Option Portfolios",
    "text": "2.5 Option Portfolios\nIndividual options can be combined with each other and with the underlying asset to create portfolios with specific risk-reward profiles. These strategies allow investors to implement sophisticated views about market direction, volatility, and risk management. We examine several common option portfolios below.\n\nProtective Put\nA protective put combines a long position in the underlying asset with a long put option. This strategy provides downside protection while maintaining upside potential.\n\n\nCode\n# Parameters for all strategies\nS0 = 100  # Current stock price\nK_put = 95   # Put strike\nK_call = 105 # Call strike (for other strategies)\nput_premium = 3\ncall_premium = 2\nS = np.linspace(80, 120, 100)\n\n# Protective put: Long stock + Long put\nstock_payoff = S  # Stock value at maturity\nput_payoff = np.maximum(K_put - S, 0)  # Put payoff at maturity\nprotective_put_payoff = stock_payoff + put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=stock_payoff, mode='lines', \n                        name='Long Stock', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=put_payoff, mode='lines', \n                        name='Long Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=protective_put_payoff, mode='lines', \n                        name='Protective Put', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_put, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Put Strike = ${K_put}\")\n\nfig.update_layout(\n    title=\"Protective Put Strategy\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.6: Protective put: long stock + long put\n\n\n\n\nThe protective put acts like insurance for a stock position. The value at maturity is always at least the put strike price, providing downside protection, while maintaining unlimited upside potential with the stock.\n\n\nCollar\nA collar combines a protective put with a covered call (selling a call option against the stock position). This strategy provides downside protection while capping upside potential in exchange for reducing the net premium cost.\n\n\nCode\n# Collar: Long stock + Long put + Short call\ncall_payoff = -np.maximum(S - K_call, 0)  # Short call payoff at maturity\ncollar_payoff = stock_payoff + put_payoff + call_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=stock_payoff, mode='lines', \n                        name='Long Stock', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=put_payoff, mode='lines', \n                        name='Long Put', line=dict(color='green', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=call_payoff, mode='lines', \n                        name='Short Call', line=dict(color='orange', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=collar_payoff, mode='lines', \n                        name='Collar', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_put, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Put Strike = ${K_put}\")\nfig.add_vline(x=K_call, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Call Strike = ${K_call}\")\n\nfig.update_layout(\n    title=\"Collar Strategy\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.7: Collar: long stock + long put + short call\n\n\n\n\nThe collar provides a bounded range of values at maturity. The portfolio value is limited to a minimum of the put strike and a maximum of the call strike, regardless of how far the stock price moves.\n\n\nBull Call Spread\nA bull call spread involves buying a call option and selling another call option with a higher strike price. This strategy profits from moderate upward price movement.\n\n\nCode\n# Bull call spread parameters\nK_low = 95   # Lower strike (long call)\nK_high = 105 # Higher strike (short call)\nlow_call_premium = 7\nhigh_call_premium = 3\n\n# Bull call spread: Long low-strike call + Short high-strike call\nlong_call_payoff = np.maximum(S - K_low, 0)  # Long call payoff at maturity\nshort_call_payoff = -np.maximum(S - K_high, 0)  # Short call payoff at maturity\nbull_spread_payoff = long_call_payoff + short_call_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=long_call_payoff, mode='lines', \n                        name=f'Long {K_low} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=short_call_payoff, mode='lines', \n                        name=f'Short {K_high} Call', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=bull_spread_payoff, mode='lines', \n                        name='Bull Call Spread', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_low, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low Strike = ${K_low}\")\nfig.add_vline(x=K_high, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High Strike = ${K_high}\")\n\nfig.update_layout(\n    title=\"Bull Call Spread\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.8: Bull call spread: long low-strike call + short high-strike call\n\n\n\n\nThe bull call spread has a maximum value of (high strike - low strike) when the stock price is at or above the higher strike, and a minimum value of zero when the stock price is at or below the lower strike.\n\n\nBear Put Spread\nA bear put spread involves buying a put option and selling another put option with a lower strike price. This strategy profits from moderate downward price movement.\n\n\nCode\n# Bear put spread: Long high-strike put + Short low-strike put\nhigh_put_premium = 8\nlow_put_premium = 4\n\nlong_put_payoff = np.maximum(K_high - S, 0)  # Long put payoff at maturity\nshort_put_payoff = -np.maximum(K_low - S, 0)  # Short put payoff at maturity\nbear_spread_payoff = long_put_payoff + short_put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=long_put_payoff, mode='lines', \n                        name=f'Long {K_high} Put', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=short_put_payoff, mode='lines', \n                        name=f'Short {K_low} Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=bear_spread_payoff, mode='lines', \n                        name='Bear Put Spread', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_low, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low Strike = ${K_low}\")\nfig.add_vline(x=K_high, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High Strike = ${K_high}\")\n\nfig.update_layout(\n    title=\"Bear Put Spread\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.9: Bear put spread: long high-strike put + short low-strike put\n\n\n\n\nThe bear put spread has a maximum value of (high strike - low strike) when the stock price is at or below the lower strike, and a minimum value of zero when the stock price is at or above the higher strike.\n\n\nStraddle\nA straddle involves buying both a call and a put option with the same strike price. This strategy profits from large price movements in either direction (high volatility).\n\n\nCode\n# Straddle: Long call + Long put (same strike)\nK_straddle = 100\nstraddle_call_premium = 5\nstraddle_put_premium = 5\n\nstraddle_call_payoff = np.maximum(S - K_straddle, 0)  # Call payoff at maturity\nstraddle_put_payoff = np.maximum(K_straddle - S, 0)  # Put payoff at maturity\nstraddle_payoff = straddle_call_payoff + straddle_put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=straddle_call_payoff, mode='lines', \n                        name=f'Long {K_straddle} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=straddle_put_payoff, mode='lines', \n                        name=f'Long {K_straddle} Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=straddle_payoff, mode='lines', \n                        name='Long Straddle', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_straddle, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Strike = ${K_straddle}\")\n\n# Note: Breakeven lines removed since we're showing value at maturity, not profit/loss\n\nfig.update_layout(\n    title=\"Long Straddle\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.10: Long straddle: long call + long put (same strike)\n\n\n\n\nA straddle has its minimum value of zero when the stock price equals the strike price at maturity. The value increases as the stock price moves away from the strike in either direction, with no upper limit on potential value.\n\n\nButterfly Spread\nA butterfly spread involves buying options at two different strike prices and selling two options at a middle strike price. This strategy profits when the stock price stays near the middle strike (low volatility).\n\n\nCode\n# Butterfly spread parameters\nK_low_bf = 90\nK_mid_bf = 100\nK_high_bf = 110\nlow_call_bf_premium = 12\nmid_call_bf_premium = 6\nhigh_call_bf_premium = 2\n\n# Butterfly: Long low call + Short 2 middle calls + Long high call\nbf_low_call = np.maximum(S - K_low_bf, 0)  # Long low call payoff at maturity\nbf_mid_call = -2 * np.maximum(S - K_mid_bf, 0)  # Short 2 middle calls payoff at maturity\nbf_high_call = np.maximum(S - K_high_bf, 0)  # Long high call payoff at maturity\nbutterfly_payoff = bf_low_call + bf_mid_call + bf_high_call\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=bf_low_call, mode='lines', \n                        name=f'Long {K_low_bf} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=bf_mid_call, mode='lines', \n                        name=f'Short 2x {K_mid_bf} Calls', line=dict(color='green', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=bf_high_call, mode='lines', \n                        name=f'Long {K_high_bf} Call', line=dict(color='orange', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=butterfly_payoff, mode='lines', \n                        name='Butterfly Spread', line=dict(color='red', width=3)))\n\nfig.add_hline(y=0, line_dash=\"dot\", line_color=\"gray\")\nfig.add_vline(x=K_low_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low = ${K_low_bf}\")\nfig.add_vline(x=K_mid_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Mid = ${K_mid_bf}\")\nfig.add_vline(x=K_high_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High = ${K_high_bf}\")\n\nfig.update_layout(\n    title=\"Butterfly Spread\",\n    xaxis_title=\"Stock Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", width=600, height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 2.11: Butterfly spread: long low call + short 2 middle calls + long high call\n\n\n\n\nThe butterfly spread achieves its maximum value when the stock price equals the middle strike at expiration. The value decreases as the stock price moves away from the middle strike, reaching zero when the stock price is at or beyond either outer strike.\n\n\nInteractive Portfolio Builder\nThe strategies shown above represent just a few of the many possible option combinations. The interactive figure below allows you to experiment with different option portfolios by entering quantities for various option positions and the underlying asset.\n\n\n\n\n\nInteractive portfolio builder.\n\n\nFigure 2.12: The value at maturity of a portfolio of options is plotted, assuming all of the options have the same maturity. Enter positive quantities for long positions in options and negative quantities for short positions. Long or short positions in the underlying asset can also be included. Cash means a position in a risk-free asset sufficient to deliver the specified amount of cash at the option maturity.\n\n\n\nThis interactive tool enables you to:\n\nBuild complex option strategies by combining multiple positions\nVisualize the payoff profile of any portfolio combination\nExperiment with different strike prices and position sizes\nUnderstand how adding or removing positions affects the overall risk-reward profile\n\nTry recreating the strategies we’ve discussed above, or experiment with your own combinations to develop intuition about how option portfolios behave.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#volume-and-open-interest-patterns",
    "href": "Chapter_Intro_Options.html#volume-and-open-interest-patterns",
    "title": "2  Options",
    "section": "2.6 Volume and Open Interest Patterns",
    "text": "2.6 Volume and Open Interest Patterns\nUnderstanding trading volume and open interest patterns provides insight into market behavior and liquidity in options markets. These patterns reflect how traders use options and where market activity concentrates.\n\nThe Life Cycle of Open Interest\nWhen an exchange first introduces a new option series (a specific combination of underlying asset, strike price, and expiration date), open interest starts at zero. Open interest represents the total number of outstanding option contracts that have not been closed or exercised.\nInitial Growth Phase: As traders begin to notice and trade the new option, open interest grows. Each time a new buyer purchases an option from a new seller (rather than from someone closing an existing position), open interest increases by one contract. For example:\n\nDay 1: Trader A buys 10 call contracts from Trader B → Open interest = 10\nDay 2: Trader C buys 5 call contracts from Trader D → Open interest = 15\n\nDay 3: Trader E buys 3 call contracts from Trader A (closing A’s position) → Open interest = 15 (unchanged)\n\nPeak Activity: Open interest typically reaches its peak when the option has several weeks or months remaining until expiration and the strike price is reasonably close to the current stock price. During this phase, the option attracts both speculators and hedgers.\nDecline Phase: As expiration approaches, open interest generally declines for several reasons: - Traders close positions by making offsetting trades rather than holding to expiration - Some positions are exercised early (for American options) - Risk managers prefer not to hold options too close to expiration due to increased time decay and volatility\nFinal Settlement: At expiration, remaining open interest is settled through automatic exercise (for in-the-money options) or expires worthless (for out-of-the-money options).\n\n\nWhy Out-of-the-Money Options Are Popular\nExamining Figure 2.1 reveals that trading activity and open interest are often concentrated in out-of-the-money options rather than in-the-money ones. Several factors explain this pattern:\n1. Leverage and Cost Efficiency Out-of-the-money options cost significantly less than in-the-money or at-the-money options. This lower cost provides higher leverage, allowing traders to control more shares with the same dollar investment. A trader with $1,000 might be able to buy: - 2 in-the-money calls at $500 each, or\n- 20 out-of-the-money calls at $50 each\n2. Speculative Appeal Out-of-the-money options offer the potential for large percentage returns if the underlying stock moves favorably. While the probability of profit may be lower, the potential rewards are proportionally higher, attracting speculative traders.\n3. Hedging Applications Portfolio managers often use out-of-the-money puts as portfolio insurance. These “tail risk” hedges provide protection against large market declines while minimizing the cost of insurance premiums.\n4. Time Value Focus Out-of-the-money options consist entirely of time value (no intrinsic value). Traders who want to bet on volatility or time decay often prefer these options because their value is most sensitive to these factors.\n\n\nObservable Patterns in Market Data\nWhen examining options market data, several consistent patterns emerge:\nStrike Price Distribution: - Volume and open interest concentrate in strikes within roughly 10-20% of the current stock price - Call activity tends to be higher in strikes above the current price - Put activity tends to be higher in strikes below the current price\nMaturity Effects: - Near-term expirations (1-8 weeks) typically show the highest volume due to active trading - Longer-term options (3+ months) may show high open interest but lower daily volume - Options expiring in less than a week often see volume spikes as traders close positions\nTime Decay Impact: - Options with strikes far from the current price show less frequent trading - Last trade dates for these “far out-of-the-money” options may be days or weeks old - Bid-ask spreads widen significantly for strikes with little trading interest\nAsymmetric Patterns: - Put options often show higher implied volatility than calls (volatility skew) - Open interest in puts may spike during market uncertainty - Call open interest may concentrate in strikes just above current resistance levels\nThese patterns reflect the diverse motivations of options traders: speculation, hedging, income generation, and portfolio management. Understanding these patterns helps explain why certain options trade actively while others remain dormant, and why pricing and liquidity can vary dramatically across different strikes and expirations.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#put-call-parity",
    "href": "Chapter_Intro_Options.html#put-call-parity",
    "title": "2  Options",
    "section": "2.7 Put-Call Parity",
    "text": "2.7 Put-Call Parity\nPut-call parity is one of the most important relationships in options pricing. It establishes a precise connection between the prices of European calls, puts, the underlying asset, and risk-free bonds. This relationship must hold to prevent arbitrage opportunities - riskless profit possibilities that would be quickly eliminated by trader activity.\n\nThe Put-Call Parity Relationship\nFor European options on non-dividend-paying stocks, put-call parity states that:\n\\[\\text{Cash} + \\text{Call} = \\text{Put} + \\text{Underlying}\\]\nMore precisely, if we denote: - \\(C\\) = price of a European call option - \\(P\\) = price of a European put option\n- \\(S\\) = current price of the underlying stock - \\(K\\) = strike price (same for both call and put) - \\(r\\) = risk-free interest rate - \\(T\\) = time to expiration\nThen put-call parity requires: \\[Ke^{-rT} + C = P + S\\]\nThe term \\(Ke^{-rT}\\) represents the present value of the strike price - the amount of cash that, when invested at the risk-free rate, will grow to exactly \\(K\\) at expiration.\n\n\nUnderstanding the Economic Logic\nThe put-call parity relationship reflects the fact that two different portfolios have identical payoffs at expiration:\nPortfolio A (Left Side): Cash + Call - Hold cash worth \\(Ke^{-rT}\\) (which grows to \\(K\\) by expiration) - Own a call option with strike \\(K\\)\nPortfolio B (Right Side): Put + Underlying\n- Own a put option with strike \\(K\\) - Own one share of the underlying stock\nLet’s examine what happens at expiration for any stock price \\(S_T\\):\nCase 1: Stock price at expiration \\(S_T &gt; K\\) - Portfolio A: Cash grows to \\(K\\), call is worth \\((S_T - K)\\), total value = \\(K + (S_T - K) = S_T\\) - Portfolio B: Put expires worthless, stock is worth \\(S_T\\), total value = \\(0 + S_T = S_T\\)\nCase 2: Stock price at expiration \\(S_T \\leq K\\)\n- Portfolio A: Cash grows to \\(K\\), call expires worthless, total value = \\(K + 0 = K\\) - Portfolio B: Put is worth \\((K - S_T)\\), stock is worth \\(S_T\\), total value = \\((K - S_T) + S_T = K\\)\nSince both portfolios have identical payoffs in all possible scenarios, they must have the same current value to prevent arbitrage opportunities.\n\n\nArbitrage Example\nSuppose put-call parity is violated. For example, assume: - Stock price: \\(S = \\$100\\) - Strike price: \\(K = \\$100\\)\n- Time to expiration: \\(T = 0.25\\) years (3 months) - Risk-free rate: \\(r = 5\\%\\) - Call price: \\(C = \\$6\\) - Put price: \\(P = \\$4\\)\nPresent value of strike: \\(Ke^{-rT} = 100e^{-0.05 \\times 0.25} = \\$98.76\\)\nPut-call parity requires: \\(98.76 + 6 = 4 + 100\\), or \\(104.76 = 104\\)\nSince \\(104.76 &gt; 104\\), the left side is overpriced relative to the right side. An arbitrageur would:\n\nSell the expensive side: Sell the call and lend $98.76 at the risk-free rate\nBuy the cheap side: Buy the put and buy the stock\nInitial cash flow: \\(+6 + 98.76 - 4 - 100 = +\\$0.76\\) (immediate profit!)\n\nAt expiration, regardless of the stock price, the arbitrageur can close all positions with zero net cash flow, keeping the initial $0.76 as riskless profit.\n\n\nPractical Implications\nPut-call parity has several important applications:\n1. Options Pricing: If we know the prices of a call, the underlying stock, and the risk-free rate, we can determine what the put price should be (and vice versa).\n2. Synthetic Instruments: We can create synthetic positions: - Synthetic call: \\(C = P + S - Ke^{-rT}\\)\n- Synthetic put: \\(P = C - S + Ke^{-rT}\\) - Synthetic stock: \\(S = C - P + Ke^{-rT}\\)\n3. Conversion and Reversal Strategies: Professional traders use these synthetic relationships to identify mispriced options and construct arbitrage trades.\n\n\nImportant Limitations\nPut-call parity as stated above applies specifically to: - European options (cannot be exercised before expiration) - Non-dividend-paying stocks (dividends complicate the relationship) - Same strike price and expiration for both call and put\nFor American options, the relationship becomes an inequality because early exercise rights have value. For dividend-paying stocks, the present value of expected dividends must be subtracted from the stock price in the parity relationship.\nDespite these limitations, put-call parity remains one of the most reliable and useful relationships in options theory, providing a foundation for understanding options pricing and identifying trading opportunities.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Options.html#early-exercise-of-american-options",
    "href": "Chapter_Intro_Options.html#early-exercise-of-american-options",
    "title": "2  Options",
    "section": "2.8 Early Exercise of American Options",
    "text": "2.8 Early Exercise of American Options\nMost exchange-traded options are American-style, meaning they can be exercised at any time before expiration. However, early exercise is not always optimal and should be considered carefully. Understanding when early exercise might be beneficial requires analyzing the trade-off between immediate payoff and the option’s remaining time value.\n\nThe General Principle: Time Value vs. Intrinsic Value\nAn option’s market price consists of two components: - Intrinsic value: The immediate payoff if exercised now - Time value: The additional value from the possibility of more favorable price movements before expiration\nWhen you exercise an option early, you capture the intrinsic value but forfeit all remaining time value. Therefore, early exercise is generally only optimal when the time value has become negligible or when other factors make immediate exercise advantageous.\n\n\nAmerican Calls on Non-Dividend-Paying Stocks\nFor American call options on stocks that pay no dividends, early exercise is never optimal. This important result follows from the fact that:\n\nThe call’s market value always exceeds its intrinsic value when time remains\nYou can always sell the call in the market for more than you would receive from exercising\nThere’s no benefit (like dividend capture) that would offset the loss of time value\n\nExample: Suppose you own a call option with strike $100 on a stock currently trading at $110. The intrinsic value is $10, but the option trades for $12 due to remaining time value. Exercising gives you $10, while selling gives you $12 - clearly, selling is superior.\n\n\nAmerican Puts: When Early Exercise May Be Optimal\nAmerican put options, unlike calls, may sometimes benefit from early exercise. This typically occurs when:\n1. Deep In-the-Money Puts When a put is very deep in-the-money, its time value becomes small relative to intrinsic value. If the stock price has fallen dramatically, the put may trade close to its intrinsic value, making early exercise reasonable.\n2. High Interest Rates Early exercise of a put provides immediate cash that can be invested at the risk-free rate. When interest rates are high, this immediate investment opportunity may outweigh the option’s remaining time value.\n3. Extreme Scenarios If the underlying stock becomes worthless (bankruptcy), a put with any strike greater than zero should be exercised immediately since the maximum payoff has been achieved.\n\n\nCalls on Dividend-Paying Stocks\nAmerican calls on dividend-paying stocks present a more complex situation. Early exercise might be optimal:\nJust Before Ex-Dividend Date: When a stock pays a large dividend, the stock price typically drops by approximately the dividend amount on the ex-dividend date. Call holders do not receive the dividend, so they may prefer to: 1. Exercise the call just before the ex-dividend date to capture the dividend 2. Accept the loss of time value in exchange for the dividend payment\nThe decision depends on comparing the dividend amount to the call’s remaining time value.\n\n\nPractical Considerations\nIn practice, individual investors rarely find early exercise optimal because:\n1. Time Value Loss: The mathematical conditions favoring early exercise are uncommon 2. Transaction Costs: Exercise triggers stock purchase/sale with associated costs\n3. Tax Implications: Early exercise may accelerate tax liabilities 4. Liquidity: Selling the option is usually more efficient than exercising\nProfessional Arbitrageurs are more likely to exercise early when: - They can immediately hedge the resulting stock position - They have identified precise arbitrage opportunities - Transaction costs are minimal due to their trading infrastructure\n\n\nLooking Ahead\nThe precise mathematical conditions for optimal early exercise involve sophisticated option pricing models that account for factors like: - Interest rate differentials - Dividend timing and amounts\n- Volatility dynamics - The option’s moneyness and time to expiration\nThese topics are explored in detail in later chapters on American option pricing and numerical methods. For now, the key insight is that while American options provide early exercise flexibility, this right is valuable primarily in specific circumstances rather than as a general trading strategy.\nThe early exercise feature does make American options more valuable than otherwise identical European options, but this premium is often small except in the special cases outlined above.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html",
    "href": "Chapter_Brownian.html",
    "title": "3  Brownian Motion",
    "section": "",
    "text": "3.1 Brownian Paths\nBrownian motion is a fundamental tool for modeling variables that change randomly over time. Consider predicting a future stock price. We don’t know today what the price will be tomorrow, nor what it will be the following day, nor what it will be the day after that. We can regard the price three days from now as today’s price plus the change from today to tomorrow plus the change from tomorrow to the following day plus the change from that day to the next. Thus, there are three random changes in this small example. A simple way to model this situation is to assume that each change is a normally distributed random variable with some mean and variance. Thus, the price in three days is viewed as today’s price plus the sum of three normal increments.\nRather than predicting daily changes as in the previous paragraph, we might be interested in predicting hourly changes or even minute-to-minute changes. This will lead to more, but smaller, increments. A Brownian motion is a model of changes at all frequencies, with all changes being normally distributed.\nWe will ultimately deal with different means and different variances, but we start with what is called a standard Brownian motion, which is similar to beginning the study of normal random variables by studying a standard normal variable, that is, a normal random variable with a zero mean and a unit variance. The definition of a standard Brownian motion is that its change over any time interval\nThe last bullet point reflects the fact that things are more uncertain the further into the future we look.1\nWe call a variable that changes randomly over time a stochastic process. A path of a stochastic process is a random function of time, recording how it evolves over time. We can plot an approximate path of a Brownian motion by summing up normally distributed changes. We take an interval of time \\([0, t]\\) and split it up as \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] where the times \\(t_i\\) are equally spaced, meaning that \\(t_i-t_{i-1} = t/n\\), which we will call \\(\\Delta t\\). We generate \\(n\\) normally distributed random variables with zero means and variance equal to \\(\\Delta t\\) and define the approximate Brownian motion, which we call \\(B\\), as the cumulative sum of the normal variables. By convention, we start any Brownian motion at \\(B_0=0\\). Our approximation fits the definition of a standard Brownian motion, except that we have limited the frequency of the changes to \\(n\\) changes within the interval. By taking \\(n\\) larger, we can always get a better approximation. An introduction to simulation (also called Monte Carlo analysis) is provided in the appendis (Chapter 16).\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\n\n# generate dB for each time step\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\n\n# B starts at 0 and is cumulative sum of the dB\nB = np.zeros(n+1)\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Approximate Brownian Motion',\n    template='plotly_white',\n    height=300,\n)\n\nfig.show()\n\n\n\n\n\n\n\n        \n        \n        \n\n\n(a) A path of an approximate Brownian motion with 1,000 normally distributed steps.\n\n\n\n\n\n\n                            \n                                            \n\n\n(b)\n\n\n\n\n\nFigure 3.1",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#sec-s:brownian_binomial",
    "href": "Chapter_Brownian.html#sec-s:brownian_binomial",
    "title": "3  Brownian Motion",
    "section": "3.2 Binomial Approximation",
    "text": "3.2 Binomial Approximation\nWe can also generate an approximate path of a Brownian motion by taking only up or down steps of a fixed size at each date, rather than using normally distributed steps. We call this a binomial model. A binomial model approximates the normally distributed increments of a Brownian Motion due to the Central Limit Theorem, which says that an appropriately scaled sum of a large number of random variables has approximately a normal distribution. The binomial approximation is often useful for pricing options, especially American options, as we will see. An introduction to binomial models is provided in the appendix. (Chapter 15).\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\nsqdt = np.sqrt(dt)\n\n# generate dB for each time step\ndB = np.random.choice([-sqdt, sqdt], size=n)\nB = np.zeros(n+1)\n\n# Brownian path starts at 0 and is cumulative sum of the dB\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Binomial Process',\n    template='plotly_white',\n    height=300,\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 3.2: A path of an approximate Brownian motion with 1,000 binomial steps.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#sec-s:quadraticvariation",
    "href": "Chapter_Brownian.html#sec-s:quadraticvariation",
    "title": "3  Brownian Motion",
    "section": "3.3 Nonzero Quadratic Variation",
    "text": "3.3 Nonzero Quadratic Variation\nFigure 3.1 and Figure 3.2 illustrate a distinctive characteristic of a Brownian motion: it jiggles rapidly, moving up and down in a very erratic way. The name Brownian motion derives from the botanist Robert Brown’s observations of the erratic behavior of particles suspended in a fluid. The plot of other functions with which we may be familiar will be much smoother. This is captured in the concept of quadratic variation.\nConsider a discrete partition \\[0=t_0 &lt; t_1 &lt; t_2 &lt; \\cdots &lt; t_n=t\\] of the time interval \\([0,t]\\) as before. Let \\(B\\) be a Brownian motion and calculate the sum of squared changes \\[\\sum_{i=1}^n (\\Delta B_{t_i})^2\\; ,\\] where \\(\\Delta B_{t_i}\\) denotes the change \\(B_{t_i}-B_{t_{i-1}}.\\) If we consider finer partitions with the length of each time interval \\(t_i-t_{i-1}\\) going to zero, the limit of the sum is called the quadratic variation of the process. For a Brownian motion, the quadratic variation over an interval \\([0,t]\\) is equal to \\(t\\) with probability one. Here is a plot of the quadratic variation (that is, the cumulative sum of squared changes) of the previous approximation of a Brownian motion. The plot shows that the approximation has quadratic variation through each date \\(s \\le t\\) that is approximately equal to \\(s\\).\n\n\nCode\n# using the approximate path created in the previous code block\n# quadratic variation is cumulative sum of squared changes\n\ndQ = dB**2\nQ = np.zeros(n+1)\nQ[1:] = dQ.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=Q, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;' \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Quadratic Variation',\n    template='plotly_white',\n    height=300\n)\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 3.3: Quadratic variation of an approximate Brownian motion path with 1,000 normally distributed steps.\n\n\n\n\nTo better visualize the convergence of the quadratic variation of a Brownian motion as the number \\(n\\) of subdivisions of the interval \\([0, t]\\) grows, we encourage readers to interact with the plot below, which simulates a handful of approximate Brownian paths and their quadratic variations.\n\n\n\n\n\n\n\nFigure 3.4: Convergence of quadratic variation of approximate Brownian motions. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it.\n\n\n\nThe typical functions with which we are familiar are continuously differentiable. If \\(x\\) is a continuously differentiable function of time, then the quadratic variation of \\(x\\) is zero. A simple example is a linear function: \\(x_s = as\\) for all \\(s\\) for a constant \\(a\\). Then, using the previous partition of the interval \\([0, t]\\), the sum of squared changes of the function from \\(0\\) to \\(t\\) is \\[\\sum_{i=1}^n (\\Delta x_{t_i})^2 = \\sum_{i=1}^n  [a\\,\\Delta t]^2 = na^2 (\\Delta t)^2 = na^2 \\left(\\frac{t}{n}\\right)^2 = \\frac{a^2t^2}{n} \\rightarrow 0\\] as \\(n \\rightarrow \\infty\\). For example, if \\(a=1\\) and \\(n=1000\\), then the sum of squared changes from date \\(0\\) to date \\(1\\) is \\(1000 \\times 0.001^2 = 0.001\\). Essentially the same argument shows that the quadratic variation of any continuously differentiable function is zero, because such a function is approximately linear at each point. Thus, the jiggling of a Brownian motion, which leads to the nonzero quadratic variation, is quite unusual.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#infinite-total-variation",
    "href": "Chapter_Brownian.html#infinite-total-variation",
    "title": "3  Brownian Motion",
    "section": "3.4 Infinite Total Variation",
    "text": "3.4 Infinite Total Variation\nTo explain exactly how unusual the nonzero quadratic variation is, it is helpful to consider total variation, which is defined in the same way as quadratic variation but with the squared changes \\((\\Delta B_{t_i})^2\\) replaced by the absolute values of the changes \\(|\\Delta B_{t_i}|.\\) A general mathematical theorem states that, if the quadratic variation of a continuous function is nonzero, then its total variation is infinite. Therefore, each path of a Brownian motion has infinite total variation (with probability one). This means that, to draw a true path of a Brownian motion on a blackboard, we would need an infinite amount of chalk!\nIf we zoom in close enough in Figure 3.1, we can see the linear steps \\(\\Delta B\\). However, if we could zoom in on a segment of a path of a true Brownian motion, it would look much the same as the entire picture does to the naked eye—no matter how small the segment, we would still see the characteristic jiggling. That jiggling, even at microscopic scales, is the source of the infinite variation.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#continuous-martingales-and-levys-theorem",
    "href": "Chapter_Brownian.html#continuous-martingales-and-levys-theorem",
    "title": "3  Brownian Motion",
    "section": "3.5 Continuous Martingales and Levy’s Theorem",
    "text": "3.5 Continuous Martingales and Levy’s Theorem\nOne may well question why we should be interested in this curious mathematical object. The reason is that asset pricing inherently involves martingales (variables that evolve randomly over time in such a way that their expected changes are always zero), as our fundamental pricing formula (Equation 6.28) establishes. Furthermore, continuous processes (variables whose paths are continuous functions of time) are much more tractable mathematically than are processes that can jump at some instants. So, we are led to a study of continuous martingales. An important fact is that any non-constant continuous martingale must have infinite total variation. So, the normal functions with which we are familiar are left behind once we enter the study of continuous martingales.\nThere remains perhaps the question of why we focus on Brownian motion within the world of continuous martingales. The answer here is that any continuous martingale is really just a transformation of a Brownian motion. This is a consequence of the following important fact, which is known as Levy’s theorem: \n\n\n\n\n\n\nImportant Principle\n\n\n\nA continuous martingale is a Brownian motion if and only if its quadratic variation over each time interval \\([s, t]\\) equals \\(t-s\\).\n\n\nThus, among continuous martingales, a Brownian motion is distinguished by the condition that its quadratic variation over each time interval is equal to the length of the interval. This is really just a normalization. A different continuous martingale may have a different quadratic variation, but it can be converted to a Brownian motion by changing the clock speed to measure time according to the quadratic variation. Furthermore, many continuous martingales can be constructed as stochastic integrals with respect to a Brownian motion. We take up that topic in the next chapter.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#sec-s:correlation",
    "href": "Chapter_Brownian.html#sec-s:correlation",
    "title": "3  Brownian Motion",
    "section": "3.6 Correlation of Brownian Motions",
    "text": "3.6 Correlation of Brownian Motions\nConsider two standard Brownian motions \\(B_1\\) and \\(B_2\\). The relation between the two Brownian motions is determined by their covariance or correlation. Given dates \\(s&lt;t\\), we know that both changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\) are normally distributed with zero means and variances equal to \\(t-s\\), given information at date \\(s\\). There is a stochastic process \\(\\rho\\) such that the covariance of these two normally distributed random variables, given the information at date \\(s\\), is \\[\\mathrm{E}_s \\left[\\int_s^t \\rho_u\\mathrm{d}   u\\right]\\; .\\] The process \\(\\rho\\) is called the correlation process of the two Brownian motions. The correlation of the changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\), given information at date \\(s\\), is \\[\\frac{\\text{covariance}}{\\text{product of standard deviations}}  = \\frac{\\mathrm{E}_s\\int_s^t \\rho_u \\mathrm{d}   u}{\\sqrt{t-s} \\sqrt{t-s}} = \\frac{1}{t-s}\\mathrm{E}_s\\int_s^t \\rho_u \\mathrm{d}   u\\; .\\] Thus, the correlation is the expected average value of \\(\\rho_u\\). In particular, when \\(\\rho\\) is constant, the correlation of the changes is \\(\\rho\\). The two Brownian motions are independent if \\(\\rho=0\\). In this case, knowledge of one Brownian motion – even knowledge of its future values – will not help to predict the other.\nJust as we computed quadratic variation by taking a limit of sums of squared changes, we compute what is called joint variation by taking a limit of sums of products of changes. For the two Brownian motions, the joint variation over an interval \\([0, t]\\) is \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n \\Delta B_{1t_i} \\times \\Delta B_{2t_i} \\] given increasingly fine partitions \\(0=t_0 &lt; \\cdots &lt; t_n=t\\) as before. The joint variation of two Brownian motions equals the integral of their correlation process; that is, the joint variation over \\([0, t]\\) equals \\(\\int_0^t \\rho_s\\mathrm{d} s\\), with probability one. Thus, the expected joint variation equals the covariance.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#exercises",
    "href": "Chapter_Brownian.html#exercises",
    "title": "3  Brownian Motion",
    "section": "3.7 Exercises",
    "text": "3.7 Exercises\n\nExercise 3.1 Consider a discrete partition \\(0=t_0 &lt; t_1 &lt; \\cdots t_n=t\\) of the time interval \\([0,t]\\) with \\(t_i - t_{i-1} = \\Delta t = t/n\\) for each \\(i\\). Consider the function \\[X_t=\\mathrm{e}^t\\; .\\] Write a function that computes and plots \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\), where \\[\\Delta X_{t_i} = X_{t_i}-X_{t_{i-1}} = \\mathrm{e}^{t_i} - \\mathrm{e}^{t_{i-1}}\\; .\\]\n\n\nExercise 3.2 Repeat the previous problem for the function \\(X_t = t^3\\). In both this and the previous problem, can you tell what happens to \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\) as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 3.3 Write a function to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^2\\) from a partition of an interval \\([0, t]\\), for given \\(t\\) and \\(n\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 3.4 Repeat the previous problem to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^3\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 3.5 Repeat the previous problem, computing instead \\(\\sum_{i=1}^n |\\Delta B_{t_i}|\\) where \\(| \\cdot |\\) denotes the absolute value. What happens to this sum as \\(n \\rightarrow \\infty\\)?",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#footnotes",
    "href": "Chapter_Brownian.html#footnotes",
    "title": "3  Brownian Motion",
    "section": "",
    "text": "A formal definition of a Brownian motion would include a specification of the information that we have for predicting the future. The definition given here is correct when the only information is the past history of the Brownian motion.↩︎",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html",
    "href": "Chapter_Ito.html",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "4.1 Examples\nWe use the changes of a Brownian motion to model randomness. We build other stochastic processes using those changes. The general idea is \\[\\text{change} = \\text{mean} + \\text{std dev} \\times \\text{change in Brownian motion}\\,.\\] The mathematical foundations for our construction were created by K. Ito. The key concepts are the Ito integral, Ito processes, and Ito’s formula (also called Ito’s lemma). Using these foundations, we can build quite general processes from changes in Brownian motions, including processes with non-normal distributions.\nWe begin with some simple examples. Consider a discrete partition of a time interval: \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] with equally spaced times. Let \\(\\Delta t\\) denote the difference between successive times.\nFirst, let’s drop the randomness entirely. Consider the equation \\[X_{t_i} -  X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t \\qquad(4.1)\\] for a constant \\(\\mu\\). Thus, we have “change \\(\\,=\\,\\) mean,” where the mean is proportional to the previous value with proportionality factor \\(\\mu \\Delta t\\). Figure 4.1 presents a plot of \\(X\\), for particular values of \\(X_0\\), \\(\\mu\\), and \\(\\Delta t\\).\nIf we increase \\(n\\), making \\(\\Delta t\\) smaller, then \\(X\\) converges to the solution of the ordinary differential equation \\[\\mathrm{d} X_t = \\mu X_t\\mathrm{d}  t\\,. \\qquad(4.2)\\] Equation 4.2 has a known solution, which is \\[X_t = X_0 \\mathrm{e}^{\\mu t}\\,. \\qquad(4.3)\\] To verify this, we only need to differentiate \\(X\\) defined in Equation 4.3: \\[\\frac{\\mathrm{d} X_t}{\\mathrm{d} t} = \\mu X_0 \\mathrm{e}^{\\mu t} = \\mu X_t\\,.\\] The function presented in Equation 4.3 is also shown in Figure 4.1.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nn = 10   # number of subdivisions\nt = 1     # last date\nDeltat = t/n\nX1 = np.ones(n+1)\nfor i in range(1, n+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat\n\nX2 = np.exp(mu * np.arange(0, t+Deltat, Deltat))\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n\n\n\n\n\n\n\n        \n        \n        \n\n\n(a) The functions \\(X\\) satisfying Equation 4.1 (difference equation) and Equation 4.3 (differential equation) for X0 = 1, mu = 1, and Delta t = 0.1.\n\n\n\n\n\n\n                            \n                                            \n\n\n(b)\n\n\n\n\n\nFigure 4.1\nNow, let’s include randomness. Let’s make the noise proportional to the value of \\(X\\), So, let \\(B\\) be a standard Brownian motion and consider the equation \\[X_{t_i} - X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t + \\sigma X_{t_{i-1}} \\Delta B_{t_i} \\qquad(4.4)\\] where \\(\\sigma\\) is another constant, and \\(\\Delta B_{t_i} = B_{t_i} - B_{t_{i-1}}\\). A solution \\(X\\) of this equation has random paths, due to the random noise \\(\\Delta B_{t_i}\\). An example of a path is shown in Figure 4.2. Ito showed how we can take the limit of this equation as we make \\(\\Delta t\\) smaller and make sense of the equation \\[\n\\mathrm{d} X_t = \\mu X_t\\mathrm{d}  t + \\sigma X_t \\mathrm{d}  B_t\\,.\n\\qquad(4.5)\\] The solution \\(X\\) of Equation 4.5 is \\[X_t = \\mathrm{e}^{(\\mu  - \\sigma^2/2)t + \\sigma B_t}\\,. \\qquad(4.6)\\] We can show that \\(X\\) defined in Equation 4.6 satisfies Equation 4.5 by differentiating, as we showed that \\(X\\) defined in Equation 4.3 satisfies Equation 4.2. However, we first need to explain Ito’s formula, which is a formula for differentiating functions of Brownian motions and, more generally, functions of Ito processes. An approximate path of \\(X\\) is shown in Figure 4.2. It is generated by taking \\(\\Delta t\\) very small, just as we generated approximate paths of Brownian motions in Chapter 3.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nsigma = 1\nt = 1\n\n# Brownian path\nn = 1000   \ndt = t/n\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\nB = np.zeros(n+1)\nB[1:] = np.cumsum(dB)\n\n# Brownian path with discrete steps\nn_discrete = 10\nDeltat = t/n_discrete\nB_discrete = B[::int(n/n_discrete)]\nDeltaB = np.diff(B_discrete)\n\n# X in discrete-time \nX1 = np.ones(n_discrete+1)\nfor i in range(1, n_discrete+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat + sigma * X1[i-1] * DeltaB[i-1]\n\n# Continuous-time\nX2 = np.exp((mu - 0.5 * sigma**2) * np.arange(0, t+dt, dt) + sigma * B)\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+dt, dt), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 4.2: Paths of the processes satisfying Equation 4.4 (difference equation) and Equation 4.6 (differential equation) for X0 = 1, mu = 1, Delta t = 0.1, and sigma = 1.\nThe functions and processes \\(X\\) defined in this section have important interpretations. Equation 4.1 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t\\). This could represent the value of a savings account that earns interest of \\(\\mu \\Delta t\\) in each period of length \\(\\Delta t\\). This is the common way of calculating, for example, monthly interest, where \\(\\mu\\) is called the annual rate of interest and \\(\\Delta t\\) would be \\(1/12\\). The limiting Equation 4.3 is called continuous compounding of interest.\nSimilarly, Equation 4.4 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t + \\sigma \\Delta B\\). This represents a random rate of return – for example, the return of a stock. The expected rate of return in this case is \\(\\mu \\Delta t\\), and the variance of the rate of return is \\(\\sigma^2 \\Delta t\\). The limiting Equation 4.3 is called continuous compounding of returns.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:discreteito",
    "href": "Chapter_Ito.html#sec-s:discreteito",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "Theory Extra\n\n\n\n\n\nTo see how one might guess that Equation 4.3 is the solution of Equation 4.2, we can examine the logarithm of \\(X\\). A general rule gives us \\(\\mathrm{d} \\log X = \\mathrm{d} X / X\\), so \\(\\mathrm{d} \\log X = \\mu \\mathrm{d} t\\). We can integrate both sides of this to obtain \\(\\log X_t - \\log X_0 = \\mu t\\). Now, rearranging and exponentiating gives \\(X_t = X_0\\mathrm{e}^{\\mu t}\\). Later, we follow similar steps to see that Equation 4.6 is the solution of Equation 4.5.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itoprocesses",
    "href": "Chapter_Ito.html#sec-s:itoprocesses",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.2 Ito Processes",
    "text": "4.2 Ito Processes\nThe meaning of Equation 4.2 is that, for all \\(t  &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\mathrm{d} s\\,.\\] We assume the reader is familiar with integrals, so we do not explain this further. The function of time \\(X\\) defined in Equation 4.3 satisfies this equation. Similarly, the meaning of Equation 4.5 is that, for all \\(t &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\mathrm{d} s + \\int_0^t \\sigma X_s \\mathrm{d} B_s\\,.\\] The first integral in this formula is an ordinary integral. The second is an Ito integral, which is to be explained. The sum of an ordinary integral and an Ito integral is called an Ito process. An Ito process always has continuous paths.\nLet’s depart from the example of the previous section and consider a process \\(X\\) satisfying, for all \\(t&gt;0\\), \\[X_t = \\int_0^t \\alpha_s\\mathrm{d} s + \\int_0^t \\theta_s \\mathrm{d} B_s\\,. \\qquad(4.7)\\] where \\(\\alpha\\) and \\(\\theta\\) can be stochastic processes. The example of the previous section fits this form, because we could take \\(\\alpha_s = \\mu X_s\\) and \\(\\theta_s = \\sigma X_s\\). The definition of the Ito integral \\[\\int_0^t \\theta_s \\mathrm{d} B_s\\] is relatively complicated. It is enough for our purposes to know that it can be approximated by a discrete sum \\[\\sum_{i=1}^n \\theta_{t_{i-1}}(B_{t_i} - B_{t_{i-1}})\\,,\\] given a partition \\[ 0 = t_0 &lt; \\cdots &lt; t_n = t\\,,\\] when \\(n\\) is large and the time between successive dates is small. The Ito integral exists provided \\(\\theta\\) does not anticipate the future (so \\(\\theta_{t_{i-1}}\\) is independent of the increment \\(B_{t_i}- B_{t_{i-1}}\\)) and provided \\(\\theta\\) does not explode to \\(\\pm \\infty\\) in finite time, so \\[\\int_0^t \\theta_s^2 \\mathrm{d} s &lt; \\infty\\] for all \\(t &gt; 0\\), with probability one.\nWe also write Equation 4.7 as \\[\n\\mathrm{d} X_t = \\alpha_t\\mathrm{d} t + \\theta_t \\mathrm{d} B_t\\,.\n\\qquad(4.8)\\] We interpret this as “change \\(=\\) mean \\(+\\) noise” with \\(\\alpha_t \\mathrm{d} t\\) being the mean and \\(\\theta_t\\mathrm{d} B_t\\) being the mean-zero random noise. The quantity \\(\\alpha_t\\) is also called the drift of the process \\(X\\) at time \\(t\\). The coefficient \\(\\theta_t\\) is called the diffusion coefficient of \\(X\\) at time \\(t\\). If \\(\\alpha\\) and \\(\\theta\\) are constant, it is standard to refer to an Ito process \\(X\\) as a \\((\\alpha,\\theta)\\)–Brownian motion. When they are constant, we obtain \\[X_t= X_0 + \\alpha t + \\theta B_t\\,.\\]\nAn Ito process as in Equation 4.7 can be a martingale only if \\(\\alpha=0\\). This should seem sensible, because \\(\\alpha\\mathrm{d}  t\\) is the expected change in \\(X\\), and a process is a martingale only if its expected change is zero. This observation plays a fundamental role in deriving asset pricing formulas. Conversely, if \\(\\alpha=0\\) and \\[\n\\mathrm{E} \\left[\\int_0^t \\theta^2_s\\mathrm{d}   s\\right] &lt; \\infty\n\\qquad(4.9)\\] for each \\(t\\), then the Ito process is a continuous martingale, and the variance of its date–\\(t\\) value, calculated with the information available at date \\(0\\), is: \\[\\mathrm{var}(X_t) = \\mathrm{E} \\left[\\int_0^t \\theta^2_t\\mathrm{d}  s\\right]\\; .\\]",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "href": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.3 Quadratic and Joint Variation of Ito Processes",
    "text": "4.3 Quadratic and Joint Variation of Ito Processes\nTo compute the quadratic variation of an Ito process, we use the following simple and important rules (for the sake of brevity, we drop the subscript \\(t\\) from \\(B_t\\) here and sometimes later). These rules should be regarded as mnemonic devices. The calculations we do with them lead to the correct results, but the objects have no real mathematical meaning.\n\n\n\n\n\n\nImportant Principle\n\n\n\n\\[\n(\\mathrm{d}  t)^2 = 0\\;,\n\\qquad(4.10)\\]\n\\[\n(\\mathrm{d}  t)(\\mathrm{d}  B) =0\\;,\n\\qquad(4.11)\\]\n\\[\n(\\mathrm{d}  B)^2 =\\mathrm{d}  t\\;.\n\\qquad(4.12)\\]\n\n\nWe apply these rules to compute the quadratic variation of any Ito proces \\(X\\) as follows:\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(\\mathrm{d}  X = \\alpha\\mathrm{d}   t + \\theta\\mathrm{d}   B\\) for a Brownian motion \\(B\\), then \\[\\begin{align}\n(\\mathrm{d}  X)^2 &= (\\alpha\\mathrm{d} t+\\theta\\mathrm{d}   B)^2\\\\\n&= \\alpha^2(\\mathrm{d}  t)^2 + 2\\alpha\\theta(\\mathrm{d}  t)(\\mathrm{d}  B) + \\theta^2(\\mathrm{d}  B)^2\\\\\n&= \\theta^2\\mathrm{d}   t\\;.\n\\end{align}\\] To compute the quadratic variation of the Ito process \\(X\\) over any particular period of time, we integrate \\((\\mathrm{d} X)^2\\) over that period as1] \\[\n\\int_0^t (\\mathrm{d}  X_s)^2 = \\int_0^t \\theta^2_s\\mathrm{d}   s\\;.\n\\qquad(4.13)\\]\n\n\nNow consider two Ito processes: \\[\n\\mathrm{d}  X_{1t} = \\mu_{1t}\\mathrm{d}   t + \\sigma_{1t}\\mathrm{d}   B_{1t}\\;,\n\\qquad(4.14)\\]\n\\[\n\\mathrm{d}  X_{2t} = \\mu_{2t}\\mathrm{d}   t + \\sigma_{2t}\\mathrm{d}   B_{2t}\\;,\n\\qquad(4.15)\\]\nwhere \\(B_1\\) and \\(B_2\\) are standard Brownian motions. We calculate the product of differentials of Ito processes as follows.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(X_1\\) and \\(X_2\\) are Ito processes as in Equation 4.14 and Equation 4.15, then \\[(\\mathrm{d} X_1)(\\mathrm{d} X_2) = (\\sigma_{1}\\mathrm{d} B_{1})(\\sigma_{2}\\mathrm{d} B_{2})= \\sigma_1\\sigma_2\\rho\\mathrm{d} t \\qquad(4.16)\\] where \\(\\rho\\) is the correlation process of the two Brownian motions.\n\n\nThe real meaning of this rule is that it is possible to calculate the joint variation (i.e., limit of sum of products of changes) of the two Ito processes from \\(0\\) to \\(t\\) as \\[\\int_0^t (\\mathrm{d} X_{1s})(\\mathrm{d} X_{2s}) = \\int_0^t (\\sigma_{1s}\\mathrm{d} B_{1s})(\\sigma_{2s}\\mathrm{d} B_{2s}) = \\int_0^t \\sigma_{1s}\\sigma_{2s}\\rho_s\\mathrm{d} s\\,.\n\\qquad(4.17)\\] The last integral in this equation is the correct formula for the quadratic variation. As with squaring differentials, taking products of differentials is a mnemonic device to get us to the correct formula.2",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itosformula",
    "href": "Chapter_Ito.html#sec-s:itosformula",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.4 Introduction to Ito’s Formula",
    "text": "4.4 Introduction to Ito’s Formula\nFirst we recall some facts of the ordinary calculus. If \\(y=f(x)\\) and \\(x_t = g(t)\\) with \\(f\\) and \\(g\\) being continuously differentiable functions, then \\[\\frac{\\mathrm{d}  y}{\\mathrm{d}  t} = \\frac{\\mathrm{d}  y}{\\mathrm{d}  x}\\times \\frac{\\mathrm{d}  x}{\\mathrm{d}  t} = f'(x_t)g'(t)\\; .\\] This implies that, for each \\(t&gt;0\\), \\[y_t = f(x_t) = y_0 + \\int_0^t \\frac{\\mathrm{d}  y}{\\mathrm{d}  s}\\mathrm{d}   s = y_0 + \\int_0^t f'(x_s)g'(s)\\mathrm{d}   s\\; .\\] Substituting \\(\\mathrm{d} x_s = g'(s)\\mathrm{d}   s\\), we can also write this as \\[\ny_t = f(x_t) = y_0 + \\int_0^t f'(x_s)\\mathrm{d}   x_s\\,,\n\\qquad(4.18)\\] or, in differential form, \\[\ndy_t = f'(x_t)\\mathrm{d} x_t \\,.\n\\qquad(4.19)\\] What people frequently remember about integrals from their calculus courses is that there are a lot of tricky substitutions that can be made to simplify the calculation of various integrals. We won’t need those in this book. All we will use are equations of the form of Equation 4.18, which is a special case of the Fundamental Theorem of Calculus, which says that a function is the integral of its derivative. Intuitively, we can think of Equation 4.18 as saying that the change in \\(y\\) over a discrete interval (from \\(0\\) to \\(t\\)) is the continuous sum (integral) of its infinitesimal changes.\nWe will contrast Equation 4.18 with the following special case of Ito’s formula for the calculus of Ito processes.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(B\\) is a Brownian motion and \\(Y = f(B)\\) for a twice-continuously differentiable function \\(f\\), then \\[\\mathrm{d}   Y_t = f'(B_t)\\mathrm{d}   B_t + \\frac{1}{2}f''(B_t)\\mathrm{d}   t  \\,.\n\\qquad(4.20)\\]\n\n\nComparing Equation 4.20 to Equation 4.19, we see that Ito’s formula has an extra term involving the second derivative \\(f''\\).\nEquation 4.20 implies that \\(Y=f(B)\\) is an Ito process with drift \\(f''(B_t)/2\\) and diffusion coefficient \\(f'(B_t)\\). The real meaning of Equation 4.20 is the integrated form: \\[\nY_t = f(B_t) = Y_0 + \\int_0^t f'(B_s)\\mathrm{d}   B_s + \\frac{1}{2}\\int_0^t f''(B_s)\\mathrm{d}   s\\;.\n\\qquad(4.21)\\] Thus, the change in \\(Y\\) over a discrete interval is again the continuous sum of its infinitesimal changes, but now the infinitesimal changes are given by Equation 4.20. Note that the first integral in Equation 4.21 is an Ito integral.\nTo gain some intuition for the extra term in Ito’s formula, we return to the ordinary calculus. Given dates \\(s&lt;t\\), the derivative defines a linear approximation of the change in \\(y\\) from \\(s\\) to \\(t\\); that is, setting \\(\\Delta x = x_t-x_s\\) and \\(\\Delta y = y_t - y_s\\), we have the approximation \\[\\Delta y \\approx f'(x_s) \\,\\Delta x\\; .\\] A better approximation is given by the second-order Taylor series expansion \\[\\Delta y \\approx f'(x_s)\\,\\Delta x + \\frac{1}{2} f''(x_s)\\,(\\Delta x)^2\\; .\\] An interpretation of Equation 4.18 is that the linear approximation works perfectly for infinitesimal time periods \\(\\mathrm{d}  s\\), because we can compute the change in \\(y\\) over the time interval \\([0,t]\\) by summing up the infinitesimal changes \\(f'(x_s)\\mathrm{d}   x_s\\). In other words, the second-order term \\(\\frac{1}{2} f''(x_s)\\,(\\Delta x)^2\\) vanishes when we consider very short time periods.\nThe second-order Taylor series expansion in the case of \\(Y=f(B)\\) is \\[\\Delta Y \\approx f'(B_s)\\,\\Delta B + \\frac{1}{2} f''(B_s)\\,(\\Delta B)^2\\; .\\] For example, given a partition \\(0=t_0 &lt; t_1 &lt; \\cdots &lt; t_n=t\\) of the time interval \\([0,t]\\), we have, with the same notation we have used earlier,\n\\[\nY_t = Y_0 + \\sum_{i=1}^n \\Delta Y_{t_i}  \n\\approx Y_0 + \\sum_{i=1}^n f'(B_{t_{i-1}})\\,\\Delta B_{t_i} + \\frac{1}{2} \\sum_{i=1}^n f''(B_{t_{i-1}})\\,(\\Delta B_{t_i})^2\\;.\n\\qquad(4.22)\\]\nIf we make the time intervals \\(t_i-t_{i-1}\\) shorter, letting \\(n \\rightarrow \\infty\\), then we cannot expect that the extra term here will disappear, leading to the result of the ordinary calculus shown in Equation 4.18, because we know that \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n (\\Delta B_{t_i})^2 = t\\; ,\\] whereas for the continuously differentiable function \\(x_t = g(t)\\), the same limit is zero. In fact it seems sensible to interpret the limit of \\((\\Delta B)^2\\) as \\((\\mathrm{d}  B)^2 =\\mathrm{d}  t\\). This is perfectly consistent with Ito’s formula: if we take the limit in Equation 4.22, replacing the limit of \\((\\Delta B_{t_i})^2\\) with \\((\\mathrm{d}  B)^2 = \\mathrm{d}  t\\), we obtain Equation 4.21.\nTo see the accuracy of Ito’s approximation over different time steps, as well as the impact of the second-derivative term \\(\\int_0^t (1/2)f''(B_s)\\mathrm{d} s\\), we encourage readers to interact with the plot below. It examines the function \\(f(x)=\\mathrm{e}^{x}\\) (for which we have \\(f'(x)=\\mathrm{e}^x\\) and \\(f''(x) = \\mathrm{e}^x\\)). It simulates an approximate path of a Brownian motion as we have done before. It then compares the true value of \\(\\mathrm{e}^{B_{t_i}}\\) to the Ito expansion \\[\\mathrm{e}^{B_t}=1 + \\int_0^t \\mathrm{e}^{B_s} \\mathrm{d} B_s + \\frac{1}{2}\\int_0^t \\mathrm{e}^{B_s} \\mathrm{d} s\\] using the discretization \\[\\Delta \\mathrm{e}^{B_{t_i}}= \\mathrm{e}^{B_{t_{i-1}}} \\Delta B_{t_i} + \\frac{1}{2} \\mathrm{e}^{B_{t_{i-1}}} \\Delta t \\,.\\] Notice that the discretization is just a second-order Taylor series expansion. The discretization approximates the true value better if we take \\(n\\) larger and \\(\\Delta t\\) smaller. The important take-away from the figure is that the cumulative second-derivative terms in the discretization do not vanish as we take \\(n\\) larger but instead continue to contribute significantly to the approximation.\n\n\n\n\n\n\n\nFigure 4.3: Accuracy of the Ito approximation. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-a-brownian-motion",
    "href": "Chapter_Ito.html#functions-of-time-and-a-brownian-motion",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.5 Functions of Time and a Brownian Motion",
    "text": "4.5 Functions of Time and a Brownian Motion\nWe extend the example in the previous section slightly. Consider a process \\(Y\\) defined as \\(Y_t = f(t, B_t)\\) for some function \\(f\\). The following rule states that \\(Y\\) is an Ito process with drift equal to \\[\\frac{\\partial f}{\\partial t} + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial B^2}\\] and diffusion coefficient equal to \\(\\partial f/\\partial B\\). This is what we need to remember to make calculations. The real meaning of \\((\\mathrm{d} B)^2\\) is \\(\\mathrm{d} t\\), so we can (and will) substitute that in the following rule, but it may be easier to remember \\((\\mathrm{d} B)^2\\). This becomes more important when we consider more complex examples in the next sections.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(f(t, B)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(B\\) and \\(Y_t= f(t, B_t)\\) for a standard Brownian motion \\(B\\), then \\[\\mathrm{d} Y = \\frac{\\partial f(t, B)}{\\partial t}\\mathrm{d} t + \\frac{\\partial f(t, B)}{\\partial B}\\mathrm{d} B + \\frac{1}{2} \\frac{\\partial^2 f(t, B)}{\\partial B^2}(\\mathrm{d} B)^2\\,.\n\\qquad(4.23)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe can finish the discussion in Section 4.1 regarding the process defined in Equation 4.6 by applying Equation 4.23. We want to show that the process satisfies Equation 4.5. We do that by differentiating and applying the Equation 4.23. For \\(f(t, B) = \\mathrm{e}^{(\\mu - \\sigma^2/2)t + \\sigma B}\\), we have \\[\\frac{\\partial f}{\\partial t} = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)f(t, B)\\,,\\quad \\frac{\\partial f}{\\partial B} = \\sigma f(t, B)\\,, \\quad \\frac{\\partial^2 f}{\\partial B^2} = \\sigma^2f(t, B)\\,.\\] Therefore, \\[\\mathrm{d} Y = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)Y\\mathrm{d} t + \\sigma Y \\mathrm{d} B + \\frac{1}{2}\\sigma^2 Y\\,(\\mathrm{d} B)^2 = \\mu Y\\mathrm{d} t + \\sigma Y \\mathrm{d} B\\] This verifies Equation 4.5.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-an-ito-process",
    "href": "Chapter_Ito.html#functions-of-time-and-an-ito-process",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.6 Functions of Time and an Ito Process",
    "text": "4.6 Functions of Time and an Ito Process\nNow consider the more general case \\(Y_t = f(t, X_t)\\) where \\(X\\) is an Ito process. As explained before, this means that \\[\\mathrm{d} X_t = \\alpha_t\\mathrm{d} t + \\theta_t \\mathrm{d} B_t\n\\qquad(4.24)\\] for some stochastic processes \\(\\alpha\\) and \\(\\theta\\), where \\(B\\) is a standard Brownian motion. Then, from our previous rules, \\((\\mathrm{d} X)^2 = \\theta^2\\mathrm{d} t\\). Ito’s formula in this more general case takes the same form as Calculation Rule \\(\\ref{ruleito1}\\), replacing the Brownian motion \\(B\\) with the Ito process \\(X\\).\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(f(t, X)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X\\) and \\(Y_t= f(t, X_t)\\) where \\(X\\) is an Ito process, then \\[\\mathrm{d} Y = \\frac{\\partial f(t, X)}{\\partial t}\\mathrm{d} t + \\frac{\\partial f(t, X)}{\\partial X}\\mathrm{d} X + \\frac{1}{2} \\frac{\\partial^2 f(t, X)}{\\partial X^2}(\\mathrm{d} X)^2\\,.\n\\qquad(4.25)\\]\n\n\nWe can write Equation 4.25 in terms of \\(\\mathrm{d} t\\) and \\(\\mathrm{d} B\\) terms by substituting from Equation 4.24 and using \\((\\mathrm{d} X)^2 = \\theta^2\\mathrm{d} t\\). This produces \\[\\mathrm{d} Y = \\left(\\frac{\\partial f(t, X)}{\\partial t} + \\alpha\\frac{\\partial f(t, X)}{\\partial X} + \\frac{1}{2}\\theta^2 \\frac{\\partial^2 f(t, X)}{\\partial X^2}\\right)\\mathrm{d} t + \\theta\\frac{\\partial f(t, X)}{\\partial X}\\mathrm{d} B\\,.\\]\nHere are some important examples of Ito’s formula.\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y = X^\\alpha\\) for a constant \\(\\alpha\\), then \\[\\mathrm{d} Y = \\alpha X^{\\alpha-1}\\mathrm{d} X + \\frac{1}{2}\\alpha (\\alpha - 1)X^{\\alpha-2}(\\mathrm{d} X)^2\\,.\\] This is equivalent to \\[\\frac{\\mathrm{d} Y}{Y} = \\alpha \\frac{\\mathrm{d} X}{X} + \\frac{\\alpha(\\alpha-1)}{2}\\left(\\frac{\\mathrm{d} X}{X}\\right)^2\\,.\n\\] {#ito-powerformula}\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y=\\mathrm{e}^X\\), then \\[\\frac{\\mathrm{d}  Y}{Y}=\\mathrm{d}  X + \\frac{(\\mathrm{d}  X)^2}{2}\\;.\n\\qquad(4.26)\\]\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y=\\log X\\), then \\[\n\\mathrm{d}  Y=\\frac{\\mathrm{d}  X}{X} - \\frac{1}{2}\\left(\\frac{\\mathrm{d}  X}{X}\\right)^2\\;.\n\\qquad(4.27)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe showed in the previous Example that \\(X\\) defined in Equation 4.6 satisfies Equation 4.5, but it is also useful to see how we can start from Equation 4.5 and deduce that Equation 4.6 is the solution. We can do that by taking logarithms. Set \\(Y_t = \\log X_t\\). Then, using Equation 4.27 and substituting from Equation 4.5, we have \\[\\mathrm{d} \\log X = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d} t + \\sigma\\mathrm{d} B\\,.\\] There is no \\(X\\) on the right-hand side of this, so we can simply integrate to compute \\(\\log X_t\\) as \\[\\log X_t = \\log X_0 + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\,.\\] Exponentiating gives Equation 4.6.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-multiple-ito-processes",
    "href": "Chapter_Ito.html#functions-of-time-and-multiple-ito-processes",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.7 Functions of Time and Multiple Ito Processes",
    "text": "4.7 Functions of Time and Multiple Ito Processes\nUsing Equation 4.16 for products of differentials, we can state Ito’s formula for a function of time and two Ito processes as follows.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(Y_t = f(t, X_{1t}, X_{2t})\\) where \\(X_1\\) and \\(X_2\\) are Ito processes and \\(f\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X_1\\) and \\(X_2\\), then \\[\\begin{multline}\n\\mathrm{d}  Y =  \\frac{\\partial f}{\\partial t}\\mathrm{d}   t + \\frac{\\partial f}{\\partial X_1}\\mathrm{d}   X_1 +  \\frac{\\partial f}{\\partial X_2}\\mathrm{d}   X_2 \\\\+ \\frac{1}{2} \\frac{\\partial^2 f}{\\partial X_1^2}\\,(\\mathrm{d}  X_1)^2 +  \\frac{1}{2}  \\frac{\\partial^2 f}{\\partial X_2^2}\\,(\\mathrm{d}  X_2)^2\n+ \\frac{\\partial^2 f}{\\partial X_1\\partial X_2}\\,(\\mathrm{d}  X_1)(\\mathrm{d}  X_2)\\;.\n\\end{multline} \\qquad(4.28)\\]\n\n\nThis is analogous to a second-order Taylor series expansion in the variables \\(X_1\\) and \\(X_2\\). A similar formula applies to functions of more two Ito processes. We just need to include a term for each \\(\\mathrm{d} X_i\\), each \\((\\mathrm{d} X_i)^2\\) and each \\((\\mathrm{d} X_i)(\\mathrm{d} X_j)\\).\nHere are some important examples. We switch notation from \\(X_1\\) and \\(X_2\\) to \\(X\\) and \\(Y\\) and from \\(Y\\) to \\(Z\\) so we can drop the subscripts. These formulas follow from Equation 4.28 by taking \\(f(x,y)=xy\\) or \\(f(x,y)=y/x\\).\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Z=XY\\), then \\(\\mathrm{d}  Z=X\\mathrm{d}   Y+Y\\mathrm{d}   X + (\\mathrm{d}  X)(\\mathrm{d}  Y)\\). We can write this as \\[\n\\frac{\\mathrm{d}  Z}{Z}=\\frac{\\mathrm{d}  X}{X} + \\frac{\\mathrm{d}  Y}{Y} + \\left(\\frac{\\mathrm{d}  X}{X}\\right)\\left(\\frac{\\mathrm{d}  Y}{Y}\\right)\\;.\n\\qquad(4.29)\\]\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Z=Y/X\\), then \\[\\frac{\\mathrm{d}  Z}{Z} = \\frac{\\mathrm{d}  Y}{Y} -\\frac{\\mathrm{d}  X}{X} - \\left(\\frac{\\mathrm{d}  Y}{Y}\\right)\\left(\\frac{\\mathrm{d}  X}{X}\\right) + \\left(\\frac{\\mathrm{d}  X}{X}\\right)^2\\;.\n\\qquad(4.30)\\]\n\n\nThe following is a special case of Equation 4.29 that we encounter often.\n\n\n\n\n\n\nKey Result\n\n\n\nLet\n\\[Y_t =\\exp\\left(\\int_0^t q_s\\mathrm{d}   s\\right)\\] for some (possibly random) process \\(q\\) and define \\(Z=XY\\) for any Ito process \\(X\\). Equation 4.29 gives us \\[\n\\frac{\\mathrm{d}  Z}{Z}=q\\mathrm{d}   t + \\frac{\\mathrm{d}  X}{X}\\;.\n\\qquad(4.31)\\] This is the same as in the usual calculus.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#exercises",
    "href": "Chapter_Ito.html#exercises",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "4.8 Exercises",
    "text": "4.8 Exercises\n\nExercise 4.1 Ito’s Lemma can be used in different ways to get the same answer. For example, let \\(X_t = a t + b B_t\\) and use Ito’s lemma on the function \\(e^{X_t}\\). Alternatively, let \\(f(t, B_t) = e^{a t + bB_t}\\). Use Ito’s lemma on \\(f(,)\\).\n\n\nExercise 4.2 Let \\(\\mathrm{d} X_t = \\mu X_t \\mathrm{d} t + \\sigma X_t \\mathrm{d} B_t\\). Use Ito’s lemma to find \\(\\log(X_t)\\) . What is the expected value and variance of \\(\\log(X_t)\\) ?",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#footnotes",
    "href": "Chapter_Ito.html#footnotes",
    "title": "4  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "In a more formal mathematical presentation, one normally writes \\(\\mathrm{d} \\langle X,X\\rangle\\) for what we are writing here as \\((\\mathrm{d}  X)^2\\). This is the differential of the quadratic variation process, and the quadratic variation through date \\(t\\) is \\[\n\\langle X,X\\rangle _t = \\int_0^t \\mathrm{d} \\langle X,X\\rangle_s = \\int_0^t \\sigma^2_s\\mathrm{d}   s\\;.\n\\] Our mnenomic device of squaring differentials leads us to the correct formula.↩︎\nA somewhat more precise definition than our previous description of the stochastic integral \\(\\int_0^t \\sigma_{1,t} dB_{1t}\\) is when Equation 4.9 holds, the stochastic integral is the (unique) martingale with joint variation with any other Ito process given by Equation 4.17.↩︎",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html",
    "href": "Chapter_GBM.html",
    "title": "5  Geometric Brownian Motion",
    "section": "",
    "text": "5.1 Continuously Compounded Returns\nA random variable \\(\\tilde{y}\\) is lognormally distributed if it can be written as \\(\\tilde{y}=  \\mathrm{e}^{\\tilde{x}}\\) where \\(\\tilde{x}\\) has a normal distribution. Another way of saying this is that \\(\\log \\tilde y\\) is normally distributed. We denote the expected value (mean) of any random variable using the symbol \\(\\mathrm{E}\\). The mean of a lognormal random variable is given by the following.\nAn example of the distribution of a lognormal random variable is shown in Figure 5.1.\nAn important stochastic process is geometric Brownian motion given by \\[\nS_t=S_0\\mathrm{e}^{\\mu t- \\sigma^2 t/2 + \\sigma B_t}\n\\qquad(5.2)\\] for constants \\(\\mu\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion. For each time \\(t\\), the random variable \\(S_t\\) in Equation 5.2 is a lognormal random variable. Ito’s formula for exponentials of Ito processes implies \\[\n\\frac{\\mathrm{d}  S}{S} = \\mu\\mathrm{d}   t+\\sigma\\mathrm{d}   B\\;.\n\\qquad(5.3)\\] When we see an equation of the form Equation 5.3, we should recognize Equation 5.2 as the solution.\nThe process \\(S\\) is called a geometric Brownian motion. We interpret Equation 5.3 as stating that \\(\\mu\\mathrm{d}   t\\) is the expected rate of change of \\(S\\) and \\(\\sigma^2\\mathrm{d}   t\\) is the variance of the rate of change in an instant \\(\\mathrm{d}  t\\). We call \\(\\mu\\) the drift and \\(\\sigma\\) the volatility. The geometric Brownian motion grows at the average rate of \\(\\mu\\), in the sense that \\(\\mathrm{E}[S_t] = \\mathrm{e}^{\\mu t}S_0\\). This can be verified with the aid of Equation 5.1.\nIf \\(\\mu=0\\), then \\(\\mathrm{E}[S_t] = S_0\\). In fact, a geometric Brownian motion \\(S\\) as in Equation 5.2 and Equation 5.3 is a martingale when \\(\\mu=0\\). It is an example of what is called an exponential martingale. An exponential is always positive, so an exponential martingale is always positive.\nTaking the natural logarithm of Equation 5.2 gives an equivalent form of the solution: \\[\n\\log S_t= \\log S_0+\\left(\\mu -\\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\;.\n\\qquad(5.4)\\] This shows that \\(\\log S_t - \\log S_0\\) is a \\((\\mu-\\sigma^2/2,\\sigma)\\)–Brownian motion. Given information at time \\(t\\), the logarithm of \\(S(u)\\) for \\(u&gt;t\\) is normally distributed with mean \\((u-t)(\\mu-\\sigma^2/2)\\) and variance \\((u-t)\\sigma^2\\). Because \\(S\\) is the exponential of its logarithm, \\(S\\) can never be negative. For this reason, a geometric Brownian motion is a better model for stock prices than is a Brownian motion. The differential of Equation 5.4 is \\[\n\\mathrm{d}  \\log S_t = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\mathrm{d}   t+ \\sigma\\mathrm{d}   B_t\\;.\n\\qquad(5.5)\\]\nWe can summarize this discussion as follows.\nWe can simulate a path of a geometric Brownian motion \\(S\\) by first simulating \\(\\log S\\) and then computing the exponential. We simulate the changes \\(\\Delta \\log S\\) as normally distributed random variables with mean equal to \\((\\mu-\\sigma^2/2)\\Delta t\\) and variance equal to \\(\\sigma^2\\Delta t\\). We could also simulate the changes \\(\\Delta \\log S\\) using a binomial model as in Section 3.2.\nGiven a rate of return \\(r\\) over a time period of \\(\\Delta t\\) years, the annualized continuously compounded return is defined to be the number \\(x\\) such that \\(\\mathrm{e}^{x\\Delta t} = 1+r\\); equivalently, \\(x = \\log(1+r) / \\Delta t\\). We frequently take “annualized” for granted and just say “continuously compounded return.” As an example, if you earn 1% in a month, then the continuously compounded return is \\(\\log (1.01) / (1/12) = 0.1194\\).\nThe reason for the name “continuously compounded” is that compounding a monthly rate of interest of \\(0.1194/12\\) for a total of \\(n\\) times during a month produces a total return over the month of \\[\\left(1 + \\frac{0.1194/12}{n}\\right)^ n - 1\\,,\\] which converges to \\(0.01\\) as \\(n \\rightarrow \\infty\\). Thus, compounding an infinite number of times during a month at an annual rate of \\(0.1194\\) (equal to a monthly rate of \\(0.1194/12\\)) is equivalent to the actual 1% return.1\nGiven a dividend-reinvested asset price \\(S\\), the rate of return from date \\(t_1\\) to \\(t_2\\) is \\(S_{t_2}/S_{t_1} - 1\\). Denote this rate of return by \\(r\\) and defined the corresponding continuously compounded return \\[x = \\log(1+r) = \\log\\left(\\frac{S_{t_2}}{S_{t_1}}\\right) = \\log S_{t_2} - \\log S_{t_1}\\,.\\] Using Equation 5.4, we see that the continuously compounded return is \\[\nx = \\log S_{t_2} - \\log S_{t_1} = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)(t_2-t_1)+ \\sigma\\,(B_{t_2} - B_{t_1})\\;.\n\\qquad(5.6)\\] Thus, from the vantage point of date \\(t_1\\), the continuously compounded return is normally distributed with mean \\[\\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\Delta t\\] and variance \\(\\sigma^2 \\Delta t\\), where we define \\(\\Delta t = t_2-t_1\\). Given historical data on rates of return, the parameters \\(\\mu\\) and \\(\\sigma\\) can be estimated by standard methods.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#sec-tailprobs",
    "href": "Chapter_GBM.html#sec-tailprobs",
    "title": "5  Geometric Brownian Motion",
    "section": "5.2 Tail Probabilities of Geometric Brownian Motions",
    "text": "5.2 Tail Probabilities of Geometric Brownian Motions\nFor each of the numeraires discussed in the previous section, we have \\[\n\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\;,\n\\qquad(5.7)\\]\nfor some \\(\\alpha\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion under the probability measure associated with the numeraire. Specifically, \\(\\sigma=\\sigma\\), \\(B=B^*\\), and\n\nfor the risk-neutral probability, \\(\\alpha = r-q-\\sigma^2/2\\),\nwhen \\(\\mathrm{e}^{qt}S_t\\) is the numeraire, \\(\\alpha = r-q +\\sigma^2/2\\),\nwhen another risky asset price \\(Y\\) is the numeraire, \\(\\alpha = r-q+\\rho\\sigma\\phi-\\sigma^2/2\\).\n\nWe will assume in this section that \\(\\alpha\\) and \\(\\sigma\\) are constants. The essential calculation in pricing options is to compute \\(\\text{prob}(S_t&gt;K)\\) and \\(\\text{prob}(S_t&lt;K)\\) for a constant \\(K\\) (the strike price of an option), where \\(\\text{prob}\\) denotes the probabilities at date \\(0\\) (the date we are pricing an option) associated with a particular numeraire.\nEquation 5.7 gives us \\[\\log S_t = \\log S_0 + \\alpha T + \\sigma B_t\\; .\\] Given this, we deduce\n\\[\nS_t &gt; K  \\quad\\Longleftrightarrow\\quad \\log S_t &gt; \\log K\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\sigma B_t &gt; \\log K - \\log S_0-\\alpha T\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\frac{B_t}{\\sqrt{T}} &gt; \\frac{\\log K - \\log S_0-\\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log S_0-\\log K + \\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(5.8)\\]\nThe random variable on the left-hand side of Equation 5.8 has the standard normal distribution—it is normally distributed with mean equal to zero and variance equal to one. As is customary, we will denote the probability that a standard normal is less than some number \\(d\\) as \\(\\mathrm{N}(d)\\). We conclude:\n\n\n\n\n\n\nKey Result\n\n\n\nAssume \\(\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&gt;K) = \\mathrm{N}(d)\\;,\n\\qquad(5.9)\\] where \\[\nd = \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(5.10)\\]\n\n\nThe probability \\(\\text{prob}(S_t&lt;K)\\) can be calculated similarly, but the simplest way to derive it is to note that the events \\(S_t&gt;K\\) and \\(S_t&lt;K\\) are complementary—their probabilities sum to one (the event \\(S_t=K\\) having zero probability). Therefore \\(\\text{prob}(S_t&lt;K) = 1-\\mathrm{N}(d)\\). This is the probability that a standard normal is greater than \\(d\\), and by virtue of the symmetry of the standard normal distribution, it equals the probability that a standard normal is less than \\(-d\\). Therefore, we have:\n\n\n\n\n\n\nKey Result\n\n\n\nAssume \\(\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&lt;K) = \\mathrm{N}(-d)\\;,\n\\qquad(5.11)\\] where \\(d\\) is defined in Equation 5.10.",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#exercises",
    "href": "Chapter_GBM.html#exercises",
    "title": "5  Geometric Brownian Motion",
    "section": "5.3 Exercises",
    "text": "5.3 Exercises\n\nExercise 5.1 Use Ito’s Lemma to derive the stochastic differential equation for \\(S_t^2\\). Show that \\(S(t)^2\\) is a geometric Brownian motion if \\(\\mu\\) and \\(\\sigma\\) are constants and find \\(\\mathrm{E}[S(t)^2]\\).\n\n\nExercise 5.2 Let \\[\\begin{align*}\n\\frac{\\mathrm{d} S_1}{S_1} &= \\mu_1\\mathrm{d} t + \\sigma_1 \\mathrm{d} B_1\\\\\n\\frac{\\mathrm{d} S_2}{S_2} &= \\mu_1\\mathrm{d} t + \\sigma_2 \\mathrm{d} B_2\n\\end{align*}\\] where the \\(\\mu_i\\) and \\(\\sigma_i\\) are constants and \\(B_1\\) and \\(B_2\\) are Brownian motions with constant correlation \\(\\rho\\).\n\nDefine \\(Y=S_1S_2\\). Show that \\(Y\\) is a geometric Brownian motion and calculate its drift and volatility.\nRepeat for \\(Y=S_1/S_2\\).\n\nHint: use the facts \\(\\mathrm{e}^{x+y}=\\mathrm{e}^x \\times \\mathrm{e}^y\\) and \\(\\mathrm{e}^x/\\mathrm{e}^y = \\mathrm{e}^{x-y}\\).\n\n:",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#footnotes",
    "href": "Chapter_GBM.html#footnotes",
    "title": "5  Geometric Brownian Motion",
    "section": "",
    "text": "The reason for considering this concept is that compound returns like \\((1+r_1)(1+r_2)\\) are simpler to analyze in some contexts as \\(\\mathrm{e}^{x_1+x_2}\\).↩︎",
    "crumbs": [
      "Part 2: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html",
    "href": "Chapter_Arbitrage.html",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "",
    "text": "6.1 Fundamental Ideas\nThis chapter introduces the change of measure (or change of numeraire or martingale) method for valuing derivative securities. The method is illustrated in a finite-state model and then extended to more general (continuum of states) models.\nThe pricing and hedging results in this book are not tied to any particular currency. However, for specificity, the discussion will generally be in terms of dollars.\nThe fundamental concept underlying most finance theory, from Miller-Modigliani to the Black Scholes model, is linear pricing. The concept of linear pricing is essentially the same as asking what is the price of five apples and six oranges. Of course, this is the price of one apple times five plus the price of one orange times six. However, instead of pricing bundles of commodities today, we will find prices of dollars in different contigencies at times in the future.\nAn arbitrage opportunity is a trading strategy that produces nonnegative cash flows at all times in all contingencies with a strictly positive cash flow at some time in some contingency. If such an opportunity were to exist, traders would exploit it until prices adjust to eliminate this possibility. Although simple, this has powerful implications.\nConsider a world where there are \\(J\\) possible states of the world at timme \\(t\\). No arbritrage then implies the following properties.\nThis conclusion generalizes to other models, including models in which the stock price takes a continuum of possible values, interpreting “sum” in that case as an integral. We discuss more general models later in this chapter.\nWe can think of any security as a portfolio of what are called Arrow securities (in recognition of the seminal work of Kenneth Arrow (Arrow 1964)). An Arrow security’s payoff is tied to a specific state of the world, paying $1 at time t if the state in question occurs and paying nothing otherwise. State prices are the prices of these Arrow securities, and, given these state prices, we can value any security. The state prices can be found by inverting the pricing relationship for prices of traded securities; in other words use traded securities to find the prices of securities that pay off a dollar in each time/state contingency. While in general this can be challenging, the procedure is easily illlustrated in the binomial model that we examine next.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#fundamental-ideas",
    "href": "Chapter_Arbitrage.html#fundamental-ideas",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "",
    "text": "If \\(X\\) and \\(Y\\) are time \\(t\\) random cash flows, the time 0 price today of the random cash flow \\(aX+bY\\) is t \\(a\\) times the time 0 price of \\(X\\) plus \\(b\\) times the time zero price of \\(Y\\). If \\(P(\\cdot)\\) is a pricing function that gives us the price of a random cash flow today, then \\(P(aA+bB)=aP(A) + bP(B)\\). In other words, the pricing operator is linear. This follows because if this fails to hold, there is an arbitrage assuming an agent can buy and sell any quantities at these prices. Because the pricing operator is linear, it must have the form \\(P(X) = \\sum_{j=1}^J \\pi_j X_j\\) where \\(X_j\\) si the random cash flow in state~\\(j\\). We call \\(\\pi_j\\) the price of a dollar at time \\(t\\) in state \\(j\\) or a state price.\nThe price of any positive nonzero random cash flow at time \\(t\\) is strictly positive. Again, this follows from no arbitrage (think how much of an asset paying a positive dividend you would want if it were free or even if you were paid to take the asset). This implies the state prices are strictly positive.\nThe pricing operator obeys time value of money: \\(1=\\sum_{j=1}^J \\pi_j e^{rt}\\), where \\(r\\) is the continuously compounded yield to maturity of a bond maturing at \\(t\\). This is the present value rule, in other words, the present value of the future value \\(e^{rt}\\) is one or, equivalently, the present value of a dollar paid at \\(t\\) is \\(e^{-rt}\\).\nThe pricing operator must be consistent with observable prices. The price \\(S_0\\) of a traded asset with random cash flows at time \\(t\\) is given by \\(S_0= \\sum_{j=1}^J \\pi_j S_j\\) where \\(S_j\\) is the random cash flow in state \\(j\\).\n\n\n\n\n\n\n\nImportant Principle\n\n\n\nIn the absence of arbitrage opportunities, there exist positive state prices such that the price of any security is the sum across the states of the world of its payoff multiplied by the state price.\n\n\n\n\n\nFundamental Ideas in a Simple Setting\nIn this section we consider the following very simple framework. There is a stock with price \\(S\\) today (which we call date \\(0\\)). At the end of some period of time of length \\(t\\), the stock price will take one of two values: either \\(S_u\\) or \\(S_d\\), where \\(S_u &gt; S_d\\). If the stock price equals \\(S_u\\), we say we are in the up state of the world, and, if it equals \\(S_d\\), we say we are in the down state. The stock does not pay a dividend prior to \\(t\\). There is also a risk-free asset earning a continuously compounded rate of interest \\(r\\).\nWe can relax the assumption that the stock does not pay a dividend prior to \\(t\\). We do that by assuming we are enrolled in a dividend-reinvestment program, so we receive additional shares of the asset instead of receiving cash dividends. If a company does not operate a dividend-reinvestment program, then we can simulate one on our own by buying shares with cash dividends received. In our model, we start with one share at date \\(0\\) with price \\(S_0\\), and we consider the future value – either \\(S_u\\) or \\(S_d\\) – of owning more than one share at date \\(t\\), because the number of shares grows through reinvestment of dividends. We call this future value a “dividend-reinvested asset price” because of this property, and we formulate valuation principles for such assets throughout the book.\nAssume \\[\n\\frac{S_u}{S} &gt; \\mathrm{e}^{rt} &gt; \\frac{S_d}{S}\\;.\n\\qquad(6.1)\\] This condition means that the rate of return on the stock in the up state is greater than the risk-free rate, and the rate of return on the stock in the down state is less than the risk-free rate. If it were not true, there would be an arbitrage opportunity: if the rate of return on the stock were greater than the risk-free rate in both states, then one should buy an infinite amount of the stock on margin, and conversely if the rate of return on the stock were less than the risk-free rate in both states, then one should short an infinite amount of stock and put the proceeds in the risk-free asset. So what we are assuming is that there are no arbitrage opportunities in the market for the stock and risk-free asset.\n\n\nState prices\nIt is a simple matter to solve for state prices in this model. We have two equations and two unknowns.\n\\[ 1 = \\pi_u e^{rt} + \\pi_d e^{rt} \\] \\[ S = \\pi_u S_u + \\pi_d S_d \\]\nSolving these equations gives \\(\\pi_u  = \\frac{S-e^{-rt}S_d}{S_u - S_d}\\) and \\(\\pi_d = \\frac{e^{-rt}S_u-S}{S_u - S_d}\\). Notice the requirement that \\(\\pi_s &gt; 0\\) is precisely the no arbitrage condition Equation 6.1 in the previous section.\nA somewhat more enlightening description of the state prices is that \\(\\pi_u\\) is the price of an Arrow securtity that pays \\(1\\) if the stock price goes up and nothing if the stock price goes down. We can solve for portfolios of the stock and risk-free asset that have these payoffs. Let \\(A\\) be the number of shares of stock and \\(B\\) be the amount borrowed or lent at time zero. Then this portfolio will have a payoff of 1 in the up state and 0 in the down state if \\[A S_u + B e^{rt} = 1\\] and \\[A S_d + B e^{rt} =0\\,.\\]\nSolving these for \\(A\\) and \\(B\\), we get \\(A= \\frac{1}{S_u - S_d}\\) and \\(B = -e^{-rt}\\frac{S_d}{S_u - S_d}\\). The time zero cost of this portfolio is \\(AS +B = \\frac{S - e^{-rt} S_d}{S_u - S_d} = \\pi_u\\). A similar exercise reveals \\(\\pi_d\\) is the time 0 price of a portfoio that has a value of 0 in the up state and 1 in the down state.\nGiven the state prices, we can value any derivative security whose payoffs depend on the stock price and the risk free asset. For example, consider a European call option on the stock with maturity \\(t\\) and strike \\(K\\). A call option gives the owner the right (but not the obligation) to buy the stock at the fixed price called the strike. The value of this at the option maturity \\(t\\) is the excess of the stock price over \\(K\\) if the excess is positive and is zero otherwise, which we write as \\(C_u=\\max(0,S_u-K)\\) in the up state and \\(C_d=\\max(0,S_d-K)\\) in the down state. Therefore, the value of the call option today, \\(C\\), is given by \\[C = \\pi_u C_u + \\pi_d C_d\\,.\\]\n\n\nOption Deltas and Replication\nA more traditional way to derive option prices is by finding a portfolio that replicates the option payoff. By no arbitrage, the initial cost of the portfolio must be the option price. We now show this is consistent with the state price approach. Again consider a European call option on the stock with maturity \\(t\\) and strike \\(K\\).\nThe delta of the call option is defined to be the difference between the call values in the up and down states divided by the difference between the underlying values; that is, \\(\\delta = (C_u-C_d)/(S_u-S_d)\\). Multiplying by \\(S_u-S_d\\) gives us \\(\\delta(S_u-S_d) = C_u-C_d\\) and rearranging yields \\(\\delta S_u - C_u = \\delta S_d-C_d\\), which is critical to what follows. Consider purchasing \\(\\delta\\) shares of the stock at date \\(0\\) and borrowing \\[\\mathrm{e}^{-rt}(\\delta S_u-C_u) = \\mathrm{e}^{-rt}(\\delta S_d-C_d)\\] dollars at date \\(0\\). Then you will owe \\[\\delta S_u-C_u = \\delta S_d-C_d\\] dollars at date \\(t\\), and hence the value of the portfolio at date \\(t\\) in the up state will be \\[\\text{value of delta shares} - \\text{dollars owed} = \\delta S_u - (\\delta S_u-C_u) = C_u\\; ,\\] and the value of the portfolio at date \\(t\\) in the down state will be \\[\\text{value of delta shares} - \\text{dollars owed} = \\delta S_d - (\\delta S_d-C_d) = C_d\\;\\;.\\] Thus, this portfolio of buying delta shares and borrowing money (i.e., buying delta shares on margin) replicates the call option. Consequently, the value \\(C\\) of the option at date \\(0\\) must be the date–0 cost of the portfolio; i.e., \\[\nC = \\text{cost of delta shares} - \\text{dollars borrowed}\\] \\[ = \\delta S - \\mathrm{e}^{-rt}(\\delta S_u-C_u)\\,.\n\\qquad(6.2)\\]\n\n\n\n\n\n\nExample\n\n\n\n\n\nSuppose a stock price today is \\(S=100\\), and suppose that the price at a future date \\(t\\) will be either \\(S_u=110\\) or \\(S_u=90\\). The following figure depicts this situation.\n {fig-align=“center”}\nConsider a call option with a strike of \\(K=105\\) that matures at \\(t\\). The value of being able to buy a stock at \\(105\\) and sell it for \\(110\\) is \\(5\\), and the value of being able to buy at \\(105\\) and sell at \\(90\\) is zero, so the value of the call option at date \\(t\\) is as shown below. Our goal is to answer the question: What is the call worth at date \\(0\\)?\n\n\n\n\n\nWe calculate the option \\(\\delta\\) as described above: \\[\\frac{C_u - C_d}{S_u-S_d} = \\frac{5-0}{110-90} = \\frac{1}{4}\\,.\\] The following shows the value of \\(\\delta\\) shares at date \\(0\\) and at date \\(t\\).\n\n\n\n\n\nThe critical feature of this figure is that the difference between the up and down values at date \\(t\\) is the same as the difference between the up and down values of the call; that is, it is \\(5\\) dollars. This is guaranteed by our formula for \\(\\delta\\). The portfolio of \\(\\delta\\) shares is worth more than the call at date \\(t\\), but if we owed \\(22.50\\), then the value of the portfolio after paying back the loan would match the call value. At an interest rate of 5% (as a rate from date \\(0\\) to date \\(t\\) instead of continuous compounding, for simplicity), we could borrow \\(21.43\\) and then owe \\(22.50\\). This is depicted in the following.\n\n\n\n\n\nIf we subtract the previous figure from the figure showing the value of \\(\\delta\\) shares, we obtain the figure below. What it means is that if we invest \\(3.57\\) of our own money, and borrow \\(21.43\\), then we can buy \\(\\delta\\) shares, and, after paying back the loan with interest, our portfolio value will match the value of the call option. In other words, we can replicate the call option by buying \\(\\delta\\) shares of the stock on margin. Because we can create the call option value at date \\(t\\) by investing \\(3.57\\) of our own money at date \\(0\\), the price of the call option at date \\(0\\) should be \\(3.57\\). If the price of the call option were different, then there would be an arbitrage opportunity. This is the calculation that is made in Equation 6.2.\n\n\n\n\n\n\n\n\n\n\nState Prices\nWe now rewrite the option pricing Equation 6.2 in terms of state prices. By substituting for \\(\\delta\\) in Equation 6.2, we can rearrange Equation 6.2 as\n\\[\nC = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times C_u + \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times C_d\\; .\n\\qquad(6.3)\\]\nA little algebra also shows that \\[\nS = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times\nS_u + \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times S_d\\; ,\n\\qquad(6.4)\\]\nand \\[\n1 = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times \\mathrm{e}^{rt}+ \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times \\mathrm{e}^{rt}\\;.\n\\qquad(6.5)\\]\nIt is convenient to denote the factors appearing in these equations as \\[\n\\pi_u = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\quad \\text{and} \\quad \\pi_d = \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\;.\n\\qquad(6.6)\\]\nThe numbers \\(\\pi_u\\) and \\(\\pi_d\\) are called the state prices, for reasons that will be explained below.\nWith these definitions, we can write Equation 6.3–Equation 6.5 as\n\\[\nC = \\pi_uC_u + \\pi_dC_d\\;,\n\\qquad(6.7)\\]\n\\[\nS = \\pi_uS_u+\\pi_dS_d\\;,\n\\qquad(6.8)\\]\n\\[\n1 = \\pi_u\\mathrm{e}^{rt} + \\pi_d \\mathrm{e}^{rt}\\;.\n\\qquad(6.9)\\]\nThese equations have the following interpretation: the value of a security today is its value in the up state times \\(\\pi_u\\) plus its value in the down state times \\(\\pi_d\\). This applies to Equation 6.9 by considering an investment of $1 today in the risk-free asset—it has value 1 today and will have value \\(\\mathrm{e}^{rt}\\) in both the up and down states at date \\(t\\). Moreover, this same equation holds for any other derivative asset – for example, a put option – for the same \\(\\pi_u\\) and \\(\\pi_d\\) defined in Equation 6.6.\nWe can think of any security as a portfolio of what are called Arrow securities (in recognition of the seminal work of Kenneth Arrow (Arrow 1964)). In this model, one of the Arrow securities pays $1 at date \\(t\\) if the up state occurs and the other pays $1 at date \\(t\\) if the down state occurs. For example, the stock is equivalent to a portfolio consisting of \\(S_u\\) units of the first Arrow security and \\(S_d\\) units of the second, because the stock is worth \\(S_u\\) dollars in the up state and \\(S_d\\) dollars in the down state. Equation 6.7–Equation 6.9 show that \\(\\pi_u\\) is the price of the first Arrow security and \\(\\pi_d\\) is the price of the second. For example, the right-hand side of Equation 6.8 is the value of the stock at date \\(0\\) viewed as a portfolio of Arrow securities when the Arrow securities have prices \\(\\pi_u\\) and \\(\\pi_d\\). Because the stock clearly is such a portfolio, its price today must equal the value of that portfolio, which is what Equation 6.8 asserts.\nAs mentioned before, the prices \\(\\pi_u\\) and \\(\\pi_d\\) of the Arrow securities are called the state prices, because they are the prices of receiving $1 in the two states of the world. The state prices should be positive, because the payoff of each Arrow security is nonnegative in both states and positive in one. A little algebra shows that the conditions \\(\\pi_u&gt;0\\) and \\(\\pi_d&gt;0\\) are exactly equivalent to our no-arbitrage assumption Equation 6.1.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#risk-neutral-probability",
    "href": "Chapter_Arbitrage.html#risk-neutral-probability",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.2 Risk-Neutral Probability",
    "text": "6.2 Risk-Neutral Probability\nWe have our basic pricing formula \\[ P(X)= \\sum_{s=1}^S \\pi_s X_s \\] Let \\(p_s = \\pi_s e^{rt}\\). Then \\(\\sum_{s=1}^S p_s = 1\\) and \\(p_s&gt;0\\). Therefore, we can think of \\(p_s\\) as probabilities. We refer to \\(p_s\\) as risk neutral probabilities. Given this we can write \\[P(X)= \\sum_{s=1}^S p_s e^{-rt} X_s \\] which can be thought of the expected discounted value of the future cash flows. The risk neutral probabilities are so-called since we discount by the risk-free rate. However, the risk neutral probabilities should not be confused with actual probabilities since they are really prices.\nUnlike the Capital Asset Pricing Model, for example, there is no risk premium in the discount rate. This is the calculation we would do to price assets under the actual probabilities if investors were risk neutral (or for zero-beta assets). So, we can act as if investors are risk neutral by adjusting the probabilities.1 Of course, we are not really assuming investors are risk neutral. We have simply embedded any risk premia in the probabilities.\nNotice the expected return using the risk neutral probabilities for any investement is the risk free rate: \\[\\frac{\\sum_{s=1}^S p_s X_s}{P(X)} = e^{rt}\\], so it is important to realize that the risk neutral probabilities are distinct from the actual probabilities used in portfolio theory.\n\nRisk-Neutral Probability in the Binomial Model\nTo apply Key Principle \\(\\ref{principle:stateprices}\\) in the most convenient way, we manipulate the state prices so we can interpret the sums on the right-hand sides of Equation 6.7–Equation 6.9 in terms of expectations. The expectation (or mean) of a random variable is of course its probability-weighted average value.\nSet \\(p_u = \\pi_u\\mathrm{e}^{rt}\\) for the up state and \\(p_d = \\pi_d\\mathrm{e}^{rt}\\) for the down state. Equation 6.7–Equation 6.9 can be written as\n\\[\nC = \\mathrm{e}^{-rt}[p_uC_u+p_dC_d]\\;,\n\\qquad(6.10)\\]\n\\[\nS = \\mathrm{e}^{-rt}[p_uS_u+p_dS_d]\\;,\n\\qquad(6.11)\\]\n\\[\n1= p_u+p_d\\;.\n\\qquad(6.12)\\]\nThe numbers \\(p_u\\) and \\(p_d\\) are called the risk-neutral probabilities of the up and down states. The numbers are both positive (because the state prices are positive under our no-arbitrage assumption) and Equation 6.12 states that they sum to one, so it is indeed sensible to consider them as (artificial) probabilities. Equation 6.10 and Equation 6.11 state that the value of a security today is its expected value at date \\(t\\) discounted at the risk-free rate, when we take the expectation using the risk-neutral probabilities. Thus, these are present value formulas.\nIt follows from Equation 6.11 that the expected return of the stock under the risk-neutral probabilities is the risk-free return; that is, \\[\\frac{p_uS_u + p_dS_d}{S} = \\mathrm{e}^{rt}\\,.\\] This is a general fact: expected returns relative to the risk-neutral probabilities equal the risk-free return.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#martingale-pricing",
    "href": "Chapter_Arbitrage.html#martingale-pricing",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.3 Martingale Pricing",
    "text": "6.3 Martingale Pricing\nA martingale is a stochastic process for which the expected value of tomorrow’s value is today’s value. In the context of our model discounted values of non-dividend paying trading strategies are martingales, that is if \\(X(0)\\) is today’s value of a portfolio with payoffs random \\(X\\) at time \\(t\\), \\[  \\frac{X(0))}{R(0))} = \\sum_{s=1}^S p_s \\frac{X_s}{e^{r t}} = \\mathrm{E}^R\\left[\\frac{X}{R_t}\\right] \\] where \\(R(0) = 1\\), the initial investment in the risk free asset. In this sense, the discounted value today is the expected discounted discounted value in one period, where the expectation uses the risk neutral probabilities.\n’’\n\nMartingales\nEquation 6.10 and Equation 6.11 can be written in an equivalent form, which, though somewhat less intuitive, generalizes more readily. First, let’s introduce some notation for the price of the risk-free asset. Considering an investment of $1 today that grows to \\(\\mathrm{e}^{rt}\\) at date \\(t\\), it is sensible to take the price today to be \\(R=1\\) and the price in the up and down states at date \\(t\\) to be \\(R_u=R_d=\\mathrm{e}^{rt}\\).2 In terms of this notation, Equation 6.10–Equation 6.12 can be written as:\n\\[\n\\frac{C}{R} = p_u \\frac{C_u}{R_u} + p_d \\frac{C_d}{R_d}\\;,\n\\qquad(6.13)\\]\n\\[\n\\frac{S}{R} = p_u \\frac{S_u}{R_u} + p_d \\frac{S_d}{R_d}\\;,\n\\qquad(6.14)\\]\n\\[\n1=p_u+p_d\\;.\n\\qquad(6.15)\\]\nEquation 6.13 and Equation 6.14 each state that the price of a security today divided by the price of the risk-free asset equals the expected future value of the same ratio, when we take expectations using the risk-neutral probabilities. In other words, the mean of the date–\\(t\\) value of the ratio is equal to the ratio today.\nA variable that changes randomly over time with the expected future value being always equal to the current value is called a martingale. Thus, we have shown that the ratio of the stock price to the price of the risk-free asset is a martingale when using the risk-neutral probabilities.\nThe ratio of one price to another is the value of the first (numerator) asset when we are using the second (denominator) asset as the numeraire. The term numeraire means a unit of measurement. For example, the ratio \\(C/R\\) is the value of the call when we use the risk-free asset as the unit of measurement: it is the number of units of the risk-free asset for which one call option can be exchanged (to see this, note that \\(C/S\\) shares is worth \\(C/R \\times R = C\\) dollars, so \\(C/R\\) units of the risk-free asset is worth the same as one call). Thus, we have shown that asset prices using the risk-free asset as numeraire are martingales relative to the risk-neutral probabilities.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#sec-s:change_numeraire",
    "href": "Chapter_Arbitrage.html#sec-s:change_numeraire",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.4 Change of Numeraire",
    "text": "6.4 Change of Numeraire\nOur choice of the risk free asset to derive risk neutral probabilities was somewhat arbitrary. In fact any strictly positive non-dividend paying trading strategy can be used as a numeraire. In other words instead of quoting the price of apples and oranges in dollars, we can quote prices in numbers of oranges. One apple is equal to the price of one apple in dollars divided by the price of oranges in dollars and one dollar is equal to one divided by the price of oranges. In our model, instead of measuring payoffs in units of an investment in the risk free asset, we can measure payoffs in different units. We explain this as follows.\nThe price of any non dividend paying asset or dividend reinvested trading strategy with strictly positive value is \\[Y(0) = \\sum_{s=1}^S \\pi_s Y_s \\] Rearranging, we can define probabilities \\(\\text{prob}^Y_s = \\frac{\\pi_s}{Y(0)}\\). Then we have \\(\\sum_{s=1}^S \\text{prob}^Y_s =1\\) and we can write the price of the risk free asset and any traded security as \\[1 = Y(0) \\sum_{s=1}^S \\text{prob}^Y_s \\frac{e^{rt}}{Y_s} = Y(0) \\mathrm{E}^Y\\left[\\frac{e^{rt}}{Y} \\right]\\] \\[S(0) = Y(0) \\sum_{s=1}^S \\text{prob}^Y \\frac{S_s}{Y_s}  = Y(0) \\mathrm{E}^Y\\left[\\frac{S}{Y}\\right] \\] Notice \\(\\frac{S}{Y}\\) is a martingale using the probabilities \\(\\text{prob}_s^Y\\). The ratio \\(\\frac{S}{Y}\\) is the number of shares of \\(Y\\) that security \\(S\\) is worth. Therefore, using the probabilities \\(p_s^Y\\), the value of the number of shares of \\(Y\\) an investment is worth follows a martingale.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf there are no arbitrage opportunities, then for each dividend-reinvested asset, there exists a probability measure such that the ratio of any other dividend-reinvested asset price to the first (numeraire) asset price is a martingale.\n\n\nAn assignment of probabilities to events is called a probability measure, or simply a measure (because it measures the events, in a sense). Thus, we have described two different probability measures: one using the risk-free asset as numeraire and one using the stock as numeraire. The probability measure using the risk-free asset as numeraire defined in the previous section is universally called the risk-neutral probability. When we use one of these probabilities, we commonly say that we are changing numeraires.\nWe have applied this statement to the risk-free asset, which pays dividends (interest). However, the price \\(R_s=\\mathrm{e}^{rt}\\) for all \\(s=1,\\dots,S\\), includes the interest, so no interest has been withdrawn—the interest has been reinvested—prior to the maturity \\(t\\) of the option. This is what we mean by a dividend-reinvested asset. In general, we apply the formulas developed in this and the following section to dividend-paying assets by considering the portfolios in which dividends are reinvested.\n\nOther Numeraires in the Binomial Model\nNote that the risk-neutral probabilities are the state prices multiplied by the gross return on the risk-free asset. Analogously, define numbers \\(\\text{prob}^S_u = \\pi_uS_u/S\\) and \\(\\text{prob}^S_d = \\pi_dS_d/S\\). Substituting for \\(\\pi_u\\) and \\(\\pi_d\\) in Equation 6.7–Equation 6.9 and continuing to use the notation \\(R\\) for the price of the risk-free asset, we obtain\n\\[\n\\frac{C}{S} = \\text{prob}^S_u \\frac{C_u}{S_u} + \\text{prob}^S_d \\frac{C_d}{S_d}\\;,\n\\qquad(6.16)\\]\n\\[\n1 = \\text{prob}^S_u + \\text{prob}^S_d\\;,\n\\qquad(6.17)\\]\n\\[\n\\frac{R}{S} = \\text{prob}^S_u \\frac{R_u}{S_u} + \\text{prob}^S_d \\frac{R_d}{S_d}\\;.\n\\qquad(6.18)\\]\nEquation 6.17 establishes that we can view the \\(\\text{prob}^S\\)’s as probabilities (like the risk-neutral probabilities, they are positive because the state prices are positive). Equation 6.16 and Equation 6.18 both state that the ratio of a security price to the price of the stock is a martingale when we use the \\(\\text{prob}^S\\)’s’ as probabilities. Thus, asset prices using the stock as numeraire are martingales when we use the \\(\\text{prob}^S\\) probabilities.\n\n\nPractical Implementation\nFor this exposition, it was convenient to first calculate the state prices and then calculate the various probabilities. However, that is not the most efficient way to proceed in most applications. In a typical application, we would view the prices of the stock and risk-free asset in the various states of the world as given, and we would be attempting to compute the value of the call option. Note that t Equation 6.7–Equation 6.9, Equation 6.13–Equation 6.15, and Equation 6.16–Equation 6.18 are all equivalent. In each case we would consider that there are three unknowns—the value \\(C\\) of the call option and either two state prices or two probabilities. In each case the state prices or probabilities can be computed from the last two equations in the set of three equations and then the call value \\(C\\) can be computed from the first equation in the set. All three sets of equations produce the same call value.\nIn fact, as we will see, it is not even necessary to calculate the probabilities. The fact that ratios of dividend-reinvested asset prices to the numeraire asset price are martingales tell us enough about the probabilities to calculate derivative values without having to calculate the probabilities themselves.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#stochastic-discount-factor",
    "href": "Chapter_Arbitrage.html#stochastic-discount-factor",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.5 Stochastic Discount Factor",
    "text": "6.5 Stochastic Discount Factor\nUp until now, no mention of the true proabilities has been made. However, another pricing formula that is commonly encountered is to use a stochastic discount factor. Denote the actual probability of state \\(s\\) as \\(\\text{prob}_s\\).If we define \\(m_s = \\frac{\\pi_s}{\\text{prob}_s}\\), we can write \\[ P(X) = \\sum_{s=1}^S \\text{prob}_s m_s X_s = \\mathrm{E}\\left[m X\\right] \\].\nWe call the random variable \\(m\\) the stochastic discount factor. We can calculate an asset value as the expectation of its future value discounted (multiplied) by the the stochastic factor \\(m\\).\nA further decomposition of \\(m\\) is useful. Notice that \\[ 1 = \\mathrm{E}\\left[m e^{rt}\\right] \\] so in a sense to be made precise later, \\(m e^{rt}\\) is a martingale when we identify the time 0 value of \\(m\\) as 1. Therefore, we can write the price of any asset with time \\(t\\) value \\(X\\) as \\[  P(X) = \\mathrm{E}\\left[m e^{rt} \\frac{X}{e^{rt}}\\right] = \\sum_{s=1}^S \\text{prob}_s m_s e^{rt} \\frac{X_s}{e^{rt}} =\\mathrm{E}^R\\left[\\frac{X}{e^{rt}}\\right]\\] Therefore, the risk neutral probabilities are \\[p_s = \\text{prob}_s m_s e^{rt} \\] and the random variable \\(m e^{rt}\\) changes the probability measure from the true probability measure to the risk neutral measure: for any random variable \\(Z\\), \\(\\mathrm{E}[m e^{rt} Z] = \\mathrm{E}^R[Z]\\).\n\nStochastic Discount Factor in the Binomial Model\nWe now consider yet another reformulation of the pricing relations Equation 6.7–Equation 6.9. This formulation generalizes more easily to pricing when there are a continuum of states.\nLet \\(\\text{prob}_u\\) denote the actual probability of the up state and \\(\\text{prob}_d\\) denote the probability of the down state. These probabilities are irrelevant for pricing derivatives in the two-state up-and-down model, but we use them to write the pricing relations Equation 6.7–Equation 6.9 as expectations with respect to the actual probabilities. To do this, we can define \\[\\begin{align*}\nm_u &= \\frac{\\pi_u}{\\text{prob}_u}\\; ,\\\\\nm_d &= \\frac{\\pi_d}{\\text{prob}_d}\\;.\n\\end{align*}\\] Then Equation 6.7–Equation 6.9 can be written as\n\\[\nC = \\text{prob}_um_uC_u + \\text{prob}_dm_dC_d\\;,\n\\qquad(6.19)\\]\n\\[\nS = \\text{prob}_um_uS_u + \\text{prob}_dm_dS_d\\;,\n\\qquad(6.20)\\]\n\\[\nR = \\text{prob}_um_uR_u + \\text{prob}_dm_dR_d\\;.\n\\qquad(6.21)\\]\nThe right-hand sides are expectations with respect to the actual probabilities. For example, the right-hand side of Equation 6.19 is the expectation of the random variable that equals \\(m_uC_u\\) in the up state and \\(m_dC_d\\) in the down state. The risk-neutral probabilities can be calculated from \\(m_u\\) and \\(m_d\\) as \\(p_u=\\text{prob}_um_uR_u/R\\) and \\(p_d=\\text{prob}_dm_dR_d/R\\). Likewise, the probabilities using the stock as the numeraire can be calculated from \\(m_u\\) and \\(m_d\\) as \\(\\text{prob}^S_u=\\text{prob}_um_uS_u/S\\) and \\(\\text{prob}^S_d=\\text{prob}_dm_dS_d/S\\).\nThe random variable \\(m\\) the stochastic discount factor. Equation 6.20–Equation 6.21 show that we can calculate an asset value as the expectation of its future value discounted (multiplied) by the the stochastic factor \\(m\\).",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#more-general-models",
    "href": "Chapter_Arbitrage.html#more-general-models",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.6 More General Models",
    "text": "6.6 More General Models\nNow, we drop the assumption that there are a finite number of possible future prices of the stock and allow a general distribution with potentially a continuum of possible values. Denote the future price as \\(S_t\\). Our principle regarding the stochastic discount factor developed in the preceding section can in general be expressed as:3\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf there are no arbitrage opportunities, then there exists for each date \\(t\\) a strictly positive random variable \\(m_t\\), called a stochastic discount factor, such that the date–\\(0\\) value of any dividend-reinvested asset with price \\(P\\) is \\[\nP_0 = \\mathrm{E}[m_tP_t]\\;.\n\\qquad(6.22)\\]\n\n\nHere, \\(\\mathrm{E}[m_tS_t]\\) denotes the expectation of the random variable \\(m_tS_t\\). In a two-state model (or in any model with only a finite number of states of the world), the concept of an expectation is clear: it is just a weighted average of outcomes, the weights being the probabilities. In the two-state model, the right-hand side of Equation 6.20 is the same as the right-hand side of Equation 6.22.4\nTo convert from state prices to probabilities corresponding to different numeraires, we follow the same procedure as at the end of the previous section: we multiply together (i) the probability of the state, (ii) the value of \\(m_t\\) in the state, and (iii) the gross return of the numeraire in the state. If there is a continuum of states, then the actual probability of any individual state is typically zero, so this multiplication produces a zero probability. However, we can nevertheless add up these probabilities to define the probability of any event \\(A\\), an event being a set of states of the world. To do this, let \\(1_A\\) denote the random variable that takes the value 1 when \\(A\\) is true and which is zero otherwise. Then the probability of \\(A\\) using \\(S\\) as the numeraire is defined as \\[\n\\mathrm{E}\\left[1_Am_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(6.23)\\]\nThis makes sense as a probability because it is nonnegative and because, if \\(A\\) is the set of all states of the world, then its probability is \\(\\mathrm{E}[m_tS_t/S_0]\\), which equals one by virtue of Equation 6.22. From Equation 6.23 for the probability of any event \\(A\\), it can be shown that the expectation of any random variable \\(X\\) using \\(S\\) as the numeraire is \\[\n\\mathrm{E}\\left[Xm_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(6.24)\\]\nDifferent numeraires lead to different probability measures and hence to different expectations. To keep this straight, we use the numeraire as a superscript on the expectation symbol: for example, \\(\\mathrm{E}^S\\) denotes expectation with respect to the probability measure that corresponds to \\(S\\) being the numeraire. Also, we use the symbol \\(\\text{prob}^S(A)\\) to denote the probability of an event \\(A\\) when we use \\(S\\) as the numeraire. So, Equation 6.23 and Equation 6.24 are written as\n\\[\n\\text{prob}^S(A) = \\mathrm{E}\\left[1_Am_t\\frac{S_t}{S_0}\\right]\\;,\n\\qquad(6.25)\\]\n\\[\n\\mathrm{E}^S[X] = \\mathrm{E}\\left[Xm_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(6.26)\\]\n\nFundamental Pricing Formula\nOur key result in the two-state up-and-down example considered earlier was that the ratio of the price of any dividend-reinvested asset to the price of the numeraire asset is not expected to change when we use the probability measure corresponding to the numeraire. We now demonstrate the same result in this more general model. Recall that \\(t\\) denotes an arbitrary but fixed date at which we have defined the probabilities using \\(S\\) as the numeraire in Equation 6.23. At each date \\(s&lt;t\\), let \\(\\mathrm{E}^P_s\\) denote the expectation given information at time \\(s\\) and using a dividend-reinvested asset price \\(P\\) as the numeraire (we continue to write the expectation at date \\(0\\) without a subscript; i.e., \\(\\mathrm{E}^S\\) has the same meaning as \\(\\mathrm{E}^S_0\\)). Let \\(Y\\) denote the price of another dividend-reinvested asset. We will show that \\[\n\\frac{Y_s}{P_s} = \\mathrm{E}^P_s \\left[\\frac{Y_t}{P_t}\\right]\\;.\n\\qquad(6.27)\\]\nThus, the expected future (date–\\(t\\)) value of the ratio \\(Y/P\\) always equals the current (date–\\(s\\)) value when we change probability measures using \\(P\\) as the numeraire. As discussed in the preceding section, the mathematical term for a random variable whose expected future value always equals its current value is martingale. Thus, we can express Equation 6.27 as stating that the ratio \\(Y/P\\) is a martingale when we compute expectations using the probability measure that corresponds to \\(S\\) being the numeraire.\nThe usefulness of Equation 6.27 is that it gives us a formula for the asset price \\(Y_s\\) at any time \\(s\\)—and recall that this formula holds for every dividend-reinvested asset. The formula is obtained from Equation 6.27 by multiplying through by \\(P_s\\):\n\n\n\n\n\n\nImportant Principle\n\n\n\nIn the absence of arbitrage opportunities, prices \\(P\\) and \\(Y\\) of dividend-reinvested assets satisfy, for all \\(s&lt;t\\), \\[\nY_s = P_s\\mathrm{E}^P_s \\left[\\frac{Y_t}{P_t}\\right]\\;.\n\\qquad(6.28)\\]\n\n\nWe call Equation 6.28 the fundamental pricing formula. It is at the heart of modern pricing of derivative securities. It is a present value relation: the value at time \\(s\\) of the asset with price \\(Y\\) is the expectation, under the appropriate probability measure, of its value \\(Y_t\\) at time \\(t\\) discounted by the (possibly random) factor \\(P_s/P_t\\).\nFor example, assume the risk free rate is constant. Letting \\(P_s = R_s\\) denote the value \\(\\mathrm{e}^{rs}\\) of the risk-free asset and using it as the numeraire, Equation 6.28 becomes \\[\nY_s = \\mathrm{e}^{rs}\\\\mathrm{E}^R_s\\left[\\frac{Y_t}{\\mathrm{e}^{rt}}\\right] = \\mathrm{e}^{-r(t-s)}\\mathbb{\\mathrm{E}}^R_s [Y_t]\\;,\n\\qquad(6.29)\\]\nwhich means that the value \\(Y_s\\) is the expected value of \\(Y_t\\) discounted at the risk-free rate for the remaining time \\(t-s\\), when the expectation is computed under the risk-neutral probability.\nNotice that this implies \\(m_t e^{rt}\\) is a martingale. This tells us how to change probabilities as follows: for any time \\(t\\) random variable5, \\(Z\\), \\[E[m_t e^{rt} Z] = E^R[Z] \\] Similar remarks also apply to any dividend reinvested trading strategy, \\(X\\), \\(m_t X_t\\) is a martingale. Then \\[E[m_t X_t Z] = X(0) E^X[Z]\\].\nWe end this section with a proof of Equation 6.27.6\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nConsider any time \\(s&lt;t\\) and any event \\(A\\) that is distinguishable by time \\(s\\). Consider the trading strategy of buying one share of the asset with price \\(Y\\) at time \\(s\\) when \\(A\\) has happened and financing this purchase by short selling \\(Y_s/P_s\\) shares of the asset with price \\(P\\). Each share of this asset that you short brings in \\(P_s\\) dollars, so shorting \\(Y_s/P_s\\) shares brings in \\(Y_s\\) dollars, exactly enough to purchase the desired share of the first asset. Hold this portfolio until time \\(t\\) and then liquidate it. Liquidating it generates \\[1_A\\left(Y_t-\\frac{Y_s}{P_s}P_t\\right)\\] dollars. The multiplication by the random variable \\(1_A\\) is because we only implement this strategy when \\(A\\) occurs (i.e., when \\(1_A=1\\)). Consider the security that pays this number of dollars at time \\(t\\). Because we obtained it with a trading strategy that required no investment at any time, its price at time \\(0\\) must be \\(0\\). We already observed that we can represent the price in terms of state prices, so we conclude that \\[\\mathrm{E} \\left[m_t1_A\\left(Y_t-\\frac{Y_s}{P_s}P_t\\right)\\right] = 0\\;\\;.\\] When we divide by \\(P_0\\), this still equals zero. Factoring \\(P_t\\) outside the parentheses gives \\[\\mathrm{E} \\left[1_A\\frac{P_t}{P_0}m_t\\left(\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right)\\right] = 0\\;\\;.\\] We see from Equation 6.26 for expectations using \\(P\\) as the numeraire that we can write this as \\[\\mathrm{E}^P\\left[1_A\\left(\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right)\\right]=0\\;.\\] This is true for any event \\(A\\) distinguishable at time \\(s\\), so the expectation of \\(Y_t/P_t-Y_s/P_s\\) must be zero given any information at time \\(s\\) when we use \\(P\\) as the numeraire; i.e., \\[\\mathrm{E}^P_s\\left[\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right]=0\\; ,\\] or, equivalently \\[\\mathrm{E}^P_s\\left[\\frac{Y_t}{P_t}\\right] = \\frac{Y_s}{P_s}\\;.\\]",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#multiple-cash-flows",
    "href": "Chapter_Arbitrage.html#multiple-cash-flows",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.7 Multiple Cash Flows",
    "text": "6.7 Multiple Cash Flows\nOur valuation formulae work for dividend paying assets or trading strategies that make periodic payments. We simply sum up the value of the individual cash flows. If a stock pays dividends \\(D_t\\) up to and including time \\(T\\) and the stock price at time \\(T\\) is \\(S(T)\\) then the stock price is given by \\[S(0)= \\mathrm{E}\\left[\\sum_{t=1}^T m_t D_t + M_T S(T)\\right] \\]",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#further-discussion",
    "href": "Chapter_Arbitrage.html#further-discussion",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.8 Further Discussion",
    "text": "6.8 Further Discussion\nHow do the probabilities of different events change when we change probability measures? Which events become more likely and which become less likely? These are natural questions to ask. Let’s consider the risk-neutral probability assuming the risk free rate is constant. Equation 6.29 can be rearranged as \\[\\frac{\\mathrm{E}^{R}_s[Y_t]}{Y_s} = \\mathrm{e}^{r(t-s)}\\,.\\] This means that the expected return on on the dividend-reinvested asset with price \\(Y\\) is the risk-free rate. Stocks generally have positive risk premia, meaning they are expected to return more than the risk-free rate. Hence, when we shift from the actual probabilities to the risk-neutral probability, we are decreasing expected returns. How does this happen? It is because we increase the probabilities of bad events (low stock returns) and decrease the probabilities of good events (high stock returns).\nIn Example \\(\\ref{example:binomial}\\), it is easy to calculate that the risk-neutral probabilities are \\(p_u=0.75\\) and \\(p_d=0.25\\). To value the call option, we did not need to specifythe actual probabilities, but if the expected return of the stock is higher than the risk-free return – that is, if the stock has a positive risk premium – then it must be the case that \\(p_u &gt; 0.75\\). For example, if the expected return is 8%, then \\(p_u=0.9\\). Thus, if the stock has a positive risk premium, then the risk-neutral probability of the stock falling is higher than the actual probability.\nThe usual way to value risky assets is to discount expected future values at a risk-adjusted rate that is higher than the risk-free rate. What we have shown is that we can instead value risky assets by adjusting the probabilities and discounting at the risk-free rate. Instead of increasing the discount rate relative to the risk-free rate, we increase the probabilities of bad events. These are alternative ways of valuing risky assets.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#exercises",
    "href": "Chapter_Arbitrage.html#exercises",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "6.9 Exercises",
    "text": "6.9 Exercises\n\nExercise 6.1 Create a Python function in which the user inputs \\(S\\), \\(S_d\\), \\(S_u\\), \\(K\\), \\(r\\) and \\(t\\). Check that the no-arbitrage condition Equation 6.1 is satisfied. Compute the value of a call option in each of the following ways:\n\nCompute the delta and use Equation 6.2.\nCompute the state prices and use Equation 6.7.\nCompute the risk-neutral probabilities and use Equation 6.10.\nCompute the probabilities using the stock as numeraire and use Equation 6.16.\n\nVerify that all of these methods produce the same answer.\n\n\nExercise 6.2 In a two-state model, a put option is equivalent to \\(\\delta_p\\) shares of the stock, where \\(\\delta_p = (P_u-P_d)/(S_u-S_d)\\) (this will be negative, meaning a short position) and some money invested in the risk-free asset. Derive the amount of money \\(x\\) that should be invested in the risk-free asset to replicate the put option. The value of the put at date \\(0\\) must be \\(x+\\delta_pS\\).\n\n\nExercise 6.3 Using the result of the previous exercise, repeat Exercise 6.1} for a put option.\n\n\n\n\n\nArrow, K. J. 1964. “The Role of Securities in the Optimal Allocation of Risk Bearing.” Review of Economic Studies 31: 91–96.\n\n\nCox, J., and S. Ross. 1976. “The Valuation of Options for Alternative Stochastic Processes.” Journal of Financial Economics 3: 145–66.\n\n\nGeman, H., N. El Karoui, and J.-C. Rochet. 1995. “Changes of Numeraire, Changes of Probability Measure and Option Pricing.” Journal of Applied Probability 32: 443–58.\n\n\nHarrison, J. M., and D. Kreps. 1979. “Martingales and Arbitrage in Multiperiod Securities Markets.” Journal of Economic Theory 20: 381–408.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#footnotes",
    "href": "Chapter_Arbitrage.html#footnotes",
    "title": "6  Fundamentals of Arbitrage Pricing",
    "section": "",
    "text": "This fundamental idea is due to Cox and Ross (Cox and Ross 1976).↩︎\nAll of the equations appearing below are also true if instead we take \\(R=\\mathrm{e}^{-rt}\\) and \\(R_u=R_d=1\\).↩︎\nWe have proven this in the two-state model, but we will not prove it in general. As is standard in the literature, we simply adopt it as an assumption. A general proof is in fact difficult and requires a definition of no arbitrage that is considerably more complicated than the simple assumption Equation 6.1 that is sufficient in the two-state up-and-down model.↩︎\n In general the expectation (or mean) of a random variable is an intuitive concept, and an intuitive understanding is sufficient for this book, so we will not give a formal definition. It should be understood that we are assuming implicitly, whenever necessary, that the expectation exists (which is not always the case). In this regard, it is useful to note in passing that a product of two random variables \\(XY\\) has a finite mean whenever \\(X\\) and \\(Y\\) have finite variances.↩︎\nIn other words a random variable whose value is known at time \\(t\\)↩︎\nThe proof is due to Harrison and Kreps (Harrison and Kreps 1979). See also Geman, El Karoui and Rochet (Geman, El Karoui, and Rochet 1995). We omit here technical assumptions regarding the existence of expectations.↩︎",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Fundamentals of Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html",
    "href": "Chapter_Deltas.html",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "",
    "text": "7.1 State Prices\nIn principle, once we know the state prices or stochastic discount factor we can find the value of any future cash flows and derivatives. In the binomial model in Chapter 6 we found the state prices by replicating the payoffs to Arrow securities using the stock and the bond. However in the continuous time setting, we must have a way of deriving this information. In this chapter, we will see that through dynamic trading strategies, we can replicate the payoffs of derivative securities. This allows us to find prices of digital options which essentially allow us to find state prices. We first discuss the classic Merton argument for replicating the payoff of a call option.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#replicating-portfolios",
    "href": "Chapter_Deltas.html#replicating-portfolios",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "7.2 Replicating Portfolios",
    "text": "7.2 Replicating Portfolios\nIn addition to the original Black Scholes derivation, another derivation of the Black Scholes formula is provided by Merton (Merton 1973). He asked the question of whether, by trading the stock and the risk-free asset, the payoff to a European call option can be replicated.\nFor this chapter, we assume that the stock price follows \\[ \\mathrm{d} S(t) = (\\mu - q) S(t) \\mathrm{d} t + \\sigma S(t) \\mathrm{d} B(t) \\] where owning the stock entitles the owner to a flow of dividends \\(q S(t) \\mathrm{d} t\\).\nThe additonal feature of dividends does not add much complexity to the model. However, we have to be careful; for example, a European call option does not entitle the owner to the dividends paid prior to exercise of the option.\nAssuming a risk neutral measure, the total return on the stock should be the risk free rate. Therefore the risk neutral dynamics are \\[S(t) = S(0) \\exp\\left(\\left(r - q - \\frac{1}{2}\\sigma^2\\right) t + \\sigma B_t^R \\right)\\].\nLet \\(\\delta_t\\) be the number of shares of the stock held at time \\(t\\) and \\(\\alpha_t\\) the number of shares of an initial investment of one dollar in the risk free asset. Then the portfolio value, \\(W_t\\) is \\(W_t= \\alpha_t R(t) + \\delta_t S(t)\\) where \\(R(t)= e^{rt}\\) is the time \\(t\\) value of an initial time \\(0\\) investment of one dollar in the risk free asset. The portfolio should start with an initial value, \\(W_0\\), should not have any cash inflows or outflows and have a terminal value equal to a call payoff so the changes in value are completely dictated by the changes in the value of the assets. That is, assuming continuous trading, \\[  d W_t = \\delta_t d S(t) + \\delta_t q S(t) dt + \\alpha_t  d R(t) = \\delta_t \\left(\\mu S(t) dt  + \\sigma S(t) d B_t\\right)  + \\alpha_t r R(t) dt\\] with terminal condition \\[ W_T = \\alpha_T R(T) + \\delta_T S(T) = (S(T) - K)^{+} \\] The problem is to find \\(\\delta_t\\) and \\(\\alpha_t\\) for all times and states. If we can accomplish this, then by `no-arbitrage’ the call price must be the value of the initial investment. Assume the call price is a function of the stock price and time: \\(C(t,S(t))\\). Then by Ito’s Lemma \\[ d C(t,S(t)) = \\left(\\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (\\mu-q) S(t) + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S_t^2 \\right) dt + \\frac{\\partial C}{\\partial S} \\sigma S(t) dB_t \\] It should be apparent that we want to hold \\(\\delta = \\frac{\\partial C}{\\partial S}\\), which is called the delta of the call option. By doing so, we match the diffusion term in the change in wealth and the change in the call option. Then matching the drift terms in both expressions \\[ \\frac{\\partial C}{\\partial S} \\mu S(t) + \\alpha_t r R(t) = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (\\mu-q) S(t) + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t)^2\\] which can be solved to give \\[ \\alpha_t r R(t) =r \\left(W_t -\\frac{\\partial C}{\\partial S} S(t) \\right)  = \\frac{\\partial C}{\\partial t}-\\frac{\\partial C}{\\partial S} q S(t)  + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t^2\\] which gives the equation \\[r W_t = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S}(r-q) S(t)+\\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t)^2\\] with a boundary condition \\(W_T = (S(T)-K)^{+}\\). However, no-arbitrage suggests \\(W_t = C(t,S(t))\\) which gives us the partial differential equation \\[r C = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (r-q) S+\\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S^2\\] with a boundary condition \\(C(T,S_T)= (S_T - K)^{+}\\). Close observation of the right hand side we see this is the drift term of Ito expansion for \\(C\\) if we work in the risk neutral measure. The right hand side then says in the risk neutral measure, the call option earns the risk free return. This is a partial differential equation and a fairly tedious set of calcuations show the Black Scholes formula, the risk neutral expected discounted payoff is a solution (in fact it is the only positive solution).1 The risk-neutral expectation is \\[C= e^{-q (T-t)} S(t) \\mathrm{N}(d_1) - K e^{r(T-t)} \\mathrm{N}(d_2)\\] \\[ d_1= \\frac{\\log(S(t) / K) + (r -q + \\frac{1}{2} \\sigma^2) (T-t)}{\\sigma \\sqrt{T}};~~ d_2= d_1 - \\sigma \\sqrt{T-t}.  \\qquad(7.1)\\] which is the Black Scholes formula adjusted for dividends.\nHowever, there is nothing special about a call option. The same argument will apply for any European style option. The only difference is the terminal condition. This procedure allows us to replicate the payoff of any European option even for those which might not be traded. We can solve for the replication strategy for digital options by solving the PDE with a boundary condition given by the digital option payoff. The solution to the PDE with the terminal condition is given by the risk neutral expectaion of the the discounted terminal condition (payoffs). This observation had a profound effect on practice.\n\nThe Fundamental Partial Differential Equation\nFollowing the analysis above, we see any European style derivative security with a payoff at a fixed date \\(T\\) , which depends on the stock price, must satisfy the fundamental partial differential equation (pde). If the derivative price is \\(D(S(t),t)\\), then the fundamental pde is \\[r D = \\frac{\\partial D}{\\partial t} + \\frac{\\partial D}{\\partial S} (r-q) S+\\frac{1}{2} \\frac{\\partial^2 D}{\\partial S^2} \\sigma^2 S^2\\] with the boundary condition \\(D(S(T),T) = F(S(T))\\). The solution is the risk neutral expected discounted payoff \\[ D(S(t),t) = E_t^R[e^{-r(T-t)}F(S(T))] .\\] The replicating portfolio is to hold \\(\\frac{\\partial D}{\\partial S}\\) shares of stock and \\(D-\\frac{\\partial D}{\\partial S} S\\) dollars in the riskless asset. One can verify that the stock price, the value of the riskless asset, and the value of digital options all satisfy this equation.\n\n\nPortfolio Insurance\nA particularly popular example is portfolio insurance. Recall that a protective put position buys both a put and a share on the same asset, and the payoff at the expiration of the position is given by \\(\\max(K,S_T)\\). The reason for the name protective put is apparent since the position can pay off no less than \\(K\\). The cost of this insurance is the price of the put. However, if the put is not traded, we can synthetically replicate this payoff using the procedure above assuming we can trade continuously. For this example, we assume the stock does not pay dividends (\\(q=0\\)).2\nThe basic recipe is to start with inital wealth equal to that for a protective put position: \\(W_0 = P(0,S_0)+S_0\\). The delta of the protective put position can be calcuated to be the delta of the put plus 1 which is \\(\\mathrm{N}(d_1)\\), where \\(d_1\\) is calculated at each point in time. However, in practice we cannot trade continuously. A simple discrete strategy would rebalance at intervals \\(\\Delta t\\). The strategy calculates \\(\\mathrm{N}(d_1)\\) at time 0 and holds \\(P(0,S_0)+S_0 - \\mathrm{N}(d_1)S_0\\) dollars in the risk free asset and \\(\\mathrm{N}(d_1)\\) shares of the asset. Thereafter these holdings are adjusted. The change in portfolio value over the interval \\(\\Delta t\\) is \\[\\Delta W= W_{i \\Delta t}- W_{(i-1)\\Delta t} \\] \\[\n= (P((i-1)\\Delta t,S_{(i-1)\\Delta t})+S_{(i-1)\\Delta t} - \\mathrm{N}(d_1-)S_{(i-1)\\Delta t})(R_{i\\Delta t}-R_{(i-1)\\Delta t}) + \\mathrm{N}(d1-)(S_{i\\Delta t}-S_{(i-1)\\Delta t})\n\\] where \\(\\mathrm{N}(d1-)\\) is the delta chosen at time \\((i-1)\\Delta t\\). The question is if the Black Scoles model is correct, how accurate can a discrete rebalancing scheme be? This is simulated in the following code:\n\n\nCode\nimport numpy as np\n# from bsfunctions import *\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\nfrom scipy import stats\n# incs = np.genfromtxt('incs.csv',delimiter=\",\",skip_header=1)\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate.\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return np.exp(-q*T)*S0 * -norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ndef blackscholes_delta(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate.\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if type(call) == bool:\n        if call:\n            return np.exp(-q*T)*norm.cdf(d1,0,1)\n        else:\n            return np.exp(-q*T)*norm.cdf(-d1,0,1)\n    else:\n        print(\"Not a valid value for call\")\n\n# parameters\n# number of paths\n# n = incs.shape[1]\nn = 100000\n# number of divisions\n# m = incs.shape[0]\nm = 100\n# interest rate\nr = .1\n# dividend yield\nq=0.0\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n\n# seed for random generator\nseed= 1234\n# define a random generator\nrg = np.random.RandomState(seed)\n# initialize\n\n\n# generate normal random vairables\ndt= T/m\nvol=sig*np.sqrt(dt)\nincs = rg.normal(0,vol,[m,n])\n\n\ntline = np.linspace(0,T,m+1)\n\n\nSt = np.zeros((m+1,n))\n#St1 = np.zeros((m+1,n))\n\nV_vec = np.zeros((m+1,n))\n\ndelta = np.zeros((m,n))\n\nput= blackscholes(S0,K,r, q, sig,T,call=False)\n\nincs_cumsum =  np.concatenate((np.zeros((1,n)),incs),axis=0).cumsum(axis=0)\nV_vec = np.zeros((m+1,n))\nt_mat =  np.repeat(tline.reshape((m+1,1)), n, axis=1)\ndrift_cumsum = (mu -q -0.5*sig**2) * t_mat\n\nSt = S0 * np.exp(incs_cumsum + drift_cumsum)\n\ndelta = blackscholes_delta(St[:-1,:],K,r, q, sig,T-t_mat[:-1,:])\n\nV_vec[0,:] = S0 + put\n\nfor i in range(1,m+1):\n    V_vec[i,:] = V_vec[i-1,:] + (np.exp(r*dt)-1) * (V_vec[i-1,:] - delta[i-1,:] * St[i-1,:])+ delta[i-1,:] * (St[i,:]-St[i-1,:])\n\n# Uses actual simulated changes in riskfree and stock price not the dt and dB approximations \n# plot ST versus VT\nplt.scatter(St[m,:],V_vec[m,:])\nplt.xlabel('Stock Price at Maturity')\nplt.ylabel('Value of Portfolio Insurance')\nplt.show()\n\n\n\n\n\n\n\n\n\nWith \\(m=100\\) rebalancing dates over \\(T=0.5\\) for the parameters chosen the repliacting strategy does a pretty good job. The hedging errors occur when the stock price is close to the strike price. This is not surprising since the delta changes (measured by the gamma) fastest around this point. A gamma hedge would potentially improve the performance.\nThe portfolio insurance rebalancing scheme involves selling stock and buying bonds when the stock price goes down and buying stocks and selling bonds when the stock price goes up. This can be destabilizing and was identified as a contributor to the 1987 stock market crash.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#sec-s_deltahedging",
    "href": "Chapter_Deltas.html#sec-s_deltahedging",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "7.3 Delta Hedging",
    "text": "7.3 Delta Hedging\nThe ability to create a fully hedged (risk-free) portfolio of the stock and an option is the essence of the arbitrage argument underlying the Black-Scholes formula, as we saw in Chapter 6 for the binomial model. For a call option, such a portfolio consists of \\(\\delta\\) shares of the underlying asset and a short call option, or a short position of \\(\\delta\\) shares of the underlying and a long call option. These portfolios have no instantaneous exposure to the price of the underlying. To create a perfect hedge, the portfolio must be adjusted continuously, because the delta changes when the price of the underlying changes and when time passes. In practice, any hedge will therefore be imperfect, even if the assumptions of the model are satisfied.\nWe first consider the continuous-time hedging argument. Consider a European call option with maturity \\(T\\), and let \\(C(S,t)\\) denote the value of the option at date \\(t&lt;T\\) when the stock price is \\(S\\) at date \\(t\\). Consider a portfolio that is short one call option and long \\(\\delta\\) shares of the underlying asset and that has a (short) cash position equal to \\(C-\\delta S\\). This portfolio has zero value at date \\(t\\).\nThe change in the value of the portfolio in an instant \\(\\mathrm{d} t\\) is \\[\n-\\mathrm{d} C + \\delta \\,\\mathrm{d} S + q \\delta S\\,\\mathrm{d} t+(C-\\delta S)r\\,\\mathrm{d} t\\;.\n\\qquad(7.2)\\]\nThe first term reflects the change in the value of the option, the second term is the capital gain or loss on \\(\\delta\\) shares of stock, the third term is the dividends received on \\(\\delta\\) shares of stock, and the fourth term is the interest expense on the short cash position.\nOn the other hand, we know from Ito’s formula that\n\\[\n\\mathrm{d} C = \\frac{\\partial C}{\\partial S}\\,\\mathrm{d} S + \\frac{\\partial C}{\\partial t}\\,\\mathrm{d} t + \\frac{1}{2}\\frac{\\partial^2C}{\\partial S^2} (\\mathrm{d} S)^2  \n\\] \\[\n= \\delta \\,\\mathrm{d} S + \\Theta \\,\\mathrm{d} t + \\frac{1}{2}\\Gamma \\sigma^2S^2\\,\\mathrm{d} t\\;.\n\\qquad(7.3)\\] where we call \\(\\Theta = \\frac{\\partial C}{\\partial t}\\) the time decay and \\(\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}\\) is the Gamma or convexity.\nSubstituting Equation 7.3 into Equation 7.2 shows that the change in the value of the portfolio is \\[\n-\\Theta \\,\\mathrm{d} t - \\frac{1}{2}\\Gamma \\sigma^2S^2\\,\\mathrm{d} t+ q \\delta S\\,\\mathrm{d} t+(C-\\delta S)r\\,\\mathrm{d} t\\;.\n\\qquad(7.4)\\]\nSeveral aspects of this are noteworthy. First, as noted earlier, the delta hedge (being long \\(\\delta\\) shares of the underlying) eliminates the exposure to changes in the price of the underlying—there is no \\(\\mathrm{d} S\\) term in Equation 9.6. Second, \\(\\Theta\\) will be negative, because it captures the time decay in the option value; being short the option means the portfolio will profit from time decay at rate \\(-\\Theta\\). Third, this portfolio is short gamma. We can also say it is short convexity, the term convexity referring to the convex shape of the option value as a function of the price of the underlying, which translates mathematically to a positive second derivative (gamma). The volatility in the stock makes convexity valuable, and a portfolio that is short convexity will suffer losses. Finally, the portfolio is earning dividends but paying interest.\nIt is straightforward to check, from the definitions of \\(\\Theta\\), \\(\\Gamma\\) and \\(\\delta\\), that the sum of the terms in Equation 9.6 is zero. The time decay in the option value and dividends received on the shares of the underlying exactly offset the losses due to convexity and interest. Therefore, the delta hedge is a perfect hedge. The portfolio, which has a zero cost, neither earns nor loses money. This is true not only on average but for every possible change in the stock price.\nTo see how well this works with only discrete adjustments to the hedge, one can simulate the changes in \\(S\\) over time and sum the gains and losses over discrete rebalancing periods. One should input the actual (not risk-neutral) expected rate of return on the asset to compute the actual distribution of gains and losses.3",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#sec-s_gammahedging",
    "href": "Chapter_Deltas.html#sec-s_gammahedging",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "7.4 Gamma Hedging",
    "text": "7.4 Gamma Hedging\nTo attempt to improve the performance of a discretely rebalanced delta hedge, one can use another option to create a portfolio that is both delta and gamma neutral. Being delta neutral means hedged as in the previous section—the portfolio value has no exposure to changes in the underlying asset price. In other words, it means that the derivative of the portfolio value with respect to the price of the underlying (the portfolio delta) is zero. Being gamma neutral means that the delta of the portfolio has no exposure to changes in the underlying price, which is equivalent to the second derivative of the portfolio value with respect to the price of the underlying (the portfolio gamma) being zero. If the delta truly did not change, then there would be no need to rebalance continuously, and hence no hedging error introduced by only adjusting the portfolio at discrete times rather than continuously. However, there is certainly no guarantee that a discretely-rebalanced delta/gamma hedge will perform better than a discretely rebalanced delta hedge. \nA delta/gamma hedge can be constructed as follows. Suppose we have written (shorted) a call option and we want to hedge both the delta and gamma using the underlying asset and another option, for example, another call option with a different strike. In practice, one would want to use a liquid option for this purpose, which typically means that the strike of the option will be near the current value of the underlying (i.e., the option used to hedge would be approximately at the money).\nLet \\(\\delta\\) and \\(\\Gamma\\) denote the delta and gamma of the written option and let \\(\\delta'\\) and \\(\\Gamma'\\) denote the delta and gamma of the option used to hedge. Consider holding \\(a\\) of shares of the stock and \\(b\\) units of the option used to hedge in conjunction with the short option. The delta of the stock is one (\\(\\mathrm{d} S/\\mathrm{d} S = 1\\)), so to obtain a zero portfolio delta we need\n\\[\n0 = - \\delta + a + b\\delta'.\n\\qquad(7.5)\\]\nThe gamma of the stock is zero (\\(\\mathrm{d}^2 S/\\mathrm{d} S^2 = d\\,1/\\mathrm{d} S = 0\\)), so to obtain a zero portfolio gamma we need\n\\[\n0 = - \\Gamma + b\\Gamma'\\;.\n\\qquad(7.6)\\]\nEquation Equation 7.6 shows that we should hold enough of the second option to neutralize the gamma of the option we have shorted; i.e., \\[\\\nb= \\frac{\\Gamma}{\\Gamma'}\n\\] Equation Equation 7.5 shows that we should use the stock to delta hedge the portfolio of options; i.e., \\[\na=\\delta - \\frac{\\Gamma}{\\Gamma'}\\delta'\\;.\n\\]\n\nDiscretely-Rebalanced Delta Hedges\nIn practice of course, we cannot continuously rebalance to maintain a perfect delta hedge at every instant. There is risk when rebalancing at discrete times. We can model a discretely rebalanced delta hedge as follows. To compute the real-world distribution of gains and losses from a discretely-rebalanced delta hedge, we input the expected rate of return \\(\\mu\\). We consider adjusting the hedge at dates \\(0=t_0&lt;t_1&lt;\\cdots&lt;t_N=T\\), with \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\). The changes in the natural logarithm of the stock price between successive dates \\(t_{i-1}\\) and \\(t_i\\) are simulated as \\[\\Delta \\log S = \\left(\\mu-q-\\frac{1}{2}\\sigma^2\\right)\\,\\Delta t + \\sigma\\,\\Delta B\\; ,\\] where \\(\\Delta B\\) is normally distributed with mean zero and variance \\(\\Delta t\\). The random variables \\(\\Delta B\\) are simulated as standard normals multiplied by \\(\\sqrt{\\Delta t}\\). We begin with the portfolio that is short a call, long \\(\\delta\\) shares of the underlying, and short \\(\\delta S-C\\) in cash. After the stock price changes, say from \\(S\\) to \\(S'\\), we compute the new delta \\(\\delta'\\). The cash flow from adjusting the hedge is \\((\\delta-\\delta')S'\\). Accumulation (or payment) of interest on the cash position is captured by the factor \\(e^{r\\Delta t}\\). Continuous payment of dividends is modelled similarly: the dividends earned during the period \\(\\Delta t\\) is taken to be \\(\\delta S\\left(e^{q\\Delta t}-1\\right)\\). The cash position is adjusted due to interest, dividends, and the cash flow from adjusting the hedge. At date \\(T\\), the value of the portfolio is the cash position less the intrinsic value of the option.\nSuppose we set up a delta hedge at date \\(0\\) for a call option that we have sold. We sell the call at the Black-Scholes price \\(C(0, S_0)\\). We use the proceeds plus borrowed funds to buy \\(\\delta_0 = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)\\) shares, where \\(d_1\\) is the parameter at date 0 for the Black-Scholes call value and delta. We rebalance the hedge at each date \\(t_1, \\ldots, t_n\\), holding the short call position until it matures at date \\(T\\). Rebalancing means that we trade to re-establish the delta hedge based on the Black-Scholes call delta at that date, buying shares when the delta has gone up and selling shares when the delta has fallen. Let \\(\\delta_t\\) denote the Black-Scholes delta at each \\(t\\) and let \\(C_t\\) denote the Black-Scholes call value \\(C(t, S_t)\\).\nOur cash position at date 0 is \\(-(\\delta_0 S_0 - C_0)\\). The cash position changes at each subsequent date due to (i) interest earned/paid on the cash position during the period, (ii) dividends received during the period on the shares owned, and (iii) cash paid or received when buying or selling stock to re-establish the delta hedge. Approximate the interest on cash in each time period as \\(r\\cdot \\Delta t\\) per dollar of cash at the beginning of the period. Approximate the dividends received in each time period as \\(q \\cdot \\Delta t\\) per dollar value of stock at the beginning of the period.\nThe portfolio starts at a zero value at date \\(0\\), because we used none of our own funds to put it on. Let \\(V_t\\) denote the portfolio value at date \\(t\\). The change in the portfolio value from \\(t_i\\) to \\(t_{i+1}\\) for each \\(i\\) is \\[V_{t_{i+1}} - V_{t_i} = - (\\delta_{t_i}S_{t_i} - V_{t_i})r\\Delta t + \\delta_{t_i}S_{t_i}q\\Delta t + \\delta_{t_i}\n(S_{t_{i+1}} - S_{t_i}) - (C_{t_{i+1}} - C_{t_i})\\,.\\] The terms on the right-hand side are (i) interest paid on borrowed funds, (ii) dividends received on shares owned, (iii) gain or loss on the shares owned, (iv) change in the value of the short call position. The following figure simulates stock price paths and computes the portfolio value at date \\(t_{n+1}=T\\). Of course, the call value at date \\(T\\) is its intrinsic value.\nTo describe the distribution of gains and losses, we compute percentiles of the distribution. You should see that the hedge becomes more nearly perfect as the number of periods \\(N\\) is increased. Note that this is true regardless of the \\(\\mu\\) that is input, which reaffirms the point that option values and hedges do not depend on the expected rate of return of the underlying. The percentile is calculated taking into account the dicreteness of the sample.4\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\nimport scipy.optimize as optimize\n\ndef simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, pct):\n    \"\"\"\n    Inputs:\n    S0 = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    mu = expected rate of return\n    N = number of time periods\n    M = number of simulations\n    pct = percentile to be returned\n    \"\"\"\n    dt = T / N\n    SigSqrdt = sigma * np.sqrt(dt)\n    drift = (mu - q - 0.5 * sigma ** 2) * dt\n    Comp = np.exp(r * dt)\n    Div = np.exp(q * dt) - 1\n    LogS0 = np.log(S0)\n   # Call0 = black_scholes_call(S0, K, r, sigma, q, T)\n    Call0 = blackscholes(S0,K,r, q, sigma,T)\n    Delta0 = blackscholes_delta(S0,K,r, q, sigma,T)\n   # Delta0 = black_scholes_call_delta(S0, K, r, sigma, q, T)\n    Cash0 = Call0 - Delta0 * S0\n    Profit = np.zeros(M)\n\n    for i in range(M):\n        LogS = LogS0\n        Cash = Cash0\n        S = S0\n        Delta = Delta0\n\n        for j in range(1, N):\n            LogS += drift + SigSqrdt * np.random.randn()\n            NewS = np.exp(LogS)\n            NewDelta = blackscholes_delta(NewS, K, r, q, sigma, T - j * dt)\n            Cash = Comp * Cash + Delta * S * Div - (NewDelta - Delta) * NewS\n            S = NewS\n            Delta = NewDelta\n\n        LogS += drift + SigSqrdt * np.random.randn()\n        NewS = np.exp(LogS)\n        HedgeValue = Comp * Cash + Delta * S * Div + Delta * NewS\n        Profit[i] = HedgeValue - max(NewS - K, 0)\n\n    return np.percentile(Profit, pct * 100)\n\n# Example usage (you can replace these with input values)\nS = 100  # Initial stock price\nK = 100  # Strike price\nr = 0.05  # Risk-free rate\nsigma = 0.2  # Volatility\nq = 0.02  # Dividend yield\nT = 1  # Time to maturity in years\n# CallPrice = 10  # Call price for implied volatility calculation\n\n# Simulate delta hedging profit\nS0 = 100  # Initial stock price\nmu = 0.1  # Expected rate of return\nM = 1000  # Number of simulations\nN = 252  # Number of time periods\npct = 0.95  # Percentile to be returned\n\ndelta_hedge_profit = simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, pct)\nprint(f\"Delta Hedge Profit (95th percentile): {delta_hedge_profit}\")\n\n\nDelta Hedge Profit (95th percentile): 0.6667961533243001\n\n\n\n\n\n\n\n\n\nFigure 7.1: Simulated Discretely Rebalanced Delta Hedges. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it.\n\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nThe basic premise which underlies our analysis is that we can use traded assets to replicate payoffs in any state time contingency. On the surface this would seem to be a stretch. For example, it seems implausible that we could find the value of a security which pays off in the event Martians land on earth. Fortuneately, we are only concerned with relevant events. For example, suppose we model the stock price using two sources of uncwertainty governed by two independent Brownian motions \\(B_{1,t}\\) and \\(B_{2,t}\\) and write \\[ \\mathrm{d} S(t) = \\mu S(t) \\mathrm{d} t + \\sigma_1 S(t) \\mathrm{d} B_{1,t} + \\sigma_2 S(t) \\mathrm{d} B_{2,t} . \\] Then defining \\(\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2}\\) and \\(B_t = \\frac{\\sigma_1}{\\sigma} B_{1,t} + \\frac{\\sigma_2}{\\sigma} B_{2,t}\\), \\(B_t\\) is a Brownian motion by Levy’s theorem and \\[ \\mathrm{d} S(t) = \\mu S(t) \\mathrm{d} t + \\sigma S(t) \\mathrm{d} B_t .\\] We can value options on the stock. However, we can not find state prices which depend on \\(B_{1,t}\\) and \\(B_{2,t}\\) by themselves; this would require more securities. Later, we will study stochastic volatility models where \\(\\sigma\\) depends on a differnt Brownian motion. In this setting, we need more assets to dynamically replicate pay offs. However, we can overcome this difficulty by either trading another asset or choosing the risk neutral measure to match traded options prices.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#exercises",
    "href": "Chapter_Deltas.html#exercises",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "7.5 Exercises",
    "text": "7.5 Exercises\n\nExercise 7.1 The delta of a call option is \\(e^{-q(T-t)} N(d_1)\\). Create Python code which inputs \\(K\\), \\(r\\), \\(\\sigma\\), \\(q\\) and \\(T\\). Compute the delta of a call option for stock prices \\(S = .01K\\), \\(.02K\\), , \\(1.99K\\), \\(2K\\) (i.e., \\(S = iK/100\\) for \\(i=1, \\ldots 200\\)) and plot the delta against the stock price.\n\n\nExercise 7.2 The delta of a digital option that pays $1 when \\(S(T)&gt;K\\) is \\[\\frac{\\mathrm{e}^{-rT}\\mathrm{n}(d_2)}{\\sigma S\\sqrt{T}}\\; .\\] Repeat the previous problem for the delta of this digital. Given that in reality it is costly to trade (due to commissions, the bid-ask spread and possible adverse price impacts for large trades), do you see any problems with delta hedging a short digital near maturity if it is close to being at the money?\n\n\nExercise 7.3 Modify the Python code for replicating portfolio insurance to simulate a discrete replication of a digital option using the delta in the previous problem. Run the code for \\(10,20,100,1000\\) rebalancing dates. When does the strategy do a good job and when does it fail?\n\n\nExercise 7.4 The gamma of a call option is \\(e^{-q (T-t)} \\mathrm{n}(d_1) \\frac{1}{S(t) \\sigma \\sqrt{T-t}}\\). Repeat Exercise 7.1 for the gamma of a call option.\n\n\nExercise 7.5 Calculate the value (risk neutral expected discounted value of the payoff) of a derivative security which pays \\(S(T)^2\\) at time \\(T\\). What is the delta, number of shares in the replicating portfolio (\\(\\frac{\\partial D}{\\partial S}\\)), and the Gamma, (\\(\\frac{\\partial^2 D}{\\partial S^2}\\) )? Verify the value of the derivative satisfies the funadamental pde with the appropriate boundary condition.\n\n\nExercise 7.6 Calculate the value (risk neutral expected discounted value of the payoff) of a derivative security which pays \\(\\log(S(T))\\) at time \\(T\\). What is the delta, number of shares in the replicating portfolio (\\(\\frac{\\partial D}{\\partial S}\\)), and the Gamma, (\\(\\frac{\\partial^2 D}{\\partial S^2}\\) ).? Verify the value of the derivative satisfies the funadamental pde with the appropriate boundary condition.\n\n\nExercise 7.7 Recall the put-call parity no-arbitrage relationship \\[C(S(t),t) = P(S(t),t) + S(t) - e^{-r(T-t)} K .\\] Use put-call parity to derive the Delta and Gamma of a put option. Is the price convex in \\(S\\) ?\n\n\nExercise 7.8 Consider delta and gamma hedging a short call option, using the underlying and a put with the same strike and maturity as the call. Calculate the position in the underlying and the put that you should take, using the analysis in Section 7.4. Will you ever need to adjust this hedge? Relate your result to put-call parity.\n\n\nExercise 7.9 The delta of a share digital that pays one share when \\(S(T)&gt;K\\) is \\[\\mathrm{e}^{-qT}\\mathrm{N}(d_1) + \\frac{\\mathrm{e}^{-qT}\\mathrm{n}(d_1)}{\\sigma \\sqrt{T}}\\; .\\] Repeat Exercise 7.1 for the delta of this share digital.\n\n\nExercise 7.10  \nModify the function Simulated_Delta_Hedge_Profit to compute percentiles of gains and losses for an investor who writes a call option and constructs a delta and gamma hedge using the underlying asset and another call option. Include the exercise price of the call option used to hedge as an input, and assume it has the same time to maturity as the option that is written. Hint: In each period , the updated cash position can be calculated as\nwhere denotes the number of shares of the stock held, denotes the number of units held of the option that is used for hedging, and denotes the price of the option used for hedging (computed from the Black-Scholes formula each period). This expression embodies the interest earned (paid) on the cash position, the dividends received on the shares of stock and the cash inflows (outflows) from adjusting the hedge. At the final date , the value of the hedge is\nand the value of the overall portfolio is the value of the hedge less\nwhere denotes the strike price of the option used to hedge and denotes the strike of the option that was written.\n\n\nExercise 7.11 Suppose an investor invests in a portfolio with price \\(S\\) and constant dividend yield \\(q\\). Assume the investor is charged a constant expense ratio \\(\\alpha\\) (which acts as a negative dividend) and at date \\(T\\) receives either his portfolio value or his initial investment, whichever is higher. This is similar to a popular type of variable annuity. Letting \\(D\\) denote the number of dollars invested in the contract, the contract pays \\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}\\right)\n\\qquad(7.7)\\] at date \\(T\\).\nWe can rearrange the expression Equation 7.7 as\n\\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}\\right) = D + \\max\\left(0, \\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}-D\\right)\n\\] \\[\n= D + \\mathrm{e}^{-\\alpha T}D\\max\\left(0,\\frac{\\mathrm{e}^{qT}S(T)}{S(0)}-\\mathrm{e}^{\\alpha T}\\right)\\;.\n\\qquad(7.8)\\]\nThus, the contract payoff is equivalent to the amount invested plus a certain number of call options written on the gross holding period return \\(\\mathrm{e}^{qT}S(T)/S(0)\\). Note that \\(Z(t) = \\mathrm{e}^{qt}S(t)/S(0)\\) is the date–\\(t\\) value of the portfolio that starts with \\(1/S(0)\\) units of the asset (i.e., with a $1 investment) and reinvests dividends. Thus, the call options are call options on a non-dividend paying portfolio with the same volatility as \\(S\\) and initial price of $1. This implies that the date–0 value of the contract to the investor is \\(\\mathrm{e}^{-rT}D\\) plus\n\nCreate a Python function to compute the fair expense ratio; i.e., find \\(\\alpha\\) such that the date–0 value of the contract is equal to \\(D\\). Hint: Use scipy minimize or brute force iteration. You can use \\(\\alpha=0\\) as a lower bound. Because the value of the contract is decreasing as \\(\\alpha\\) increases, you can find an upper bound by iterating until the value of the contract is less than \\(D\\).\nHow does the fair expense ratio vary with the maturity \\(T\\)? Why?\n\n\n\n\n\n\nMerton, R. 1973. “Theory of Rational Option Pricing.” Bell Journal of Economics and Management Science 4: 141–83.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#footnotes",
    "href": "Chapter_Deltas.html#footnotes",
    "title": "7  Delta Hedges, Replication, and PDEs",
    "section": "",
    "text": "Essentially, this can be called the Feynman Kac solution to the PDE.↩︎\nAs a good exercise, the reader should work out how the analysis would change if \\(q &gt; 0\\).↩︎\nIt is useful to recall risk neutral probabilities really represent prices, not actual probability of events.↩︎\nIf numsims = 11 and pct =0.1, the percentile function returns the second lowest element in the series. The logic is that 10% of the numbers, excluding the number returned, are below the number returned—i.e., 1 out of the other 10 are below—and 90% of the others are above. In particular, if pct = 0.5, the percentile function returns the median. When necessary, the function interpolates; for example, if numsims = 10 and pct=0.1, then the number returned is an interpolation between the lowest and second lowest numbers.↩︎",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html",
    "href": "Chapter_Girsanov.html",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "",
    "text": "8.1 Digital Options\nOur no-arbitrage conditions work in the continuous time setting. We remind the reader that no-arbitrage (in simple strategies) means the existence of a risk neutral measure under which all discounted dividend reinvested trading strategies follow martingales. In the risk neutral measure (denoted by \\(R\\)) are for \\(t \\le \\tau\\) \\[ \\frac{R(t)}{R(t)} = \\mathrm{E}_t^R\\left[\\frac{R(\\tau)}{R(\\tau)}\\right] =1\\] in other words the discounted investment in the risk free asset is trivially a martingale while \\[ \\frac{S(t)}{R(t)} = \\mathrm{E}_t^R\\left[\\frac{S(\\tau)}{R(\\tau)}\\right], \\] in other words, the discounted value of an non dividend paying investment or any dividend reinvested strategy is a martingale.\nHowever, we also saw we do not need to use the risk free investment as a numeraire. Using any strictly positive dividend reinvested trading strategy, \\(V(t)\\), we have in the \\(V\\) as numeraire measure (denoted by \\(V\\)), for \\(t \\le \\tau\\) \\[\\frac{R(t)}{V(t)} = \\mathrm{E}_t^V\\left[\\frac{R(\\tau)}{V(\\tau)}\\right].\\] the number of shares of \\(V\\) an investment in the risk free asset is worth follows a martingale, while\n\\[ \\frac{S(t)}{V(t)} = \\mathrm{E}_t^V\\left[\\frac{S(\\tau)}{V(\\tau)}\\right] \\] for any dividend reinvested strategy the number of shares of \\(V\\) it is worth follows a martingale while \\[ \\frac{V(t)}{V(t)} = E_t^V\\left[\\frac{V(\\tau)}{V(\\tau)}\\right] =1,\\] in other words, the number of shares of an investment in \\(V\\) is always \\(1\\), a trivial martingale.\nIt is important to realize that when we change numeraire, we also change the probabilities used for pricing. We first describe some elementary payoffs, called digital options, which are similar to Arrrow securities. The payoffs to digital options describe these probabilities.\nIn a continuous time environment with a continuum of possible states, for technical reasons we can not use Arrow securities. For example, if \\(x\\) is lognormally distributed, the probability of \\(x=5\\) is zero. However, the probability \\(x \\in (5-\\epsilon, \\epsilon)\\) is greater than zero for all \\(\\epsilon &gt;0\\). Therefore, the primitive securities are essentially intervals in time and state with given payoffs. For European style payoffs, we can focus on digital option payoffs with a fixed expiration \\(T\\). Digital options specify a payoff if a certain event occurs and nothing otherwise. For example, an option which pays \\(1\\) at expiration \\(T\\) on the event \\(S(T)&gt;K\\). Using mathematical notation, we use indicator functions \\({\\bf{1}}_{\\{A\\}}\\) which is a random variable equal to \\(1\\) if the event \\(A\\) occurs and \\(0\\) if \\(A\\) does not occur (i.e. the complement of \\(A\\) occurs). Using this notation, the payoff for this example is \\({\\bf{1}}_{\\{S(T)&gt;K\\}}\\). Given the prices of these primitive securities, combined with the risk free asset can give us the prices of all European derivatives. For example, buying the risk free asset with payoff \\(1\\) and selling the example produces a payoff of 1 dollar on the complement. The payoff to this strategy if \\(1 -{\\bf{1}}_{\\{S(T)&gt;K\\}} = {\\bf{1}}_{\\{S(T)&lt;K\\}}\\). By combining digital options with different strikes we can approximate any payoff at time \\(T\\). It is useful to note that \\(\\mathrm{E}[{\\bf{1}}_{|[A]}]= \\text{prob}(A)\\). Therefore the prices of digital options give the risk neutral probabilities of various events.\nWe can use our no arbitrage results to price these digital options: the time \\(t\\) price of the payoff \\({\\bf{1}}_{\\{S(T)&gt;K\\}}\\) at time \\(T\\) is given by \\[ R(t) \\mathrm{E}_t^R \\left[\\frac{1}{R(T)} {\\bf{1}}_{\\{S(T)&gt;K\\}}\\right]  = e^{-r(T-t)} \\text{prob}^R(S(T)&gt;K)\\], assuming the risk free rate is constant.\nHowever, we can also consider payoffs in different numeraires. For example, an option which pays one share of \\(S\\) when \\(S(T) &gt;K\\). The time \\(t\\) price of such an option can be written as \\[ R(t) \\mathrm{E}_t^R \\left[\\frac{S(T)}{R(T)}  {\\bf{1}}_{\\{S(T) &gt;K\\}}\\right].\\] However, we can use the share as numeraire (assuming the share does not pay dividends) is the same as \\[S(t) \\mathrm{E}_t^S \\left[ {\\bf{1}}_{\\{S(T) &gt;K\\}}\\right] = S(t) \\text{prob}^S(S(T)&gt;K)\\]\nIn the next section, we show how a mathematical result called Girsanov’s Theorem lets us construct the different probability measures.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#sec-c:girsanov",
    "href": "Chapter_Girsanov.html#sec-c:girsanov",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.2 Changes of Probability Measure and Girsanov’s Theorem",
    "text": "8.2 Changes of Probability Measure and Girsanov’s Theorem\nWhen we change probability measures, we cannot expect a process \\(B\\) that was a Brownian motion to remain a Brownian motion. The expected change in a Brownian motion must always be zero, but when we change probabilities, the expected change of \\(B\\) is likely to become nonzero. However, the Brownian motion \\(B\\) will still be an Ito process under the new probability measure. In fact, every Ito process under one probability measure will still be an Ito process under the new probability measure, and the diffusion coefficient of the Ito process will be unaffected by the change in probabilities.1 Changing probabilities only changes the drift of an Ito process.\nThis should not be surprising. Section 3.3 explains that a Brownian motion \\(B\\) can be defined as a continuous martingale with paths that jiggle in such a way that the quadratic variation over any interval \\([0,T]\\) is equal to \\(T\\). Changing the probabilities will change the probabilities of the various paths (so it may affect the expected change in \\(B\\)) but it will not affect how each path jiggles. So, under the new probability measure, \\(B\\) should still be like a Brownian motion but it may have a nonzero drift. If we consider a general Ito process, the reasoning is the same. The diffusion coefficient \\(\\sigma\\) determines how much each path jiggles, and this is unaffected by changing the probability measure. Furthermore, instantaneous covariances—the \\((\\mathrm{d}  X)(\\mathrm{d}  Y)\\) terms—between Ito processes are unaffected by changing the probability measure. Only the drifts are affected.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#example-risk-neutral-probability",
    "href": "Chapter_Girsanov.html#example-risk-neutral-probability",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.3 Example: Risk-Neutral Probability",
    "text": "8.3 Example: Risk-Neutral Probability\nDenote the price of a dividend-reinvested asset by \\(S\\). Assume there is a constant continuously-compounded risk-free rate \\(r\\), and set \\(R_t = \\mathrm{e}^{rt}\\), which is a dividend-reinvested asset price. The principle elucidated in Section 6.4 tells us that, in the absence of arbitrage opportunities, there is a probability measure (called the risk-neutral probability) with respect to which \\(S/R\\) is a martingale.\nSetting \\(Y=S/R\\), Equation 4.31 implies that \\[\\frac{\\mathrm{d} Y}{Y} = \\frac{\\mathrm{d} S}{S} - r\\mathrm{d} t\\,.\\] Because \\(Y\\) is a martingale under the risk-neutral probability, it cannot have a drift under that probability measure, so the drift of \\(S\\) must be the risk-free rate under that probability measure. So, we have shown the following.\n\n\n\n\n\n\nImportant Principle\n\n\n\nThe expected rate of return of any asset under the risk-neutral probability must be the risk-free rate.\n\n\nSuppose \\[\\frac{\\mathrm{d} S}{S} = \\mu\\mathrm{d} t + \\sigma \\mathrm{d} B\\] for a constant \\(\\sigma\\), where \\(B\\) is a Brownian motion.\nBecause only the drift of \\(S\\) changes when we change probability measures, and because the drift under the risk-neutral probability is the risk-free rate, we have \\[\\frac{\\mathrm{d} S}{S} = r\\mathrm{d} t + \\sigma \\mathrm{d} B^*\\] where \\(B^*\\) is a Brownian motion under the risk-neutral probability.\nWe could follow similar reasoning to calculate the drift of \\(S\\) under other probability measures, but instead we will apply a general result called Girsanov’s Theorem.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#girsanovs-theorem-in-the-black-scholes-model",
    "href": "Chapter_Girsanov.html#girsanovs-theorem-in-the-black-scholes-model",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.4 Girsanov’s Theorem in the Black Scholes Model",
    "text": "8.4 Girsanov’s Theorem in the Black Scholes Model\nIn the Black Scholes model, denote the dividend reinvested value by \\[ dS_t = \\mu S_t \\mathrm{d} t + \\sigma S_t \\mathrm{d} B_t \\] where \\(B\\) is a Brownian motion. However, when we say \\(B_t\\) is a Brownian motion this involves a probability measure since \\(B_t\\) is assumed to be normally distributed with zero mean and standard deviation \\(\\sqrt{t}\\). We can rewrite the process \\[ dS_t = r S_t \\mathrm{d} t + \\sigma S_t \\mathrm{d} \\left(B_t + \\frac{\\mu - r}{\\sigma}t\\right) \\] and the risk neutral measure is one which makes \\(B_t + \\frac{\\mu - r}{\\sigma}t\\) a Brwonian Motion. Girsanov’s Theorem tells us how to change the probability measure so that \\(B_t + \\frac{\\mu - r}{\\sigma}t\\) is a Brownian motion. Define \\(\\kappa = \\frac{\\mu - r}{\\sigma}\\). The term \\(\\kappa\\) is called the price of risk, or Sharpe ratio.\n\n\n\n\n\n\nImportant Principle\n\n\n\nDefine \\[Z_t = \\exp\\left(-\\frac{1}{2}\\kappa^2 t - \\kappa B_t \\right).\\] Because \\(Z_T\\) is lognormal, \\(\\mathrm{E}[Z_T]=1\\). Then the under the probability measure defined for any \\(Y\\) which is a function of \\(B_t;~0\\le t \\le T\\) by \\[ \\mathrm{E}^\\kappa[Y] = \\mathrm{E}[Z_T Y] \\] \\(B_t^\\kappa= B_t + \\kappa t\\) is a Brownian motion with \\(\\mathrm{E}^\\kappa[B_t^\\kappa]= 0\\) and standard deviation \\(\\sqrt{t}\\). Moreover, if \\(M_t\\) is a martingale under \\(P^\\kappa\\), then \\(Z_t M_t\\) is a martingale under the original probability measure.\n\n\nThis is a simple version of Girsanov’s Theorem. Given the original measure under which \\(B_t\\) is a brownian motion, Girsanov’s Theorem tells us how to construct the risk-neutral measure. In our leading case, we use Ito’s Lemma to show that \\(Z_t \\frac{S(t)}{R(t)}\\) is a martingale. Alternatively, using our the expectations of lognormal random variables we can see, recalling \\(\\kappa = \\frac{\\mu-r}{\\sigma}\\), \\[Z_t \\frac{S_(t)}{R(t)}= S(0) \\exp\\left(\\left(\\mu -r -\\frac{1}{2}\\kappa^2 \\right)t +(\\sigma - \\kappa)B_t \\right) = S(0) \\exp\\left(-\\frac{1}{2}(\\sigma - \\kappa)^2 t + (\\sigma - \\kappa)B_t \\right) \\] so \\[\\mathrm{E}\\left[Z_t \\frac{S(t)}{R(t)}\\right]= S(0) .\\] Finally, we can use the last statement in the Key Principle to find \\(\\kappa\\). Since we know \\(\\frac{S(t)}{R(t)}\\) is a martingale in the risk neutral measure, then in the original measure \\(Z_t \\frac{S(t)}{R(t)}\\) is a martingale. Using the product rule form of Ito’s Lemma, \\[\\mathrm{d} Z_t \\frac{S(t)}{R(t)} = (\\mu - r) Z_t \\frac{S(t)}{R(t)} \\mathrm{d} t + (\\sigma - \\kappa) Z_t \\frac{S(t)}{R(t)} \\mathrm{d} B_t + \\mathrm{d} &lt;Z,\\frac{S}{R}&gt;_t. \\] For this to be a martingale, we must have \\[ (\\mu - r) Z_t \\frac{S(t)}{R(t)} \\mathrm{d} t= -\\mathrm{d} &lt;Z,\\frac{S}{R}&gt;_t= \\kappa \\sigma Z_t \\frac{S(t)}{R(t)} \\mathrm{d} t,\\] which immediately yields \\(\\kappa= \\frac{\\mu-r}{\\sigma}\\).\nSome further justification for this form of Girsanov’s Theorem is in the box below which may be skipped.\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nTo illustrate why this form of the Theorem holds, condsider the special case where we compute \\(\\mathrm{E}[Z_T f(B_T)]\\). The distribution of a Brownian motion at time \\(T\\) has mean zero and standard deviation \\(\\sqrt{T}\\). The density is \\[\\frac{1}{\\sqrt{2 \\pi T}} \\exp\\left(-\\frac{1}{2} \\frac{x^2}{T} \\right)\\] and the expected value of any function of the Brownian motion is \\[ \\mathrm{E}[f(B_T)] = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2 \\pi T}} \\exp\\left(-\\frac{1}{2} \\frac{x^2}{T} \\right) f(x) dx \\] Let us compute \\[ \\mathrm{E}\\left[\\exp\\left(-\\frac{1}{2} \\kappa^2 T + \\kappa B_T\\right)f(B_T)\\right]= \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2 \\pi T}} \\exp\\left(-\\frac{1}{2} \\frac{x^2}{T} \\right) \\exp\\left(-\\frac{1}{2} \\kappa^2 T + \\kappa x\\right) f(x) dx \\] Now observe that \\[\\exp\\left(-\\frac{1}{2} \\frac{x^2}{T} \\right) \\exp\\left(-\\frac{1}{2} \\kappa^2 T + \\kappa x\\right) = \\exp\\left(-\\frac{1}{2} \\frac{x^2 + \\kappa^2 T^2 - 2 \\kappa x T}{T}\\right)\\] \\[= \\exp\\left(-\\frac{1}{2} \\frac{(x-\\kappa T)^2}{T} \\right) \\] so this is the density of a Brownian motion with drift \\(\\kappa\\); the mean is \\(\\kappa T\\) and the standard deviation is \\(\\sqrt{T}\\). Therefore \\[ \\mathrm{E}\\left[\\exp\\left(-\\frac{1}{2} \\kappa^2 t + \\kappa B_t\\right)f(B_t)\\right]= \\mathrm{E}^\\kappa\\left[f(B_t)\\right] \\] but under the probabilty \\(P^{\\kappa}\\) defined by the density \\[\\frac{1}{\\sqrt{2 \\pi T}}\\exp\\left(-\\frac{1}{2} \\frac{(x-\\kappa T)^2}{T} \\right),\\] \\(B_T\\) has mean \\(\\kappa T\\). Demeaning this expression gives \\(B_T-\\kappa T\\) has zero mean and standard deviation \\(\\sqrt{T}\\) and we conclude \\(B_t + \\kappa t\\) is a Brownian motion.\n\n\n\nWe now explain various changes of numeraire.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#stochastic-discount-factor",
    "href": "Chapter_Girsanov.html#stochastic-discount-factor",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.5 Stochastic Discount Factor",
    "text": "8.5 Stochastic Discount Factor\nGiven the change of measure, the stochastic discount factor is given by \\[m_t=e^{-r t} Z_t \\]. In differential form, \\[ dm_t = -r m_t \\mathrm{d} t -\\kappa m_t \\mathrm{d} B_t \\] We then have \\[\\mathrm{E}[m_T Y]= \\mathrm{E}^R[e^{-rT}Y].\\] We can also use Ito’s Lemma to show \\(m_t S(t)\\) is an Itoo process without drift in our original probability measure: \\[  \\mathrm{d} m_t S(t) = m_t \\mathrm{d} S_t + S_t \\mathrm{d} m_t + \\mathrm{d} &lt;m,S&gt;_t\\] \\[= \\left(m_t S_t \\sigma -\\kappa m_t S_t \\right) \\mathrm{d} B_t\\] is an Ito process without drift under the original probability measure, while \\(e^{-rt} S(t)\\) is an Ito process without drift in the risk neutral probability measure: \\[ \\mathrm{d} e^{-rt} S(t) = e^{-rt} \\mathrm{d} S(t) - S(t) r e^{-rt}  \\mathrm{d} t = e^{-rt} S(t) \\sigma \\mathrm{d} B^R_t\\], since the cross variation term \\(&lt;\\frac{1}{R},S&gt;_t=0\\). Recall an Ito process without drift is not necessarily a martingale but if the diffusion coefficient is well behaved it is a martingale; in fact Equation 4.9 holds for this case. Alternatively, the martingale property in this simple example with constant coefficients \\(\\mu\\), \\(r\\), and \\(\\sigma\\) follows from direct calculation using the formula for the expected value of a lognormal random variable.\nWe have two equivalent expressions for the value, \\(X(t)\\), at time \\(t \\le T\\), for time \\(T\\) payoffs, \\(X\\), \\[ X(t) = \\frac{1}{m_t} \\mathrm{E}_t\\left[ m_T X \\right] \\] and \\[ X(t) = \\frac{1}{R(t)} \\mathrm{E}^R_t\\left[\\frac{X}{R(T)}\\right]\\] In fact, while it is beyond the scope of this book, the stochatic discount factor is the reciprical of the portfolio strategy which maximizes the expected continuously compounded portfolio grwoth rate and therefore corresponds to another change of numeraire (see ??? Long, Heath Platen, etc). In other words, the pricing formulae above correspond to a change of numeraire where \\(V(t)= \\frac{1}{m_t}\\) and the probabilities are the original probabilities.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#underlying-as-numeraire",
    "href": "Chapter_Girsanov.html#underlying-as-numeraire",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.6 Underlying as Numeraire",
    "text": "8.6 Underlying as Numeraire\nAnother important numeraire in the Black Scholes model is the underlying asset. For now, assume the underlying asset pays no dividends before time \\(T\\). Then our pricing relationships become \\[ \\frac{R(t)}{S(t)} = \\mathrm{E}^S_t\\left[\\frac{R(T)}{S(T)} \\right] \\] \\[ \\frac{S(t)}{S(t)} = \\mathrm{E}^S_t\\left[\\frac{S(T)}{S(T)}\\right] =1\\]\nIn other words, using the \\(S\\) probability measure, \\(\\frac{R(t)}{S(t)}\\) is a martingale for \\(0 \\le t \\le T\\). We have \\[ \\frac{R(t)}{S(t)} = \\frac{1}{S(0)} \\exp\\left(\\frac{1}{2} \\sigma^2 t- \\sigma B_t^R \\right) \\] where \\(B_t^R = B_t + \\frac{\\mu-r}{\\sigma} t\\) is a Brownian motion in the risk neutral measure. This is obviously not a martingale in the risk neutral measure, but \\[ \\frac{R(t)}{S(t)} = \\frac{1}{S(0)} \\exp\\left(-\\frac{1}{2} \\sigma^2 t  - \\sigma B_t^S \\right) \\] is a martingale if \\(B_t^S = B_t^R + \\sigma t\\) is a martingale for some probability measure \\(\\text{prob}^S\\). Girsanov’s theorem then tells us the probability measure \\[ \\text{prob}^S(A)= \\mathrm{E}^R\\left[Z_T {\\bf{1}}_{\\{A\\}} \\right] \\] where \\[ Z_t = \\exp\\left(-\\frac{1}{2} \\sigma^2 t - \\sigma B_t^R \\right)  \\] is a lognormally distributed exponential martingale. Under this change of measure, \\[ dS(t) = \\left(r + \\sigma^2 \\right) \\mathrm{d} t + \\sigma B_t^S. \\]\nAlternatively, we can use Girsanov’s Theorem. In this case, we solve for \\(\\kappa\\) which makes \\(Z_t \\frac{R(t)}{S(t)}\\) into a martingale in te original measure. Using the product rule from Ito’s Lemma, \\[ \\mathrm{d} \\frac{R(t)}{S(t)} = \\left(r-\\mu - \\sigma^2 \\right) \\frac{R(t)}{S(t)} \\mathrm{d} t - \\sigma \\frac{R(t)}{S(t)} \\mathrm{d} B_t \\] \\[ \\mathrm{d} Z_t \\frac{R(t)}{S(t)} = \\left(r-\\mu + \\sigma^2\\right) Z_t \\frac{R(t)}{S(t)} \\mathrm{d} t -(\\sigma + \\kappa) Z_t \\frac{R(t)}{S(t)} \\mathrm{d} B_t + \\mathrm{d} &lt;Z,\\frac{R}{S} &gt;_t \\] In order for this to be a martingale, we must have \\[ \\left(r-\\mu - \\sigma^2 \\right) Z_t \\frac{R(t)}{S(t)} \\mathrm{d} t = -\\mathrm{d} &lt;Z,\\frac{R}{S} &gt;_t = \\kappa \\sigma Z_t \\frac{R(t)}{S(t)} \\mathrm{d} t, \\] which gives \\(\\kappa = \\frac{\\mu-r}{\\sigma} - \\sigma\\). Notice that if \\(B_t^S = B_t + \\kappa t\\) then \\[ \\mathrm{d} S(t) = \\left(r + \\sigma^2 \\right) S(t) \\mathrm{d} t + \\sigma S(t) \\mathrm{d} B_t^S .\\]\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(S\\) is the price of the price of an non-dividend paying asset, then \\[\n\\frac{\\mathrm{d}  S}{S} = (r+ \\sigma^2)\\mathrm{d}   t+\\sigma\\mathrm{d}   B^S\\;,\n\\qquad(8.1)\\] where now \\(B^S\\) is a Brownian motion when \\(S_t\\) is the numeraire.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#digital-options-in-the-black-scholes-model",
    "href": "Chapter_Girsanov.html#digital-options-in-the-black-scholes-model",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.7 Digital Options in the Black Scholes Model",
    "text": "8.7 Digital Options in the Black Scholes Model\nGiven our results above, we can now value digital options in the Black Scholes model.\nThe digital option which pays \\({\\bf{1}}_{\\{S(T) \\ge K\\}}\\) is fairly easy to value by taking the risk neutral expectation \\(\\mathrm{E}^R\\left[e^{-rT} {\\bf{1}}_{\\{S(T) \\ge K}\\right]\\). Notice that using \\[S(T)= S(0) \\exp\\left( \\left(r-\\frac{\\sigma^2}{2}\\right) t + \\sigma B_t^R \\right)\\] Then the tail probabilities are calculated as in Chapter 5 : \\[\\{ S(T) \\ge K\\} = \\{\\log(S(T)) \\ge \\log(K)\\} = \\{\\frac{\\log\\left(S(0){K}\\right) + \\left(r - \\frac{\\sigma^2}{2} \\right) T}{\\sigma \\sqrt{T}} \\ge - \\frac{B_T}{\\sqrt{T}} \\} ,\\] and \\(-\\frac{B_T}{\\sqrt{T}}\\) is distributed according to a standard noraml random variable (mean 0 and standard deviation 1). Therefore, the value of this digital option is \\[ e^{- r t} N(d_2)\\] where \\(d_2= \\frac{\\log\\left(S(0){K}\\right) + \\left(r - \\frac{\\sigma^2}{2} \\right) T}{\\sigma \\sqrt{T}}\\) and \\(N(d)\\) is the probability that a standard normal random variable is less than or equal to \\(d\\); that is \\[N(d)= \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^d e^{-\\frac{x^2}{2}} dx. \\]\nThe payoff \\(S(T) {\\bf{1}}_{\\{S(T) \\ge K\\}}\\) can, in principle, be found by taking the risk neutral expectations of the discounted payoff: \\[\\mathrm{E}^R\\left[S(T) {\\bf{1}}_{\\{S(T) \\ge K\\}}\\right].\\] However, it is easier to use the stock as numeriare: \\[S(0) \\mathrm{E}^S\\left[ {\\bf{1}}_{\\{S(T) \\ge K\\}}\\right]\\] Then since \\[ \\mathrm{d} S(t) = (r+ \\sigma^2) S(t) \\mathrm{d} t + \\sigma S(t) \\mathrm{d} B_t^S \\] where \\(B_t^S\\) is a Brownian motion in the measure \\(P^S\\). But finding the expectaion of the indicator is now the same exercise as before. By writing the explicit solution for \\(S(T)\\), the price of the payoff is found to be \\[S(0) N(d_1)\\] where \\(d_1= \\frac{\\log\\left(S(0){K}\\right) + \\left(r + \\frac{\\sigma^2}{2} \\right) T}{\\sigma \\sqrt{T}}\\).",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#sec-s:girsanov",
    "href": "Chapter_Girsanov.html#sec-s:girsanov",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.8 General Probability Measures and Drifts",
    "text": "8.8 General Probability Measures and Drifts\nWe now expand our discussion to include correlated Brownian motions as discussed in Section 3.6. Our main analysis will focus on the case with two correlated Brownian motions and we state results for an arbitrary number of Brownian motions.\nWe begin with a \\(d\\) dimensional Brownian motion, \\[{\\bf{B}}_t = \\left(\\begin{array}[pos]{spalten}\nB_{1,t} \\\\ B_{2,t} \\\\ \\vdots \\\\ B_{d,t}\n  \\end{array} \\right) \\]. where the \\(B_{i,t}\\) are uncorrelated, and a vector \\[{\\bf{\\kappa}}_t = \\left(\\begin{array}[pos]{spalten}\n\\kappa_{1,t} \\\\ \\kappa_{2,t} \\\\ \\vdots \\\\ \\kappa_{d,t}\n  \\end{array} \\right) \\]. and remind the reader \\(||{\\bf{\\kappa}}_t||^2 = \\sum_{i=1}^d \\kappa_{i,t}^2\\). The stochastic integral \\[\\int_0^t {\\bf{\\kappa}}_t^{\\prime} \\mathrm{d} {\\bf{B}}_s = \\sum_{i=1}^d \\int_0^t \\kappa_{i,s} \\mathrm{d} B_{i,s} \\] is defined in the natural way. The following is a more general statement of Girsanov’s Theorem.\n\n\n\n\n\n\nImportant Principle\n\n\n\nLet \\[Z_t = \\exp\\left(-\\frac{1}{2}\\int_0^t ||{\\bf{\\kappa}}_s||^2 \\mathrm{d} s - \\int_0^t {\\bf{\\kappa}}_s^{\\prime} \\mathrm{d} {\\bf{B}}_s \\right)\\] and assume \\(\\mathrm{E}[Z_T]=1\\). Then under the probability measure \\[\\text{prob}^{\\kappa}(A) = \\mathrm{E}\\left[Z_T {\\bf{1}}_{\\{A\\}}\\right],\\] \\(B_{i,t}^\\kappa = B_{i,t} + \\int_0^t \\kappa_{i,s} \\mathrm{d} t\\) is a Brownian motion for \\(0 \\le t \\le T\\). Moreover, if \\(M_t\\) is a martingale under \\(P^\\kappa\\) then \\(Z_t M_t\\) is a martingale under the original probability measure.\n\n\nAs explained in Chapter 6, we need to know the distribution of the underlying under probability measures corresponding to different numeraires. Let \\(S\\) be the price of an asset which does not pay dividends. Let \\(V\\) be the price of another another asset that does not pay dividends. Let \\(r_t\\) denote the instantaneous risk-free rate at date \\(t\\) and let \\(R_t = \\exp\\left(\\int_0^t r_s\\mathrm{d}   s\\right)\\). Assume \\[\\begin{align*}\n\\mathrm{d}  S(t) &= \\mu_t S(t) \\mathrm{d}   t+\\sigma_t S(t) \\mathrm{d}   B_t\\; ,\\\\\n\\mathrm{d}  V(t) &= \\theta_t V(t) \\mathrm{d}   t+\\phi_t V(t) \\mathrm{d}   W_t\\;,\n\\end{align*}\\] where \\(B_t=B_{1,t}\\) and \\(W_t=\\rho_t B_{1,t} + \\sqrt{1-\\rho_t^2} B_{2,t}\\) are Brownian motions under the actual probability measure with correlation \\(\\rho\\), and where \\(\\mu, \\theta, \\sigma, \\phi\\) and \\(\\rho\\) can be quite general random processes, although they must satisfy some restrictions below.\nWe consider the dynamics of the asset prices \\(S\\) and \\(V\\) under three different probability measures. In each case, we follow the same steps: (i) we note that the ratio of an asset price to the numeraire asset price must be a martingale, (ii) we use Ito’s formula to calculate the drift of this ratio, and (iii) we use the fact that the drift of a martingale must be zero to compute the drift of \\(\\mathrm{d}  S/S\\).\n\nRisk-Neutral Probability\nUnder the risk-neutral probability,\n\\[\\frac{S(t)}{R(t)} = \\exp\\left(-\\int_0^t r_s\\mathrm{d}   s\\right) S(t)\\] is a martingale and \\[\\frac{V(t)}{R(t)} = \\exp\\left(-\\int_0^t r_s \\right) V(t) \\] is a martingale.\n\n\n\n\n\n\nKey Result\n\n\n\nIn the risk neutral measure, \\(B_{1,t}^R = B_{1,t} + \\int_0^t \\kappa_{1,s} \\mathrm{d} s\\) and \\(B_{2,t}^R = B_{2,t} + \\int_0^t \\kappa_{2,s} \\mathrm{d} s\\) \\[\n\\frac{\\mathrm{d}  S(t)}{S(t)} = r_t \\mathrm{d}   t+\\sigma_t\\mathrm{d}   B_{1,t}^R\\;,\n\\qquad(8.2)\\] \\[\n\\frac{\\mathrm{d}  V(t)}{V(t)} = r_t \\mathrm{d}   t+ \\phi_t \\mathrm{d}  W_t^R\\;,\n\\qquad(8.3)\\] where \\(B_{1,t}^R\\), \\(B_{2,t}^R\\), and \\(W_t^R = \\rho_t B_{1,t}^R + \\sqrt{1-\\rho_t^2} B_{2,t}\\) are Brownian motions under the risk-neutral probability.\n\n\nWe can use Girsanov’s Theorem to solve for \\(\\kappa\\). We should have \\(Z_t S(t)\\) is a martingale and \\(Z_t V(t)\\) is a martingale. Therefore, using the product rule from Ito’s Lemma \\[ \\mathrm{d} Z_t \\frac{S(t)}{R(t)} = (\\mu_t-r_t ) Z_t \\frac{S(t)}{R(t)} \\mathrm{d} t + (\\sigma_t - \\kappa_{1,t} ) Z_t \\frac{S(t)}{R(t)} \\mathrm{d} B_{1,t} + \\mathrm{d} &lt;Z,\\frac{S}{R}&gt;_t \\]\n\\[\\mathrm{d} Z_t \\frac{V(t)}{R(t)} = (\\theta_t-r_t ) Z_t \\frac{V(t)}{R(t)} \\mathrm{d} t + (\\rho_t \\phi_t - \\kappa_{1,t} ) Z_t \\frac{V(t)}{R(t)} \\mathrm{d} B_{1,t} + (\\sqrt{1-\\rho_t^2} \\phi_t Z_t \\frac{V(t)}{R(t)} \\mathrm{d} B_{2,t}+ \\mathrm{d} &lt;Z,\\frac{V}{R}&gt;_t \\] Therefore, we must have \\[(\\mu_t - r_t) Z_t \\frac{S(t)}{R(T)} \\mathrm{d} t = - \\mathrm{d} &lt;Z,\\frac{S}{R}&gt;_t = \\kappa_{1,t} \\sigma_t Z_t \\frac{S(t)}{R(t)} \\mathrm{d} t \\] and \\[(\\theta_t - r_t) Z_t \\frac{V(t)}{R(T)} \\mathrm{d} t = - \\mathrm{d} &lt;Z,\\frac{V}{R}&gt;_t = \\left(\\kappa_{1,t} \\rho_t \\phi_t  + \\kappa_{2,t} \\sqrt{1-\\rho_t^2} \\phi_t \\right) Z_t \\frac{V(t)}{R(t)} \\mathrm{d} t \\] where the cross variation is computed using Equation 4.16. Solving we obtain \\[ \\kappa_{1,t} = \\frac{\\mu_t-r_t}{\\sigma_t} \\] \\[ \\kappa_{2,t} = \\frac{\\theta_t - r_t}{\\sqrt{1-\\rho_t^2} \\phi_t} -\\frac{\\mu_t -r_t}{\\sigma_t} \\frac{\\rho_t}{\\sqrt{1-\\rho_t^2}}\\] if \\(\\rho_t \\neq \\pm 1\\). These equations do not make sense if \\(\\sigma_t=0\\) and \\(\\mu_t - r_t \\neq 0\\) or \\(\\phi_t=0\\) and \\(\\theta_t -r_t \\neq )\\). This is perfectly natural; if either condition is violated, loosely speaking, an asset with no instantaneous risk offers a different return from the risk free asset which is an arbitrage. The case where \\(\\rho_t = \\pm 1\\) is where the Brownian motions are perfectly correlated or negatively correlated is important and must be solved differently. In this case, the equations become \\[\\kappa_{1,t}= \\frac{\\mu_t-r_t}{\\sigma_t}\\] \\[\\kappa_{1,t} = \\pm \\frac{\\theta_t -r_t}{\\phi_t}\\] These equations say when the assets are pefectly positively or negatively correlated, the compensation for risk is the same. This is a no-arbitrage condition; otherwise, there is an arbitrage.2\n\n\nAnother Asset as the Numeraire\nWhen \\(S\\) is the numeraire, the process \\(Y_t\\) defined as \\[Y_t = \\frac{R(t)}{S(t)} = \\frac{\\exp\\left(\\int_0^t r_s\\mathrm{d}   s\\right)}{S(t)}\\] is a martingale. Using the rule for ratios from Ito’s Lemma, we have \\[\\frac{\\mathrm{d}  Y}{Y} =r\\mathrm{d}   t - \\frac{\\mathrm{d}  S}{S} + \\left(\\frac{\\mathrm{d}  S}{S}\\right)^2 = (r + \\sigma^2)\\mathrm{d}   t - \\frac{\\mathrm{d}  S}{S}\\; .\\] Because the drift of \\(\\mathrm{d}  Y/Y\\) must be zero, this implies that the drift of \\(\\mathrm{d}  S/\nS\\) is \\((r + \\sigma^2)\\mathrm{d}   t\\).\nOn the other hand, \\(X_t\\) defined as \\[X_t = \\frac{V(t)}{S(t)}\\] is also a martingale. Again, using the product rule from Ito’s Lemma, \\[\\frac{\\mathrm{d} X}{X}= \\frac{\\mathrm{d} V}{V} - \\frac{\\mathrm{d} S}{S} -\\left(\\frac{\\mathrm{d} V}{V}\\right)\\left(\\frac{\\mathrm{d} S}{S}\\right) + \\left(\\frac{\\mathrm{d} S}{S}\\right)^2 .\\] Since the drift must be zero, we conclude \\[ \\frac{\\mathrm{d} V}{V} = \\left(r + \\rho \\phi \\sigma \\right) \\mathrm{d} t + \\phi \\mathrm{d} W^S \\] We conclude that:\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(S\\) is the numeraire, then \\[\n\\frac{\\mathrm{d}  S}{S} = (r + \\sigma^2)\\mathrm{d}   t+\\sigma\\mathrm{d}   B^S\\;,\n\\qquad(8.4)\\] \\[ \\frac{\\mathrm{d} V}{V} = \\left(r + \\rho \\phi \\sigma \\right) \\mathrm{d} t + \\phi \\mathrm{d} W^S \\] where now \\(B^S\\) is a Brownian motion when \\(S(t)\\) is the numeraire.\n\n\n\n\nAnother Risky Asset as the Numeraire\nWhen the other asset with price \\(V\\) is the numeraire, \\(X_t\\) defined as \\[X_t = \\frac{S(t)}{V(t)}\\] must be a martingale.\nWe can have use our previous example to compute the dynamics of \\(S\\) and \\(V\\) when \\(V\\) is the numeraire. We conclude that:\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(V\\) is the numeraire, then \\[\n\\frac{\\mathrm{d}  S}{S} = (r +  \\rho\\sigma\\phi)\\mathrm{d}   t+\\sigma\\mathrm{d}   B_{1,}^V\\;,\n\\qquad(8.5)\\] \\[ \\frac{\\mathrm{d} V}{V} = \\left(r + \\phi^2 \\right) \\mathrm{d} t + \\phi \\mathrm{d} W^V \\]\nwhere \\(B^V\\) and \\(W^V\\) denote a Brownian motions under the probability measure corresponding to the dividend-reinvested risky asset \\(V\\) being the numeraire, and where \\(\\rho\\) is the correlation of \\(S\\) and \\(V\\).\n\n\nNotice that Equation 8.5, while more complicated, is also more general than the others. In fact, it includes Equation 8.2 and Equation 8.4 as special cases: (i) if \\(Y\\) is the price of the instantaneously risk-free asset, then \\(\\phi=0\\) and Equation 8.5 simplifies to Equation 8.2, and (ii) if \\(Y=\nV\\), then \\(\\phi=\\sigma\\) and \\(\\rho=1\\), so Equation 8.5 simplifies to Equation 8.4.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#exercises",
    "href": "Chapter_Girsanov.html#exercises",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "8.9 Exercises",
    "text": "8.9 Exercises\n\nExercise 8.1 Use simulation to find \\(\\mathrm{E}^R[e^{-r T}{\\mathbf{1}}_{\\{S(T) \\ge K\\}}]\\) in the risk-neutral probability where \\[\\begin{equation*}\n\\mathrm{d}   S(t)= r S(t) \\mathrm{d}   t + \\sigma S(t) \\mathrm{d}   B_t^R\n\\end{equation*}\\] Verify that \\(S(t)/e^{r t}\\) is a martingale in the \\(R\\) measure where \\(B^R\\) is a Brownian motion. Then use simulation to find \\(S_0\\mathrm{E}^S[\\frac{1}{S(T)} {\\mathbf{1}}_{\\{S(T) \\ge K\\}}]\\) in the pricing measure which uses the share as numeraire where \\[\\begin{equation*}\n\\mathrm{d}   S(t) = (r + \\sigma^2) S(t) \\mathrm{d}   t + \\sigma S(t) \\mathrm{d}   B_t^S\n\\end{equation*}\\] so the log satisfies \\[\\begin{equation*}\n\\log(S(t)) = \\log(S(0)) + (r + \\frac{\\sigma^2}{2})t + \\sigma B_t^S\n\\end{equation*}\\] You should verify \\(e^{rt}/S(t)\\) is a martingale in the \\(S\\) measure where \\(B^S\\) is a Brownian motion. Both estimates should be the same up to simulation error and give the time zero value of the random payoff \\({\\mathbf{1}}_{\\{S(T) \\ge K\\}}\\) which is a random variable equal to \\(1\\) if \\(S(T)\\ge K\\) and \\(0\\) otherwise. You should choose the values for \\(r\\), \\(\\sigma\\), \\(T\\), and \\(K\\).\n\n\nExercise 8.2 Calculate the price of the digital option that pays \\({\\bf{1}}_{\\{S(T) \\le K\\}}\\) using the assupmtions of the Black Scholes model.\n\n\nExercise 8.3 Calculate the price of the digital option that pays \\(S(T) {\\bf{1}}_{\\{S(T) \\le K\\}}\\) using the assumptions of the Black Scholes model.\n\n\nExercise 8.4 Supppose \\(S\\) and \\(V\\) are as in Section 8.8 with constant coefficients. Find the value of an option which pays \\(V(T) {\\bf{1}}_{\\{V(T) \\ge S(T)\\}}\\). Hint: use \\(V\\) as a numeraire.",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_Girsanov.html#footnotes",
    "href": "Chapter_Girsanov.html#footnotes",
    "title": "8  “No Arbitrage” in Continuous Time",
    "section": "",
    "text": "To be a little more precise, this is true provided sets of states of the world having zero probability continue to have zero probability when the probabilities are changed. Because of the way we change probability measures when we change numeraires (cf. Equation 6.23) this will always be true for us.↩︎\nThere are other restrictions which are buried in the statement ``Assume \\(\\mathrm{E}[Z_T]=1\\).’’ A sufficient condition is \\(||\\kappa||\\) is uniformly bounded but it is not necessary.↩︎",
    "crumbs": [
      "Part 3: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>\"No Arbitrage\" in Continuous Time</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html",
    "href": "Chapter_BlackScholes.html",
    "title": "9  Black-Scholes",
    "section": "",
    "text": "9.1 European Call and Put Values\nThis chapter expands the discussion of the very important Black-Scholes formulas for the values of European calls and puts. Options are written on asset prices, not dividend-reinvested asset prices, with which we have been primarily dealing to this point. U.S. companies pay dividends quarterly (if they pay dividends). If the option will mature before the next dividend is paid (to be more precise, if it matures before the next ex-dividend date, which is when the stock begins trading without right to the subsequent dividend) then dividends are not an issue. We discuss a model suitable for valuing options that mature after one or more upcoming dividend payments in ?sec-c:americans. In this chapter, we make a simplifying assumption. We assume that dividends are paid continuously at a rate proportional to the underlying asset price. The Black-Scholes assumptions are that the underlying asset pays a constant dividend yield \\(q\\) and has price \\(S\\) satisfying \\[\n\\frac{\\mathrm{d}  S}{S} = (\\mu - q) \\,\\mathrm{d}   t + \\sigma\\,\\mathrm{d}   B\n\\qquad(9.1)\\]\nfor a Brownian motion B. Here \\(\\sigma\\) is assumed to be constant (though we will allow it to vary in a non-random way at the end of the chapter) and \\(\\mu\\) can be a quite general random process. It is also assumed that there is a constant continuously-compounded risk-free rate \\(r\\).\nUnder these assumptions, we complete the discussion of Chapter 7 and Section 8.2 to derive option pricing formulas. Recall that, to price a European call option, all that remains to be done is to calculate the probabilities of the option finishing in the money when we use the risk-free asset and the underlying asset as numeraires. We do this using the results of Section 8.8.\nIn Section 8.8—see Equation 8.2—we learned that under the Black-Scholes assumption Equation 9.1 we have \\[\\frac{\\mathrm{d}  S}{S} =( r-q)\\,\\mathrm{d}   t+\\sigma\\,\\mathrm{d}   B^*\\; ,\\] where \\(B^*\\) is a Brownian motion under the risk-neutral probability.1 on the volatility coefficients and on \\(B\\) and \\(B^*\\) to distinguish the Brownian motion driving \\(S\\) from the Brownian motion driving \\(Y\\) and to distinguish their volatilities are not needed here. In ?sec-s:geometricbrownianmotion, we observed that this is equivalent to \\[\\mathrm{d}  \\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}   t + \\sigma\\,\\mathrm{d}   B^*\\; .\\]\nA European call option pays \\(S_T-K\\) at date \\(T\\) if \\(S_T&gt;K\\) and 0 otherwise. Again letting \\[\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;,\n\\end{cases}\n\\end{equation*}\\] the payoff of the call can be written as \\(xS_T-xK\\). This is equivalent to one share digital minus \\(K\\) digitals, with the digitals paying in the event that \\(S_T&gt;K\\). The share digital is worth \\(\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)\\) at date \\(0\\) and each digital is worth \\(\\mathrm{e}^{-rT}\\mathrm{N}(d_2)\\). Note that ?eq-digital_d2 and Equation 7.1 for \\(d_1\\) and \\(d_2\\) imply \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\). Therefore, combining the results of the previous two sections yields the Black-Scholes formula:\nA European put option pays \\(K-S_T\\) at date \\(T\\) if \\(S_T&lt;K\\) and 0 otherwise. As before, let \\[\\begin{equation*}\ny =  \\begin{cases} 1 & \\text{if $S_T&lt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] The payoff of the put option is \\(yK-yS_T\\). This is equivalent to \\(K\\) digitals minus one share digital, all of the digitals paying when \\(S_T&lt;K\\). Thus, we have:\nThe values of the European put and call satisfy put-call parity, and we can also find one from the other by2 \\[\n\\mathrm{e}^{-rT}K + \\text{Call Price} = \\mathrm{e}^{-q T}S_0+ \\text{Put Price}\\;.\n\\qquad(9.4)\\]\nThe following figure shows how the Black-Scholes call and put values depend on the underlying asset price and other model parameters. The call and put values are computed with the following code.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    \n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef black_scholes_put(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-r * T) * K - np.exp(-q * T) * S)\n\n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(-d1)\n    N2 = norm.cdf(-d2)\n    return np.exp(-r * T) * K * N2 - np.exp(-q * T) * S * N1",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#european-call-and-put-values",
    "href": "Chapter_BlackScholes.html#european-call-and-put-values",
    "title": "9  Black-Scholes",
    "section": "",
    "text": "9.2\n\n\n\nThe value of a European call option at date \\(0\\) is \\[\n\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\qquad(9.2)\\]\nwhere \\(d_1\\) is defined in Equation 7.1 and \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\).\n\n\n\n\n\n\n\n\n\n9.3\n\n\n\nThe value of a European put option at date \\(0\\) is \\[\n\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2)-\\mathrm{e}^{-q T}S_0\\mathrm{N}(-d_1)\\;,\n\\qquad(9.3)\\]\nwhere \\(d_1\\) is defined in Equation 7.1 and \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\).\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9.1: Black-Scholes Explorer. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#greeks",
    "href": "Chapter_BlackScholes.html#greeks",
    "title": "9  Black-Scholes",
    "section": "9.4 Greeks",
    "text": "9.4 Greeks\nThe derivatives (calculus derivatives, not financial derivatives!) of an option pricing formula with respect to the inputs are commonly called Greeks. The most important Greek is the option delta. This measures the sensitivity of the option value to changes in the value of the underlying asset. The following table shows the standard Greeks, with reference to the Black-Scholes pricing formula.\n\n\n\n\n\n\n\n\n\n\n\nInput\nInput Symbol\n\nGreek\n\nGreek Symbol\n\n\n\n\nStock price\n\\(S\\)\n\ndelta\n\n\\(\\delta\\)\n\n\ndelta\n\\(\\delta\\)\n\ngamma\n\n\\(\\Gamma\\)\n\n\n- Time to maturity\n\\(-T\\)\n\ntheta\n\n\\(\\Theta\\)\n\n\nVolatility\n\\(\\sigma\\)\n\nvega\n\n\\(\\cal{V}\\)\n\n\nInterest rate\n\\(r\\)\n\nrho\n\n\\(\\rho\\)\n\n\n\nThe second line of the above shows \\(\\delta\\) as an input.3 Of course, it is not an input but instead is calculated. Gamma, the derivative of \\(\\delta\\), is the second derivative of the option price with respect to the underlying asset price. The reason for calculating \\(\\Theta\\) as the derivative with respect to \\(-T\\) instead of \\(T\\) is that the time-to-maturity \\(T\\) decreasing (\\(-T\\) increasing) is equivalent to time passing, so \\(\\Theta\\) measures the change in the option value when time passes.\nWe can calculate these from the Black-Scholes formula using the chain rule from differential calculus. The derivative of the normal distribution function \\(\\mathrm{N}\\) is the normal density function \\(\\mathrm{n}\\) defined as \\[\\mathrm{n}(d) = \\frac{1}{\\sqrt{2\\pi}}\\mathrm{e}^{-d^2/2}\\; .\\] One can easily verify directly that \\[\n\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)=\\mathrm{e}^{-rT}K\\mathrm{n}(d_2)\\;,\n\\qquad(9.5)\\]\nwhich simplifies the calculations for the Black-Scholes call option pricing formula. For this formula, the Greeks are as follows: \\[\\begin{align*}\n\\delta &= \\mathrm{e}^{-q T}\\mathrm{N}(d_1) + \\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\frac{\\partial d_1}{\\partial S} -\\mathrm{e}^{-rT}K\\mathrm{n}(d_2)\\frac{\\partial d_2}{\\partial S}\\\\\n&= \\mathrm{e}^{-q T}\\mathrm{N}(d_1) + \\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\left(\\frac{\\partial d_1}{\\partial S}-\\frac{\\partial d_2}{\\partial S}\\right)\\\\\n&=\\mathrm{e}^{-q T}\\mathrm{N}(d_1)\\;,\\\\\n\\Gamma &=\\mathrm{e}^{-q T}\\mathrm{n}(d_1)\\frac{\\partial d_1}{\\partial S}= \\mathrm{e}^{-q T}\\mathrm{n}(d_1)\\frac{1}{S\\sigma\\sqrt{T}}\\;,\n\\end{align*}\\] \\[\\begin{align*}\n\\Theta &=-\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\frac{\\partial d_1}{\\partial T} +q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1) \\\\\n&\\quad + \\mathrm{e}^{-rT}K\\mathrm{n}(d_2)\\frac{\\partial d_2}{\\partial T} -r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\left(\\frac{\\partial d_2}{\\partial T}-\\frac{\\partial d_1}{\\partial T}\\right)\\\\\n&\\quad + q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1)-r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=-\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\frac{\\sigma}{2\\sqrt{T}}+ q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1)-r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\\\\\n\\cal{V}&=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\frac{\\partial d_1}{\\partial \\sigma} - \\mathrm{e}^{-rT}K\\mathrm{n}(d_2)\\frac{\\partial d_2}{\\partial \\sigma}\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\left(\\frac{\\partial d_1}{\\partial \\sigma}-\\frac{\\partial d_2}{\\partial \\sigma}\\right)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\sqrt{T}\\;,\\\\\n\\rho &=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\frac{\\partial d_1}{\\partial r} - \\mathrm{e}^{-rT}K\\mathrm{n}(d_2)\\frac{\\partial d_2}{\\partial r} +T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}(d_1)\\left(\\frac{\\partial d_1}{\\partial r}-\\frac{\\partial d_2}{\\partial r}\\right)+T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;.\n\\end{align*}\\]\nWe can calculate the Greeks of a European put option from the call option Greeks and put-call parity (assuming \\(q=0\\)): \\[\\text{Put Price} = \\text{Call Price} +\\mathrm{e}^{-rT}K- \\mathrm{e}^{-q T}S_0\\; .\\] For example, the delta of a put is the delta of a call (with the same strike and maturity) minus \\(\\mathrm{e}^{-q T}\\), and the gamma of a put is the same as the gamma of the corresponding call.\nTo see how the Greeks respond to changes in the various inputs to the Black-Scholes formula (e.g., interest rate (\\(r\\)), time to maturity (\\(T\\)) and volatility (\\(\\sigma\\))), we encourage readers to interact with the plot below. The code used for the calculations is here:\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef d1(S, K, r, sigma, T):\n    \"\"\"\n    Computes d1 used in Black-Scholes.\n    \"\"\"\n    return (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n\ndef d2(S, K, r, sigma, T):\n    \"\"\"\n    Computes d2 used in Black-Scholes.\n    \"\"\"\n    return d1(S, K, r, sigma, T) - sigma * np.sqrt(T)\n\ndef call_price(S, K, r, sigma, T):\n    \"\"\"\n    Black-Scholes price for a call option.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    return S * norm.cdf(d_1) - K * np.exp(-r * T) * norm.cdf(d_2)\n\ndef put_price(S, K, r, sigma, T):\n    \"\"\"\n    Black-Scholes price for a put option.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    return K * np.exp(-r * T) * norm.cdf(-d_2) - S * norm.cdf(-d_1)\n\ndef greeks(S, K, r, sigma, T, option_type=\"call\"):\n    \"\"\"\n    Return the main Greeks for Black-Scholes.\n\n    Parameters\n    ----------\n    S : float or numpy array\n        Underlying price.\n    K : float\n        Strike price.\n    r : float\n        Risk-free interest rate.\n    sigma : float\n        Volatility.\n    T : float\n        Time to maturity (in years).\n    option_type : str\n        'call' or 'put'.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    pdf_d1 = norm.pdf(d_1)\n    cdf_d1 = norm.cdf(d_1)\n    cdf_d2 = norm.cdf(d_2)\n    \n    if option_type == \"call\":\n        # Delta\n        delta = cdf_d1\n        # Gamma (same for call & put)\n        gamma = pdf_d1 / (S * sigma * np.sqrt(T))\n        # Vega (same for call & put, but typically scaled by 0.01 if desired in %)\n        vega = S * pdf_d1 * np.sqrt(T)\n        # Theta\n        theta = - (S * pdf_d1 * sigma) / (2 * np.sqrt(T)) \\\n                - r * K * np.exp(-r * T) * cdf_d2\n        # Rho\n        rho = K * T * np.exp(-r * T) * cdf_d2\n    else:  # put\n        # Delta\n        delta = cdf_d1 - 1\n        # Gamma (same for call & put)\n        gamma = pdf_d1 / (S * sigma * np.sqrt(T))\n        # Vega (same for call & put)\n        vega = S * pdf_d1 * np.sqrt(T)\n        # Theta\n        theta = - (S * pdf_d1 * sigma) / (2 * np.sqrt(T)) \\\n                + r * K * np.exp(-r * T) * norm.cdf(-d_2)\n        # Rho\n        rho = - K * T * np.exp(-r * T) * norm.cdf(-d_2)\n\n    return delta, gamma, vega, theta, rho\n\n\n\n\n\n\n\n\n\nFigure 9.2: Black-Scholes Greeks Explorer. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#sec-s:deltahedging",
    "href": "Chapter_BlackScholes.html#sec-s:deltahedging",
    "title": "9  Black-Scholes",
    "section": "9.5 Theta and Gamma in Delta Hedges",
    "text": "9.5 Theta and Gamma in Delta Hedges\nLet \\(C(t, S_t)\\) denote the value at date \\(t\\) of a European call option that matures at \\(T&gt;t\\) under the Black-Scholes assumption. This value is given by the Black-Scholes call formula, taking the initial underlying asset price to be \\(S_t\\) and the time to maturity to be \\(T-t\\). Ito’s formula tells us that\n\\[\n\\mathrm{d}  C = \\frac{\\partial C}{\\partial S}\\,\\mathrm{d}   S + \\frac{\\partial C}{\\partial t}\\mathrm{d}   t + \\frac{1}{2}\\frac{\\partial^2C}{\\partial S^2} (\\mathrm{d}  S)^2  \n\\]\nUsing our notation for Greeks, this is \\[\n\\mathrm{d}  C = \\delta \\,\\mathrm{d}   S + \\Theta \\,\\mathrm{d}   t + \\frac{1}{2}\\Gamma (\\mathrm{d}  S)^2  = \\delta \\,\\mathrm{d} S - \\Theta \\,\\mathrm{d} t + \\frac{1}{2}\\Gamma \\sigma^2 S^2 \\,\\mathrm{d} t\\,.\n\\]\nIf we sell a call option and combine the proceeds with borrowed funds to buy \\(\\delta\\) shares of the underlying asset, as discussed in ?sec-c:deltas, then the change in the portfolio value is \\[\\delta (\\mathrm{d} S + q S \\,\\mathrm{d} t) - (\\delta S - C)r\\mathrm{d} t - \\mathrm{d} C\\] which simplifies to \\[\\delta q S \\,\\mathrm{d} t - (\\delta S - C)r\\,\\mathrm{d} t - \\Theta \\,\\mathrm{d} t - \\frac{1}{2}\\Gamma \\sigma^2 S^2 \\,\\mathrm{d} t\\,.\n\\qquad(9.6)\\]\nSeveral aspects of this are noteworthy. First, as noted earlier, the delta hedge eliminates the exposure to changes in the price of the underlying—there is no \\(\\mathrm{d}  S\\) term in Equation 9.6. Second, \\(\\Theta\\) is negative, because it captures the time decay in the option value; being short the option means the portfolio will profit from time decay at rate \\(-\\Theta\\). Third, this portfolio is short gamma. We can also say it is short convexity, the term convexity referring to the convex shape of the option value as a function of the price of the underlying, which translates mathematically to a positive second derivative (gamma).4 The volatility in the stock makes convexity valuable, and a portfolio that is short convexity will suffer losses. Finally, the portfolio is earning dividends but paying interest.\nIt is straightforward to check, from the definitions of \\(\\Theta\\), \\(\\Gamma\\) and \\(\\delta\\) in the preceding section, that the sum of the terms in Equation 9.6 is zero. The time decay in the option value and dividends received on the shares of the underlying exactly offset the losses due to convexity and interest. Therefore, the delta hedge is a perfect hedge. The portfolio, which has a zero cost, neither earns nor loses money. This is true not only on average but for every possible change in the stock price.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#sec-s:impliedvolatility",
    "href": "Chapter_BlackScholes.html#sec-s:impliedvolatility",
    "title": "9  Black-Scholes",
    "section": "9.6 Implied Volatilities",
    "text": "9.6 Implied Volatilities\nAll of the inputs into the option pricing formulas are in theory observable, except for the volatility coefficient \\(\\sigma\\). We can estimate \\(\\sigma\\) from historical data (see ?sec-c:stochasticvolatility), or estimate it from the prices of other options. The latter method exploits the fact that there is a one-to-one relationship between the price given by the Black-Scholes formula and the \\(\\sigma\\) that is input, so one can take the price as given and infer \\(\\sigma\\) from the formula. The \\(\\sigma\\) computed in this way is called the implied volatility. The implied volatility from one option can be used to price another (perhaps non-traded or less actively traded) option.\nEven if we acknowledge that the model is not correct, the computation of implied volatilities is still useful for characterizing market prices, because we can quickly describe an option as expensive or cheap depending on whether its implied volatility is large or small. Somewhat paradoxically, it is less easy to see if an option is expensive or cheap by looking at its price, because one must consider the price in the context of the exercise price and maturity. To some extent, the implied volatility normalizes the price relative to the exercise price and maturity. Of course, it does not always pay to sell expensive options or buy cheap options, unless they are expensive or cheap relative to an accurate model!\nIf we compute implied volatilities for options with the same maturity but different strikes, we will typically obtain different implied volatilities for different options. If we plot implied volatility against the strike, the pattern one normally sees for equities and equity indices is the implied volatility declining as the strike increases until the strike is somewhere near the current value of the underlying (so the option is at the money). The implied volatility then generally flattens out or increases slightly at higher strikes. The graph looks like a twisted smile (smirk). This pattern has been very pronounced in equity index option prices since the crash of 1987. This moneyness structure of implied volatilities is inconsistent with the Black-Scholes model. It suggests that the risk-neutral return distribution is not lognormal but instead exhibits a higher likelihood of extreme returns than the lognormal distribution (i.e., it has fat tails) with the likelihood of extreme negative returns being higher than the likelihood of extreme positive returns (i.e., it is skewed).",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#exercises",
    "href": "Chapter_BlackScholes.html#exercises",
    "title": "9  Black-Scholes",
    "section": "9.7 Exercises",
    "text": "9.7 Exercises\n\nExercise 9.1 Use put-call parity to derive the Greeks of a put option, and write a Python function that computes the value and Greeks.\n\n\nExercise 9.2 Consider delta and gamma hedging a short call option, using the underlying and a put with the same strike and maturity as the call. Calculate the position in the underlying and the put that you should take, using the analysis in ?sec-s:gammahedging. Will you ever need to adjust this hedge? Relate your result to put-call parity.\n\n\nExercise 9.3 Compute the value of an at-the-money call option (\\(S=K\\)) using the Python code for volatilities \\(\\sigma = .01, .02, \\ldots, 1.0\\). Plot the call value against the volatility.\n\n\nExercise 9.4 Repeat the previous problem for \\(S=1.2K\\) (an example of an in-the-money call option).\n\n:::",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#footnotes",
    "href": "Chapter_BlackScholes.html#footnotes",
    "title": "9  Black-Scholes",
    "section": "",
    "text": "There is no other risky asset price \\(Y\\) in this model, so the subscripts we used in Section 8.8↩︎\nThe put-call parity relation follows from the fact that both the left and the right-hand sides are the prices of portfolios that have value \\(\\max(S_T,K)\\) at the maturity of the option. To see this for the left-hand side, note that \\(\\mathrm{e}^{-rT}K\\) is sufficient cash to accumulate to \\(K\\) at date \\(T\\), allowing exercise of the call when it is in the money and retention of the cash \\(K\\) otherwise. For the right-hand side, note that \\(\\mathrm{e}^{-q T}S_0\\) is enough cash to buy \\(\\mathrm{e}^{-q T}\\) shares of the stock at date \\(0\\) which, with reinvestment of dividends, will accumulate to one share at date \\(T\\), enabling exercise of the put if it is in the money or retention of the share otherwise.↩︎\nThe delta is frequently denoted by the upper case \\(\\Delta\\), but we will use the lower case, reserving the upper case for discrete changes, e.g., \\(\\Delta t\\). One may have noticed also that the symbol for vega is a little different from the others; this reflects the fact that vega is not actually a Greek letter.↩︎\nA curious reader may ask why we don’t say that the portfolio is long concavity instead of saying that it is short convexity. This is a mystery to your authors also.↩︎",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html",
    "href": "Chapter_Merton.html",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "10.1 Margrabe’s Formula\nIn this chapter, we will derive three important generalizations of the Black-Scholes formula. We will derive them from the Black-Scholes formula, which shows that all of the formulas are equivalent. We will start with Margrabe’s (Margrabe 1978) formula for an option to exchange one asset for another. Standard calls and puts are special cases, involving the exchange of cash for an asset or an asset for cash. From Margrabe’s formula, we will derive Black’s (Black 1976) formulas for options on forward and futures contracts. Then, from Black’s formulas, we will derive Merton’s (Merton 1973) formulas for calls and puts in the absence of a constant risk-free rate.\nUnless explicitly stated otherwise, we will not assume in this chapter the existence of a risk-free asset (or even an instantaneously risk-free asset as described in Chapter 6). This implies that the market is incomplete and there are many risk-neutral probabilitys. Nevertheless, we can price exchange options, forward and futures options, and stock options by arbitrage. Understanding this issue is not essential for deriving the formulas in this chapter—as mentioned, they will all be derived from the Black-Scholes formula—but the issue is nonetheless important. It is discussed in the final section of the chapter.\nNaturally, all of the option-pricing formulas discussed in this chapter are quite similar. The similarity can be seen from the Black-Scholes formula for a call option, which we can write as follows (replacing \\(d_1\\) by \\(x\\) and \\(d_2\\) by \\(y\\)): \\[\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(x) - \\mathrm{e}^{-rT}K\\mathrm{N}(y)\\;,\n\\qquad(10.1)\\]\nwhere\n\\[\nx=\\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\qquad(10.2)\\]\n\\[\ny = x -\\sigma\\sqrt{T}\\;.\n\\qquad(10.3)\\]\nNote that \\(\\mathrm{e}^{-qT}S_0\\) is the present value at date \\(0\\) of the stock that would be acquired if the option is exercised, because it is the cost that one must pay at date \\(0\\) to have one share of the stock at date \\(T\\) with no withdrawal of dividends in the interim. Obviously, \\(\\mathrm{e}^{-rT}K\\) is the present value of the cash that is paid if the option is exercised. Moreover, \\(x\\) is equal to \\[\\frac{\\log \\left(\\frac{\\mathrm{e}^{-qT}S_0}{\\mathrm{e}^{-rT}K} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\] and the logarithm in the numerator is of the ratio of present values. All of the option pricing formulas in this chapter have the same form: the present value of the asset to be acquired multiplied by \\(\\mathrm{N}(x)\\) minus the present value of the asset to be delivered multiplied by \\(\\mathrm{N}(y)\\). Moreover in each case \\(x\\) is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\) all divided by \\(\\sigma\\sqrt{T}\\), and in each case \\(y\\) is defined by Equation 10.3. Notice that the Black-Scholes put option formula has this structure also. The Black-Scholes put option formula is \\[\n\\mathrm{e}^{-rT}K\\mathrm{N}(x) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(y)\\;,\n\\qquad(10.4)\\]\nwhere\n\\[\nx =-d_2\n=  - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q-\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\] \\[\n=\\frac{\\log \\left(\\frac{\\mathrm{e}^{-rT}K}{\\mathrm{e}^{-qT}S_0} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.5)\\]\n\\[\ny=-d_1\n= - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n=x - \\sigma\\sqrt{T}\\;.\n\\] This similarity is discussed further in later, where the pricing formulas are implemented in Python.\nConsider two assets with prices \\(S_1\\) and \\(S_2\\) and a European option to exchange asset 2 for asset 1 at date \\(T\\). The value of the option at maturity is \\[\\max(0,S_1(T)-S_2(T))\\; .\\] Note that there is no real difference between a put and a call: the exchange option can be viewed as a call on the first asset with random strike \\(S_2(T)\\) or as a put on the second asset with random strike \\(S_1(T)\\).\nAssume the assets pay constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\mathrm{d}  S_i}{S_i} = \\mu_i\\mathrm{d}   t+\\sigma_i\\mathrm{d}   B_i\\] where each \\(B_i\\) is a Brownian motion under the actual probability measure. As before, the drifts \\(\\mu_i\\) can be quite general random processes. We also allow the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the Brownian motions to be random processes; however, we make the assumption that \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\n\\qquad(10.6)\\]\nis a constant. As shown in ?eq-volatilityratio, \\(\\sigma\\) is the volatility of \\(S_1/S_2\\) (and also \\(S_2/S_1\\)). So, the assumption we are making is that the volatility of the ratio of the asset prices is constant. In Section 10.15, we will relax this assumption to allow \\(\\sigma\\) to be time-varying (though still non-random).\nThe following is the formula of Margrabe (Margrabe 1978):\nMargrabe’s derivation is a very simple argument based on the Black-Scholes formula. We noted in ?sec-c:foreignexchange that the Black-Scholes formula does not depend on the currency—if the underlying asset and risk-free asset are dollar denominated, the formula gives the dollar value of an option; if they are yen denominated, the formula gives the yen value of an option, etc. So we can take the currency to be units of the second asset; i.e., we will use the second asset as numeraire. With this numeraire, the value of the first asset is \\(S_1/S_2\\). The value of the exchange option at maturity is \\[\\max(0,S_1(T)-S_2(T)) = S_2(T)\\max\\left(0,\\frac{S_1(T)}{S_2(T)}-1\\right)\\; .\\] This is the value in the natural currency (e.g., dollars). The value using the second asset as numeraire is obtained by dividing by \\(S_2(T)\\), so it is \\[\\max\\left(0,\\frac{S_1(T)}{S_2(T)}-1\\right)\\; .\\] This is the value of a standard call option, the underlying being the first asset measured in units of the second. We can apply the Black-Scholes formula to obtain the value of the option (in units of the second asset) at date \\(0\\). Multiplying this value by \\(S_2(0)\\) will give the option value in the natural currency.\nThe risk-free rate when the second asset is the numeraire is the dividend yield on the second asset \\(q_2\\). To see this, note that the price of the second asset is always equal to one; moreover, an investment in the second asset will accumulate at the rate \\(q_2\\) via reinvestment of dividends. Therefore, \\(q_2\\) is a risk-free rate of return.\nThe dividend yield on the first asset remains \\(q_1\\). To see this, note that the dividend paid in the natural currency is \\(q_1S_1(t)\\mathrm{d}   t\\) in an instant \\(\\mathrm{d}  t\\) and the value of this dividend using the second asset as numeraire is \\([q_1S_1(T)/S_2(T)]\\mathrm{d}   t\\), which is the fraction \\(q_1\\mathrm{d}   t\\) of the value \\(S_1(T)/S_2(T)\\) of the first asset using the second asset as numeraire.\nThe volatility of the first asset using the second as numeraire is the volatility of the ratio \\(S_1(T)/S_2(T)\\), which is \\(\\sigma\\) defined in Equation 10.6. Applying the Black-Scholes formula with these inputs yields Margrabe’s formula directly.1.\nIn terms of programming, we could of course write entirely separate programs for the options discussed so far and those to be discussed in this chapter but it will become clear that they have common structure. As discussed in the introduction to this chapter, each is the present value of what is received upon exercise multiplied by \\(\\mathrm{N}(x)\\) minus the present value of what is delivered upon exercise multiplied by \\(\\mathrm{N}(y)\\) and \\(x\\) in each case is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\), all divided by \\(\\sigma\\sqrt{T}\\). Thus, we first write a code for a generic option price. Later we use this generic option price function to price other options.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\n\n\n\n# Example usage\nP1 = 100\nP2 = 90\nsigma = 0.2\nT = 1\n\nprint(\"Generic Option:\", generic_option(P1, P2, sigma, T))\n\n\nGeneric Option: 13.589108116054796\nNow we can use the following one-line programs to value exchange options.\nCode\ndef margrabe(S1, S2, sigma, q1, q2, T):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    T = time to maturity\n    \"\"\"\n    P1 = np.exp(-q1 * T) * S1\n    P2 = np.exp(-q2 * T) * S2\n    return generic_option(P1, P2, sigma, T)\n\n# Example usage\nS1 = 100\nS2 = 90\nsigma = 0.2\nq1 = 0.01\nq2 = 0.02\n\nprint(\"Margrabe Option:\", margrabe(S1, S2, sigma, q1, q2, T))\n\n\nMargrabe Option: 14.05169829758782\nWe could also have calculated the Black-Scholes call formula as \\[\n\\text{Generic\\_Option}(Exp(-q*T)*S, Exp(-r*T)*K, sigma, T)\n\\]\nand the Black-Scholes put formula as\n\\[\n\\text{Generic\\_Option}(Exp(-r*T)*K, Exp(-q*T)*S, sigma, T).\n\\]",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:margrabe",
    "href": "Chapter_Merton.html#sec-s:margrabe",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "10.2\n\n\n\nThe value of a European option to exchange two assets at date \\(T\\) is \\[\n\\mathrm{e}^{-q_1 T}S_1(0)\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T}S_2(0)\\mathrm{N}(d_2)\\;,\n\\qquad(10.7)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+\\left(q_2-q_1+\n\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.8)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(10.9)\\]",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:black",
    "href": "Chapter_Merton.html#sec-s:black",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.3 Black’s Formula",
    "text": "10.3 Black’s Formula\nBlack (Black 1976) gives formulas for the values of options on futures contracts when interest rates are deterministic (i.e., non-random). It is well known (and we will establish this in Section 10.12) that, when interest rates are deterministic, futures prices should equal forward prices, so Black’s formulas also yield formulas for the values of options on forward contracts when interest rates are deterministic. However, the formulas for options on forwards are valid more generally (even when interest rates vary randomly) and now a mention of Black’s formulas is more likely to be referring to the formulas for options on forwards, instead of the formulas for options on futures. In any case, we will start with the formulas for options on forwards and then in Section 10.13 derive the formulas for options on futures when interest rates are deterministic.\nWe consider a forward contract that matures at some date \\(T'\\) and a call or put option on the forward that matures at \\(T \\leq T'\\). The meaning of a call option on a forward is that exercise of the call creates a long position in the forward contract with forward price equal to the strike price of the option. The long forward contract means that the investor will receive the underlying asset at \\(T'\\) and pay the forward price (the strike of the option) at \\(T'\\). Thus, the strike price is not paid at the date of exercise but instead is paid when the underlying asset is delivered. Symmetrically, the exercise of a put creates a short position in the forward contract with forward price equal to the strike of the put, which means that the exerciser must deliver the underlying at \\(T'\\) and will receive the strike price at \\(T'\\).\nWe will denote the market forward price by \\(F_t\\). We assume the forward price satisfies \\[\n\\frac{\\mathrm{d}  F}{F} = \\mu\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\;,\n\\qquad(10.10)\\]\nwhere \\(B\\) is a Brownian motion. As before, \\(\\mu\\) can be a quite general random process. We will assume in this section that the volatility \\(\\sigma\\) is a constant and generalize to a time-varying (but non-random) volatility in Section 10.15. In Section 10.5, we will discuss the relations of the forward price and its volatility to the price and volatility of the underlying.\nBlack’s formulas are particularly useful when interest rates are assumed to be random, as we will see in Part~\\(\\ref{p_fixedincome}\\) of the book when we study fixed income derivatives. Therefore, we do not assume here that there is a constant risk-free rate. Instead we will assume that there is a discount bond that pays $1 at date \\(T'\\). It is called a discount bond because its price is the appropriate discount factor for computing the present value of nonrandom cash flows at date \\(T'\\). Such a bond is also called a zero coupon bond because it does not pay any cash flows until \\(T'\\), when it pays its face value (which we take simply for convenience to be $1). We will let \\(P(t,T')\\) denote the price of the bond at date \\(t\\).^[In this section we could drop the \\(T'\\) in \\(P(t,T')\\) and simply write \\(P_t\\), because we only consider one maturity date, but we will use the same notation when discussing multiple maturities in Part~\\(\\ref{p_fixedincome].}\\)\nBlack’s formulas are: \n\n\n\n\n\n\n10.4\n\n\n\nThe values at date \\(0\\) of European options with strike \\(K\\) and maturity \\(T\\) on a forward contract with maturity \\(T'\\) are\n\\[\n\\text{Call Price} =P(0,T')F_0\\mathrm{N}(d_1)-P(0,T')K\\mathrm{N}(d_2)\\; ,\n\\qquad(10.11)\\]\n\\[\n\\text{Put Price} =P(0,T')K\\mathrm{N}(-d_2)-P(0,T')F_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(10.12)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.13)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.14)\\]\n\n\nBlack’s formulas are a simple consequence of Margrabe’s formula. To see this, we first need to describe the value of an option on a forward at the maturity date \\(T\\) of the option. Consider a call option. Exercise of the call results in a long forward position with forward price \\(K\\). The value of the long forward is given by its market price \\(F_T\\), but we must keep in mind that the forward price is not paid until the underlying is delivered at date \\(T'\\). So suppose that you exercise the call and then sell a forward contract at the market forward price \\(F_T\\). The delivery/receipt obligations of the long and short forwards cancel, leaving you with the obligation to pay \\(K\\) dollars at date \\(T'\\) and with an asset of \\(F_T\\) dollars to be received at date \\(T'\\). The value of the net cash flow at date \\(T\\) is \\(P(T,T')[F_T-K]\\). This is the value if exercised, so the value of the call at date \\(T\\) is \\[\n\\max\\big(0, P(T,T')[F_T-K]\\big) = \\max\\big(0,P(T,T')F_T-P(T,T')K\\big)\\;.\n\\qquad(10.15)\\]\nWe can write this as \\[\n\\max(0,S_1(T)-S_2(T))\n\\qquad(10.16)\\]\nif we define \\[\nS_1(T) = P(t,T')F_t \\quad \\text{and} \\quad S_2(T) = P(t,T')K\n\\qquad(10.17)\\]\nfor \\(t=T\\) (and more generally for \\(t \\leq T\\)). Thus, the value at maturity of a call option on a forward is the value at maturity of an option to exchange the two assets with prices \\(S_1\\) and \\(S_2\\) (we will establish in a moment that \\(S_1\\) and \\(S_2\\) are actually asset prices). It follows that the value at date \\(0\\) of a call option on a forward is the value at date \\(0\\) of an option to exchange the two assets.\nNow consider a put option on a forward. Exercising the put and unwinding the short forward position by buying a forward at the market price \\(F_T\\) will leave one with a net cash flow of \\(K-F_T\\) to be received at the maturity date \\(T'\\) of the forward. Therefore the value of the put at maturity is \\[\n\\max(0,P(T,T')[K-F_T]) = \\max(S_2(T)-S_1(T))\\;.\n\\qquad(10.18)\\]\nTherefore, the value at date \\(0\\) of the put option on a forward must be the value at date \\(0\\) of an exchange option, where asset one in Equation 10.17 is exchanged for asset two.\nThe key assumption in deriving Margrabe’s formula is that the volatility of the ratio of asset prices is a constant. For a call option on a forward, the relevant ratio is \\(S_1/S_2 = F/K\\). Because \\(K\\) is a constant, the volatility of the ratio is the volatility \\(\\sigma\\) of the forward price \\(F\\), which we have assumed to be constant. For a put option on a forward, the relevant ratio is \\(S_2/S_1 = K/F\\). Ito’s formula implies\n\\[\\begin{align*}\n\\frac{d(K/F)}{K/F} &= -\\frac{\\mathrm{d}  F}{F} + \\left(\\frac{\\mathrm{d}  F}{F}\\right)^2\\; ,\\\\\n&= (-\\mu +\\sigma^2)\\mathrm{d}   t - \\sigma\\mathrm{d}   B\\\\\n&= (-\\mu+\\sigma^2)\\mathrm{d}   t + \\sigma (-\\mathrm{d}  B),\n\\end{align*}\\] The purpose of the last equality displayed here is to emphasize that we should take the volatility of \\(K/F\\) to be the positive number \\(\\sigma\\). We can do this by using \\(-B\\) as the Brownian motion instead of \\(B\\).2 Thus, we can apply Margrabe’s formula to value calls and puts on forwards (once we verify that \\(S_1\\) and \\(S_2\\) are indeed asset prices).\nTo obtain Black’s Equation 10.11 for a call on a forward from Margrabe’s Equation 10.7, we simply substitute \\(S_1(0)=P(0,T')F_0\\), \\(S_2(0)=P(0,T')K\\), \\(q_1=0\\) and \\(q_2=0\\) in Margrabe’s formula. A put option is the reverse exchange, so Margrabe’s formula gives \\[\nP(0,T')K\\mathrm{N}(d^m_1) - P(0,T')F_0\\mathrm{N}(d^m_2)\\;,\n\\qquad(10.19)\\]\nwhere \\[\\begin{align*}\nd^m_1&= \\frac{\\log\\left(\\frac{P(0,T')K}{P(0,T')F_0}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\\\\nd^m_2 &=d^m_1-\\sigma\\sqrt{T}.\n\\end{align*}\\] We introduce the superscript \\(m\\) here to distinguish these numbers in Margrabe’s formula from the \\(d_1\\) and \\(d_2\\) defined in Equation 10.13 and Equation 10.14. Notice that \\[\\begin{align*}\nd^m_1& = -\\frac{\\log\\left(\\frac{F_0}{K}\\right)-\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} = -d_2\\\\\nd^m_2 &= -\\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} =-d_1,\n\\end{align*}\\] so Margrabe’s Equation 10.19 is the same as Black’s Equation 10.12 for a put option on a forward.\nWe still need to explain why \\(S_1\\) and \\(S_2\\) defined in Equation 10.17 are asset prices, in fact the prices of dividend-reinvested assets since we have taken \\(q_1=q_2=0\\) in applying Margrabe’s formula. The case of \\(S_2\\) should be clear: it is the price of \\(K\\) units of the discount bond maturing at \\(T'\\). The case of \\(S_1\\) is more subtle. It is the price of the following portfolio constructed at date \\(0\\) and held until date \\(T\\): go long one forward contract and buy \\(F_0\\) units of the discount bond maturing at \\(T'\\). The value at date \\(t\\) of the bonds in the portfolio is \\(F_0P(t,T')\\). The value at date \\(t\\) of the long forward contract can be seen by considering unwinding it by selling a forward at date \\(t\\) at the market price \\(F_t\\). This cancels the delivery/receipt obligations on the underlying and results in a net cash flow of \\(F_t-F_0\\) to be received at date \\(T'\\). The value at date \\(t\\) of this future cash flow is \\(P(t,T')[F_t-F_0]\\) and when we add this to the value of the bonds we obtain \\(P(t,T')F_t = S_1(T)\\).\nPut-call parity for options on forwards is \\[\\text{Call Price}  + P(0,T')K = \\text{Put Price}  + P(0,T')F_0\\; .\\] The left-hand side is the cost of the call and \\(K\\) units of the discount bond, which have value \\(\\max(F_T,K)P(T,T')\\) at time \\(T\\). The right-hand side is the cost of the put option and \\(F_0\\) units of the discount bond, which, together with a long forward contract initiated at date \\(0\\), also have value \\(\\max(F_T,K)P(T,T')\\) at time \\(T\\).\nAs in the case of exchange option, we can also write one-line programs for pricing options on futures and forwards.\n\n\nCode\ndef black_call(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * F, P * K, sigma, T)\n\ndef black_put(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * K, P * F, sigma, T)\n\n\nF = 100\nK = 90\nP = 0.95\nsigma = 0.2\n\nprint(\"Black Call:\", black_call(F, K, P, sigma, T))\nprint(\"Black Put:\", black_put(F, K, P, sigma, T))\n\n\nBlack Call: 12.909652710252054\nBlack Put: 3.409652710252054",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:merton",
    "href": "Chapter_Merton.html#sec-s:merton",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.5 Merton’s Formula",
    "text": "10.5 Merton’s Formula\nNow we reconsider the Black-Scholes model but without assuming there is a constant risk-free rate. We assume instead that there is a discount bond maturing at the same date as the option. Letting \\(T\\) denote the maturity date of the option and discount bond, we write the price of the discount bond at dates \\(t \\leq T\\) as \\(P(t,T)\\). We continue to assume that the stock has a constant dividend yield \\(q\\) but we make a different assumption about volatility—instead of assuming that the volatility of the stock is constant, we assume that the volatility of its forward price is constant. We relax this to allow time-varying but non-random volatility of the forward price in Section 10.15.\nThe forward contract we consider is a forward contract for the stock maturing at the date \\(T\\) that the option matures. Let \\(F_t\\) denote the forward price for this contract at dates \\(0 \\leq t\\leq T\\). Because the forward price must equal the spot price at the maturity of a forward contract, we have \\(F_T=S_T\\). Consider a call option on the forward, with the call maturing at \\(T\\) also. In the notation of the previous section, we have \\(T'=T\\) and hence \\(P(T,T')=1\\) (the discount bond is worth $1 at maturity). Therefore the value Equation 10.15 of the call on the forward at its maturity \\(T\\) is \\[\\max(0,F_T-K) = \\max(0,S_T-K)\\; ,\\] which is the same as the value of the call on the stock. Therefore, the value at date \\(0\\) of the call on the stock must equal the value at date \\(0\\) of the call on the forward, and we can use Black’s Equation 10.11 for a call option on a forward to price a call option on the stock, assuming the forward price has a constant volatility.\nLikewise, the value at the maturity date \\(T\\) of a put option on the same forward contract is, from Equation 10.18, \\[\\max(0,K-F_T) = \\max(0,K-S_T)\\; .\\] Hence, we can use Black’s Equation 10.12 to price a put option on the stock, assuming the forward price has a constant volatility.\nIt is not necessary that the forward contract be traded, because we can create a synthetic forward using the stock. To create a synthetic forward at date \\(t\\) we buy \\(\\mathrm{e}^{-q(T-t)}\\) shares of the stock at cost \\(\\mathrm{e}^{-q(T-t)}S_t\\). With reinvestment of dividends, this will accumulate to one share at date \\(T\\). We finance the purchase of the stock by shorting \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) units of the discount bond. This results in a liability of \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at date \\(T\\), so the forward purchase is arranged by promising to pay \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at the delivery date; i.e., the forward price is^[If there is a constant risk-free rate \\(r\\), then it must be that \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), so Equation 10.20 becomes \\[F_t = \\mathrm{e}^{(r-q)(T-t)}S_t\\; ,\\] which is the same as the covered interest parity condition ?eq-forwardexchangerate—recall that we interpret the exchange rate as the price of an asset with dividend yield \\(q=r_f\\).} \\[\nF_t = \\frac{\\mathrm{e}^{-q(T-t)}S_t}{P(t,T)}\\;.\n\\qquad(10.20)\\]\nThe assumption we need to apply Black’s formulas is that \\[\n\\frac{\\mathrm{d}  F}{F} = \\mu\\mathrm{d}   t+\\sigma\\mathrm{d}   B\\;,\n\\qquad(10.21)\\]\nwhere \\(B\\) is a Brownian motion, \\(\\mu\\) can be a quite general random process, and \\(\\sigma\\) is a constant. At the end of this section, we will discuss the meaning of this assumption in terms of the volatilities of the stock and bond and their correlation.\nUnder this assumption, the following formulas originally due to Merton (Merton 1973) follow immediately from Black’s formulas Equation 10.11 - Equation 10.14 by substituting \\(F_0 = \\mathrm{e}^{-qT}S_0/P(0,T)\\).\n\n\n\n\n\n\n10.6\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price}  = \\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\;,\n\\qquad(10.22)\\]\n\\[\n\\text{Put Price} = P(0,T)K\\mathrm{N}(-d_2) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\qquad(10.23)\\]\nwhere \\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{KP(0,T)}\\right)-qT+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.24)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.25)\\]\n\n\n\nThese formulas are clearly similar to the Black-Scholes formulas. The similarities are made more apparent by writing the discount bond price in terms of its yield. The yield \\(y\\) of the discount bond is defined as \\[y = \\frac{-\\log P(0,T)}{T} \\qquad\\Longleftrightarrow \\qquad P(0,T) = \\mathrm{e}^{-yT}\\; .\n\\] Substituting this into the expressions above, we have:\n\n\n\n\n\n\n10.7\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price} =\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-yT}K\\mathrm{N}(d_2)\\;,\n\\qquad(10.26)\\]\n\\[\n\\text{Put Price} =\\mathrm{e}^{-yT}K\\mathrm{N}(-d_2)-\\mathrm{e}^{-q T}S_0\\mathrm{N}(-d_1),\n\\qquad(10.27)\\]\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(y-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.28)\\]\n\\[\nd_2 = d_1 - \\sigma\\sqrt{T}\\;.\n\\qquad(10.29)\\]\n\n\nThis shows that the Merton call and put formulas can be calculated from the Black-Scholes call and put functions given in Chapter 9 by inputting the yield of the discount bond as the risk-free rate and by inputting the volatility of the forward price as \\(\\sigma\\).\nIf one wants to assume that there is a constant risk-free rate, then the discount bond price will have to be \\(\\mathrm{e}^{-rT}\\) and its yield will be the risk-free rate \\(r\\). In this case, the forward price is \\(\\mathrm{e}^{(r-q)T}S_0\\) and it has the same volatility as \\(S\\). Making these substitutions, the Merton formulas Equation 10.26 - Equation 10.29 are the same as the Black-Scholes formulas. However, the Merton formulas are an important generalization. It is common practice to use the yield of the discount bond as the risk-free rate that is input into the Black-Scholes formulas. The Merton formulas justify this practice. It is less common to attempt to estimate the volatility of the forward price and use this (as one should since the risk-free rate really is not constant) as the volatility in the Black-Scholes-Merton formulas. However, this does little damage for pricing short-term options, because the volatility of the forward price—see Equation 10.30 below—will be approximately the same as the volatility of the underlying for short-term options, due to the low volatility of short-term bond prices. Moreover, when one computes an implied volatility from the Black-Scholes formula (using the discount bond yield as the risk-free rate), it should be regarded as the market’s view of the forward price volatility, and it is perfectly appropriate to input it into the Black-Scholes-Merton formulas to price another option (assuming of course that the forward price volatility can be regarded as constant).\nThe volatility of the forward price can be computed in terms of the volatilities and correlation of the stock and discount bond as follows. Assume that \n\\[\\begin{align*}\n\\frac{\\mathrm{d}  S}{S}& = \\mu_s\\mathrm{d}   t + \\sigma_s\\mathrm{d}   B_s\\; ,\\\\\n\\frac{\\mathrm{d}  P}{P}& = \\mu_p\\mathrm{d}   t + \\sigma_p\\mathrm{d}   B_p,\n\\end{align*}\\] where \\(B_s\\) and \\(B_p\\) are Brownian motions with correlation \\(\\rho\\). Then ?eq-volatilityproduct and ?eq-volatilityratio show that the volatility of \\(F_t = \\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) is \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_s^2+\\sigma_p^2 - 2\\rho\\sigma_s\\sigma_p}\\;.\n\\qquad(10.30)\\]\nAs mentioned before, we will consider in Section 10.15 that the the volatility Equation 10.30 may vary over time in a non-random way.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#deferred-exchange-options",
    "href": "Chapter_Merton.html#deferred-exchange-options",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.8 Deferred Exchange Options",
    "text": "10.8 Deferred Exchange Options\nA call option on a forward can be viewed as an option to exchange \\(K\\) dollars (or, equivalently, \\(K\\) units of the discount bond maturing at the maturity date of the forward) for the underlying asset, with the exchange taking place at the maturity date of the forward. Therefore, it is an exchange option in which the exchange takes place at a fixed date after the option matures. We can easily extend Margrabe’s formula to value options to exchange other assets when the option maturity precedes the date of the exchange. \nAs in Section 10.1, consider two assets with prices \\(S_i\\) and constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\mathrm{d}  S_i}{S_i} = \\mu_i\\mathrm{d}   t + \\sigma_i\\mathrm{d}   B_i\\; ,\\] where the drifts \\(\\mu_i\\), the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the two Brownian motions can be general random processes. However, also as in Section 10.1, assume that the volatility \\[\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\\] of the ratio of asset prices is constant.\nConsider an option maturing at date \\(T\\) to exchange the second asset for the first asset at date \\(T'\\geq T\\). To understand the value of the option at date \\(T\\), suppose it is exercised. To unwind the positions in the two assets, one can sell a forward contract on the asset to be received and buy a forward contract on the asset to be delivered, with the forward contracts maturing at the date of the exchange. Then the difference \\(F_1(T)-F_2(T)\\) in the forward prices is a cash flow to be received/paid at the exchange date \\(T'\\) and its value at date \\(T\\) is \\(P(T,T')[F_1(T)-F_2(T)]\\). Therefore, the value of the option at its maturity \\(T\\) is \\[\\max(0,P(T,T')F_1(T) - P(T,T')F_2(T))\\; .\\] As in Section 10.3, this valuation does not require the existence of traded forward contracts, because synthetic forwards can be created. Also as in Section 10.3 we know that \\[S^*_1(t) = P(t,T')F_1(T) \\quad \\text{and} \\quad S^*_2(t) = P(t,T')F_2(T)\\] are the prices of dividend-reinvested assets. Therefore, the option to exchange the assets at date \\(T'\\) must have the same value as an option to exchange at date \\(T\\) the assets with prices \\(S^*_i\\).\nWe recall here the arbitrage Equation 10.20 for the forward prices (making the change that here the forwards mature at \\(T'\\)): \\[F_i(t) =  \\frac{\\mathrm{e}^{-q_i(T'-t)}S_i(T)}{P(t,T')}\\; .\\] Thus, \\[S^*_i(t) = \\mathrm{e}^{-q_i(T'-t)}S_i(T)\\; .\\] This implies that the volatility of the ratio \\(S_1^*/S_2^*\\) is the same as the volatility of the ratio \\(S_1/S_2\\). Therefore, we can price a deferred exchange option from Margrabe’s formula, inputting the prices \\(S^*_i(0) = \\mathrm{e}^{-q_iT'}S_i(0)\\) as the initial asset prices and zero as their dividend yields. This formula is:\n\n\n\n\n\n\n10.9\n\n\n\nThe value of a European option maturing at date \\(T\\) to exchange two assets at date \\(T'\\) is \\[\n\\mathrm{e}^{-q_1 T'}S_1(0)\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T'}S_2(0)\\mathrm{N}(d_2)\\;,\n\\qquad(10.31)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+(q_2-q_1)T'+\n\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.32)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(10.33)\\]\n\n\n\n\nCode\ndef margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    Tmat = time to maturity of option\n    Texch = time until exchange &gt;= TOption\n    \"\"\"\n    P1 = np.exp(-q1 * Texch) * S1\n    P2 = np.exp(-q2 * Texch) * S2\n    return generic_option(P1, P2, sigma, Tmat)\n\n# Example usage\nS1 = 100\nS2 = 90\nq1 = 0.01\nq2 = 0.02\nsigma=0.2\nTmat = 1\nTexch = 2\n\nprint(\"Margrabe Deferred:\", margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch))\n\n\nMargrabe Deferred: 14.513318533107103",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:forwardhedging",
    "href": "Chapter_Merton.html#sec-s:forwardhedging",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.10 Greeks and Hedging",
    "text": "10.10 Greeks and Hedging\nThe Greeks for the Margrabe and Black formulas can be calculated in the same way that we calculated them in Chapter 9 for the Black-Scholes formula. In analogy with Equation 9.5, it can be shown for the Margrabe formula that \\[\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1) = \\mathrm{e}^{-q_2T}S_2(0)\\mathrm{n}d(d_2)\\; ,\\] and again this simplifies the calculations. This equation applies to the Black call formula by taking \\(q_1=q_2=0\\), \\(S_1(0)=P(0,T')F_0\\), and \\(S_2(0)=P(0,T')K\\), leading to \\[F_0\\mathrm{n}d(d_1) = K\\mathrm{n}d(d_2)\\; .\\] The Greeks for the Black call formula and the Margrabe formula are: \n\n\n\n\n\n\n10.11\n\n\n\n\\[\\begin{align*}\n&**Black Call** && **Margrabe**\\\\\n& & & \\\\\n\\frac{\\partial}{\\partial F} &= P(0,T')\\mathrm{N}(d_1)  % Black delta1\n&\\frac{\\partial}{\\partial S_1}&= \\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\\\ % Margrabe delta1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial P} &= F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)% Black delta2\n&\\frac{\\partial}{\\partial S_2}&=-\\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\\\ % Margrabe delta2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F^2} &= \\frac{P(0,T')\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}F_0}  % Black gamma1\n&\\frac{\\partial^2}{\\partial S_1^2}&= \\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_1(0)}\\\\ % Margrabe gamma1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial P^2} &= 0 % Black gamma2\n&\\frac{\\partial^2}{\\partial S_2^2}&=\\frac{\\mathrm{e}^{-q_2T}\\mathrm{n}d(d_2)}{\\sigma\\sqrt{T}S_2(0)}\\\\ %Margrabe gamma2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F \\partial P} &= \\mathrm{N}(d_1)&\\frac{\\partial^2}{\\partial S_1 \\partial S_2}% Black crossgamma\n&= -\\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_2(0)}\\\\ % Margrabe crossgamma\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\\frac{\\partial}{\\partial T} &= -\\frac{\\sigma P(0,T')F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}%Black theta part1\n& -\\frac{\\partial}{\\partial T}&=q_1\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{N}(d_1)\\\\ %Margrabe theta part1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n& &&-q_2\\mathrm{e}^{-q_2T}S_2(0)\\mathrm{N}(d_2)\\\\ % Margrabe theta part2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n&&&-\\frac{\\sigma \\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\\\ % Margrabe theta part3\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial \\sigma} &= \\sqrt{T}P(0,T')F_0\\mathrm{n}d(d_1) % Black vega\n&\\frac{\\partial}{\\partial \\sigma}&=\\sqrt{T}\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1) % Margrabe vega\n\\end{align*}\\]\n\n\nHedging for the Margrabe formula is much the same as for the Black-Scholes formula. We would delta-hedge a written exchange option by holding \\(\\delta_1=\\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\) shares of the first asset and \\(\\delta_2 =- \\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\) shares of the second asset (which means shorting the second asset). This position would be financed by borrowing at the risk-free rate (or shorting the discount bond). The same argument that we used in Section 9.5 shows that this zero-cost portfolio will have a zero return if continuously rebalanced.\nBecause the Black formulas are a special case of the Margrabe formula, we can delta-hedge options on forwards in the same way. Putting \\(q_1=q_2=0\\), \\(S_1(0)=P(0,T')F_0\\) and \\(S_2(0)=P(0,T')K\\), we would delta-hedge a written call option by buying \\(\\mathrm{N}(d_1)\\) shares of the first asset and shorting \\(\\mathrm{N}(d_2)\\) shares of the second, where \\(d_1\\) and \\(d_2\\) are defined in the Margrabe formulas Equation 10.8 and Equation 10.9 and equivalently in the Black formulas Equation 10.13 and Equation 10.14. This position would be financed by shorting the discount bond to raise the difference between the cost of the portfolio and the option value so that the cost of the total portfolio (including the short discount bond) equals the option value. However, the first asset here consists of a long forward contract plus \\(F_0\\) units of the discount bond, and the second asset is \\(K\\) units of the discount bond. Furthermore, we are using the discount bond to finance the position (including the buying and shorting of the discount bond!). We can conclude that buying \\(\\mathrm{N}(d_1)\\) units of the first asset means that we should buy \\(\\mathrm{N}(d_1)\\) forward contracts. This has zero cost. Therefore, the portfolio value will equal the value of the discount bonds, and this must equal the option value. So, we actually invest the option value\n\\[P(0,T')F_0\\mathrm{N}(d_1) - P(0,T')K\\mathrm{N}(d_2)\\; ,\\] in the discount bond, which means buying \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the bond.\nA more direct analysis of hedging options on forwards is possible and instructive. We will consider that topic further in Section 10.16.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:futuresforwards",
    "href": "Chapter_Merton.html#sec-s:futuresforwards",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.12 The Relation of Futures Prices to Forward Prices",
    "text": "10.12 The Relation of Futures Prices to Forward Prices\nThe difference between futures and forward contracts is that futures are marked to market, which means that daily gains and losses are posted to the investor’s margin account. Thus, there are interim cash flows on a futures contract, whereas the only cash flows on a forward contract are at the maturity of the forward. We will establish three useful facts in this section, the last of which follows from the first two:\n\nFutures prices are martingales under the risk-neutral probability.\nForward prices are martingales when we use the discount bond with the same maturity as the forward as the numeraire.\nWhen interest rates are non-random, futures prices equal forward prices.\n\nWe consider the idealized case in which the futures contract is continuously marked to market. Assume there is an instantaneously risk-free asset with rate of return \\(r\\), which could vary randomly over time, and define, as in Chapter 6, \\[R_t = \\exp\\left(\\int_0^t r_s\\,ds\\right)\\; ,\\] which is the value at date \\(t\\) of a $1 investment in the asset at date \\(0\\), with interest continuously reinvested. Let \\(T'\\) denote the maturity of the futures contract, and let \\(F^*_t\\) denote the futures price at dates \\(t \\leq T'\\) (the \\(^*\\) notation is to distinguish the futures price from the forward price \\(F\\)). Consider the portfolio strategy that starts with zero dollars and one long futures contract at price \\(F^*_0\\) and which continuously invests and withdraws from the risk-free asset the gains and losses on the futures contract. Let \\(V_t\\) denote the value of this portfolio at date \\(t\\). The change in the value of the portfolio at any instant is the interest earned (or paid, if \\(V&lt;0\\)) on the risk-free asset plus the gain/loss on the futures. This means that \\[\\mathrm{d}  V = rV\\mathrm{d}   t + \\mathrm{d}  F^*\\; .\\] Because all gains and losses on this portfolio are reinvested, \\(V\\) is the price of a dividend-reinvested asset. Therefore, under the risk-neutral probability (i.e., using \\(R\\) as the numeraire), the ratio \\(V/R\\) must be a martingale and hence have zero drift. From Ito’s formula, \\[\\begin{align*}\n\\frac{\\mathrm{d}  (V/R)}{V/R} &= \\frac{\\mathrm{d}  V}{V} - \\frac{\\mathrm{d}  R}{R}\\\\\n&=\\frac{rV\\mathrm{d}   t + \\mathrm{d}  F^*}{V} - r\\mathrm{d}   t\\\\\n&= \\frac{\\mathrm{d}  F^*}{V}\\;.\n\\end{align*}\\] Thus, the drift of \\(V/R\\) being zero implies the drift of \\(F^*\\) is zero. We need to assume (and can assume) that \\(F^*\\) is an Ito process with finite expected quadratic variation—cf. condition Equation 4.9—in which case the absence of a drift implies that it is a martingale.\nNow we turn to fact (2). Consider a forward contract with maturity \\(T'\\) and a discount bond also maturing at \\(T'\\). Let \\(F_t\\) denote the forward price and let \\(P(t,T')\\) denote the price of the discount bond at dates \\(t \\leq T'\\). We observed in Section 10.3 that there is a dividend-reinvested asset with price \\(P(t,T')F_t\\). When we use the discount bond as the numeraire, the ratio \\(P(t,T')F_t/P(t,T') = F_t\\) must be a martingale, which is fact (2). Because of this fact, a probability measure corresponding to a discount bond being the numeraire is called a forward measure. \nSuppose now that interest rates are deterministic, that is, even if \\(r\\) varies over time, it does so in a non-random way. Then the discount bond price at date \\(0\\) must be the discount factor \\[P(0,T') = \\exp\\left(-\\int_0^{T'} r_t\\mathrm{d}   t\\right)\\; .\\] Equation 6.23 gives the probability of any event \\(A\\) when the discount bond is used as the numeraire as \\[\\text{prob}^P[A] = \\\\mathrm{E}\\left[1_A\\phi_{T'}\\frac{P(T',T')}{P(0,T')}\\right] = \\exp\\left(-\\int_0^{T'} r_t\\mathrm{d}   t\\right)\\\\mathrm{E}[1_A\\phi_{T'}]\\; ,\\] where \\(\\phi\\) denotes the state prices. On the other hand, the same equation gives the probability of \\(A\\) when \\(R\\) is used as the numeraire as \\[\\text{prob}^R[A] = \\\\mathrm{E}\\left[1_A\\phi_{T'}\\frac{R_{T'}}{R_0}\\right] = \\exp\\left(-\\int_0^{T'} r_t\\mathrm{d}   t\\right)\\\\mathrm{E}[1_A\\phi_{T'}]\\; .\\] Therefore, the two probability measures are the same, and consequently the expectations \\(\\\\mathrm{E}^P\\) and \\(\\\\mathrm{E}^R\\) are the same. Now using the fact that both the futures price and the forward price must equal the spot price at maturity, we have \\(F^*_{T'} = F_{T'}\\), and, from the martingale properties, \\[F^*_t = \\\\mathrm{E}_t^P[F^*_{T'}] = \\\\mathrm{E}_t^P[F_{T'}] = \\\\mathrm{E}_t^R[F_{T'}] = F_t\\; ,\\] which is fact (3).",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:futuresoptions",
    "href": "Chapter_Merton.html#sec-s:futuresoptions",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.13 Futures Options",
    "text": "10.13 Futures Options\nNow we consider options on futures contracts, assuming that interest rates are deterministic. We just showed that in this circumstance the futures price will equal the forward price for a contract of the same maturity. However, the values of options on a futures contract do not equal the values of options on the corresponding forward contract.\nThe difference is due to marking to market. Consider futures and forward contracts with maturity \\(T'\\) and options maturing at \\(T \\leq T'\\). Exercise of a call option on a futures contract will roll the investor into a long futures contract with futures price equal to the market futures price at that date. The difference \\(F^*_T-K\\) between the market futures price and the strike price of the option is immediately credited to the investor’s margin account. On the other hand, exercise of an option on a forward and sale of the forward results in a cash flow of \\(F_T - K\\) that is received at the maturity date \\(T'\\) of the forward. Therefore, the value at maturity of a call option on a futures contract is \\(\\max(0,F^*_T-K)\\), whereas, as noted before, the value of a call option on a forward at the maturity of the option is \\(P(T,T')\\max(0,F_T-K)\\)\nAs in the analysis of options on forwards, an options on a futures contract can be viewed as an exchange option, where one exchanges the asset with price \\(S_2(T) = P(t,T)K\\) at date \\(t\\leq T\\) for the asset with price \\(S_1(T) = P(t,T)F^*_t\\). The asset with price \\(S_2\\) is of course \\(K\\) units of the discount bond maturing at \\(T\\). Assuming interest rates are deterministic, we have \\(F^*_t = F_t\\), and we noted in Section 10.3 that \\(P(t,T)F_t\\) is the price of a dividend-reinvested asset. Thus, we can apply Margrabe’s formula to price call (and put) options on futures when interest rates are deterministic. Compared to options on forwards, the difference is that the discount bonds defining the prices \\(S_1\\) and \\(S_2\\) mature at the maturity date of the option rather than at the maturity date of the futures or forward contract. The result is:\n\n\n\n\n\n\n10.14\n\n\n\nWhen interest rates are deterministic and the futures price \\(F^*\\) has a constant volatility \\(\\sigma\\), the values of European calls and puts on a futures contract are\n\\[\n\\text{Call Price} =P(0,T)F^*_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\; ,\n\\qquad(10.34)\\]\n\\[\n\\text{Put Price} =P(0,T)K\\mathrm{N}(-d_2)-P(0,T)F^*_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(10.35)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F^*_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.36)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.37)\\]\n\n\nWe can calculate these values from the Black_Call and Black_Put functions by inputting the price of the discount bond maturing when the option matures rather than the price of the discount bond maturing when the forward/futures matures.\nWe will derive delta hedges for futures options in Section 10.16.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:volatility",
    "href": "Chapter_Merton.html#sec-s:volatility",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.15 Time-Varying Volatility",
    "text": "10.15 Time-Varying Volatility\nAll of the option pricing formulas in this chapter were derived from Margrabe’s formula, the main assumption of which is that the logarithm of the ratio of asset prices at date \\(T\\) is normally distributed with variance equal to \\(\\sigma^2T\\). As in ?sec-s:timevaryingvolatility regarding the Black-Scholes formulas, the formulas in this chapter can easily be adapted to allow a time-varying but non-random volatility. If the volatility is a non-random function \\(\\sigma_t\\) of time, then we define \\(\\sigma_{\\text{avg}}\\) to be the number such that \\[\n\\sigma_{\\text{avg}}^2 = \\frac{1}{T}\\int_0^T \\sigma^2_t\\mathrm{d}   t\\;.\n\\qquad(10.38)\\]\nWe should input \\(\\sigma_{\\text{avg}}\\) as (i) the volatility of the ratio of asset prices in Margrabe’s formula and the deferred exchange option formula if \\(\\sigma_t\\) is the volatility of the ratio at date \\(t\\) or as (ii) the volatility of the forward price in Black’s and Merton’s formulas if \\(\\sigma_t\\) is the volatility of the forward price at date \\(t\\).\nAs in ?sec-s:timevaryingvolatility, equation~Equation 10.38 enables one to interpret and apply different implied volatilities computed at different maturities. Another circumstance in which it can be useful is in conjunction with bond price models such as the Vasicek and extended Vasicek models described in ?sec-c:vasicek that imply a time-varying non-random volatility for discount bond prices.3 If we assume a constant volatility for the price of the underlying and a constant correlation between the underlying and the discount bond, then we will have a time-varying non-random forward price volatility via Equation 10.30, and we should input the average volatility \\(\\sigma_{\\text{avg}}\\) defined in Equation 10.38 for the forward price volatility in Black’s and Merton’s formulas. As mentioned in Section 10.5, this will be more important for long-term options than for short-term options.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:hedgingforwards",
    "href": "Chapter_Merton.html#sec-s:hedgingforwards",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.16 Hedging with Forwards and Futures",
    "text": "10.16 Hedging with Forwards and Futures\nIn ?sec-c:foreignexchange, we considered hedging quanto contracts with currency forwards. In Section 10.10, we considered hedging options on forwards with forwards. To present a more complete analysis of these topics, we need to discuss the gains and losses that accrue from trading forwards.\nConsider dates \\(t&lt;u\\) and a forward contract with maturity \\(T\\). Suppose we purchase \\(x_t\\) forwards at date \\(t\\) and then change our position in forwards to \\(x(u)\\) at time \\(u\\). The purchase/sale of \\(x(u)-x_t\\) new contracts does not affect the portfolio value, so the change in the value of the portfolio is the change in the value of the \\(x_t\\) contracts purchased at date \\(t\\). These contracts were worth zero at date \\(t\\), because forward contracts have zero value at initiation. Selling them at date \\(u\\) cancels the obligation to deliver/receive the underlying, leaving one with a cash flow of \\(x_t[F(u)-F_t]\\) dollars to be received at date \\(T\\). The value of this cash flow at date \\(u\\) is \\(x_tP(u,T)[F(u)-F_t]\\). We can write this as \\[\\begin{align*}\nx_tP(u,T)[F(u)-F_t]  &= x_t\\big[P(t,T)[F(u)-F_t] + [P(u,T)-P(t,T)][F(u)-F_t]\\big]\\\\\n&= x_t\\big[P(t,T)\\,\\Delta F + (\\Delta P)(\\Delta F)\\big]\\;.\n\\end{align*}\\] This motivates the following definition:\n\n\n\n\n\n\n10.17\n\n\n\nThe change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\big[P(t,T)\\mathrm{d}   F_t + \\mathrm{d}  P(t,T)\\times \\mathrm{d}  F_t]\\;,\n\\qquad(10.39)\\]\nwhere \\(x_t\\) denotes the number of forward contracts held, \\(F_t\\) denotes the forward price, \\(P(t,T)\\) denotes the price of a discount bond maturing at \\(T\\), and \\(T\\) is the maturity of the forward contract.\n\n\nHedging with futures is a bit simpler, because the gains and losses are received instantaneously (daily, at least) rather than being deferred to the contract maturity. Letting \\(x_t\\) denote the number of futures contracts held at date \\(t\\) and \\(F^*_t\\) the futures price, the cash flow from the contracts is \\(x_t\\mathrm{d}   F^*_t\\). This is also the change in the value of the portfolio, because marking to market means that the contracts always have zero value.\nTo compare hedging with futures and forwards, assume there is a constant risk-free rate \\(r\\). Let \\(T\\) denote the maturity of the futures and forward contracts. Because there is a constant risk-free rate, we have \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), which implies \\((\\mathrm{d}  P)(\\mathrm{d}  F) =0\\). Moreover, futures prices equal forward prices. Thus,\n\n\n\n\n\n\n10.18\n\n\n\nIf there is a constant risk-free rate \\(r\\), the change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\mathrm{e}^{-r(T-t)}\\mathrm{d}   F_t\n\\qquad(10.40)\\]\nand the change in the value of a portfolio of futures contracts is \\[\nx_t\\mathrm{d}   F_t\\;,\n\\qquad(10.41)\\]\nwhere \\(x_t\\) denotes the number of futures/forward contracts held at date \\(t\\), \\(T\\) is the maturity of the futures and forward contracts and \\(F_t\\) is the futures (= forward) price at date \\(t\\).\n\n\nComparing Equation 10.40 and Equation 10.41, we see that if \\(x_t\\) is the number of forward contracts that should be held in a hedge, then \\[\ny_t = \\mathrm{e}^{-r(T-t)}x_t\n\\qquad(10.42)\\]\nis the number of futures contracts that should be held, because with this number of contracts we have \\[\\begin{align*}\n\\text{Change in Forward Portfolio} & = x_t\\mathrm{e}^{-r(T-t)}\\mathrm{d}   F_t\\\\\n& = y_t\\mathrm{d}   F_t\\\\\n& = \\text{Change in Futures Portfolio}\\;.\n\\end{align*}\\] In short, we don’t require as many futures contracts as forward contracts, and the scaling factor to convert from forwards to futures is just the present value factor \\(\\mathrm{e}^{-r(T-t)}\\).\nFor example, the result of ?sec-s:replicatingquantos on replicating the payoff \\(\\bar{X}S_T\\) with forward contracts leads to the following:\n\n\n\n\n\n\n10.19\n\n\n\nTo replicate the payoff \\(\\bar{X}S_T\\) at date \\(T\\), where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset, one should invest \\(V_t\\) units of domestic currency in the foreign asset and be short \\(\\mathrm{e}^{(r_f-r)(T-t)}V_t/X_t\\) currency futures at date \\(t\\), where \\(V_t\\) is defined in ?eq-quanto2 and \\(X_t\\) is the spot exchange rate.\n\n\nWe can use Equation 10.42 to determine how to delta hedge futures options. As explained in Section 10.13, assuming non-random interest rates, futures options are more valuable than options on forwards because futures are marked to market upon exercise of an option. Specifically, Black’s formulas Equation 10.11 - Equation 10.14 for options on forwards and Equation 10.34 - Equation 10.37 for options on futures show that the values are the same except for the maturity of the discount bond appearing in the equations. With a constant risk-free rate \\(r\\), options maturing at \\(T\\) and futures/forwards maturing at \\(T'\\), the relation is \\[\\text{Value of Futures Option} = \\mathrm{e}^{r(T'-T)} \\times \\text{Value of Forward Option}\\; .\\] Because the scaling factor \\(\\mathrm{e}^{r(T'-T)}\\) does not change as time passes, this implies that as time passes we have\n\\[\n\\begin{multline}\n\\text{Change in Futures Option Value } \\\\= \\mathrm{e}^{r(T'-T)} \\times \\text{Change in Forward Option Value}\\;.\n\\end{multline}\n\\qquad(10.43)\\]\nWe can combine Equation 10.42 and Equation 10.43 to convert from a hedge of a forward option using forward contracts, which we discussed in Section 10.10, to a hedge of a futures option using futures contracts. For example, we concluded in Section 10.10 that we should be long \\(\\mathrm{N}(d_1)\\) forwards to hedge a short call option on a forward contract. Consequently, Equation 10.42 shows that we can hedge a short call option on a forward by being long \\(\\mathrm{e}^{-r(T'-t)}\\mathrm{N}(d_1)\\) futures, and then we see from Equation 10.43 that the hedge for a short call on a futures is being long \\[\\mathrm{e}^{r(T'-T)}\\mathrm{e}^{-r(T'-t)}\\mathrm{N}(d_1) = \\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\] futures contracts.\nIn Section 10.10, we derived the hedges for forward options by considering them as exchange options. We can use Equation 10.39 to confirm that our calculations were correct. Consider hedging a short call maturing at \\(T\\) on a forward contract maturing at \\(T'\\). We can assume interest rates vary randomly and use discount bonds in the hedge. We stated in Section 10.10 that we should hold \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the discount bond maturing at \\(T'\\) and we should go long \\(\\mathrm{N}(d_1)\\) forwards to hedge the short call. This is a zero-cost portfolio when we include the proceeds from selling the call. Using Equation 10.39, we see that the change in the value of the portfolio will be \\[\n-\\mathrm{d}  C + [F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)]\\mathrm{d}  P + \\mathrm{N}(d_1)[P(0,T')\\mathrm{d}   F + (\\mathrm{d}  P)(\\mathrm{d}  F)]\\;.\n\\qquad(10.44)\\]\nThe value of the call at date \\(t\\) will be a function of \\(t\\), \\(P(t,T')\\) and \\(F_t\\), which we write as \\(C(t,P,F)\\). From Ito’s formula, \\[\\begin{align*}\n\\mathrm{d}  C &= \\frac{\\partial C}{\\partial t}\\mathrm{d}   t + \\frac{\\partial C}{\\partial P}\\mathrm{d}   P + \\frac{\\partial C}{\\partial F}\\mathrm{d}   F \\\\  &\\qquad + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial P^2}\\, (\\mathrm{d}  P)^2   + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial F^2}\\, (\\mathrm{d}  F)^2 + \\frac{\\partial^2 C}{\\partial F \\partial P} (\\mathrm{d}  P)(\\mathrm{d}  F)\\;.\\\\\n&=\\Theta\\mathrm{d}   t + \\delta_P\\mathrm{d}   P + \\delta_F\\mathrm{d}   F  + \\frac{1}{2}\\Gamma_{PP} (\\mathrm{d}  P)^2 + \\frac{1}{2}\\Gamma_{FF} (\\mathrm{d}  F)^2  + \\Gamma_{FP}\\,(\\mathrm{d}  P)(\\mathrm{d}  F)\\;,\n\\end{align*}\\] where the \\(\\delta\\)’s and \\(\\Gamma\\)’s denote the first and second partial derivatives indicated by the subscripts. Inserting this formula into Equation 10.44 and making use of the formulas in the table in Section 10.10, we see that the \\(\\mathrm{d}  P\\) terms cancel because \\(\\delta_P = F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\). Furthermore, the \\(\\mathrm{d}  F\\) terms cancel because \\(\\delta_F = \\mathrm{N}(d_1)P(0,T')\\). Thus, there is no exposure in the portfolio to the two risky asset prices \\(P\\) and \\(F\\). Furthermore, \\(\\Gamma_{PP} = 0\\) and the \\((\\mathrm{d}  P)(\\mathrm{d}  F)\\) terms cancel because \\(\\Gamma_{FP} = \\mathrm{N}(d_1)\\). These substitutions simplify the change Equation 10.44 in the value of the portfolio to \\[-\\Theta\\mathrm{d}   t - \\frac{1}{2}\\Gamma_{FF} (\\mathrm{d}  F)^2  = \\frac{\\sigma P(0,T')F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\mathrm{d}   t  -  \\frac{P(0,T')\\mathrm{n}d(d_1)}{2\\sigma\\sqrt{T}F_0}\\,(\\mathrm{d}  F)^2\\; ,\\] which we can see to be zero because \\((\\mathrm{d}  F)^2 = \\sigma^2F^2\\mathrm{d}   t\\). Thus, the hedge is perfect when continuously rebalanced.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:margrabecomplete",
    "href": "Chapter_Merton.html#sec-s:margrabecomplete",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.20 Market Completeness",
    "text": "10.20 Market Completeness\nA formal definition of market completeness must specify which state-contin-gent claims (random variables depending on the history of prices) can be replicated by trading the marketed assets—for example, one might want all of the claims with finite means to be replicable, or only all of the claims with finite variances, etc. A formal analysis of market completeness is not presented in this book, except for the binomial and trinomial models in Chapter 6. However, we have stated that stochastic volatility models are incomplete. This follows intuitively from the fact that a portfolio containing only one risky asset (the underlying) cannot be perfectly correlated with the two Brownian motions that determine the value of a derivative asset (the Brownian motions driving the price of the underlying and its volatility). In general, a market must include an instantaneously risk-free asset and as many risky assets as there are Brownian motions in order to be complete.\nThe exchange-option model of Margrabe—with two risky assets, two Brownian motions, and no risk-free asset—is obviously incomplete. For example, it is impossible to have exactly $100 at date \\(T\\). With no risk-free asset, there is simply no way to store money. This may seem far-fetched, but we might be interested in payoffs in real (i.e., inflation-adjusted) dollars, in which case the absence of a risk-free asset may be a normal situation. In any case, we have not assumed a risk-free asset exists, but we have priced options without appealing to equilibrium arguments. This deserves some clarification.\nAs mentioned above, a formal definition of market completeness must specify which contingent claims are to be replicable. The Margrabe model is complete for a certain set of contingent claims. Contingent claims of the form \\(S_2(T)X_T\\) where \\(X_T\\) is a random variable depending on the relative prices \\(S_1(T)/S_2(T)\\) for \\(0 \\leq t\\leq T\\) can be replicated. Likewise, contingent claims of the form \\(S_1(T)X_T\\) can be replicated. The payoffs of exchange options are of this form, so they can be priced by arbitrage, even though there are other contingent claims (for example, receiving exactly $100 at date \\(T\\)) that cannot be replicated and hence cannot be priced by arbitrage. Likewise, the Black and Merton models in which there is a zero-coupon bond but no instantaneously risk-free asset are examples of incomplete markets that are still sufficiently complete to price options by arbitrage (the options can be replicated). The proof that the Margrabe model is complete in the sense stated here follows from the change of numeraire argument used to derive Margrabe’s formula from the Black-Scholes formula (recall that the second asset is risk-free when we use it as the numeraire, so there is a risk-free asset under the new numeraire) and a proof that the Black-Scholes model is complete (which we have omitted, except to show that European options can be replicated).\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will conclude with a proof of the Margrabe formula that does not depend on the Black-Scholes formula. Let \\(x\\) denote the random variable taking the value 1 when \\(S_1(T)&gt;S_2(T)\\) and which is 0 otherwise. Then the value of the exchange option at maturity is \\(xS_1(T)-xS_2(T)\\). Let \\(V_i\\) denote the value of the portfolio beginning with \\(\\mathrm{e}^{-q_iT}\\) units of asset \\(i\\) at date \\(0\\) and reinvesting dividends, to accumulate to one share at date \\(T\\). Then \\(V_i(T)=S_i(T)\\) and from the fundamental pricing Equation 6.28 the value at date \\(0\\) of receiving \\(xS_i(T)\\) at date \\(T\\) is \\[\\begin{align*}\nV_i(0)\\\\mathrm{E}^{V_i}\\left[x\\frac{S_i(T)}{V_i(T)}\\right] &= \\mathrm{e}^{-q_iT}S_i(0)\\\\mathrm{E}^{V_i}[x] \\\\\n&= \\mathrm{e}^{-q_iT}S_i(0)\\times\\text{prob}^{V_i}\\big(V_1(T)&gt;V_2(T)\\big)\\; .\n\\end{align*}\\] We can write the value of receiving \\(xS_1(T)\\) as \\[\\mathrm{e}^{-q_1T}S_1(0)\\times\\text{prob}^{V_1}\\left(\\frac{V_2(T)}{V_1(T)} &lt; 1\\right)\\] and the value of receiving \\(xS_2(T)\\) as \\[\\mathrm{e}^{-q_2T}S_2(0)\\times\\text{prob}^{V_2}\\left(\\frac{V_1(T)}{V_2(T)} &gt; 1\\right)\\;.\\] Note that \\(V_2/V_1\\) is a martingale when we use \\(V_1\\) as the numeraire and \\(V_1/V_2\\) is a martingale when we use \\(V_2\\) as the numeraire. Because they are martingales, they have no drifts. The volatility of the ratios is given in Equation 10.6. Therefore, we have \\[\\begin{align*}\n\\frac{\\mathrm{d}  (V_2/V_1)}{V_2/V_1} &= \\sigma \\mathrm{d}   B^*_1,\\\\\n\\frac{\\mathrm{d}  (V_1/V_2)}{V_1/V_2} &= \\sigma \\mathrm{d}   B^*_2,\n\\end{align*}\\] where \\(B^*_i\\) is a Brownian motion when \\(V_i\\) is used as the numeraire. Margrabe’s formula now follows from the tail probability formulas Equation 5.9–Equation 5.11.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#section-10",
    "href": "Chapter_Merton.html#section-10",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "Derive the Greeks of a call option on a futures contract.\n\n\nUsing the results of the previous exercise, show that the delta hedge of a written call on a futures contract that consists of \\(\\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\) long futures contracts and the value of the call invested in the risk-free asset is a riskless hedge.\n\n\nDerive a formula (like put-call parity) for the value of an option to exchange asset~1 for asset~2 in terms of the value of an option to do the reverse exchange.\n\n\nCreate a Python function Black_Call_Implied_Vol that uses bisection to compute an implied forward price volatility from Black’s formula and the market price of a call option on a forward.\n\n\nUsing a synthetic forward argument, derive the forward price for a forward contract on a stock, where the forward matures at \\(T'\\) and the stock pays a single known cash dividend \\(D\\) at date \\(T&lt;T'\\).\n\n\nUsing the result of the previous exercise and Black’s formula, derive a formula for the value of a European call option on a stock that pays a single known cash dividend before the option matures.\n\n\nModify the function Simulated_Delta_Hedge_Profits to compute the percentiles of gains and losses for an investor who writes a call option on a forward contract and uses a discretely-rebalanced delta hedge. As in ?exr-e_forwardhedging, you will need to create a variable to keep track of the net asset/liability from trading forwards and include it in the valuation at date \\(T\\).\n\n\nConsider the portfolio that promises to pay \\(\\bar{X}S_T\\) at date \\(T\\) and replicates the payoff using currency forwards described in ?sec-s:replicatingquantos, where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset. Using Equation 10.39 of gains and losses from trading forwards, verify that the portfolio is riskless.\n\n\nRepeat the previous exercise using the futures hedge described in Section 10.16.\n\n\nIt has been observed empirically that implied volatilities of stocks are upward biased estimates of future volatility. Given that there is not really a constant risk-free rate, implied volatilities should be interpreted as implied forward-price volatilities, whereas the empirical literature has measured future volatility as the subsequent volatility of the stock. What assumptions about bond volatilities and the correlation of bonds and stocks could explain the empirical finding; i.e., what assumptions imply that the volatility of the forward price exceeds the volatility of the stock?\n\n\nIn the continuous-time Ho-Lee model described in ?sec-c:vasicek, the volatility of a discount bond with time \\(\\tau\\) to maturity is \\(\\sigma_r\\tau\\) for a constant \\(\\sigma_r\\). Under this assumption, calculate the average volatility of the forward price of a stock from date \\(0\\) to date \\(T\\), where \\(T\\) is the maturity of the forward contract. Assume the stock has a constant volatility \\(\\sigma_s\\) and the correlation between the stock and bond is a constant \\(\\rho\\).\n\n\nMaking the same assumptions as in the previous exercise, and using the result of that exercise and Merton’s formula, write a Python function to calculate the value of a call option on a stock. The inputs should be \\(S\\), \\(K\\), \\(P\\), \\(\\sigma_s\\), \\(\\sigma_r\\), \\(\\rho\\), \\(q\\), and \\(T\\).\n\n\n\n\n\nBlack, F. 1976. “The Pricing of Commodity Contracts.” Journal of Financial Economics 3: 167–79.\n\n\nMargrabe, W. 1978. “The Value of an Option to Exchange One Asset for Another.” Journal of Finance 33: 177–86.\n\n\nMerton, R. 1973. “Theory of Rational Option Pricing.” Bell Journal of Economics and Management Science 4: 141–83.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#footnotes",
    "href": "Chapter_Merton.html#footnotes",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "Of course, it is possible to give a direct proof, without relying on the Black-Scholes formula. A sketch is given in Section 10.20↩︎\nThis is really nothing more than the usual convention of defining the standard deviation of a random variable to be the positive square root of the variance.↩︎\nThe volatility of a discount bond price cannot be constant because it must go to zero as the bond approaches maturity.↩︎",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html",
    "href": "Chapter_Asians.html",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "11.1 Asian Options\nThis chapter addresses some “non-vanilla” options that are very important for hedging: Asian options, basket options, and spread options. More exotic options are studied in the following chapter.\nAn Asian option is an option whose value depends on the average underlying asset price during the lifetime of the option. Average-price calls and puts are defined like standard calls and puts but with the final asset price replaced by the average price. Average-strike calls and puts are defined like standard calls and puts but with the exercise price replaced by the average asset price. A firm that must purchase an input at frequent intervals or will sell a product in a foreign currency at frequent intervals can use an average price option as an alternative to buying multiple options with different maturity dates. The average-price option will generally be both less expensive and a better hedge than purchasing multiple options.\nIn practice, the average price is computed by averaging over the prices sampled at a finite number of discrete dates. First, we consider the case of continuous sampling. With continuous sampling, the average price at date \\(T\\) for an option written at date \\(0\\) will be denoted by \\(A_T\\) and is defined as \\[\nA_T = \\frac{1}{T}\\int_0^T S_t\\mathrm{d}   t\\; .\n\\] A sum of lognormally distributed variables is not itself lognormally distributed. Likeise, the integral above, which is essentially a continuous sum of the prices at different dates, is not lognormally distributed.\nAn alternative contract would replace the average price with the geometric average. This is defined as the exponential of the average logarithm. We denote this by \\(A^g\\). The average logarithm is \\[\n\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\; ,\n\\] and the geometric average is \\[\nA^g_T = \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\right)\\; .\n\\] The concavity of the logarithm function guarantees that \\[\n\\log \\frac{1}{T}\\int_0^T S_t &gt; \\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t \\; .\n\\] Therefore, \\[\\begin{align*}\nA_T &= \\exp\\left(\\log \\frac{1}{T}\\int_0^T S_t\\right)\\\\\n&&gt; \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\right) \\\\\n&= A^g_T\\; .\n\\end{align*}\\] Consequently, approximating the value of an average-price or average-strike option by substituting \\(A^g_T\\) for \\(A_T\\) produces a biased estimate of the value. Nevertheless, the geometric average\\(A^g_T\\) and the arithmetic average \\(A_T\\) are highly correlated, so \\(A^g_T\\) forms a very useful for Monte-Carlo valuation of average-price and average-strike options, as will be discussed later. To implement the idea, we need a valuation formula for options written on \\(A^g_T\\). We derive this for an average-price call, in which \\(A^g_T\\) substitutes for \\(A_T\\).\nSpecifically, consider a contract that pays \\(\\max(0,A^g_T-K)\\) at its maturity \\(T\\). This is a geometric-average-price call. Let \\(V_t\\) denote the value at date \\(t\\) of receiving \\(A^g_T\\) at date \\(T\\). This can be calculated, and the result is given below. \\(V_t\\) is the value of a dividend-reinvested portfolio, and, by definition, \\(V_T=A^g_T\\), so the geometric-average-price call is equivalent to a standard call with \\(V\\) being the price of the underlying. We will show that \\(V\\) has a time-varying but non-random volatility. This allows us to apply the Black-Scholes formula. We could attempt the same route to price average-price options, but we would find that the volatility of the corresponding value \\(V\\) varies randomly, making the Black-Scholes formula inapplicable.\nThe value \\(V_t\\) can be calculated as \\[\nV_t= \\mathrm{e}^{-r(T-t)}\\\\mathrm{E}^R_t\\big[A^g_T\\big]\\; .\n\\] Define \\[\nA^g_t = \\exp\\left(\\frac{1}{t}\\int_0^t \\log S_u\\,du\\right)\\;.\n\\]\nWe will verify at the end of this section that \\[\nV_t = \\mathrm{e}^{-r(T-t)}(A^g_t)^{\\frac{t}{T}}S_t^{\\frac{T-t}{T}}\\exp\\left(\\frac{(r-q-\\sigma^2/2)(T-t)^2}{2T} + \\frac{\\sigma^2(T-t)^3}{6T^2}\\right)\\;.\n\\qquad(11.1)\\]\nTwo points are noteworthy. First, the value at date \\(0\\) is\n\\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left(\\frac{(r-q-\\sigma^2/2)T}{2} + \\frac{\\sigma^2T}{6}\\right)\n\\] \\[\n=\\exp\\left(-\\frac{6r+6q + \\sigma^2}{12}T\\right)S_0\\;.\n\\qquad(11.2)\\]\nSecond, the volatility comes from the factor \\(S_t^{(T-t)/T}\\), and, by Ito’s formula, \\[\n\\mathrm{d}  \\log S_t^{(T-t)/T} = \\text{something}\\mathrm{d}    t + \\left(\\frac{T-t}{T}\\right)\\sigma\\mathrm{d}   B\\;.\n\\] We can compute the average volatility in the sense of \\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{T}\\int_0^T \\left(\\frac{T-t}{T}\\right)^2\\sigma^2\\mathrm{d}   t}\n=\\frac{\\sigma}{\\sqrt{3}}\\;.\n\\] and insert that into the Black-Scholes formula as \\(\\sigma\\).1 This yields:\nWe can also value a discretely-sampled geometric-average-price call by the same arguments. Consider dates \\(0&lt;t_0&lt; t_1 &lt; \\cdots t_N=T\\), where \\(t_i-t_{i-1}=\\Delta t\\) for each \\(i\\) and suppose the price is to be sampled at the dates \\(t_1,\\ldots,t_N\\). Now let \\(V_t\\) denote the value at date \\(t\\) of the contract that pays \\[\n\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right) = \\left(\\prod_{i=1}^N S_{t_i}\\right)^{1/N}\n\\qquad(11.3)\\]\nat date \\(T\\). The call option will pay \\(\\max(0,V_T-K)\\) at date \\(T\\). Let \\(k\\) denote the integer such that \\(t_{N-k-1} \\leq t &lt; t_{N-k}\\). This means that we have already observed the prices \\(S(t_1), \\ldots, S(t_{N-k-1})\\) and we have yet to observe the \\(k+1\\) prices \\(S(t_{N-k}), \\ldots ,S(t_N)\\). Define \\(\\varepsilon = (t_{N\\!-k}-t)/\\Delta t\\), which is fraction of the interval \\(\\Delta t\\) that must pass before we reach the next sampling date \\(t_{N\\!-k}\\). We will show at the end of this section that\n\\[\n\\begin{multline}\nV_t = \\mathrm{e}^{-r(T-t)}S_t^{\\frac{k+1}{N}}\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\\\\n\\times\\,\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}\\!+\\! \\frac{k(k+1)\\nu}{2N}\\! +\\! \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}\\!+\\!\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\;,\n\\end{multline}\n\\qquad(11.4)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\)\nAgain, two points are noteworthy. Assume the call was written at date \\(0\\) and the first observation date \\(t_1\\) is \\(\\Delta t\\) years away. Then, we have \\(k+1=N\\) and \\(\\varepsilon=1\\) so \\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left( \\frac{(N+1)\\nu\\Delta t}{2} + \\frac{(N+1)(2N+1)\\sigma^2\\Delta t}{12N} \\right)\\;.\n\\qquad(11.5)\\]\nSecond, the volatility of \\(V_t\\) comes from the factor \\(S_t^{(k+1)/N}\\), and \\[\n\\frac{ \\mathrm{d}  S^{\\frac{k+1}{N}}}{S^{\\frac{k+1}{N}}} = \\text{something}\\mathrm{d}    t + \\left(\\frac{k+1}{N}\\right)\\sigma\\mathrm{d}   B\\;.\n\\] This implies that the average volatility, in the sense of ?sec-s:timevaryingvolatility, is\n\\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{N}\\sum_{k=0}^{N-1} \\left(\\frac{k+1}{N}\\right)^2\\sigma^2\\mathrm{d}   t}\n\\] \\[\n=\\frac{\\sigma}{N^{3/2}}\\sqrt{\\frac{N(N+1)(2N+1)}{6}}\\;,\n\\qquad(11.6)\\]\nwhere we have used the fact that \\(\\sum_{i=1}^N i^2 = N(N+1)(2N+1)/6\\) to obtain the second equality. Thus, the Black-Scholes formula implies:\nThis formula will be used in Section 13.3 as a control variate for pricing discretely-sampled average-price calls (even average-price calls that were written before the date of valuation).\nThe following code computes the price of a geometric-average-price call.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    \n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\nS=60\nK=50\nr=0.05\nsigma=0.2\nq=0\nT=1\nN=100\n\nprint(\"Discrete Geometric Average Price Call:\", discrete_geom_average_price_call(S, K, r, sigma, q, T, N))\n\n\nDiscrete Geometric Average Price Call: 10.87461058434939",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#asian-options",
    "href": "Chapter_Asians.html#asian-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "11.2\n\n\n\nThe value at date \\(0\\) of a continuously-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 11.2, and \\(\\sigma_{\\text{avg}}=\\sigma/\\sqrt{3}\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3\n\n\n\nThe value at date \\(0\\) of a discretely-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\qquad(11.7)\\]\nwhere \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 11.5, and \\(\\sigma_{\\text{avg}}\\) is defined in Equation 11.6.\n\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will now derive Equation 11.1 and Equation 11.4. We will begin with Equation 11.1. The random variable \\(A^g_T\\) is normally distributed under the risk-neutral probability given information at time \\(t\\). To establish this, and to calculate the mean and variance of \\(A^g_T\\), the key is to change the order of integration in the integral in the second line below to obtain the third line: \\[\\begin{align*}\n\\int_t^T \\log S_u\\,du &= \\int_t^T \\left\\{\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(u-t) + \\sigma [B(u)-B_t]\\right\\}\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_t^u \\mathrm{d}  B_s\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_s^T du\\mathrm{d}   B_s\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T (T-s)\\mathrm{d}   B_s\n\\end{align*}\\] and then to note that \\(\\int_t^T (T-s)\\mathrm{d}   B_s\\) is normally distributed with mean zero and variance equal to \\[\n\\int_t^T (T-s)^2\\,ds =\\frac{(T-t)^3}{3}\\;.\n\\] Therefore \\(\\\\mathrm{E}^R_t\\left[A^g_T\\right]\\) is the expectation of the exponential of a normally distributed random variable. Equation~Equation 11.1 now follows from the fact that if \\(x\\) is normally distributed with mean \\(\\mu\\) and variance \\(\\sigma^2\\) then \\(\\\\mathrm{E}\\left[\\mathrm{e}^x\\right] = \\mathrm{e}^{\\mu+\\sigma^2/2}\\).\nTo establish Equation 11.4, note that the discounted risk-neutral expectation of Equation 11.3, conditional on having observed \\(S(t_1), \\ldots, S(t_{N-k-1})\\), is\n\\[\nV_t = \\mathrm{e}^{-r(T-t)}\\\\mathrm{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n= \\mathrm{e}^{-r(T-t)}\\exp\\left(\\frac{1}{N}\\sum_{i=1}^{N-k-1} \\log S_{t_i}\\right)\\times \\\\mathrm{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n=\\left(\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\right)\\times \\mathrm{e}^{-r(T-t)}\\\\mathrm{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\\;.\n\\qquad(11.8)\\]\nLet \\(\\Delta_0B = B(t_{N-k})-B_t\\) and \\(\\Delta_iB = B(t_{N\\!-k+i})-B(t_{N\\!-k+i-1})\\) for \\(i \\geq 1\\). We can write the sum of logarithms inside the expectation above as \\[\\begin{multline*}\n\\sum_{i=0}^{k}\\big\\{[\\log S_t + (t_{N-k+i}-t)\\nu + \\sigma [B(t_{N-k+i})-B_t]\\big\\}\\\\\n=(k+1)\\log S_t + \\sum_{i=0}^{k} (\\varepsilon + i)\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} [\\Delta_0B + \\Delta_1B + \\cdots + \\Delta_iB] \\\\\n=(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} (k+1-i)\\Delta_iB\\;,\n\\end{multline*}\\] where to obtain the last equality we used the fact that \\(\\sum_{i=0}^k i = k(k+1)/2\\). The random variables \\(\\Delta_iB\\) are normally distributed with mean zero and variance \\(\\Delta t\\) (the variance is \\(\\varepsilon \\Delta t\\) for \\(i=0\\)). Thus, the sum of logarithms is a normally distributed random variable with mean \\[\n(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t\n\\] and variance \\[\n(k+1)^2\\sigma^2\\varepsilon\\Delta t + \\sigma^2\\sum_{i=1}^{k} (k+1-i)^2\\Delta t = (k+1)^2\\sigma^2\\varepsilon\\Delta t +\\frac{k(k+1)(2k+1)\\sigma^2}{6}\\; ,\n\\] using the fact that \\(\\sum_{i=1}^k i^2 = k(k+1)(2k+1)/6\\). The expectation of the exponential of a normally distributed random variable equals the exponential of its mean plus one-half of its variance, and the exponential of \\((k+1)\\log S_t/N\\) is \\(S_t^{(k+1)/N}\\). Therefore the conditional expectation in Equation 11.8 is \\[S_t^{\\frac{k+1}{N}}\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}+ \\frac{k(k+1)\\nu}{2N} + \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}+\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\; ,\n\\] which implies Equation 11.4.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#basket-options",
    "href": "Chapter_Asians.html#basket-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.4 Basket Options",
    "text": "11.4 Basket Options\nA basket option is an option written on a portfolio of assets. For example, someone may want to hedge the change in the value of the dollar relative to a basket of currencies. A basket option is an alternative to purchasing separate options on each currency. Generally, the basket option would have a lower premium than the separate options, because an option on a portfolio is cheaper (and pays less at maturity) than a portfolio of options.\nLetting \\(S_1\\), , \\(S_n\\) denote the asset prices and \\(w_1\\), , \\(w_n\\) the weights specified by the contract, a basket call would pay \\[\\max\\left(0,\\;\\sum_{i=1}^n w_iS_{iT} - K\\right)\\] at maturity \\(T\\). A spread option is actually a special case of a basket option, with \\(n=2\\), \\(w_1=1\\), and \\(w_2=-1\\). The difficulty in valuing basket options is the same as that encountered in valuing spread options. The volatility of the basket price \\(\\sum_{i=1}^nw_iS_{it}\\) will vary over time, depending on the relative volatilities of the assets and the price changes in the assets. For example, consider the case \\(n=2\\) and write \\(S_t\\) for the basket price \\(w_1S_{1t}+w_2S_{2t}\\). Then \\[\\begin{align*}\n\\frac{\\mathrm{d}  S}{S} &= \\frac{w_1\\mathrm{d}   S_1}{S} + \\frac{w_2\\mathrm{d}   S_2}{S}\\\\\n&=\\frac{w_1S_1}{S}\\times \\frac{\\mathrm{d}  S_1}{S_1} + \\frac{w_2S_2}{S}\\times \\frac{\\mathrm{d}  S_2}{S_2}\\;.\n\\end{align*}\\] Let \\(x_{it}=w_iS_{it}/S_t\\). This is the fraction of the portfolio value that the \\(i\\)–th asset contributes. It will vary randomly over time as the prices change. Letting \\(\\sigma_i\\) denote the volatilities of the individual assets and \\(\\rho\\) their correlation, the formula just given for \\(\\mathrm{d}  S/S\\) shows that the instantaneous volatility of the basket price at any date \\(t\\) is \\[\n\\sqrt{x_{t}^2\\sigma_1^2 + 2x_{1t}x_{2t}\\rho\\sigma_1\\sigma_2 + x_{2t}^2S_{2t}\\sigma_2^2}\\; .\n\\]\nHence, the volatility will vary randomly over time as the \\(x_i\\) change. There is no simple closed-form solution for the value of a basket option.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#spread-options",
    "href": "Chapter_Asians.html#spread-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.5 Spread Options",
    "text": "11.5 Spread Options\nA spread option is a call or a put written on the difference of two asset prices. For example, a spread call will pay at maturity \\(T\\) the larger of zero and \\(S_{1T}-S_{2T}-K\\), where the \\(S_i\\) are the asset prices and \\(K\\) is the strike price of the call. Spread options can be used by producers to hedge the difference between an input price and an output price. They are also useful for hedging basis risk. For example, someone may want to hedge an asset by selling a futures contract on a closely related but not identical asset. This exposes the hedger to basis risk: the difference in value between the asset and the underlying asset on the futures contract. A spread call can hedge the basis risk: take \\(S_1\\) to be the value of the asset underlying the futures contract and \\(S_2\\) the value of the asset being hedged.\nA spread option is actually an exchange option. Assuming constant dividend yields \\(q_1\\) and \\(q_2\\), we can take the assets underlying the exchange option to be as follows\n\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_1T}\\) units of the asset with price \\(S_1\\) and reinvest dividends, leading to a value of \\(S_{1T}\\) at date \\(T\\),\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_2T}\\) units of the asset with price \\(S_2\\) and invest \\(\\mathrm{e}^{-rT}K\\) in the risk-free asset. Reinvesting dividends and accumulating interest means that we will have \\(S_{2T}+K\\) dollars at date \\(T\\).\n\nHowever, we cannot apply Margrabe’s formula to price spread options, because the second portfolio described above will have a stochastic volatility. To see this, note that if the price \\(S_{2t}\\) falls to a low level, then the portfolio will consist primarily of the risk-free asset, so the portfolio volatility will be near the volatility of the risk-free asset, which is zero. On the other hand, if \\(S_{2t}\\) becomes very high, then the portfolio will be weighted very heavily on the stock investment, and its volatility will approach the volatility of \\(S_2\\).",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#exercises",
    "href": "Chapter_Asians.html#exercises",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.6 Exercises",
    "text": "11.6 Exercises\n\nExercise 11.1 Intuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T'\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Compute and plot the value of the option for \\(T=0.1T'\\), \\(T=0.2T'\\), , \\(T=0.9T'\\).\n\n\nExercise 11.2 Create a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K'=S\\) (i.e., the call is at the money) and maturity \\(T'\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T'\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\nExercise 11.3 Create a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T'\\). Take the date of the dividend payment to be \\(T=0.5T'\\) and take the strike price to be \\(K=S\\). The value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\nExercise 11.4 Create a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 12.6. Verify that the function gives the same result as the function Chooser.\n\n\nExercise 11.5 Write Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Take the time to maturity of the underlying call and put to be \\(T'\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T'\\). Compute the cost of the chooser and the cost of the straddle.\n\n\nExercise 11.6 A stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 12.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\nExercise 11.7 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 11.8 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 11.9 Modify Exercise 12.7 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 12.7 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 11.10 Modify Exercise 12.8 by including the hedge in Exercise 12.9. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 11.11 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 12.7.\n\n\nExercise 11.12 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\nExercise 11.13 Using the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\nExercise 11.14 Derive Equation 12.19 for the value of a call on a put.\n\n\nExercise 11.15 Complete the derivation of Equation 12.34 for the value of a chooser option.\n\n\nExercise 11.16 Derive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\nExercise 11.17 Using the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_{20} + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#footnotes",
    "href": "Chapter_Asians.html#footnotes",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "We assumed a constant volatility when deriving the Black-Scholes formula, but it is easy to check that the same logic works when the volatility is non-randomly time-varying if we substitute this average volatility.↩︎",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html",
    "href": "Chapter_Exotics.html",
    "title": "12  Other Exotics",
    "section": "",
    "text": "12.1 Barrier Options\nWe study six classes of exotic options:\nA down-and-out call pays the usual call value at maturity if and only if the stock price does not hit a specified lower bound during the lifetime of the option. If it does breach the lower barrier, then it is out. Conversely, a down-and-in call pays off only if the stock price does hit the lower bound. Up-and-out and up-and-in calls are defined similarly, and there are also put options of this sort. The out versions are called knock-outs and the in versions are called knock-ins.\nKnock-ins can be priced from knock-outs and vice-versa. For example, the combination of a down-and-out call and a down-and-in call creates a standard European call, so the value of a down-and-in can be obtained by subtracting the value of a down-and-out from the value of a standard European call. Likewise, up-and-in calls can be valued by subtracting the value of an up-and-out from the value of a standard European call. Both knock-outs and knock-ins are of course less expensive than comparable standard options.\nWe will describe the pricing of a down-and-out call. The pricing of up-and-out calls and knock-out puts is similar. Often there are rebates associated with the knocking-out of a barrier option, but we will not include that feature here.\nA down-and-out call provides a hedge against an increase in an asset price, just as does a standard call, for someone who is short the asset. The difference is that the down-and-out is knocked out when the asset price falls sufficiently. Presumably this is acceptable to the buyer because the need to hedge against high prices diminishes when the price falls. In fact, in this circumstance the buyer may want to establish a new hedge at a lower strike. However, absent re-hedging at a lower strike, the buyer of a knock-out call obviously faces the risk that the price may reverse course after falling to the knock-out boundary, leading to regret that the option was knocked out. The rationale for accepting this risk is that the knock-out is cheaper than a standard call. Thus, compared to a standard call, a down-and-out call provides cheaper but incomplete insurance.\nThe combination of a knock-out call and a knock-in call (or knock-out puts) with the same barrier and different strikes creates an option with a strike that is reset when the barrier is hit. This is a hedge that adjusts automatically to the market. An example is given in Probs.~\\(\\ref{e_standardknockout3}\\) and~\\(\\ref{e_standardknockout4}\\).",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:barriers",
    "href": "Chapter_Exotics.html#sec-s:barriers",
    "title": "12  Other Exotics",
    "section": "",
    "text": "Down-and-Out Call Payoff\nLet \\(L\\) denote the lower barrier for the down-and-out call and assume it has not yet been breached at the valuation date, which we are calling date \\(0\\). Denote the minimum stock price realized during the remaining life of the contract by \\(z = \\min_{0\\leq t\\leq T} S_t\\). In practice, this minimum is calculated at discrete dates (for example, based on daily closing prices), but we will assume here that the stock price is monitored continuously for the purpose of calculating the minimum.\nThe down-and-out call will pay \\(\\max(0,S_T-K)\\) if \\(z &gt; L\\) and 0 otherwise, at its maturity T.\nLet \\[\nx = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z &gt; L$;,}\\\\\n0 & \\text{otherwise;.} \\end{cases}\n\\] Then the value of the down-and-out call at maturity is \\[\nxS_T - xK\\; .\n\\]\n\n\nNumeraires\nAs in other cases, the value at date \\(0\\) can be written as \\[\n\\mathrm{e}^{-qT}S_0\\times\\text{prob}^{V}(x=1) - \\mathrm{e}^{-rT}K\\times\\text{prob}^{R}(x=1)\\; ,\n\\]\nwhere \\(V_t = \\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nTo calculate \\(\\text{prob}^{V}(x=1)\\) and \\(\\text{prob}^{R}(x=1)\\), we consider two cases.\n\nSuppose \\(K&gt;L\\). Define \\[\ny = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z \\leq L$}\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;K\\) is equal to the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!K) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!K) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\]\nAs in the derivation of the Black-Scholes formula, we have \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_2)\\;,\n\\qquad(12.1)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.2)\\]\nFurthermore , defining \\[\nd_1' = \\frac{\\log\\left(\\frac{L^2}{KS_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2' = d_1'-\\sigma\\sqrt{T}\\;,\n\\qquad(12.3)\\]\nit can be shown that\n\\[\n\\text{prob}^{V}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1')\\;,\n\\qquad(12.4)\\]\n\\[\n\\text{prob}^{R}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2')\\;.\n\\qquad(12.5)\\]\n\nSuppose \\(K \\leq L\\). Then the condition \\(S_T&gt;K\\) in the definition of the event \\(x=1\\) is redundant: if \\(z &gt; L \\geq K\\), then it is necessarily true that \\(S_T&gt;K\\). Therefore, the probability (under either numeraire) of the event \\(x=1\\) is the probability that \\(z &gt; L\\). Define \\[y = \\begin{cases} 1 & \\text{if $S_T&gt;L$ and $z \\leq L$;,}\\\\\n0 & \\text{otherwise;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;L\\) is the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, as in the previous case (but now with \\(K\\) replaced by \\(L\\)), \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!L) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!L) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\] Also as before, we know that \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_2)\\;,\n\\qquad(12.6)\\]\nwhere now\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{L}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.7)\\]\nMoreover, \\(\\text{prob}^{V}(y=1)\\) and \\(\\text{prob}^{R}(y=1)\\) are given by Equation 12.4 - Equation 12.5 but with \\(K\\) replaced by \\(L\\), which means that \\[\nd_1' = \\frac{\\log\\left(\\frac{L}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2'= d_1' - \\sigma\\sqrt{T}\\;.\n\\qquad(12.8)\\]\n\n\nDown-and-Out Call Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a continuously-sampled down-and-out call option with barrier \\(L\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\left[\\mathrm{N}(d_1)-\\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1')\\right]\\\\ - \\mathrm{e}^{-rT}K\\left[\\mathrm{N}(d_2) - \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2')\\right]\\;,\n\\end{multline}\n\\qquad(12.9)\\]\nwhere\n\nif \\(K&gt;L\\), \\(d_1\\), \\(d_2\\) , \\(d_1'\\) and \\(d_2'\\) are defined in Equation 12.2 - Equation 12.3,\nif \\(K\\leq L\\), \\(d_1\\), \\(d_2\\), \\(d_1'\\) and \\(d_2'\\) are defined in Equation 12.7 - Equation 12.8.\n\n\n\nThe following code computes the price of a down and out call option.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef down_and_out_call(S, K, r, sigma, q, T, Barrier):\n    if K &gt; Barrier:\n        a = S / K\n        b = Barrier * Barrier / (K * S)\n    else:\n        a = S / Barrier\n        b = Barrier / S\n\n    d1 = (np.log(a) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1prime = (np.log(b) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2prime = d1prime - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N1prime = norm.cdf(d1prime)\n    N2prime = norm.cdf(d2prime)\n    x = 1 + 2 * (r - q) / (sigma ** 2)\n    y = x - 2\n    q1 = N1 - (Barrier / S) ** x * N1prime\n    q2 = N2 - (Barrier / S) ** y * N2prime\n\n    return np.exp(-q * T) * S * q1 - np.exp(-r * T) * K * q2\n\nS=100\nK=120\nr=0.05\nsigma=0.2\nq=0\nT=1\nprint(\"Down and Out Call:\", down_and_out_call(S, K, r, sigma, q, T, 80))\n\n\nDown and Out Call: 3.2407203551989525",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:lookbacks",
    "href": "Chapter_Exotics.html#sec-s:lookbacks",
    "title": "12  Other Exotics",
    "section": "12.2 Lookbacks",
    "text": "12.2 Lookbacks\n A floating-strike lookback call pays the difference between the asset price at maturity and the minimum price realized during the life of the contract. A floating-strike lookback put pays the difference between the maximum price over the life of the contract and the price at maturity. Thus, the floating-strike lookback call allows one to buy the asset at its minimum price, and the floating-strike lookback put allows one to sell the asset at its maximum price. Of course, one pays upfront for this opportunity to time the market. These options were first discussed by Goldman, Sosin and Gatto (Goldman, Sosin, and Gatto 1979).\nA fixed-strike lookback put pays the difference between a fixed strike price and the minimum price during the lifetime of the contract. Thus, a fixed-strike lookback put and a floating-strike lookback call are similar in one respect: both enable one to buy the asset at its minimum price. However, the put allows one to sell the asset at a fixed price whereas the call allows one to sell it at the terminal asset price. A fixed-strike lookback call pays the difference between the maximum price and a fixed strike price and is similar to a floating-strike lookback put in the sense that both enable one to sell the asset at its maximum price. Fixed-strike lookback options were first discussed by Conze and Viswanathan (Conze and Viswanathan 1991). We will discuss the valuation of floating-strike lookback calls. As in the discussion of barrier options, we will assume that the price is continuously sampled for the purpose of computing the minimum.\n\nFloating-Strike Lookback Call Payoff\nAs in the previous section, let \\(z\\) denote the minimum stock price realized over the remaining lifetime of the contract. This is not necessarily the minimum stock price realized during the entire lifetime of the contract. Let \\(S_{\\min}\\) denote the minimum stock price realized during the lifetime of the contract up to and including date \\(0\\), which is the date at which we are valuing the contract. The minimum stock price during the entire lifetime of the contract will be the smaller of \\(z\\) and \\(S_{\\text{min}}\\). The payoff of the floating strike lookback call is \\(S_T - \\min\\left(z, S_{\\text{min}}\\right)\\).\n\n\nCalculations\nThe value at date \\(0\\) of the piece \\(S_T\\) is simply \\(\\mathrm{e}^{-qT}S_0\\). It can be shown (see, e.g., Musiela and Rutkowski (Musiela and Rutkowski 1997) for the details) that the value at date \\(0\\) of receiving \\[\n\\min(z, S_{\\text{min}})\n\\] at date \\(T\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) -\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2') \\\\\n+\\left(1+ \\frac{\\sigma^2}{2(r-q)}\\right)\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;.\n\\end{multline*}\\] where\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S_{\\text{min}}}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; , \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(12.10)\\]\n\\[\nd_1' = \\frac{\\log\\left(\\frac{S_{\\text{min}}}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2'=d_1' - \\sigma\\sqrt{T} \\;.\n\\qquad(12.11)\\]\nUsing the fact that \\([1-\\mathrm{N}(-d_1)]\\mathrm{e}^{-qT}S_0=\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)\\), this implies:\n\n\nFloating-Strike Lookback Call Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value at date \\(0\\) of a continuously-sampled floating-strike lookback call, given that the minimum price during the lifetime of the contract through date \\(0\\) is \\(S_{\\text{min}}\\) and the remaining time to maturity is \\(T\\), is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) \\\\+\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2') \\\\\n-\\frac{\\sigma^2}{2(r-q)}\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\end{multline}\n\\qquad(12.12)\\]\nwhere \\(d_1\\), \\(d_2\\), and \\(d_2'\\) are defined in Equation 12.10 - Equation 12.11.\n\n\nThe following program calculates the price of a floating strike lookback option.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\n# Example usage\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\n\nprint(\"Floating Strike Call:\", floating_strike_call(S, r, sigma, q, T, 90))\n\n\nFloating Strike Call: 16.27191861732918",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#compound-options",
    "href": "Chapter_Exotics.html#compound-options",
    "title": "12  Other Exotics",
    "section": "12.3 Compound Options",
    "text": "12.3 Compound Options\nA compound option is an option on an option, for example a call option on a call option or a call on a put. These options are useful for hedging when there is some uncertainty about the need for hedging which may be resolved by the exercise date of the compound option. As speculative trades, they have the benefit of higher leverage than ordinary options. These options were first discussed by Geske (Geske 1979).\n\nCall-on-a-Call Payoff\nLet the underlying call option have exercise price \\(K'\\) and maturity \\(T'\\). Consider an option maturing at \\(T&lt;T'\\) to purchase the underlying call at price \\(K\\).\nLet \\(C(t,S)\\) denote the value at date \\(t\\) of the underlying call when the stock price is \\(S\\) (i.e., \\(C\\) is the Black-Scholes formula). It is of course rational to exercise the compound call at date \\(T\\) if the value of the underlying call exceeds \\(K\\); i.e., if \\(C(T,S_T)&gt;K\\). Let \\(S^*\\) denote the critical price such that \\(C(T,S^*)=K\\). To calculate \\(S^*\\), we need to solve\nBlack_Scholes_Call(S*,Kprime,r,sigma,q,Tprime-T) = K\nfor \\(S^*\\). We can do this by bisection or one of the other methods mentioned in Section 9.6. It is rational to exercise the compound option when \\(S_T &gt; S^*\\).\nWhen \\(S_T &gt; S^*\\), exercise of the compound option generates a cash flow of \\(-K\\) at date \\(T\\). There is a cash flow (of \\(S_{T'}-K'\\)) at date \\(T'\\) only if the compound call is exercised and the underlying call finishes in the money. This is equivalent to: \\[\nS_T &gt; S^* \\quad\\text{and}\\quad S_{T'}&gt;K'\\;.\n\\qquad(12.13)\\]\nLet \\[\n\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$;,}\\\\\n                               0 & \\text{otherwise;,}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$ and $S_{T'}&gt;K'$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\end{align*}\n\\] The cash flows of the compound option are \\(-xK\\) at date \\(T\\) and \\(yS_{T'}-yK'\\) at date \\(T'\\). We can value the compound option at date \\(0\\) by valuing these separate cash flows.\nThe cash flow \\(-xK\\) is the cash flow from being short \\(K\\) digital options on the underlying asset with strike price \\(S^*\\) and maturity \\(T\\). Therefore the value at date \\(0\\) of this cash flow is \\(-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\), where \\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},  \\qquad d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.14)\\]\n\n\nNumeraires\nThe payoffs \\(yS_T\\) and \\(yK'\\) are similar to share digitals and digitals, respectively, except that the event \\(y=1\\) is more complex than we have previously encountered. However, we know from the analysis of share digitals and digitals that the values at date \\(0\\) of these payoffs are \\[\n\\mathrm{e}^{-q T'}S_0\\times\\text{prob}^V\\!(y=1) \\quad \\text{and}\\quad \\mathrm{e}^{-rT'}K'\\times\\text{prob}^R(y=1)\\; ,\n\\] where \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nWe will calculate the two probabilities in terms of the bivariate normal distribution function.\n\nThe event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K'\\; ,\n\\] where \\(B^*\\) is a Brownian motion when the underlying asset (\\(V\\)) is used as the numeraire. These conditions can be rearranged as\n\n\\[-\\frac{B^*_T}{\\sqrt{T}}&lt;d_1 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}}&lt;d_1'\\;,\n\\qquad(12.15)\\]\nwhere \\(d_1\\) is defined in Equation 12.14, and \\[\nd_1' = \\frac{\\log\\left(\\frac{S_0}{K'}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'}{\\sigma\\sqrt{T'}}\\;,\n\\qquad d_2'=d_1'-\\sigma\\sqrt{T'}\\;.\n\\qquad(12.16)\\]\nThe two standard normal variables on the left-hand sides in Equation 12.15 have a covariance equal to \\[\n\\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_{T'}) = \\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_T) = \\sqrt{\\frac{T}{T'}}\\; ,\n\\]\nthe first equality following from the fact that \\(B_T\\) is independent of \\(B_{T'}-B_T\\) and the second from the fact that the covariance of a random variable with itself is its variance. Hence, \\(\\text{prob}^V\\!(y=1)\\) is the probability that \\(a\\leq d_1\\) and \\(b\\leq d_1'\\), where \\(a\\) and \\(b\\) are standard normal random variables with covariance (= correlation coefficient) of \\(\\sqrt{T/T'}\\). We will write this probability as \\(\\mathrm{M}\\!\\left(d_1,d_1',\\sqrt{T/T'}\\right)\\). A program to approximate the bivariate normal distribution function \\(\\mathrm{M}\\) is provided later.\n\nThe calculation for \\(\\text{prob}^R(y=1)\\) is similar. The event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\\;,\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K'\\; ,\n\\] where \\(B^*\\) now denotes a Brownian motion under the risk-neutral probability. These are equivalent to \\[\n-\\frac{B^*_T}{\\sqrt{T}}&lt;d_2 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}} &lt; d_2'\\;.\n\\qquad(12.17)\\]\n\nHence, \\(\\text{prob}^R(y=1)=\\mathrm{M}\\!\\left(d_2,d_2',\\sqrt{T/T'}\\right)\\).\n\n\nCall-on-a-Call Pricing Formula\nWe conclude:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call on a call is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2) + \\mathrm{e}^{-q T'}S_0\\mathrm{M}\\!\\left(d_1,d_1',\\sqrt{T/T'}\\right)\n\\\\- \\mathrm{e}^{-rT'}K'\\mathrm{M}\\!\\left(d_2,d_2',\\sqrt{T/T'}\\right)\\;,\n\\end{multline}\n\\qquad(12.18)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.14 and \\(d_1'\\) and \\(d_2'\\) are defined in Equation 12.16.\n\n\n\n\nPut-Call Parity\nEuropean compound options with the same underlyings and strikes satisfy put-call parity in the usual way: \\[\n\\text{Cash} + \\text{Call} = \\text{Underlying} + \\text{Put}\\; .\n\\]\nThe portfolio on each side of this equation gives the owner the maximum of the strike and the value of the underlying at the option maturity. In the case of options on calls, put-call parity is specifically \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on call} \\\\= \\text{Value of underlying call} + \\text{Value of put on call}\\; ,\n\\end{multline*}\\] where \\(K\\) is the strike price of the compound options and \\(T\\) is their maturity date. Likewise, for options on puts, we have \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on put} \\\\= \\text{Value of underlying put} + \\text{Value of put on put}\\; .\n\\end{multline*}\\] Thus, the value of a put on a call can be derived from the value of a call on a call. The value of a put on a put can be derived from the value of a call on a put, which we will now consider.\n\n\nCall-on-a-Put Pricing Formula\nConsider a call option maturing at \\(T\\) with strike \\(K\\) with the underlying being a put option with strike \\(K'\\) and maturity \\(T'&gt;T\\). The underlying of the put is the asset with price \\(S\\) and constant volatility \\(\\sigma\\). The call on the put will never be in the money at \\(T\\) and hence is worthless if \\(K&gt; \\mathrm{e}^{-r(T'-T)}K'\\), because the maximum possible value of the put option at date \\(T\\) is \\(\\mathrm{e}^{-r(T'-T)}K'\\). So assume \\(K&lt; \\mathrm{e}^{-r(T'-T)}K'\\).\nLet \\(S^*\\) again denote the critical value of the stock price such that the call is at the money at date \\(T\\) when \\(S_T=S^*\\). This means that \\(S^*\\) solves\nBlack_Scholes_Put(S*,Kprime,r,sigma,q,Tprime-T) = K.\nWe leave it as an exercise to confirm the following.\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call on a put is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2) + \\mathrm{e}^{-rT'}K'\\mathrm{M}\\!\\left(-d_2,-d_2',\\sqrt{T/T'}\\right) \\\\- \\mathrm{e}^{-q T'}S_0\\mathrm{M}\\!\\left(-d_1,-d_1',\\sqrt{T/T'}\\right) \\;,\n\\end{multline}\n\\qquad(12.19)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.14 and \\(d_1'\\) and \\(d_2'\\) are defined in Equation 12.16.\n\n\nWe will use bisection to find the critical price \\(S^*\\). We can use \\(e^{q(T'-T)}(K+K')\\) as an upper bound for \\(S^*\\) and 0 as a lower bound.^[We set the value of the call to be zero when the stock price is zero. The upper bound works because (by put-call parity and the fact that the put value is nonnegative) \\(C(T,S) \\geq e^{-q(T'-T)}S-e^{-r(T'-T)}K'\\). Therefore, when \\(S = e^{q(T'-T)}(K+K')\\), we have \\(C(T,S) \\geq K + K' - e^{-r(T'-T)}K' &gt; K\\). }\nThe following uses \\(10^{-6}\\) as the error tolerance in the bisection.\n\n\nCode\nimport numpy as np\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\n\ndef call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * (Tu - Tc)) * (Kc + Ku)\n    guess = 0.5 * lower + 0.5 * upper\n    flower = -Kc\n    fupper = black_scholes_call(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(d2)\n    M1 = binormal_prob(d1, d1prime, rho)\n    M2 = binormal_prob(d2, d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-q * Tu) * S * M1 - np.exp(-r * Tu) * Ku * M2\n\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n\n# print(\"Call on Call:\", call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu))\n\n\nThe implementation of the call-on-a-put formula is of course very similar to that of a call-on-a-call. One difference is that there is no obvious upper bound for \\(S^*\\), so we start with \\(2K'\\) (= 2*K2) and double this until the value of the put is below \\(K\\). We can take 0 again to be the lower bound. Recall that we assume \\(K&lt;\\mathrm{e}^{-r(T'-T)}K'\\) and the right-hand side of this is the value of the put at date \\(T\\) when \\(S_T=0\\).\n\n\nCode\ndef black_scholes_put(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-r * T) * K - np.exp(-q * T) * S)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(-d1)\n        N2 = norm.cdf(-d2)\n        return np.exp(-r * T) * K * N2 - np.exp(-q * T) * S * N1\n\ndef call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    flower = np.exp(-r * (Tu - Tc)) * Ku - Kc\n    upper = 2 * Ku\n    fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    while fupper &gt; 0:\n        upper *= 2\n        fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n\n    guess = 0.5 * lower + 0.5 * upper\n    fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(-d2)\n    M1 = binormal_prob(-d1, -d1prime, rho)\n    M2 = binormal_prob(-d2, -d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-r * Tu) * Ku * M2 - np.exp(-q * Tu) * S * M1\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n# print(\"Call on Put:\", call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu))",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#options-on-the-max-or-min",
    "href": "Chapter_Exotics.html#options-on-the-max-or-min",
    "title": "12  Other Exotics",
    "section": "12.4 Options on the Max or Min",
    "text": "12.4 Options on the Max or Min\nWe will consider here an option written on the maximum or minimum of two asset prices; for example, a call on the maximum pays \\[\n\\max(0,\\max(S_1(T), S_2(T))-K) = \\max(0,S_1(T)-K,S_2(T)-K)\n\\] at maturity \\(T\\). There are also call options on \\(\\min(S_1(T), S_2(T))\\) and put options on the maximum and minimum of two (or more) asset prices. Pricing formulas for these options are due to Stulz (Stulz 1982), who also discusses applications. We will assume the two assets have constant dividend yields \\(q_i\\), constant volatilities \\(\\sigma_i\\), and a constant correlation \\(\\rho\\).\n\nCall-on-the-Max Payoff\nTo value the above option, define the random variables: \\[\\begin{align*}\nx&= \\begin{cases} 1 & \\text{if $S_1(T)&gt;S_2(T)$ and $S_1(T)&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\ny&= \\begin{cases} 1 & \\text{if $S_2(T)&gt; S_1(T)$ and $S_2(T)&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\nz&= \\begin{cases} 1 & \\text{if $S_1(T) &gt; K$ or $S_2(T)&gt; K$}\\; ,\\\\\n0 & \\text{otherwise}\\;. \\end{cases}\n\\end{align*}\\] Then the value of the option at maturity is \\[\nxS_1(T) + yS_2(T) - zK\\; .\n\\]\n\n\nNumeraires\nConsider numeraires \\(V_1(t) = \\mathrm{e}^{q_1t}S_1(T)\\), \\(V_2(t)=\\mathrm{e}^{q_2t}S_2(T)\\), and \\(R_t=\\mathrm{e}^{rt}\\). By familiar arguments, the value of the option at date \\(0\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-q_1T}S_1(0)\\times\\text{prob}^{V_1}(x=1) + \\mathrm{e}^{-q_2T}S_2(0)\\times\\text{prob}^{V_2}(y=1) \\\\- \\mathrm{e}^{-rT}K\\times\\text{prob}^R(z=1)\\; .\n\\end{multline*}\\]\n\n\nCalculating Probabilities\n\nWe will begin by calculating \\(\\text{prob}^{V_1}(x=1)\\). From the second and third examples in Section 8.8, the asset prices satisfy \\[\\begin{align*}\n\\frac{\\mathrm{d}  S_1}{S_1} &= (r-q_1+\\sigma^2_1)\\mathrm{d}   t + \\sigma_1\\mathrm{d}   B^*_{1}\\; ,\\\\\n\\frac{\\mathrm{d}  S_2}{S_2} &= (r-q_2+\\rho\\sigma_1\\sigma_2)\\mathrm{d}   t + \\sigma_2\\mathrm{d}   B^*_{2}\\;,\n\\end{align*}\\] where \\(B^*_{1}\\) and \\(B^*_{2}\\) are Brownian motions when we use \\(V_1\\) as the numeraire. Thus, \\[\n\\begin{align*}\n\\log S_1(T) &= \\log S_1(0) + \\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}(T)\\; ,\\\\\n\\log S_2(T) &= \\log S_2(0) + \\left(r-q_2+\\rho\\sigma_1\\sigma_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}(T)\\;.\n\\end{align*}\n\\] The condition \\(\\log S_1(T) &gt; \\log K\\) is therefore equivalent to\n\n\\[\n  -\\frac{1}{\\sqrt{T}}B^*_{1}(T) &lt; d_{11}\\;,\n\\qquad(12.20)\\]\nand the condition \\(\\log S_1(T)&gt;\\log S_2(T)\\) is equivalent to \\[\n\\frac{\\sigma_2B^*_{2}(T)-\\sigma_1B^*_{1}(T)}{\\sigma\\sqrt{T}} &lt; d_1\\;,\n\\qquad(12.21)\\]\nwhere \\[\n\\sigma =\\sqrt{\\sigma_1^2-2\\rho\\sigma_1\\sigma_2+\\sigma_2^2}\\;,\n\\qquad(12.22)\\]\nand\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+\\left(q_2-q_1+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(12.23)\\]\n\\[\nd_{11}=\\frac{\\log\\left(\\frac{S_1(0)}{K}\\right)+\\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T}{\\sigma_1\\sqrt{T}}\\;, \\qquad d_{12} = d_{11} - \\sigma_1\\sqrt{T}\\;.\n\\qquad(12.24)\\]\nThe random variables on the left-hand sides of Equation 12.20 - Equation 12.21 have standard normal distributions and their correlation is \\[\n\\rho_1 = \\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\; .\n\\] Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_1}(x=1) = \\mathrm{M}(d_{11},d_1,\\rho_1)\\;,\n\\end{equation*}\\] where \\(\\mathrm{M}\\) again denotes the bivariate normal distribution function.\n\nThe probability \\(\\text{prob}^{V_2}(y=1)\\) is exactly symmetric to \\(\\text{prob}^{V_1}(x=1)\\), with the roles of \\(S_1\\) and \\(S_2\\) interchanged. Note that the mirror image of \\(d_1\\) defined in Equation 12.23 is \\[\n\\frac{\\log\\left(\\frac{S_2(0)}{S_1(0)}\\right)+\\left(q_1-q_2+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\n\\] which equals \\(-d_2\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_2}(y=1) = \\mathrm{M}(d_{21},-d_2,\\rho_2)\\;,\n\\end{equation*}\\] where \\[\nd_{21}=\\frac{\\log\\left(\\frac{S_2(0)}{K}\\right)+\\left(r-q_2+\\frac{1}{2}\\sigma_2^2\\right)T}{\\sigma_2\\sqrt{T}},\\qquad d_{22} = d_{21}-\\sigma_2\\sqrt{T}\\;,\n\\qquad(12.25)\\]\n\nand \\[\n\\rho_2 = \\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\; .\n\\] 3. As usual, we have\n\\[\n\\begin{align*}\n\\log S_1(T) &= \\log S_1(0) + \\left(r-q_1-\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}(T)\\; ,\\\\\n\\log S_2(T) &= \\log S_2(0) + \\left(r-q_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}(T)\\;,\n\\end{align*}\n\\]\nwhere \\(B^*_{1}\\) and \\(B^*_{2}\\) now denote Brownian motions under the risk-neutral probability. The event \\(z=1\\) is the complement of the event \\[\nS_1(T)\\leq K \\quad \\text{and} \\quad S_2(T)\\leq K\\; ,\n\\] which is equivalent to\n\\[\n\\frac{1}{\\sqrt{T}}B^*_{1}(T) &lt; -d_{12}\\;,\n\\qquad(12.26)\\]\nand \\[\n\\frac{1}{\\sqrt{T}}B^*_{2}(T) &lt; -d_{22}\\;.\n\\qquad(12.27)\\]\nThe random variables on the left-hand sides of Equation 12.26 and Equation 12.27 are standard normals and have correlation \\(\\rho\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{R}(z=1) = 1- \\mathrm{M}(-d_{12},-d_{22},\\rho)\\;.\n\\end{equation*}\\]\n\n\nCall-on-the-Max Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call option on the maximum of two risky asset prices with volatilities \\(\\sigma_1\\) and \\(\\sigma_2\\) and correlation \\(\\rho\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{M}\\!\\left(d_{11},d_1,\\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\right) + \\mathrm{e}^{-q_2T}S_2(0)\\mathrm{M}\\!\\left(d_{21},-d_2,\\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\right)\\\\+ \\mathrm{e}^{-rT}K\\mathrm{M}(-d_{12},-d_{22},\\rho) - \\mathrm{e}^{-rT}K\\;,\n\\end{multline}\n\\qquad(12.28)\\]\nwhere \\(\\sigma\\) is defined in Equation 12.22 and \\(d_1\\), \\(d_2\\), \\(d_{11}\\), \\(d_{12}\\), \\(d_{21}\\) and \\(d_{22}\\) are defined in Equation 12.23 - Equation 12.24.\n\n\nThe following code shows how to compute the price of a Call on the Max.\n\n\nCode\ndef call_on_max(S1, S2, K, r, sig1, sig2, rho, q1, q2, T):\n    sigma = np.sqrt(sig2 ** 2 - 2 * rho * sig1 * sig2 + sig1 ** 2)\n    d1 = (np.log(S1 / S2) + (q2 - q1 + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d11 = (np.log(S1 / K) + (r - q1 + sig1 ** 2 / 2) * T) / (sig1 * np.sqrt(T))\n    d12 = d11 - sig1 * np.sqrt(T)\n    d21 = (np.log(S2 / K) + (r - q2 + sig2 ** 2 / 2) * T) / (sig2 * np.sqrt(T))\n    d22 = d21 - sig2 * np.sqrt(T)\n    rho1 = (sig1 - rho * sig2) / sigma\n    rho2 = (sig2 - rho * sig1) / sigma\n    M1 = binormal_prob(d11, d1, rho1)\n    M2 = binormal_prob(d21, -d2, rho2)\n    M3 = binormal_prob(-d12, -d22, rho)\n\n    return np.exp(-q1 * T) * S1 * M1 + np.exp(-q2 * T) * S2 * M2 + np.exp(-r * T) * K * M3 - np.exp(-r * T) * K\n# Example usage\n\nS1 = 100\nS2= 100\nK = 100\nr = 0.05\nsigma1 = 0.2\nsigma2 = 0.2\nq1 = 0.02\nq2= 0.01\nT=1\nrho= 0.1\n\n# print(\"Call on Max:\", call_on_max(S1, S2, K, r, sigma1, sigma2, rho, q1, q2, T))",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#forward-start-options",
    "href": "Chapter_Exotics.html#forward-start-options",
    "title": "12  Other Exotics",
    "section": "12.5 Forward-Start Options",
    "text": "12.5 Forward-Start Options\nA forward-start option is an option for which the strike price is set equal to the stock price at some later date. In essence, it is issued at the later date, with the strike price set at the money. For example, an executive may know that he is to be given an option grant at some later date with the strike price set equal to the stock price at that date.\n\nForward-Start Call Payoff\nA forward-start call is defined by its maturity date \\(T'\\) and the date \\(T&lt;T'\\) at which the strike price is set. The value of a forward-start call at maturity is \\[\\max(0,S_{T'}-S_T)\\; .\\] Let \\[x= \\begin{cases} 1 &\\text{if $S_{T'}&gt;S_T$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\] Then, the value of the call at maturity can be written as \\[\nxS_{T'}-xS_T\\; .\n\\]\n\n\nNumeraires\n\nUse \\(V_t=\\mathrm{e}^{qt}S_t\\) as numeraire to price the payoff \\(xS_{T'}\\). From the fundamental pricing Equation 6.28, the value at date \\(0\\) is \\[\\mathrm{e}^{-qT'}S_0\\\\mathrm{E}^V[x] = \\mathrm{e}^{-qT'}S_0\\times \\text{prob}^V\\!(S_{T'}&gt;S_T)\\; .\\]\nTo price the payoff \\(xS_T\\), use the following portfolio as numeraire:1purchase \\(\\mathrm{e}^{-qT}\\) shares of the stock at date \\(0\\) and reinvest dividends until date \\(T\\). This will result in the ownership of one share at date \\(T\\), worth \\(S_T\\) dollars. At date \\(T\\), sell the share and invest the proceeds in the risk-free asset and hold this position until date \\(T'\\). At date \\(T'\\), the portfolio will be worth \\(\\mathrm{e}^{r(T'-T)}S_T\\). Let \\(Z_t\\) denote the value of this portfolio for each \\(0\\leq t\\leq T'\\). The fundamental pricing Equation 6.28 implies that the value of receiving \\(xS_T\\) at date \\(T'\\) is \\[\\begin{align*}\nZ_0\\\\mathrm{E}^Z\\left[ \\frac{xS_T}{Z_{T'}}\\right] &=\n\\mathrm{e}^{-qT}S_0\\\\mathrm{E}^Z\\left[ \\frac{xS_T}{\\mathrm{e}^{r(T'-T)}S_T}\\right]\\\\&= \\mathrm{e}^{-qT-r(T'-T)}S_0\\\\mathrm{E}^Z[x] \\\\&= \\mathrm{e}^{-qT-r(T'-T)}S_0 \\times\\text{prob}^Z(S_{T'}&gt;S_T)\\;.\n\\end{align*}\\]\n\n\n\nCalculating Probabilities\n\nAs in the case of a share digital, we know that \\[\n\\log S_t = \\log S_0 + \\left(r-q +\\frac{1}{2}\\sigma^2\\right)t + \\sigma B^*_t\n\\] for all \\(t&gt;0\\), where \\(B^*\\) is a Brownian motion when \\(V\\) is used as the numeraire. Taking \\(t=T'\\) and \\(t=T\\) and subtracting yields \\[\\log S_{T'}-\\log S_T = \\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T) + \\sigma \\left[B^*_{T'}-B^*_T\\right]\\; .\\] Hence, \\(S_{T'}&gt;S_T\\) if and only if \\[-\\frac{B^*_{T'}-B^*_T}{\\sqrt{T'-T}} &lt; \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}}\\; .\\] The random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^V\\!(S_{T'}&gt;S_T) = \\mathrm{N}(d_1)\\; ,\n\\] where\n\n\\[\nd_1 = \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}} =\\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)\\sqrt{T'-T}}{\\sigma}\\;.\n\\qquad(12.29)\\]\n\nTo calculate the probability \\(\\text{prob}^Z(S_{T'}&gt;S_T)\\), note that between \\(T\\) and \\(T'\\), the portfolio with price \\(Z\\) earns the risk-free rate \\(r\\). The same argument presented in Section 8.8 shows that between \\(T\\) and \\(T'\\) we have \\[\n\\frac{\\mathrm{d}  S}{S} = (r-q)\\mathrm{d}   t + \\sigma\\mathrm{d}   B^*\\; ,\n\\] where now \\(B^*\\) denotes a Brownian motion when \\(Z\\) is used as the numeraire. This implies as usual that \\[\n\\mathrm{d} \\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\mathrm{d}   t + \\sigma\\mathrm{d}   B^*\\; ,\n\\] which means that \\[\n\\log S_{T'} - \\log S_T = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(T'-T) + \\sigma(B^*_{T'}-B^*_T)\\; .\n\\] Hence, \\(S_{T'}&gt;S_T\\) if and only if \\[\n-\\frac{B^*_{T'}-B^*_T}{\\sqrt{T'-T}} &lt; \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}}\\; .\n\\] As before, the random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^Z(S_{T'}&gt;S_T) = \\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_2 = \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)\\sqrt{T'-T}}{\\sigma}=d_1-\\sigma\\sqrt{T'-T}\\;.\n\\qquad(12.30)\\]\n\n\n\nForward-Start Call Pricing Formula\nCombining these results, we have:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a forward-start call at date \\(0\\) is \\[\n\\mathrm{e}^{-qT'}S_0\\mathrm{N}(d_1) - \\mathrm{e}^{-qT-r(T'-T)}S_0\\mathrm{N}(d_2)\\;,\n\\qquad(12.31)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.29 - Equation 12.30.\n\n\n\n\nPut-Call Parity\nForward-strike calls and puts satisfy a somewhat unusual form of put-call parity. The usual put-call parity is of the form: \\[\n\\text{Call} \\;+\\; \\text{Cash} \\quad = \\quad \\text{Put} \\;+ \\;\\text{Underlying}\\; .\n\\]\nThe amount of cash is the amount that will accumulate to the exercise price at maturity; i.e., it is \\(\\mathrm{e}^{-rT'}K\\). For forward-start calls and puts, the effective exercise price is \\(S_T\\), which is not known at date \\(0\\). However, the portfolio used as numeraire to value the second part of the payoff will be worth \\(\\mathrm{e}^{r(T'-T)}S_T\\) at date \\(T'\\), and by following the same strategy but starting with \\(\\mathrm{e}^{-r(T'-T)-qT}\\) instead of \\(\\mathrm{e}^{-qT}\\) shares, we will have \\(S_T\\) dollars at date \\(T'\\). The date–0 value of this portfolio should replace Cash in the above. Thus:\n\n\n\n\n\n\nKey Result\n\n\n\nPut-call parity for forward-start calls and puts is \\[\n\\text{Call Price} \\;+\\; \\mathrm{e}^{-r(T'-T)-qT}S_0 = \\text{Put Price} \\;+\\; \\mathrm{e}^{-qT'}S_0\\;.\n\\qquad(12.32)\\]\nThe new features in the option pricing formulas in this chapter are the use of the bivariate normal distribution function and sometimes the need to compute a critical (at-the-money) value of the underlying asset price. We will compute the critical values by bisection, in the same way that we computed implied volatilities for the Black-Scholes formula in Chapter 9.\nThe following is a fast approximation of the bivariate cumulative normal distribution function, accurate to six decimal places, due to Drezner (Drezner 1978)). For given numbers \\(a\\) and \\(b\\), this function gives the probability that \\(\\xi_1&lt;a\\) and \\(\\xi_2&lt;b\\) where \\(\\xi_1\\) and \\(\\xi_2\\) are standard normal random variables with a given correlation \\(\\rho\\), which we must input.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef binormal_prob(a, b, rho):\n    x = np.array([0.24840615, 0.39233107, 0.21141819, 0.03324666, 0.00082485334])\n    y = np.array([0.10024215, 0.48281397, 1.0609498, 1.7797294, 2.6697604])\n    a1 = a / np.sqrt(2 * (1 - rho ** 2))\n    b1 = b / np.sqrt(2 * (1 - rho ** 2))\n    if a &lt;= 0 and b &lt;= 0 and rho &lt;= 0:\n        total_sum = 0\n        for i in range(5):\n            for j in range(5):\n                z1 = a1 * (2 * y[i] - a1)\n                Z2 = b1 * (2 * y[j] - b1)\n                z3 = 2 * rho * (y[i] - a1) * (y[j] - b1)\n                total_sum += x[i] * x[j] * np.exp(z1 + Z2 + z3)\n        return total_sum * np.sqrt(1 - rho ** 2) / np.pi\n    elif a &lt;= 0 and b &gt;= 0 and rho &gt;= 0:\n        return norm.cdf(a) - binormal_prob(a, -b, -rho)\n    elif a &gt;= 0 and b &lt;= 0 and rho &gt;= 0:\n        return norm.cdf(b) - binormal_prob(-a, b, -rho)\n    elif a &gt;= 0 and b &gt;= 0 and rho &lt;= 0:\n        total_sum = norm.cdf(a) + norm.cdf(b)\n        return total_sum - 1 + binormal_prob(-a, -b, rho)\n    elif a * b * rho &gt; 0:\n        rho1 = (rho * a - b) * np.sign(a) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        rho2 = (rho * b - a) * np.sign(b) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        Delta = (1 - np.sign(a) * np.sign(b)) / 4\n        return binormal_prob(a, 0, rho1) + binormal_prob(b, 0, rho2) - Delta\n# print(\"BiNormalProb:\", binormal_prob(0.1, 0.2, 0.3))\n\n\nNotice that this function calls itself. This is an example of recursion.\nThe forward-start call pricing formula is of the same form as the Black-Scholes, Margrabe, Black, and Merton formulas. We can compute it with our Generic_Option pricing function.\n\n\nCode\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\ndef forward_start_call(S, r, sigma, q, Tset, TCall):\n    P1 = np.exp(-q * TCall) * S\n    P2 = np.exp(-q * Tset - r * (TCall - Tset)) * S\n    return generic_option(P1, P2, sigma, TCall - Tset)\n\n# Example usage\nS = 100\nK = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT = 1\nDiv = 5\nTDiv = 0.5\nTCall = 1\nN = 10\n\n# print(\"Forward Start Call:\", forward_start_call(S, r, sigma, q, 0.5, TCall))",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:choosers",
    "href": "Chapter_Exotics.html#sec-s:choosers",
    "title": "12  Other Exotics",
    "section": "12.6 Choosers",
    "text": "12.6 Choosers\nA chooser option allows the holder to choose whether the option will be a put or call at some fixed date before the option maturity. Let \\(T\\) denote the date at which the choice is made, \\(T_c\\) the date at which the call expires, \\(T_p\\) the date at which the put expires, \\(K_c\\) the exercise price of the call, and \\(K_p\\) the exercise price of the put, where \\(0&lt;T&lt;T_c\\) and \\(0&lt;T&lt;T_p\\). A simple chooser has \\(T_c=T_p\\) and \\(K_c=K_p\\). A chooser is similar in spirit to a straddle: it is a bet on volatility without making a bet on direction. A simple chooser must be cheaper than a straddle with the same exercise price and maturity \\(T'=T_c=T_p\\), because a straddle is always in the money at maturity, whereas a simple chooser has the same value as the straddle if it is in the money but is only in the money at \\(T'\\) when the choice made at \\(T\\) turns out to have been the best one.\n\nChooser Payoff\nThe value of the chooser at date \\(T\\) will be the larger of the call and put prices. Let \\(S^*\\) denote the stock price at which the call and put have the same value. We can find \\(S^*\\) by solving\nBlack_Scholes_Call(S*,Kc,r,sigma,q,Tc-T) = Black_Scholes_Put(S*,Kp,r,sigma,q,Tp-T).\nFor a simple chooser with \\(K_c=K_p=K\\) and \\(T_c=T_p=T'\\), we can find \\(S^*\\) from the put-call parity relation at \\(T\\), leading to \\(S^*=\\mathrm{e}^{(q-r)(T'-T)}K.\\)\nThe call will be chosen when \\(S_T&gt;S^*\\) and it finishes in the money if \\(S(T_c)&gt;K_c\\) at date \\(T_c\\), so the payoff of the chooser is \\(S(T_c)-K_c\\) when \\[S_T&gt;S^* \\quad \\text{and}\\quad S(T_c)&gt;K_c\\;.\n\\] The payoff is \\(K_p-S(T_p)\\) at date \\(T_p\\) when \\[\nS_T&lt;S^* \\quad \\text{and}\\quad S(T_p)&lt;K_p\\;.\n\\] Let \\[\n\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^* $ and $S(T_c)&gt;K_c$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&lt;S^*$ and $S(T_p)&lt;K_p$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\end{align*}\n\\] Then the payoff of the chooser is \\(xS(T_c)-xK_c\\) at date \\(T_c\\) and \\(yK_p-yS(T_p)\\) at date \\(T_p\\).\n\n\nNumeraires\nAs in the analysis of compound options, the value of the chooser at date \\(0\\) must be\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\times\\text{prob}^V\\!(x=1) \\;- \\;\\mathrm{e}^{-rT_c}K_c\\times\\text{prob}^R(x=1)\n\\\\+\\; \\mathrm{e}^{-rT_p}K_p\\times\\text{prob}^R(y=1) \\;- \\;\\mathrm{e}^{-q T_p}S_0\\times\\text{prob}^V\\!(y=1)\\;,\n\\end{multline}\n\\qquad(12.33)\\]\nwhere we use \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\) as numeraires.\n\n\nChooser Pricing Formula\nEquation 12.33 and calculations similar to those of the previous two sections lead us to:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a chooser option is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\mathrm{M}\\!\\left(d_1,d_{1c},\\sqrt{T/T_c}\\right) - \\mathrm{e}^{-rT_c}K_c\\mathrm{M}\\!\\left(d_2,d_{2c},\\sqrt{T/T_c}\\right)\\\\ +\\mathrm{e}^{-rT_p}K_p\\mathrm{M}\\!\\left(-d_2,-d_{2p} , \\sqrt{T/T_p}\\right) \\\\- \\mathrm{e}^{-q T_p}S_0\\mathrm{M}\\!\\left(-d_1 ,-d_{1p} ,\\sqrt{T/T_p}\\right)\\;,\n\\end{multline}\n\\qquad(12.34)\\]\nwhere \\[\\begin{equation*}\n\\begin{array}{ll}\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n& \\qquad d_2=d_1-\\sigma\\sqrt{T}\\;,\\\\\n&\\\\\nd_{1c} = \\frac{\\log\\left(\\frac{S_0}{K_c}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_c}{\\sigma\\sqrt{T_c}}\\;,\n& \\qquad d_{2c}=d_{1c}-\\sigma\\sqrt{T_c}\\;,\\\\\n&\\\\mathrm{d}_{1p} = \\frac{\\log\\left(\\frac{S_0}{K_p}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_p}{\\sigma\\sqrt{T_p}}\\;,\n& \\qquad d_{2p}=d_{1p}-\\sigma\\sqrt{T_p}\\;.\n\\end{array}\n\\end{equation*}\\]\n\n\nTo implement the bisection to compute \\(S^*\\), we can take zero as a lower bound and \\(K_c+K_p\\) as an upper bound.^[We take the call value to be zero and the put value to be \\(\\mathrm{e}^{-r(T_p-T)}K_p\\) at date \\(T\\) when the stock price is zero. To see why the upper bound works, note that when the stock price is \\(S\\) at date \\(T\\), the call is worth at least \\(S^*-K_c\\) and the put is worth no more than \\(K_p\\); i.e, \\(C \\geq S-K_c\\) and \\(P \\leq K_p\\). Therefore, \\(C-P \\geq S-K_c-K_p\\). Hence when \\(S=K_c+K_p\\), we have \\(C-P\\geq 0\\). }\n\n\nCode\ndef chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * Tc) * (Kc + Kp)\n    guess = 0.5 * Kc + 0.5 * Kp\n    flower = -np.exp(-r * (Tp - T)) * Kp\n    fupper = black_scholes_call(upper, Kc, r, sigma, q, Tc - T) - black_scholes_put(upper, Kp, r, sigma, q, Tp - T)\n    fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1c = (np.log(S / Kc) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2c = d1c - sigma * np.sqrt(Tc)\n    d1p = (np.log(S / Kp) + (r - q + sigma ** 2 / 2) * Tp) / (sigma * np.sqrt(Tp))\n    d2p = d1p - sigma * np.sqrt(Tp)\n    rhoc = np.sqrt(T / Tc)\n    rhop = np.sqrt(T / Tp)\n    M1c = binormal_prob(d1, d1c, rhoc)\n    M2c = binormal_prob(d2, d2c, rhoc)\n    M1p = binormal_prob(-d1, -d1p, rhop)\n    M2p = binormal_prob(-d2, -d2p, rhop)\n\n    return np.exp(-q * Tc) * S * M1c - np.exp(-r * Tc) * Kc * M2c + np.exp(-r * Tp) * Kp * M2p - np.exp(-q * Tp) * S * M1p\n\n# Example usage\nS = 100\nKc = 80\nKp = 80\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 1.5\nTp = 1.5\nT=1\n\n# print(\"Chooser Option:\", chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp))",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#exercises",
    "href": "Chapter_Exotics.html#exercises",
    "title": "12  Other Exotics",
    "section": "12.7 Exercises",
    "text": "12.7 Exercises\n\nExercise 12.1 Intuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T'\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Compute and plot the value of the option for \\(T=0.1T'\\), \\(T=0.2T'\\), , \\(T=0.9T'\\).\n\n\nExercise 12.2 Create a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K'=S\\) (i.e., the call is at the money) and maturity \\(T'\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T'\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\nExercise 12.3 Create a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T'\\). Take the date of the dividend payment to be \\(T=0.5T'\\) and take the strike price to be \\(K=S\\). The value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\nExercise 12.4 Create a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 12.6. Verify that the function gives the same result as the function Chooser.\n\n\nExercise 12.5 Create a Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Take the time to maturity of the underlying call and put to be \\(T'\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T'\\). Compute the cost of the chooser and the cost of the straddle.\n\n\nExercise 12.6 A stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 12.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\nExercise 12.7 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 12.8 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 12.9 Modify Exercise 12.7 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 12.7 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 12.10 Modify Exercise 12.8 by including the hedge in Exercise 12.9. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 12.11 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 12.7.\n\n\nExercise 12.12 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\nExercise 12.13 Using the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\nExercise 12.14 Derive Equation 12.19 for the value of a call on a put.\n\n\nExercise 12.15 Complete the derivation of Equation 12.34 for the value of a chooser option.\n\n\nExercise 12.16 Derive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\nExercise 12.17 Using the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_2(0) + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]\n\n\n\n\n\nConze, A., and Viswanathan. 1991. “Path Dependent Options: The Case of Lookback Options.” Journal of Finance 46: 1893–1907.\n\n\nDrezner, Z. 1978. “Computation of the Bivariate Normal Integral.” Mathematics of Computation 32: 277–79.\n\n\nGeske, R. 1979. “The Valuation of Compound Options.” Journal of Financial Economics 7: 63–81.\n\n\nGoldman, M., H. Sosin, and M. Gatto. 1979. “Path Dependent Options: ‘Buy at the Low, Sell at the High.” ’ Journal of Finance 34: 1111–27.\n\n\nMusiela, M., and M. Rutkowski. 1997. Martingale Methods in Financial Modeling. Springer, Berlin Heidelberg New York.\n\n\nStulz, R. 1982. “Options on the Minimum or Maximum of Two Risky Assets: Analysis and Applications.” Journal of Financial Economics 10: 161–85.",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#footnotes",
    "href": "Chapter_Exotics.html#footnotes",
    "title": "12  Other Exotics",
    "section": "",
    "text": "We are going to use equation~Equation 6.23 at date \\(T'\\) to define the probabilities, because it will not be known until date \\(T'\\) whether the event \\(S_{T'}&gt;S_T\\) is true. Thus, we need the price of a numeraire asset at date \\(T'\\). We would like this price to be a constant times \\(S_T\\), which is what we will obtain. An equivalent numeraire is to make a smaller investment in the same portfolio: start with \\(\\mathrm{e}^{-r(T'-T)-qT}\\) shares. This results in a final value of \\(S_T\\) at date \\(T'\\). As will be seen, this is useful for deriving the put-call parity relation for forward-start options.↩︎",
    "crumbs": [
      "Part 4: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html",
    "href": "Chapter_MonteCarlo.html",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "13.1 Introduction to Monte Carlo\nIn this chapter, we will introduce a principal numerical method for valuing derivative securities: Monte Carlo. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.\nAccording to our risk-neutral pricing Equation 6.29, the value of a security paying an amount \\(x\\) at date \\(T\\) is \\[\n\\mathrm{e}^{-rT}\\mathbb{E}^R[x]\\;.\n\\qquad(13.1)\\]\nTo estimate this by Monte-Carlo means to simulate a sample of values for the random variable \\(x\\) and to estimate the expectation by averaging the sample values.1. Of course, for this to work, the sample must be generated from a population having a distribution consistent with the risk-neutral probabilities.\nThe simplest example is valuing a European option under the Black-Scholes assumptions. Of course, for calls and puts, this is redundant, because we already have the Black-Scholes formulas. Nevertheless, we will describe how to do this for the sake of introducing the Monte Carlo method. In the case of a call option, the random variable \\(x\\) in Equation 13.1 is \\(\\max(0,S_T-K)\\). To simulate a sample of values for this random variable, we need to simulate the terminal stock price \\(S_T\\). This is easy to do, because, under the Black-Scholes assumptions, the logarithm of \\(S_T\\) is normally distributed under the risk-neutral probability with mean \\(\\log S_0+\\nu T\\) and variance \\(\\sigma^2T\\), where \\(\\nu=r-q-\\sigma^2/2\\). Thus, we can simulate values for \\(\\log S_T\\) as \\(\\log S_0+\\nu T + \\sigma\\sqrt{T}z\\), where \\(z\\) is a standard normal. We can average the simulated values of \\(\\max(0,S_T-K)\\), or whatever the payoff of the derivative is, and then discount at the risk-free rate to compute the date–0 value of the derivative. This means that we generate some number \\(M\\) of standard normals \\(z_i\\) and estimate the option value as \\(\\mathrm{e}^{-rT}\\bar{x}\\), where \\(\\bar{x}\\) is the mean of \\[x_i = \\max\\left(0,\\mathrm{e}^{\\log S_0+\\nu T + \\sigma\\sqrt{T}z_i}-K\\right)\\; .\\] To value options that are path-dependent we need to simulate the path of the underlying asset price.\nThere are two main drawbacks to Monte-Carlo methods. First, it is difficult (though not impossible) to value early-exercise features.2 To value early exercise, we need to know the value at each date if not exercised, to compare to the intrinsic value. One could consider performing a simulation at each date to calculate the value if not exercised, but this value depends on the option to exercise early at later dates, which cannot be calculated without knowing the value of being able to exercise early at even later dates, etc. In contrast, the binomial model can easily handle early exercise but cannot easily handle path dependencies.\nThe second drawback of Monte Carlo methods is that they can be quite inefficient in terms of computation time (though, as will be explained later, they may be faster than alternative methods for derivatives written on multiple assets). As in statistics, the standard error of the estimate depends on the sample size. Specifically, given a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of size \\(M\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\), the best estimate of \\(\\mu\\) is the sample mean \\(\\bar{x}\\), and the standard error of \\(\\bar{x}\\) (which means the standard deviation of \\(\\bar{x}\\) in repeated samples) is best estimated by \\[\n\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^{M} x_i^2-M\\bar{x}^2\\right)}\\;.\n\\qquad(13.2)\\] Recall that \\(\\bar{x}\\) plus or minus 1.96 standard errors is a 95% confidence interval for \\(\\mu\\) when the \\(x_i\\) are normally distributed. In the context of European option valuation, the expression Equation 13.2 gives the standard error of the estimated option value at maturity, and multiplication of Equation 13.2 by \\(\\mathrm{e}^{-rT}\\) gives the standard error of the estimated date–0 option value.\nTo obtain an estimate with an acceptably small standard error may require a large sample size and hence a relatively large amount of computation time. The complexities of Monte Carlo methods arise from trying to reduce the required sample size. Later, we will describe two such methods (antithetic variates and control variates). For those who want to engage in a more detailed study of Monte Carlo methods, the book of Glasserman (Glasserman 2004) is highly recommended. J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002) is useful for more advanced readers, and Clewlow and Strickland (Clewlow and Strickland 1998) and Brandimarte (Brandimarte 2002) are useful references that include computer code.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "href": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "Monte Carlo Valuation of a European Call\nWe will illustrate Monte Carlo by valuing a European call under the Black-Scholes assumptions. We will also estimate the delta by each of the methods described in Section 13.4 and Section 13.5. Of course, we know the call value and its delta from the Black-Scholes formulas, and they can be used to evaluate the accuracy of the Monte Carlo estimates. In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process. Therefore we set \\(m=1\\). However, we use a large number of paths, \\(n=10,000\\) to get a large sample of terminal stock prices.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 10000\n#number of divisions\nm = 1\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Dividend Yield\nq=0.0\n# Delta t\ndt = T/m\n# Drift (nu)\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2020\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before, this code generates two samples \\(St\\), which adds the simulated standard (zero mean) normal random variable, and \\(St1\\) which subtracts the simulated (zero mean) standard normal random variable. Each sample produces and estimate for the Black-Scholes European call option.\n\n\nCode\ncc=np.maximum(St[m,:]-K,0)\ncp = np.mean(cc) * np.exp(-r * T)\ncc1=np.maximum(St1[m,:]-K,0)*np.exp(-r * T)\ncp1= np.mean(np.maximum(St1[m,:]-K,0)) * np.exp(-r * T)\n\nprint('The first sample gives an estimated call price=',cp)\nprint('The second sample gives an estimated call price=',cp1)\nbsc = (cp+cp1)/2\nprint('The average of the two estimates=',bsc)\n\n\nThe first sample gives an estimated call price= 4.791646287615179\nThe second sample gives an estimated call price= 4.687624646438363\nThe average of the two estimates= 4.739635467026771\n\n\nThe true call price is given by\n\n\nCode\nfrom scipy.stats import norm\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n    \n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n        \n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n    if call:\n        return np.exp(- q *T) * S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1) \n    else:\n        return -np.exp(-q * T) * S0 * norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc=blackscholes(S0, K, r, q, sig, T, call = True)\nprint('The black scholes fromula=',truebsc)\n\n\nThe black scholes fromula= 4.759422392871532\n\n\nNotice that even with 10,000 data points for each sample the individual estimates are not very accurate compared to the exact Black Scoles price. This is a well known problem that is difficult to estimate the mean, even with a lot of data and is a drawback to Monte Carlo as discussed earlier. However, the average of the two prices is sgnificantly more accurate. This is an example of an antithetic variable which is discussed later. One simple intution is the two samples yield negatively correlated errors; if the plus sample is two high, then the minus sample will be too low. Combined, the simulation error will cancel out. Another intution is that each individual sample has a wrong estimate of the mean. However, the combined sample has zero mean by construction. Therefore combining the samples give the right mean of the simulated standard normal random variable. Nevertheless, there is still sampling error since we are estimating the mean of the discounted call payoffs, not the mean of the standard normal. This method and other methods to reduce sampling error are discussed next.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#antithetic-variates-in-monte-carlo",
    "href": "Chapter_MonteCarlo.html#antithetic-variates-in-monte-carlo",
    "title": "13  Monte Carlo Methods",
    "section": "13.2 Antithetic Variates in Monte Carlo",
    "text": "13.2 Antithetic Variates in Monte Carlo\nIn this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method. These are two of the simplest methods. They are used extensively, but there are other important methods that are also widely used. J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002) and Glasserman (Glasserman 2004) provide a wealth of information on this topic.\nThe Monte Carlo method estimates the mean \\(\\mu\\) of a random variable \\(x\\) as the sample average of randomly generated values of \\(x\\). An antithetic variate is a random variable \\(y\\) with the same mean as \\(x\\) and a negative correlation with \\(x\\). It follows that the random variable \\(z=(x+y)/2\\) will have the same mean as \\(x\\) and a lower variance. Therefore the sample mean of \\(M\\) simulations of \\(z\\) will be an unbiased estimate of \\(\\mu\\) and will have a lower standard error than the sample mean of \\(M\\) simulations of \\(x\\). Thus, we should obtain a more efficient estimator of \\(\\mu\\) by simulating \\(z\\) instead of \\(x\\).3\nIn the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent). The terminal value of the derivative written on the first asset serves as \\(x\\) and the terminal value of the derivative written on the second serves as \\(y\\). Because both asset prices have the same distribution, the means of \\(x\\) and \\(y\\) will be the same, and the discounted mean is the date–0 value of the derivative.\nConsider for example a non-path-dependent option in a world with constant volatility. In each simulation \\(i\\) (\\(i=1,\\ldots,M\\)), we would generate a standard normal \\(Z_i\\) and compute \\[\n\\begin{align*}\n\\log S_i(T) &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z_i\\; ,\\\\\n\\log S_i'(T) &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T - \\sigma\\sqrt{T}Z_i\\;.\n\\end{align*}\n\\] Given the first terminal price, the value of the derivative will be some number \\(x_i\\) and given the second it will be some number \\(y_i\\). The date–0 value of the derivative is estimated as \\[\n\\mathrm{e}^{-rT}\\frac{1}{M}\\sum_{i=1}^M\\frac{x_i+y_i}{2}\\; .\n\\]",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "href": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "title": "13  Monte Carlo Methods",
    "section": "13.3 Control Variates in Monte Carlo",
    "text": "13.3 Control Variates in Monte Carlo\n Another approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable. We can explain this in terms of linear regression in statistics. Suppose we have a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of a variable \\(x\\) with unknown mean \\(\\mu\\), and suppose we have a corresponding sample \\(\\{y_1,\\ldots,y_M\\}\\) of another variable \\(y\\) with known mean \\(\\phi\\). Then an efficient estimate of \\(\\mu\\) is \\(\\hat{\\mu} = \\bar{x} + \\hat{\\beta} (\\phi-\\bar{y})\\), where \\(\\bar{x}\\) and \\(\\bar{y}\\) denote the sample means of \\(x\\) and \\(y\\), and where \\(\\hat{\\beta}\\) is the coefficient of \\(y\\) in the linear regression of \\(x\\) on \\(y\\) (i.e., the estimate of \\(\\beta\\) in the linear model \\(x = \\alpha +\\beta y + \\varepsilon\\)). The standard Monte Carlo method, which we have described thus far, simply estimates the mean of \\(x\\) as \\(\\bar{x}\\). The control variate method adjusts the estimate by adding \\(\\hat{\\beta} (\\phi-\\bar{y})\\). To understand this correction, assume for example that the true \\(\\beta\\) is positive. If the random sample is such that \\(\\bar{y}&lt;\\phi\\), then it must be that small values of \\(y\\) were over-represented in the sample. Since \\(x\\) and \\(y\\) tend to move up and down together (this is the meaning of a positive \\(\\beta\\)) it is likely that small values of \\(x\\) were also over-represented in the sample. Therefore, one should adjust the sample mean of \\(x\\) upwards in order to estimate \\(\\mu\\). The best adjustment will take into account the extent to which small values of \\(y\\) were over-represented (i.e., the difference between \\(\\bar{y}\\) and \\(\\phi\\)) and the strength of the relation between \\(x\\) and \\(y\\) (which the estimate \\(\\hat{\\beta}\\) represents). The efficient correction of this sort is also the simplest: just add \\(\\hat{\\beta}(\\phi-\\bar{y})\\) to \\(\\bar{x}\\). In practice, the estimation of \\(\\hat{\\beta}\\) may be omitted and one may simply take \\(\\hat{\\beta}=1\\), if the relationship between \\(x\\) and \\(y\\) can be assumed to be one-for-one. If \\(\\beta\\) is to be estimated, the estimate (by ordinary least squares) is \\[\\hat{\\beta} = \\frac{\\sum_{i=1}^M x_iy_i - M\\bar{x}\\bar{y}}{\\sum_{i=1}^M y_i^2 - M\\bar{y}^2}\\; .\\] In general, the correction term \\(\\hat{\\beta}(\\phi-\\bar{y})\\) will have a nonzero mean, which introduces a bias in the estimate of \\(\\mu\\). To eliminate the bias, one can compute \\(\\hat{\\beta}\\) from a pre-sample of \\(\\{x,y\\}\\) values.\nAs an example of a control variate, in our simulation code to estimate the Black Scholes price for a call option we can use the stock price itself. The known stock price is the input price \\(S_0\\). The simulation also produces an estimate for the stock price as the dicsounted expected value of the terminal stock price \\(\\hat{S}=\\sum_{i=1}^{n} e^{- r T } S_t(m,i)\\) where \\(S_t(m,i)\\) is the \\(i\\)th simulated stock price at time \\(T\\). Theoretically these should be the same umber, but due to error they typically wil not be the same.\n\n\nCode\nSS=np.mean(St[m,:])*np.exp(-r*T)\nprint('The Estimated Stock Price for the first sample is =', SS)\nprint('The actual stock price should be=', S0)\nprint('The error is =', S0-SS)\n\n\nThe Estimated Stock Price for the first sample is = 42.05899999577932\nThe actual stock price should be= 42\nThe error is = -0.058999995779316805\n\n\nThe error is \\(S_0-\\hat{S}\\) which corresponds to \\(\\phi-y\\) above. We then compute \\(\\hat{\\beta}\\) and comute the improved estimate \\[ \\text{new estimate}= \\text{original estimate} +\\hat{\\beta}(S0-\\hat{S}) \\] In the code below we do this procedure for both samples and average the updates.\n\n\nCode\nhatbeta= np.cov(St[m,:],cc)[0,1]/np.cov(St[m,],cc)[1,1]\nhatbeta1=np.cov(St1[m,:],cc1)[0,1]/np.cov(St1[m,],cc1)[1,1]\ncorrection =hatbeta*(S0-SS)\nupdate=cp + correction\nprint('hatbeta=',hatbeta)\nprint('The original estimate for the call price from the first sample=',cp)\nprint('The original estimate for the call price from the second sample=',cp1)\nprint('The updated estimate from the first sample is=',update)\nSS1=np.mean(St1[m,:])*np.exp(-r*T)\nupdate1=cp1+hatbeta1*(S0-SS1)\nprint('The updated estimate from the second sample is=',update1)\nprint('The average of the updated estimates =',(update+update1)/2)\n\n\nhatbeta= 1.1541186403411716\nThe original estimate for the call price from the first sample= 4.791646287615179\nThe original estimate for the call price from the second sample= 4.687624646438363\nThe updated estimate from the first sample is= 4.723553292706219\nThe updated estimate from the second sample is= 4.7803850121968825\nThe average of the updated estimates = 4.751969152451551\n\n\nWe can compare this to the exact Black Scholes formula from before.\n\n\nCode\nprint('The exact Black Scholes Price is=', truebsc)\n\n\nThe exact Black Scholes Price is= 4.759422392871532\n\n\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[A_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\; .\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[K^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\; .\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\\\mathrm{E}^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\; .\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[x = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\; .\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[y =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\; .\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 11.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "title": "13  Monte Carlo Methods",
    "section": "13.4 Monte Carlo Greeks I: Difference Ratios",
    "text": "13.4 Monte Carlo Greeks I: Difference Ratios\nGreeks can be calculated by Monte Carlo by running the valuation program twice and computing a difference ratio, for example \\((C_u-C_d)/(S_u-S_d)\\) to estimate a delta. However, to minimize the error, and minimize the number of computations required, one should use the same set of random draws to estimate the derivative value for different values of the parameter. For path-independent options (e.g., European puts and calls) under the Black-Scholes assumptions, we only need to generate \\(S_T\\) and then we can compute \\(S_u(T)\\) as \\([S_u(0)/S_0] \\times S_T\\) and \\(S_d(T)\\) as \\([S_u(0)/S_0] \\times S_T\\). We can estimate standard errors for the Greeks in the same way that we estimate the standard error of the derivative value.\nActually, there is often a better method available that is just as simple. This is called pathwise calculation. We will explain this in the next section. Here we will describe how to estimate the delta and gamma of a derivative as sample means of difference ratios.\nConsider initial prices for the underlying \\(S_u&gt;S&gt;S_d\\). Denote the underlying price at the option maturity in a given simulation by \\(S_u(T)\\) when the initial underlying price is \\(S_u\\), by \\(S_T\\) when the initial underlying price is \\(S\\), and by \\(S_d(T)\\) when the initial underlying price is \\(S_d\\). Under the Black-Scholes assumptions, the logarithm of the stock price at date \\(T\\) starting from the three initial prices \\(S_d\\), \\(S\\) and \\(S_u\\) is\n\\[\n\\begin{align*}\n\\log S_d(T) &= \\log S_d + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_T &= \\log S + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_u(T) &= \\log S_u + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\;,\n\\end{align*}\n\\] so \\[\\log S_d(T) = \\log S_T + \\log S_d - \\log S\\Longrightarrow S_d(T) = \\left(\\frac{S_d}{S}\\right) S_T\\; ,\\] and \\[\\log S_u(T) = \\log S_T + \\log S_u - \\log S \\Longrightarrow S_u(T) = \\left(\\frac{S_u}{S}\\right) S_T\\; .\\] Therefore, under the Black-Scholes assumptions, we only need to simulate \\(S_T\\) and then perform the multiplications indicated above to obtain \\(S_d(T)\\) and \\(S_u(T)\\).\nConsider a particular simulation and let \\(C_d(T)\\) denote the value of the derivative at maturity when the initial asset price is \\(S_d\\), let \\(C_T\\) denote the value of the derivative at maturity when the initial asset price is \\(S\\), and let \\(C_u(T)\\) denote the value of the derivative at maturity when the initial asset price is \\(S_u\\). For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of \\(S_T\\) as just described. However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).\nThe estimates \\(C_d\\), \\(C\\) and \\(C_u\\) of the date–0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the \\(C_d(T)\\), \\(C_T\\) and \\(C_u(T)\\). One way to estimate the delta is \\((C_u-C_d)/(S_u-S_d)\\). This is a difference of discounted sample means, multiplied by the reciprocal of \\(S_u-S_d\\). Equivalently, it is the sample mean of the differences \\(C_u(T)-C_d(T)\\), multiplied by \\(\\mathrm{e}^{-rT}/(S_u-S_d)\\). The standard error is \\[\n\\frac{\\mathrm{e}^{-rT}}{S_u-S_d}\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^M \\left[C_{ui}(T)-C_{di}(T)\\right]^2 - M\\left[\\overline{C_{u}(T)}-\\overline{C_{d}(T)}\\right]^2\\right)}\\; ,\n\\] where the overline denotes the sample mean and where \\(C_{ui}(T)\\) [respectively, \\(C_{di}(T)\\)] denotes the value of the derivative at maturity in simulation \\(i\\) when the initial asset price is \\(S_u\\) [respectively, \\(S_d\\)].\nThe corresponding Monte Carlo estimate of the gamma is also a sample mean. Simple algebra shows that Equation 14.15 is equivalent to \\[\n\\Gamma = \\frac{2}{(S_u-S)(S_u-S_d)}C_u - \\frac{2}{(S_u-S)(S-S_d)}C +\\frac{2}{(S-S_d)(S_u-S_d)}C_d\\;.\n\\qquad(13.3)\\]\nNormally one would take \\(S_u=(1+\\alpha)S\\) and \\(S_d = (1-\\alpha)S\\) for some \\(\\alpha\\) (e.g., \\(\\alpha=0.01\\)). In this case Equation 13.3 simplifies to \\[\n\\Gamma = \\frac{C_u - 2C + C_d}{\\alpha^2S^2}\\;,\n\\qquad(13.4)\\]\nand the standard error of the gamma is\n\\[\n\\begin{multline*}\\frac{\\mathrm{e}^{-rT}}{\\alpha^2S^2}\\sqrt{\\frac{1}{M(M-1)}}\\\\\n\\times \\sqrt{\\sum_{i=1}^M \\left[C_{ui}(T)-2C_i(T)+C_{di}(T)\\right]^2 -M\\left[\\overline{C_{u}(T)}-2\\overline{C_T}+\\overline{C_{d}(T)}\\right]^2}\\; .\n\\end{multline*}\n\\]",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "title": "13  Monte Carlo Methods",
    "section": "13.5 Monte Carlo Greeks II: Pathwise Estimates",
    "text": "13.5 Monte Carlo Greeks II: Pathwise Estimates\nWe will examine the bias in the Monte Carlo delta estimate discussed in the preceding section and explain pathwise estimation of Greeks. By biased, we mean that the expected value of an estimate is different from the true value. It is important to recognize that if a Monte Carlo estimate is biased, then, even if a large number of simulations is used and the standard error is nearly zero, the answer provided by the Monte Carlo method will be incorrect. For simplicity, consider a European call under the Black-Scholes assumptions.\nThe delta estimate we have considered is the discounted sample mean of \\[\n\\frac{C_u(T) - C_d(T)}{S_u-S_d}\\;.\n\\qquad(13.5)\\]\nThis ratio takes on one of three values, depending on \\(S_T\\):\n\nIf \\(S_u(T) \\leq K\\) then the option is out of the money in both the up and down cases; i.e., \\[C_u(T) = C_d(T) = 0\\; ,\\] so the ratio Equation 13.5 is zero.\nIf \\(S_d(T) \\geq K\\) then the option is in the money in both the up and down cases; i.e.,\n\n\\[\n\\begin{align*} C_u(T) &= S_u(T) - K =\\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d(T) &= S_d(T) - K = \\left(\\frac{S_d}{S}\\right)S_T - K\\;,\n\\end{align*}\n\\]\nso the ratio Equation 13.5 equals \\(S_T/S\\). - If \\(S_u(T) &gt; K &gt; S_d(T)\\), then the option is in the money in only the up case; i.e., \\[\n\\begin{align*}\nC_u(T) &= S_u(T) - K = \\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d(T) &= 0\\;,\n\\end{align*}\n\\] so the ratio Equation 13.5 equals \\[\n\\frac{\\left(\\frac{S_u}{S}\\right)S_T - K}{S_u-S_d} &lt; \\frac{S_T}{S}\\; .\n\\]\nThe bias is induced by the third case above. We can see this as follows. We are trying to estimate \\[\n\\frac{\\partial }{\\partial S} \\mathrm{e}^{-rT}\\\\mathrm{E}^R \\big[\\max(0,S_T-K)\\big] = \\mathrm{e}^{-rT}\\\\mathrm{E}^R  \\left[ \\frac{\\partial }{\\partial S} \\max(0,S_T-K)\\right]\\;.\n\\qquad(13.6)\\]\nThe delta estimate \\((C_u-C_d)/(S_u-S_d)\\) replaces the mean \\(\\\\mathrm{E}^R\\) with the sample mean and replaces \\[\n\\frac{\\partial }{\\partial S} \\max(0,S_T-K)\n\\qquad(13.7)\\]\nwith the ratio Equation 13.5. The derivative Equation 13.7 takes on two possible values, depending on \\(S_T\\)—we can ignore the case \\(S_T=K\\) because it occurs with zero probability:\n\nIf \\(S_T &lt; K\\), then \\(\\max(0,S_T-K) = 0\\) and the derivative is zero.\nIf \\(S_T&gt;K\\), then \\(\\max(0,S_T-K) = S_T-K\\) and the derivative equals \\[\\frac{\\partial S_T}{\\partial S}=\\mathrm{e}^{(r-q-\\sigma^2/2)T + \\sigma B_T} = \\frac{S_T}{S}\\; .\\]\n\nTherefore, the true delta—the expectation Equation 13.6—equals4 \\[\n\\mathrm{e}^{-rT}\\\\mathrm{E}^R\\left[\\frac{S_T}{S} x\\right]\\;,\n\\qquad(13.8)\\]\nwhere \\(x\\) is the random variable defined as \\[\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] On the other hand, our analysis of the ratio Equation 13.5 shows that the expected value of the delta estimate \\((C_u-C_d)/(S_u-S_d)\\) is \\[\n\\mathrm{e}^{-rT}\\\\mathrm{E}^R\\left[\\frac{S_T}{S} y\\right] + \\mathrm{e}^{-rT}\\\\mathrm{E}^R\\left[\\frac{S_uS_T-SK}{S(S_u-S_d)}z\\right]\\;,\n\\qquad(13.9)\\]\nwhere \\[\n\\begin{align*}\ny &=  \\begin{cases} 1 & \\text{if} S_d(T)&gt;K\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\n\\] and \\[\n\\begin{align*}\nz &=  \\begin{cases} 1 & \\text{if} S_u(T)&gt;K&gt;S_d(T)\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\n\\] To contrast Equation 13.8 and Equation 13.9, note that if \\(y=1\\) then \\(x=1\\), so the term \\(\\\\mathrm{E}^R\\left[\\frac{S_T}{S} y\\right]\\) in Equation 13.9 is part of Equation 13.8. However, there are two partially offsetting errors in Equation 13.9: \\(z\\) sometimes equals one when \\(x\\) is zero, and when both \\(z\\) and \\(x\\) are one, then the factor multiplying \\(z\\) is smaller than the factor multiplying \\(x\\). In any case, the expected value Equation 13.9 is not the same as the true delta Equation 13.8. As noted before, this implies that the delta estimate will be incorrect even if its standard error is zero. The bias can be made as small as one wishes by taking the magnitude \\(S_u-S_d\\) of the perturbation to be small, but taking the perturbation to be very small will introduce unacceptable roundoff error.\nThe obvious way to estimate the delta in this situation is simply to compute the discounted sample average of \\([S_T/S]x\\). This is called a pathwise estimate of the delta, because it only uses the sample paths of \\(S_t\\) rather than considering up and down perturbations. This method is due to Broadie and Glasserman (Broadie and Glasserman 1996). Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.\nTo compute pathwise estimates in other models and for other Greeks, we need the Greek to be an expectation as on the right-hand side of Equation 13.6. Additional examples can be found in Glasserman (Glasserman 2004) and J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002).",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "href": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "title": "13  Monte Carlo Methods",
    "section": "13.6 Monte Carlo Models for Path-Dependent Options",
    "text": "13.6 Monte Carlo Models for Path-Dependent Options\nA derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length \\(\\Delta t = T/N\\) for some integer \\(N\\). Under the risk-neutral probability, the logarithm of the stock price changes over such a time period by \\[\n\\Delta \\log S = \\nu\\,\\Delta t + \\sigma\\sqrt{\\Delta t}\\,z\\;,\n\\qquad(13.10)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\) and \\(z\\) is a standard normal. Given that there are \\(N\\) time periods of length \\(\\Delta t\\), we need to generate \\(N\\) standard normals to generate a stock price path. If we generate \\(M\\) paths to obtain a sample of \\(M\\) option values, then we will need to generate \\(MN\\) standard normals.\nConsider for example a floating-strike lookback call. The formula for this option given in Section 12.2 assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing \\(\\Delta t\\) to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting \\(N\\) to be the number of weeks before the option matures.\nFor most path dependent options, a possible starting point is to generate an array of \\(n\\) paths but since we want the entire path we choose the number of time steps that is appropriate for our application. We can use the same code as in @#sec-s:mc_europeans if we are working in a Black Scholes setting.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq=0.0\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Delta t\ndt = T/m\n# Drift\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before this code generates two samples the original and the antithetic. The output is an array of \\(n\\) sample paths with \\(m\\) time steps. The sample can also be used to find the value of a floating strike lookback call.\n\n\nCode\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\nStmin=St[m:]-np.minimum(np.min(St,axis=0),S0)\nSt1min=St1[m:]-np.minimum(np.min(St1,axis=0),S0)\nfloatlkbk=np.exp(-r*T)*np.mean(Stmin)\nfloatlkbk1=np.exp(-r*T)*np.mean(St1min)\n\nprint('The first estimate is=',floatlkbk)\nprint('The second estimate is=',floatlkbk1)\nprint('The average estimate is=',(floatlkbk+floatlkbk1)/2)\nprint('The exact formula is=',floating_strike_call(S0, r, sigma, 0, T, S0))\n\n\nThe first estimate is= 5.45244209168367\nThe second estimate is= 5.468030697490039\nThe average estimate is= 5.460236394586854\nThe exact formula is= 7.231056939691567\n\n\nTo value the fixed strike lookback call option with time \\(T\\) payoff \\(\\max(\\max_{0\\le t \\le T} S_t.0)\\), we simply add the following\n\n\nCode\nStmax=np.maximum(np.max(St,axis=0)-K,0)\nSt1max=np.maximum(np.max(St1,axis=0)-K,0)\nlookbck = np.exp(-r*T) *np.mean(Stmax)\nlookbck1=np.exp(-r * T)*np.mean(St1max)\nprint('The first estimate is=',lookbck)\nprint('The second estimate is=',lookbck1)\nprint('The average estimate is=', (lookbck + lookbck1)/2)\n\n\nThe first estimate is= 7.716467940991822\nThe second estimate is= 7.769558237964809\nThe average estimate is= 7.743013089478316\n\n\nAsian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks.\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[\nA_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\;.\n\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[\nK^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\;.\n\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\n\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\\\mathrm{E}^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\;.\n\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[\nx = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;.\n\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[\ny =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\;.\n\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 11.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.\nAgain we can get a sample of payoffs using our stock price samples.\n\n\nCode\naverage = np.mean(St,axis=0)\naverage1 = np.mean(St1,axis=0)\ndpayoff=np.exp(-r*T)*np.mean(np.maximum(average-K,0))\ndpayoff1=np.exp(-r*T)*np.mean(np.maximum(average1-K,0))\nprint('The first estimate is=',dpayoff)\nprint('The second estimate is=',dpayoff1)\nprint('The average of the estimates=',(dpayoff+dpayoff1)/2)\n\n\nThe first estimate is= 3.231154315344899\nThe second estimate is= 3.296876297130776\nThe average of the estimates= 3.2640153062378374\n\n\nWe now construct a control variate, the geometric asian option which has a known formula for its value.\n\n\nCode\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\ngeom=np.exp((np.mean(np.log(St),axis=0)))\ngeom1=np.exp((np.mean(np.log(St1),axis=0)))\ngeomavgpo=np.maximum(geom-K,0)\ngeomavg1po=np.maximum(geom1-K,0)\nvalue=np.mean(geomavgpo)*np.exp(-r*T)\nvalue1=np.mean(geomavg1po)*np.exp(-r*T)\ntga=discrete_geom_average_price_call(S0, K, r, sigma, q, T, m)\nerror =tga-value\nerror1=tga-value1\nprint('The estimate from the first sample=',value)\nprint('The estimate from the second sample=',value1)\nprint('The average of the two estimates is=',(value+value1)/2)\nprint('The value from the exact formula=',tga)\nprint('The error in the first estimate=',error)\nprint('The error in the second estimate=',error1)\n\n\nThe estimate from the first sample= 3.172076049997697\nThe estimate from the second sample= 3.236566795172543\nThe average of the two estimates is= 3.20432142258512\nThe value from the exact formula= 2.6835589764289125\nThe error in the first estimate= -0.4885170735687847\nThe error in the second estimate= -0.5530078187436307\n\n\nNext we estimate the beta. As discussed before, we could simply set beta=1. Alternatively, if we estimate beta from the simulated sample, then our update could be biased. Instead we compute an independent sample from which we estimate beta. We then estimate the updated estimate for both samples from the formula \\[\n\\text{new estimate} = \\text{original estimate} + \\beta * \\text{error}\n\\]\n\n\nCode\nincpre = np.zeros(shape = (m + 1, n))\nincpre[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nStpre = np.zeros(shape = (m + 1, n))\nSt1pre=np.zeros(shape = (m + 1, n))\nStpre = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1pre = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\namean=np.mean(Stpre,axis=0)\namean1=np.mean(St1pre,axis=0)\napo = np.maximum(amean-K,0)\na1po=np.maximum(amean1-K,0)\ngmean=np.exp(np.mean(np.log(St),axis=0))\ng1mean=np.exp(np.mean(np.log(St1),axis=0))\ngpo=np.maximum(gmean-K,0)\ng1po=np.maximum(g1mean-K,0)\nbeta=np.cov(gpo,apo)[0,1]/np.cov(gpo,apo)[1,1]\nbeta1=np.cov(g1po,a1po)[0,1]/np.cov(g1po,a1po)[1,1]\nupdate=dpayoff +beta*error\nupdate1=dpayoff1+beta1*error1\n\nprint('The updated estimate for the first sample=',update)\nprint('The updated value for the second sample=',update1)\nprint('The average of the updated values is=',(update +update1)/2)\n\n\nThe updated estimate for the first sample= 2.7518403446698483\nThe updated value for the second sample= 2.7538925235582683\nThe average of the updated values is= 2.7528664341140585",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "href": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "title": "13  Monte Carlo Methods",
    "section": "13.7 Monte Carlo Valuation of Basket and Spread Options",
    "text": "13.7 Monte Carlo Valuation of Basket and Spread Options\n In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. There are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.\nThe difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral probability). In an \\(N\\)–period model, the binomial model produces \\(N+1\\) values for the terminal price of each underlying asset. Letting \\(k\\) denote the number of underlying assets, this produces \\((N+1)^k\\) combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces \\(M\\) combinations of terminal prices, where \\(M\\) is the number of simulations. Each combination is given the same weight (\\(1/M\\)) when estimating the expected value.\nWith a single underlying asset, the binomial model is more efficient, as discussed in Section 14.1, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the \\((N+1)^k\\) combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.\nTo implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. We can simulate the changes in two Brownian motions \\(B_1\\) and \\(B_2\\) that have correlation \\(\\rho\\) by generating two independent standard normals \\(Z_1\\) and \\(Z_2\\) and defining \\[\n\\Delta B_1 = \\sqrt{\\Delta t}\\,Z_1\\;, \\qquad \\text{and} \\qquad \\Delta B_2 = \\sqrt{\\Delta t}\\,Z\\; ,\n\\] where \\(Z\\) is defined as \\[\nZ = \\rho Z_1 + \\sqrt{1-\\rho^2}\\,Z_2\\;.\n\\] The random variable \\(Z\\) is also a standard normal, and the correlation between \\(Z_1\\) and \\(Z\\) is \\(\\rho\\).\n\n\nCode\n# Simulate 2 Geometric Brownian Motions\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq1=0.0\nq2=0\n# Volatility\nsig1 = 0.2\nsig2=.3\n# correlation\nrho=0.5\n# Initial Stock Price\nS0 = 42\nV0 = 50\n# Maturity\nT = 0.5\n\n# Delta t\ndt = T/m\n# Drift\ndrift1 = (r-q1-0.5*sig1**2)\ndrift2 = (r-q2-0.5*sig2**2)\n# Volatility\nvol = np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\ninc1 = np.zeros(shape = (m + 1, n))\ninc1[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nincr = np.zeros(shape = (m + 1, n))\nincr = rho*inc + np.sqrt(1-rho**2)*inc1\n\n\nThus, we can simulate the changes in the logarithms of two correlated asset prices as \\[\\begin{align*}\n\\Delta \\log S_1 &= \\nu_1\\Delta t + \\sigma_1\\sqrt{\\Delta t}Z_1 \\; ,\\\\\n\\Delta \\log S_2 &= \\nu_2\\Delta t + \\sigma_2\\rho\\sqrt{\\Delta t}Z_1 + \\sigma_2\\sqrt{1-\\rho^2}\\sqrt{\\Delta t}Z_2\\;,\n\\end{align*}\\] where \\(\\nu_i = r-q_1-\\sigma_i^2/2\\) and the \\(Z_i\\) are independent standard normals.\n\n\nCode\nSt1 = np.zeros(shape = (m + 1, n))\nSt2 = np.zeros(shape = (m + 1, n))\nSt1 = S0 * np.exp(sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2 = V0 * np.exp(sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nWe can also construct antithetic variables.\n\n\nCode\nSt1a = np.zeros(shape = (m + 1, n))\nSt2a = np.zeros(shape = (m + 1, n))\nSt1a = S0 * np.exp(-sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2a = V0 * np.exp(-sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nGiven this sample, we can estimate the value of a best of 2 option with payoff \\(\\max(S_{1T},S_{2T})\\).\n\n\nCode\npayoff = np.maximum(St1[m,:],St2[m,:])\npayoffa = np.maximum(St1a[m,:],St2a[m,:])\nvalue= np.exp(-r*T)*np.mean(payoff)\nvaluea= np.exp(-r*T)*np.mean(payoffa)\n\nprint('The first estmate is =',value)\nprint('The second estimate is =',valuea)\nprint('The avergae of the estimates is=',(value+valuea)/2)\n\n\nThe first estmate is = 50.11374784508302\nThe second estimate is = 51.46596027225067\nThe avergae of the estimates is= 50.78985405866685\n\n\nTo generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as\n\\[\n\\Delta \\log S_1 = \\nu_1\\Delta t + a_{11}\\sqrt{\\Delta t}Z_1 + a_{12}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(13.11)\\]\n\\[\n\\Delta \\log S_2 = \\nu_2\\Delta t + a_{21}\\sqrt{\\Delta t}Z_1 + a_{22}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(13.12)\\]\nwhere \\[\\begin{array}{rclcrcl}\na_{11}&=&\\sigma_1\\;, &\\qquad & a_{12}&=&0\\; ,\\\\\na_{21}&=&\\sigma_2\\rho\\;, &\\qquad & a_{22} &= &\\sigma_2\\sqrt{1-\\rho^2}\\;.\n\\end{array}\n\\]\nThese are not the only possible choices for the constants \\(a_{ij}\\). Given that \\(Z_1\\) and \\(Z_2\\) are independent standard normals, the conditions the \\(a_{ij}\\) must satisfy in order to match the variances \\(\\sigma_i^2\\Delta t\\) and correlation \\(\\rho\\) of the changes in the logarithms are\n\\[\na_{11}^2+a_{12}^2 =\\sigma_1^2\\;,\n\\qquad(13.13)\\]\n\\[\na_{21}^2+a_{22}^2 =\\sigma_2^2\\;,\n\\qquad(13.14)\\]\n\\[\na_{11}a_{21}+a_{12}a_{22} = \\sigma_1\\sigma_2\\rho\\;.\n\\qquad(13.15)\\]\nThese three equations in the four coefficients \\(a_{ij}\\) leave one degree of freedom. We choose to take \\(a_{12}=0\\) and then solve for the other three.\nIn matrix notation, the system Equation 13.13 - Equation 13.15 plus the condition \\(a_{12}=0\\) can be written as the equation \\[\n\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}^\\top = \\begin{pmatrix}\\sigma_1^2 & \\rho\\sigma_1\\sigma_2 \\\\\\rho\\sigma_1\\sigma_2 & \\sigma_2^2\\end{pmatrix}\\; ,\n\\] where \\(^\\top\\) denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the \\(a_{ij}\\) so that the lower triangular matrix \\[\nA \\equiv \\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\n\\] satisfies \\[\nAA^\\top = \\text{covariance matrix}\n\\] is called the the Cholesky decomposition of the covariance matrix. Given any number \\(L\\) of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the \\(L\\times L\\) covariance matrix always exists. An algorithm for computing the Cholesky decomposition in numpy is np.linalg.cholesky.\nWe can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.5 If there were some path dependency in the option value, we would simulate the paths of the asset prices as in Equation 13.11 - Equation 13.12. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date \\(T\\), as in Section 13.1. The value of a basket call option at its maturity \\(T\\) is \\[\n\\max\\left(0,\\;\\sum_{i=1}^L w_iS_i(T)-K\\right)\\; ,\n\\] where \\(L\\) is the number of assets in the basket (portfolio) and \\(w_i\\) is the weight of the \\(i\\)–th asset in the basket. The logarithm of the \\(i\\)–th asset price at maturity is simulated as \\[\n\\log S_i(T) = \\log S_i(0) +\\nu_iT + \\sqrt{T} \\sum_{j=1}^L a_{ij}Z_j\\; ,\n\\] where the \\(Z_j\\) are independent standard normals. Given the simulated values of the \\(\\log S_i(T)\\), the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.\nFor our two asset example we compute the value of a call opttion on an equally weighted porfotlio.\n\n\nCode\nw=0.5\nK=45\nbasketpo=np.maximum(w*St1[m,:]+(1-w)*St2[m,:]-K,0)\nbasketpoa=np.maximum(w*St1a[m,:]+(1-w)*St2a[m,:]-K,0)\nestimate=np.exp(-r*T)*np.mean(basketpo)\nestimatea=np.exp(-r*T)*np.mean(basketpoa)\nprint('The first estimate is =',estimate)\nprint('The second estimate is =',estimatea)\nprint('The average of the estimates=',(estimate+estimatea)/2)\n\n\nThe first estimate is = 4.4030641748675095\nThe second estimate is = 4.945665333101932\nThe average of the estimates= 4.674364753984721\n\n\nBelow is a three asset basket option whihc uses the numpy cholesky decomposition. In contrast to the above routine, this routine is does not have the option to generate the entire path, although this can be easily modeified.\n\n\nCode\nimport numpy as np\n#risk free rate\nr=0.1\n# number of assets\nk=3\n\n# number of paths\nn=100000\n# Horizon\nT=0.5\n\n# Initial price\n\nS0=[42,50,45]\n\n# Basket Weights\nw=[.25,.5,.25]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n# drift of log returns\n\ndrift= r*np.ones(k) -0.5*np.dot(S@S,np.ones(k))\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n# covariance matrix\n\nV = S@rho@S\n\n# generate uniform n*k normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc1=np.transpose(np.random.normal(loc = 0, scale = np.sqrt(T),size = (n,k)))\n \n\n\n# create correlated random variables\nZ=np.linalg.cholesky(V)\nincr=np.dot(Z,inc1)\n\nprint('The sample correlation matrix =',np.corrcoef(incr))\nprint('The input correlation matrix =',rho)\n\n\n\n\nSt = S0 * np.exp(drift *T + np.transpose(incr))\n#antithetic sample\nSt1 = S0 * np.exp( drift * T - np.transpose(incr))\n\nestimate=np.mean(St,axis=0)*np.exp(-r*T)\nestimate1=np.mean(St1,axis=0)*np.exp(-r*T)\nprint('The average discounted stock price averaged over both samples=',(estimate+estimate1)/2)\nprint('The initial Srock Price input =',S0)\n\nbasketpo=np.maximum(w@np.transpose(St)-K,0)\nbasketpo1=np.maximum(w@np.transpose(St1)-K,0)\nvalue=np.mean(basketpo)*np.exp(-r*T)\nvalue1=np.mean(basketpo1)*np.exp(-r*T)\nprint('The first sample estimate of the basket option value=',value)\nprint('The second sample estimate of the basket option value=',value1)\nprint('The average estimate of the basket option value=',(value+value1)/2)\n\n\nThe sample correlation matrix = [[1.         0.50356746 0.30497838]\n [0.50356746 1.         0.20383175]\n [0.30497838 0.20383175 1.        ]]\nThe input correlation matrix = [[1.  0.5 0.3]\n [0.5 1.  0.2]\n [0.3 0.2 1. ]]\nThe average discounted stock price averaged over both samples= [42.00560021 50.00484037 45.01680115]\nThe initial Srock Price input = [42, 50, 45]\nThe first sample estimate of the basket option value= 5.335894164783821\nThe second sample estimate of the basket option value= 5.2893530512000515\nThe average estimate of the basket option value= 5.312623607991936\n\n\nWe can generate the entire path of multiple assets to value, for example, lookback options on a basket. The code below values the same European basket option as above only it calculates \\(m=2\\) time steps; a lookback can be created by changing the payoffs and increasing \\(m\\).\n\n\nCode\nimport numpy as np\n#number of time steps\nm=2\n# number of assets\nk=3\n# number of sample paths\nn=100000\n\n#risk free rate\nr=0.1\n\n\n\n# Horizon\nT=0.5\n# delta t\ndt=T/m\n# Initial price\n\nS0=[42,50,45]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n\n# covariance matrix\n\nV = S@rho@S\n\n# drift of log returns\ndrift= np.array(r*np.ones(k) -0.5*np.dot(S@S,np.ones(k)))*dt\n\n# times vector\nt=np.array(range(1,m + 1,1))\n\n\ndriftv = np.transpose(np.kron(drift,t).reshape(3,m))\n\n# generate uniform n(paths)*k(assets)*m(time steps) normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc=np.random.normal(loc = 0, scale = np.sqrt(dt),size = (n,k,m))\n\n#create correlated random increments\nZ=np.linalg.cholesky(V)\n# numpy matmul assumes last two define matrix multiplication\nincr=np.matmul(Z,inc)\n\n\n\nSSt=S0*np.exp(driftv)\n\n# generate returns along path and antithetic path\n# first e^{cumsum(increments)} gives e^sigma B_t for different t\n\nStb = np.exp(np.cumsum(incr[:,:,],axis=2))\nStb1 = np.exp(-np.cumsum(incr[:,:,],axis=2))\n\n\n#Multiply by S0 e^drift for each t\nSt=np.multiply(Stb,np.transpose(SSt))\nSt1=np.multiply(Stb1,np.transpose(SSt))\n\n#Last date returns\nStm=St[:,:,m-1]\nStm1=St1[:,:,m-1]\n\n#define payoff\n# Basket Weights\nw=[.25,.5,.25]\n\n\npayoff= np.maximum(np.matmul(Stm,np.transpose(w))-K,0)\npayoff1= np.maximum(np.matmul(Stm1,np.transpose(w))-K,0)\n\n\nvalue= np.exp(-r*T)*np.mean(payoff)\nvalue1= np.exp(-r*T)*np.mean(payoff1)\nprint('The estimate for the first sample value=',value)\nprint('The estimate for the second sample value=',value1)\nprint('The average estimate for the value=',(value+value1)/2)\n\n\nThe estimate for the first sample value= 5.310173600480473\nThe estimate for the second sample value= 5.287928240443308\nThe average estimate for the value= 5.299050920461891\n\n\n\n\n\n\nBoyle, P. 1977. “Options: A Monte Carlo Approach.” Journal of Financial Economics 4: 323–38.\n\n\nBrandimarte, P. 2002. Numerical Methods in Finance: A MATLAB-Based Introduction. Wiley, New York.\n\n\nBroadie, M., and P. Glasserman. 1996. “Estimating Security Price Derivatives Using Simulation.” Management Science 42: 269–85.\n\n\n———. 1997. “Pricing American-Style Securities Using Simulation.” Journal of Economic Dynamics and Control 21: 1323–52.\n\n\nClewlow, L., and C. Strickland. 1998. Implementing Derivatives Models. Wiley, New York.\n\n\nGlasserman, P. 2004. Monte Carlo Methods in Financial Engineering. Springer, New York Berlin Heidelberg.\n\n\nJäckel, P. 2002. Monte Carlo Methods in Finance. Wiley, New York.\n\n\nLongstaff, F., and E. Schwartz. 2001. “Valuing American Options by Simulation: A Simple Least-Squares Approach.” Review of Financial Studies 14: 113–47.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#footnotes",
    "href": "Chapter_MonteCarlo.html#footnotes",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "Boyle~(Boyle 1977) introduced Monte-Carlo methods for derivative valuation, including the variance-reduction methods of control variates and antithetic variates to be discussed later↩︎\nMonte-Carlo methods for valuing early exercise include the stochastic mesh method of Broadie and Glasserman (Broadie and Glasserman 1997) and the regression method of Longstaff and Schwartz (Longstaff and Schwartz 2001). Glasserman (Glasserman 2004) provides a good discussion of these methods and the relation between them.↩︎\n The negative correlation between \\(x\\) and \\(y\\) is essential for this method to generate a real gain in efficiency. To generate \\(M\\) simulations of \\(z\\), one must generate \\(M\\) simulations of \\(x\\) and \\(M\\) of \\(y\\), which will generally require about as much computation time as generating \\(2M\\) simulations of \\(x\\). If \\(x\\) and \\(y\\) were independent, the standard error from \\(M\\) simulations of \\(z\\) would be the same as the standard error from \\(2M\\) simulations of \\(x\\), so using the antithetic variate would be no better than just doubling the sample size for \\(x\\).↩︎\nBy changing numeraires, we can show that Equation 13.8 equals \\(\\mathrm{e}^{-qT}\\\\mathrm{E}^V[x] = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)\\), as we know from Chapter 9 is the delta of a European call in the Black-Scholes model (here, as in Chapter 9, \\(V_t=\\mathrm{e}^{qt}S_t\\) denotes the value of the dividend-reinvested portfolio created from the stock).↩︎\nFor a spread option, take \\(L=2\\), \\(w_1=1\\) and \\(w_2=-1\\).↩︎",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html",
    "href": "Chapter_Binomial.html",
    "title": "14  Binomial and Trinomial Models",
    "section": "",
    "text": "14.1 Introduction to Binomial Models\nIn this chapter, we will introduce two principal numerical methods for valuing derivative securities: Monte Carlo and binomial models. We will consider two applications: valuing European options in the presence of stochastic volatility with Monte Carlo and valuing American options via binomial models. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.\nAs in the previous section, we will work with the dynamics of the logarithms of asset prices under the risk-neutral probability. Thus, our starting point is the equation \\[\n\\mathrm{d}  \\log S = \\left(r-q-\\frac{\\sigma^2}{2}\\right)\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\;,\n\\qquad(14.1)\\]\nwhere \\(B\\) represents a Brownian motion under the risk-neutral probability.\nIn the binomial model, we assume that if the stock price is \\(S\\) at the beginning of the period, it will be either \\(uS\\) or \\(dS\\) at the end of the period, where the multiplicative factors \\(u\\) and \\(d\\) are constants to be determined. This means that the rate of return is \\(\\Delta S/S = u\\!-\\!1\\) in the up state and \\(\\Delta S/S = d\\!-\\!1\\) in the down state. There are three parameters to the model: \\(u\\), \\(d\\), and the probability \\(p\\) of the up state (the probability of the down state being necessarily \\(1\\!-\\!p\\)).\nA tree constructed like this is recombining in the sense that the stock price after an up-down sequence is the same as after a down-up sequence. This is very important for reducing the computation time. For example, the number of nodes at the final date is \\(N+1\\) in a recombining tree, where \\(N\\) is the number of periods, but it is \\(2^N\\) for a non-recombining (sometimes called bushy) tree. Hence, the computation time will increase linearly with \\(N\\) for a recombining tree but exponentially with \\(N\\) for a non-recombining tree. Unfortunately, this computational savings is generally not possible for path-dependent options, because the number of distinct paths through a tree (whether recombining or not) is again \\(2^N\\).\nThe value of a European derivative is of course the discounted expectation of its value at maturity, discounting at the risk-free rate and taking the expectation under the risk-neutral probability. The binomial tree allows us to approximate the expectation very easily. We simply sum over the nodes of the tree at the option maturity and weight each node by its binomial probability. In an \\(N\\)-period model, the probability of the top node is \\(p^N\\), since the stock must go up each time to reach the top node. There are \\(N\\) paths reaching the second node from the top (since the period of the single down move could be any one of the \\(N\\) periods) and each such path has probability \\(p^{N-1}(1-p)\\); therefore, the probability of reaching the second node from the top is \\(Np^{N-1}(1-p)\\). More generally, the probability of going up \\(i\\) times and down \\(N-i\\) times is \\[\\frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\\; ,\\] where as usual \\(x!\\) denotes \\(x\\) factorial. Therefore, the expectation, for a European call option, is the following sum over the \\(N+1\\) nodes at date \\(N\\) (starting with \\(i=0\\) up moves and ending with \\(i=N\\) up moves): \\[\n\\sum_{i=0}^N \\frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\\max(u^id^{N-i}S-K,0)\\;.\n\\qquad(14.2)\\]\nMultiplying the expectation by \\(\\mathrm{e}^{-rT}\\) yields the option value.\nIt is worthwhile to emphasize the close connection between this method and the Monte-Carlo method discussed in the previous section. In the Monte-Carlo method for valuing a European call option, we generate \\(M\\) random values for \\(S_T\\) and estimate the expectation \\(\\\\mathrm{E}^R[\\max(0,S_T-K)]\\) by averaging the \\(M\\) values. This amounts to approximating the distribution of \\(S_T\\) by an \\(M\\)–point distribution, each point being assigned equal probability. In the binomial method, we choose a particular set of points for \\(S_T\\) and assign the probabilities specified above in order to approximate the distribution of \\(S_T\\). Both the Monte-Carlo and the binomial approximations are known to converge to the continuous-time distribution of \\(S_T\\) as the number of points increases. However, by specifically choosing the points and their probabilities, the binomial method allows us to use a much smaller number of points to obtain the same accuracy; i.e., for a given desired accuracy, we can use many fewer periods \\(N\\) in the binomial model than we would need simulations \\(M\\) in the Monte-Carlo method. Thus, the binomial method will be much faster. Furthermore, as we will discuss in the next section, the binomial method is much better for pricing American options. On the other hand, as mentioned in the previous section, to value a path-dependent option in an \\(N\\)–period binomial tree would require the analysis of \\(2^N\\) separate paths, so Monte Carlo may be faster for path-dependent options. Finally, as we will discuss in Section 14.6, Monte Carlo may be faster for options on multiple assets.\nThere is an important alternative method for calculating the sum Equation 14.2, which is usually called backward induction. We will describe it here and implement it in the next section to value American options. We begin at the last date, where there are \\(N+1\\) nodes. We calculate the option value at each of these nodes, storing the value at the bottom node as \\(C_0\\), the value at the next node up as \\(C(1)\\), etc. This is illustrated in the diagram on the next page. Then we step back to the penultimate date. At each node at this date, we calculate the option value as the discounted expectation of its value at the last date. From each node, there are two nodes that can be reached at the next date, corresponding to a down move or an up move. So, the option value is calculated as \\[\nC = \\mathrm{e}^{-r\\Delta t}p\\,C_{\\text{up}} + \\mathrm{e}^{-r\\Delta t}(1-p)C_{\\text{down}}\\;.\n\\qquad(14.3)\\]\nIn terms of the vector notation shown in the figure below, the down move from node \\(i\\) is also node \\(i\\) and the up move is \\(i+1\\). So, we write over the elements of the \\(C\\) vector as \\[\nC(i) = \\mathrm{e}^{-r\\Delta t}p\\,C(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)C(i)\\;.\n\\qquad(14.4)\\]\nDiscounting back through the tree like this, we reach date \\(0\\) and return the option value as \\(C_0\\). The virtue of this procedure is that it calculates a value for the option at each node in the tree, the value being the discounted expectation of the subsequent values attained by the option. This approach is essential for assessing the value of early exercise.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:introbinomial",
    "href": "Chapter_Binomial.html#sec-s:introbinomial",
    "title": "14  Binomial and Trinomial Models",
    "section": "",
    "text": "Figure 14.1: Enter parameters below to generate binomial trees for an underlying asset price and an option. The left sidebar has user controls. If it is not visible, use the  icon at the top of the figure to open it. The interest rate should be the rate per period and should be adjusted based on the number of periods. The “up move” parameter corresponds to the parameter \\(u\\) in the text as \\(u=1+\\) “up move.” The figure takes \\(d=1/u\\). Notice that the vertical axis is reverse ordered for put options, because higher stock prices produce lower put values.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:binomialparameters",
    "href": "Chapter_Binomial.html#sec-s:binomialparameters",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.2 Binomial Parameters",
    "text": "14.2 Binomial Parameters\nSeveral different ways have been proposed for matching the binomial model to the continuous-time model. Consider an \\(N\\)–period binomial model for a time period of \\(T\\) years. This means that the length of each period is \\(\\Delta t = T/N\\). In the continuous-time model, over a discrete time period \\(\\Delta t\\), we have \\[\\Delta \\log S =\\mathrm{n}u\\,\\Delta t + \\sigma\\,\\Delta B\\; ,\\] where \\(\\mathrm{n}u = r-q-\\sigma^2/2\\) and \\(B\\) is a Brownian motion under the risk-neutral probability. The mean and variance, under the risk-neutral probability, of \\(\\Delta \\log S\\) in the continuous-time model are \\[\\begin{align*}\n\\\\mathrm{E}^R[\\Delta \\log S] &= \\mathrm{n}u\\,\\Delta t\\; ,\\\\\n\\mathrm{var}^R[\\Delta \\log S]&=\\sigma^2\\Delta t\\; ,\n\\end{align*}\\] so \\[\\begin{align*}\n\\frac{\\\\mathrm{E}^R[\\Delta \\log S]}{\\Delta t} &= \\mathrm{n}u\\; ,\\\\\n\\frac{\\mathrm{var}^R[\\Delta \\log S]}{\\Delta t}&=\\sigma^2\\;.\n\\end{align*}\\] In the binomial model, we have \\[\\begin{align*}\n\\frac{\\\\mathrm{E}^R\\big[\\Delta \\log S\\big]}{\\Delta t} &=\\frac{p\\,\\log u+(1-p)\\log d}{\\Delta t}\\; ,\\\\\n\\frac{\\mathrm{var}^R\\big[\\Delta \\log S\\big] }{\\Delta t}&=\\frac{p\\,(1-p)(\\log u-\\log d)^2}{\\Delta t}\\;.\n\\end{align*}\\] In order for the binomial model to converge in the appropriate sense to the continuous-time model as the number of periods \\(N \\rightarrow \\infty\\) keeping the total amount of time \\(T\\) fixed (equivalently, as \\(\\Delta t \\rightarrow 0\\)), it is sufficient that \\[\\begin{align*}\n\\frac{p\\log u+(1-p)\\log d}{\\Delta t} &\\rightarrow \\mathrm{n}u\\; ,\\\\\n\\frac{p\\,(1-p)(\\log u-\\log d)^2}{\\Delta t} &\\rightarrow \\sigma^2\\;.\n\\end{align*}\\]\nThe most popular model is probably that proposed by Cox, Ross and Rubinstein (Cox, Ross, and Rubinstein 1979), who set \\(d=1/u\\) and\n\\[\nu = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}\\;,\n\\qquad(14.5)\\]\n\\[\np = \\frac{\\mathrm{e}^{(r-q)\\Delta t}-d}{u-d}\\;.\n\\qquad(14.6)\\]\nAnother well-known model is that of Jarrow and Rudd (Jarrow and Rudd 1983), who take \\(p=1/2\\) and\n\\[\nu = \\exp\\left(\\left((r-q-\\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma\\sqrt{\\Delta t}\\right)\\;,\n\\qquad(14.7)\\]\n\\[\nd = \\exp\\left(\\left((r-q-\\frac{1}{2}\\sigma^2\\right)\\Delta t - \\sigma\\sqrt{\\Delta t}\\right)\\;.\n\\qquad(14.8)\\]\nYet another method is proposed by Leisen and Reimer (Leisen and Reimer 1996), and Jackson and Staunton (Jackson and Staunton 2001) show that it is more efficient for approximating the Black-Scholes value of a European option than are the Cox-Ross-Rubinstein and Jarrow-Rudd trees.\nFor illustration, the Cox-Ross-Rubinstein tree will be implemented below.\n\nBinomial Valuation of European Options\nThe binomial model for path-independent European options can be implemented as follows. We will use the Cox-Ross-Rubinstein parameters. We first define the binomial parameters and some useful constants, denoting the probability \\(p\\,\\) of an up move as \\(pu\\) and the probability \\(1-p\\) of a down move as \\(pd\\). The routine below uses the combinatoric function comb(N,i) to compute the term \\(\\frac{N !}{i! (N-i)!}\\).\n\n\nCode\nimport numpy as np\nfrom scipy.special import comb\n# Binomial Model for European Option\n\nr = .1 # interest rate\nsig = .2 # volatility\nT = .5 # Expiration\nq = div = 0.0 # Dividend\nS0 = 42 # initial stock price\nK = 40 # strike price\ntimes =100 # Number of steps\ndt = T/times\ndelt = np.exp(-div*dt)\na = np.exp(r*dt)*delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu  = (a-d)/(u-d)\npd = 1-pu\nvec = np.arange(times + 1)\nvec1 = np.array([1] * (times + 1))\nS = np.array([0] * (times + 1))\nS = S0*u**(2*vec-times*vec1)\nC =  np.maximum(S-K*vec1,0*vec1)\nCC =  comb((times)*vec1,(times)*vec1-vec)*pu**(vec)*pd**(times*vec1-vec)*C\nCall = sum(CC)*np.exp(-r*T)\nprint('The Value of the European Call is=',Call)\n\n\nThe Value of the European Call is= 4.76181835776333\n\n\nThe Black Scholes value is shown below.\n\n\nCode\nfrom scipy import stats\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return -np.exp(-q*T)*S0 * norm.cdf(-d1,0,1) +K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc = blackscholes(S0,K,r, div, sig,T)\nprint('The exact Black Scholes Price is=', truebsc)\n\n\nThe exact Black Scholes Price is= 4.759422392871532\n\n\nAn alternative way to calculate te value of the call is to use a loop. This takes longer to run but is perhaps easier to understand.\n\n\nCode\nfor i in range(times+1):\n    S[i] = S0*u ** (2*i-times)\n    C[i] =  max(S[i]-K,0)\n\n    CC[i] =  comb((times),(i))*pu ** (i)*pd ** (times-i)*C[i]\n\n\n\nCall = sum(CC)*np.exp(-r*T)\nprint('The Value of the European Call is=',Call)\n\n\nThe Value of the European Call is= 4.76181835776333",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#binomial-models-for-american-options",
    "href": "Chapter_Binomial.html#binomial-models-for-american-options",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.3 Binomial Models for American Options",
    "text": "14.3 Binomial Models for American Options\nEarly exercise features are very simple to handle in a binomial framework. One only has to use the backward induction approach and check the optimality of early exercise at each node. Exercise is optimal when the intrinsic value of the option exceeds the discounted expected value of the option contingent on not exercising. When we back up in the tree, we check whether exercise is optimal, and, when it is, we replace the discounted expected value with the intrinsic value.\nEarly exercise is more important for puts than for calls (an American call on a dividend-reinvested asset should not be exercised early) so we will change our symbol for the option value from \\(C\\) to \\(P\\). For a put option, we would calculate the value at each node at the end of the tree as described in the previous section: \\[\nP(i) = \\max\\left(0,K-u^{i}d^{N-i}S\\right)\\;,\n\\qquad(14.9)\\]\nfor \\(i=0,\\ldots,N\\). For a European put, we would also back up in the tree in accord with Equation 14.4: \\[\nP(i) = \\mathrm{e}^{-r\\Delta t}p\\,P(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)P(i)\\;.\n\\qquad(14.10)\\]\nTo accommodate early exercise, we simply need to assign to \\(P(i)\\) the larger of this value and the value of early exercise. At node \\(i\\) at date \\(n\\) the stock price is \\(u^{i}d^{n-i}S\\) and the intrinsic value of a put option is \\(\\max(0,K-u^{i}d^{n-i}S)\\). Therefore we replace Equation 14.10 with \\[\nP(i) = \\max\\big(K-u^{i}d^{n-i}S, \\;\\mathrm{e}^{-r\\Delta t}p\\,P(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)P(i)\\big)\\;.\n\\qquad(14.11)\\]\nThis will be explained in more detail later.\n\nBinomial Valuation of American Options\nWe will consider an American put. It may also be optimal to exercise an American call early, if there is a positive dividend yield, and the same procedure can be used for American calls. We begin as in the previous subsection by defining the binomial parameters, some useful constants, and the stock price at the last date. We also record the value of the lowest stock price where we exercise at the last date \\(ex[n]\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n# dividend yield\ny = 0\n\n# calculate parameters for binomial model\ndt = T/n\ndelt = np.exp(-y*dt)\na = np.exp(r*dt) * delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu = (a-d)/(u-d)\npd = 1-pu\n# Build vector of ending values\n# and prices for which put is exercised\nex = np.zeros(n+1)\nS = np.zeros(n+1)\nAP = np.zeros(n+1)\n\nfor j in range(n+1):\n    S[j] = S0*u**(2*j-n)\n    AP[j] = max(K-S[j],0)\n    if AP[j]&gt;0:\n        ex[n] = S[j]\n\n\nNow we do the backward induction. Note that a period is the time period between successive dates. In a one-period model, there are two dates (the beginning and end) and in general there are \\(N+1\\) dates in an \\(N\\)–period model. We index the dates as \\(i=0,\\ldots,N\\). At each date we start by defining the stock price at the bottom node. At date \\(i\\) there have been \\(i\\) past periods, so the bottom node corresponds to \\(i\\) down moves. The put value at each node is computed as the larger of the discounted expected value and the value of immediate exercise (the intrinsic value). Having already dealt with the bottom node (\\(j=0\\)) we loop over the nodes \\(j=1,\\ldots,i\\) at each date \\(i\\), increasing the stock price by a factor of \\(u^2\\) each time. When we have backed up to date \\(0\\), we return the put value \\(AP_0\\), the value at the bottom node, which is the only node at date \\(0\\).\n\n\nCode\nfor i in range(n):\n    S = np.zeros(n-i)\n    P = np.zeros(n-i)\n    PP = np.zeros(n-i)\n    for j in range(n-i):\n        S[j] = S0*u**(2*j-(n-i-1))\n        #\n        # P calculates the value of early exercise\n        P[j] = max(K-S[j],0)\n        #\n        # PP calculates value of waiting using payoffs\n        # from next period\n        PP[j] = (pu*AP[j+1] + pd*AP[j])/a\n        #\n        # AP is the max of ealry exercise and waiting\n        AP[j] = max(P[j],PP[j])\n        #\n        # ex is price where early exercise is optimal\n        if P[j] &gt; PP[j]:\n            ex[n-i] = S[j]\n        if ex[n-i]==0:\n           ex[n-i]=np.nan\n               \n\nprint('The value of the American Put is=',AP[0])\nplt.figure(figsize=(9,6))\nplt.plot(dt*np.arange(n+1),ex)\n\n\nThe value of the American Put is= 1.643396346909605\n\n\n\n\n\n\n\n\n\nThe above code runs slowly due to the loops and looping is inefficient in Python. Below we provide a code which generatee the same answer except one of the loops is replaced by vector calculations. The program creates the stock price for each time in a vector and uses vector comparisons to calcualte the maximum of the early exercise and waiting. To understand the code, it is probably a good idea to print out vec1 and vec to see how the exponents are calulated at each node. This procedure is necessary to speed up the execution since loops are inefficient in Python.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n# dividend yield\ny = 0\n\ndt = T/n\ndelt = np.exp(-y*dt)\na = np.exp(r*dt) * delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu = (a-d)/(u-d)\npd = 1-pu\n# Build vector of ending values\n# and prices for which put is exercised\nvec = np.arange(n+1)\nvec1 = np.ones(n+1)\n\nS = S0 * u**(2*vec - n*vec1)\n\nAP = np.maximum(K-S,0)\n#print(AP)\nex = S[AP&gt;0]\neb = np.zeros(n+1)\neb[n] = ex.max()\n# Backward recursion in the loop\nfor i in range(n):\n    vec = np.arange(n-i)\n    vec1 = np.ones(n-i)\n    # Possible Stock prices at times-i period\n    S = S0 * u**(2*vec-(n-i)*vec1+1)\n#     S = S0 * u**(2*vec-(n-i))\n    # P calculates the value of early exercise\n    P = np.maximum(K*vec1 - S, 0)\n    # PP calculates value of waiting using payoffs from next period\n    PP = (pu*AP[1:(n-i+1)] + pd*AP[0:(n-i)])/a\n    # AP is the max of ealry exercise and waiting\n    AP = np.maximum(P,PP)\n    # ex is prices where early exercise is optimal\n    ex = S[AP-PP&gt;0]\n    # eb calculates the highest price\n    # where exercise is optimal to plot boundary\n    if ex.shape[0]&gt;0:\n        eb[n-i] = ex.max()\n    else:\n        eb[n-i] = np.nan\n\nprint('The value of the American Put is=',AP[0])        \n     # plot the exercise boundary\nplt.figure(figsize=(9,6))\nplt.plot(dt*np.arange(n+1),eb)\n\n\nThe value of the American Put is= 1.643396346909605\n\n\n\n\n\n\n\n\n\nHowever, when we consider binomial models for multiple assets later, we will use the tree proposed by Trigeorgis (Trigeorgis 1991), because it is the simplest to explain in that context. Trigeorgis proposes choosing \\(p\\), \\(u\\) and \\(d\\) so that the mean and variance of \\(\\Delta \\log S\\) in the binomial model match those in the continuous-time model exactly. This means that\n\\[\\begin{align*}\n\\frac{p\\log u+(1-p)\\log d}{\\Delta t} &= \\mathrm{n}u\\; ,\\\\\n\\frac{p(1-p)(\\log u-\\log d)^2}{\\Delta t} &= \\sigma^2\\;.\n\\end{align*}\\]\nThese are two equations in the three unknowns, leaving one degree of freedom, so Trigeorgis takes \\(d=1/u\\), as do Cox, Ross and Rubinstein. As we will show in the next section, taking \\(d=1/u\\) simplifies the calculations of deltas and gammas. Solving these two equations yields^[Notice that if we were to drop the \\((\\Delta t)^2\\) term in Equation 14.12 (which we could do because it becomes increasingly negligible as \\(\\Delta t \\rightarrow 0)\\), then Equation 14.12 would be the same as Equation 14.5. The different choices of \\(p\\) in Equation 14.6 and Equation 14.13 can be understood as follows. Equation 14.6 implies that the expected stock price \\(pS_u + (1-p)S_d\\) equals \\(\\mathrm{e}^{(r-q)\\Delta t}S\\), so we have average growth at the rate \\(r-q\\) as in the continuous-time model. On the other hand, Equation 14.13 implies that the expected log stock price \\(p \\,\\log S_u + (1-p) \\log S_d\\) equals \\(\\log S + \\mathrm{n}u \\Delta t\\), so the expected change in the logarithm is \\(\\mathrm{n}u\\Delta t\\), also as in the continuous-time model. Thus, both match the binomial model to the continuous-time model, the Cox-Ross-Rubinstein method focusing on the expected return (equivalently, the expected change in the price of the underlying) and the Trigeorgis method focusing on the expected continuously-compounded return (the expected change in the logarithm of the price).}\n\\[\n\\log u=\\sqrt{\\sigma^2\\Delta t + \\mathrm{n}u^2(\\Delta t)^2}\\;,\n\\qquad(14.12)\\]\n\\[\np = \\frac{1}{2}+\\frac{\\mathrm{n}u\\Delta t}{2\\log u}\\;.\n\\qquad(14.13)\\]",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:binomial_greeks",
    "href": "Chapter_Binomial.html#sec-s:binomial_greeks",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.4 Binomial Greeks",
    "text": "14.4 Binomial Greeks\nTo estimate Greeks in any valuation model, one can run the valuation program twice, for two different parameter values, and then estimate the Greek as the difference in value divided by the difference in parameters. For example, to estimate vega when the volatility of the underlying is \\(\\sigma\\), we could estimate the derivative value for a volatility of \\(0.99\\sigma\\) and for a volatility of \\(1.01\\sigma\\). Denoting the former derivative value by \\(C_d\\) and the latter by \\(C_u\\), the vega can be estimated by \\[\\frac{C_u-C_d}{1.01\\sigma-0.99\\sigma} = \\frac{C_u-C_d}{0.02\\sigma}\\; .\\] We can in principle obtain a more precise estimate of the derivative by making a smaller change in the parameter (e.g., using \\(0.999\\sigma\\) and \\(1.001\\sigma\\)) but computer round-off errors limit how small a parameter change one should take in practice.\nTo estimate the gamma when the price of the underlying is \\(S\\), we need to estimate the derivative value at two other prices for the underlying, which we will call \\(S_u\\) and \\(S_d\\), with \\(S_u&gt;S&gt;S_d\\). As just explained, the estimate of the delta (which we continue to denote by \\(\\delta\\)) would be \\[\n\\delta = \\frac{C_u-C_d}{S_u-S_d}\\;,\n\\qquad(14.14)\\]\nwhere \\(C_u\\) denotes the derivative value when the underlying is equal to \\(S_u\\) and \\(C_d\\) denotes the derivative value when the underlying is equal to \\(S_d\\). Letting \\(C\\) denote the derivative value when the underlying is equal to \\(S\\), two other obvious estimates of the delta are \\[\\delta_u = \\frac{C_u-C}{S_u-S} \\qquad \\text{and} \\qquad \\delta_d = \\frac{C-C_d}{S-S_d}\\; .\\] The first of these should be understood as an estimate of the delta when the price of the underlying is at the midpoint of \\(S_u\\) and \\(S\\), and the second is an estimate of the delta when the price of the underlying is at the midpoint of \\(S_d\\) and \\(S\\). The distance between these midpoints is \\[\\frac{S_u+S}{2} - \\frac{S_d+S}{2} = \\frac{S_u-S_d}{2}\\; ,\\] so we obtain an estimate of \\(\\Gamma\\) (the derivative of \\(\\delta\\)) as \\[\n\\Gamma = \\frac{\\delta_u-\\delta_d}{(S_u-S_d)/2}\\;.\n\\qquad(14.15)\\]\nIn a binomial model, it is possible to compute the most important Greeks, delta and gamma, more efficiently than by simply running the valuation program several times. Assume we have taken \\(d=1/u\\), so after an up and a down move (or a down and an up move) the stock price returns to its initial value \\(S\\). After fixing the length \\(\\Delta t = T/N\\) of each time period, we redefine \\(N=N+2\\). This results in an \\(N+2\\) period tree covering a time period of length \\(T+2\\Delta t\\). Now consider the tree starting two periods from the initial date. At the middle node shown below, the stock price is \\(udS=S\\). Ignoring the top and bottom nodes and the branches that follow them, the result of adding two periods is that the tree starting from \\(udS\\) is an \\(N\\)–period tree for a time period of length \\(T\\).\n\nHence, the derivative price calculated at the middle node will be the price we are trying to estimate. The derivative price at the top node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(u^2S\\). Similarly, the derivative price at the bottom node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(d^2S\\). Thus, when we back up in the tree to this date, we will have all of the information we need to return an estimate of the derivative value and to return estimates of the delta and gamma, taking \\(S_u=u^2S\\) and \\(S_d = d^2S\\) in Equation 14.14 and Equation 14.15. We are not interested in the tree to the left of what is shown above.\n\nTrinomial Valuation of American Options\nThe trinomial model is a special case of an explicit finite difference method for solving partial differnetial equations; however, it requires no knowledge of partial differential equations. It is similar to a binomial model in that it is a tree. As the name suggests, the trinomial model has three branches up, down, and middle. The middle branch eliminates the up down behavior and can lead to smoother exercise boundaries. We will use the following parameterization: at each node the stock price grows by a factor \\(u=e^{\\sigma \\sqrt{3 \\Delta t}}\\), stays the same, or declines by a factor of \\(d=1/u\\). In this sense, it inherits some of the tractabilty of the Cox, Ross, and Rubenstein model in the sense that the stock price at all nodes can be expressed as the initial stock price times \\(u\\) to a power. The probabilities are given by\n\\[\np_u = \\frac{1}{6} + \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)~~~p_m =2/3~~p_d= \\frac{1}{6} - \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)\n\\]\nWhile there are many choices for the parameterization they are not completely arbitrary. The probability \\(p_m =2/3\\) roughly corresponds to plus or minus one standard devation of a normal distribution and the up and down probabilities capture the tails. There are other parameterizations which can work ust as well.\nConceptually, although there are three states and only two assets and the market is incomplete, the model converges to the Black Scholes model but there is no direct replication strategy. Nevertheless, we are modelling the price in a risk-neutral probability. More importantly it does potentially give a better estimate of derivative prices.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nvec = np.arange(2*n+1)\nvec1 = np.ones(2*n+1)\nS = S0 * u**(vec-n*vec1)\nAP = np.maximum(K-S,0)\nex = S[AP&gt;0]\n# eb is an array to save the boundary price\neb = np.zeros(n+1)\neb[n] = ex.max()\n# Backward recursion in the loop\nfor i in range(n):\n    vec = np.arange(2*(n-i-1)+1)\n    vec1 = np.ones(2*(n-i-1)+1)\n    # Possible Stock prices at times-i period\n    S = S0 * u**(vec-(n-i-1)*vec1)\n    # P calculates the value of early exercise\n    P = np.maximum(K - S, 0)\n    # PP calculates value of waiting using payoffs from next period\n    PP = (pu*AP[2:(2*(n-i)+1)] + pm*AP[1:(2*(n-i))] + pd*AP[0:(2*(n-i)-1)])/a\n    # AP is the max of ealry exercise and waiting\n    AP = np.maximum(P,PP)\n    # ex is prices where early exercise is optimal\n    ex = S[(AP-PP)&gt;0]\n    # eb calculates the highest price\n    # where exercise is optimal to plot boundary\n    if ex.shape[0]&gt;0:\n        eb[n-i] = ex.max()\n    else:\n        eb[n-i] = np.nan\nprint('The American put price is=', AP[0])\n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),eb)\n\n\nThe American put price is= 1.6396310315369165\n\n\n\n\n\n\n\n\n\nWe again provide a program which does the same calculation using loops. It is much slower. We use the same parametrs and preamble as before and just outline the steps. As in the binomial model, we start at the last date and build \\(2n+1\\) terminal stock prices. We also keep track of the highest stock price which we exercise.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nex = np.zeros(n+1)\nS = np.zeros(2*n+1)\nAP = np.zeros(2*n+1)\n\nfor j in range(2*n+1):\n    S[j] = S0*u**(j-n)\n    AP[j] = max(K-S[j],0)\n    if AP[j]&gt;0:\n        ex[n] = S[j]\n\n\nWe then move backwards. There are two loops. The inner loop builds the stock price, the value, and exercise boundary at each time and the outer loop moves backwards in time.\n\n\nCode\nfor i in range(n):\n    S = np.zeros(2*(n-i-1)+1)\n    P = np.zeros(2*(n-i-1)+1)\n    PP = np.zeros(2*(n-i-1)+1)\n    for j in range(2*(n-i-1)+1):\n        S[j] = S0*u**(j-(n-i-1))\n        #\n        # P calculates the value of early exercise\n        P[j] = max(K-S[j],0)\n        #\n        # PP calculates value of waiting using payoffs\n        # from next period\n        PP[j] = (pu*AP[j+2] + pm*AP[j+1] + pd*AP[j])/a\n        #\n        # AP is the max of ealry exercise and waiting\n        AP[j] = max(P[j],PP[j])\n        #\n        # ex is price where early exercise is optimal\n        if P[j] &gt; PP[j]:\n            ex[n-i] = S[j]\n\nprint('The American put price is =', AP[0])            \n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),ex)            \n\n\nThe American put price is = 1.6396310315369165",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#accelerating-binomial-convergence",
    "href": "Chapter_Binomial.html#accelerating-binomial-convergence",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.5 Accelerating Binomial Convergence",
    "text": "14.5 Accelerating Binomial Convergence\nBroadie and Detemple (Broadie and Detemple 1997) show that a modified binomial model is a quite efficient way to value American put options. They modify the binomial model as follows: (i) the Black-Scholes formula is used to value the option at the penultimate date, and (ii) Richardson extrapolation is used to estimate what the option value would be with an infinite number of periods.\nIf an option is not exercised at date \\(N-1\\) in an \\(N\\)–period binomial model (i.e., one date from the end), then, because in the binomial model there are no further opportunities for early exercise, the American option at date \\(N-1\\) is equivalent to a European option at that date. The value of a European option is given by the Black-Scholes formula. Therefore, the estimate of the option value can be improved by replacing\nwith\nat date \\(N-1\\) (of course this also means that we do not need to compute the intrinsic value at date \\(N\\)). This idea can be effectively used in binomial valuation of any option for which there is a closed-form solution (like the Black-Scholes formula) for the value of the corresponding European option in a continuous-time model.\nBroadie and Detemple combine the use of the Black-Scholes formula at date \\(N-1\\) with Richardson extrapolation. Richardson extrapolation is a method that may improve the efficiency of any algorithm by extrapolating to the limit. In the case of a binomial model, the idea is to extrapolate the values calculated for different numbers of periods (different \\(N\\)’s) to try to estimate the value for \\(N=\\infty\\).\nIt is easier to work with convergence to zero than convergence to infinity, so define \\(x=1/N\\). For any value of \\(N\\), the binomial model will return a value, which is an estimate of the option value and which we denote as \\(y=f(x)\\). We would like to know the value at \\(N=\\infty\\), which in this notation is \\(f_0\\). Of course, we cannot calculate \\(f_0\\), because we do not know the function \\(f\\), but we can approximate \\(f\\) by a known function \\(g\\) and then estimate \\(f_0\\) by \\(g_0\\).\nA linear approximation is the simplest and is shown by Broadie and Detemple to be quite effective. For a linear approximation, we would take \\[g(x) = a + bx\\] for parameters \\(a\\) and \\(b\\) to be determined. We can input values \\(N_1\\) and \\(N_2 = 2N_1\\) for the number of periods, run the binomial model for each, set \\(x_i=1/N_i\\), and define \\(y_i=f(x_i)\\) to be the value of the option returned by the binomial model when the number of periods is \\(N_i\\). Then we force \\(g(x_i)=f(x_i)\\) for \\(i=1,2\\) by solving the equations \\[y_i=a + bx_i\\] for \\(a\\) and \\(b\\). Of course, \\(g_0 = a\\), so we will return the constant \\(a\\) as our estimate of \\(f_0\\). This is simpler than it may appear—we put \\[\\begin{equation*}\\begin{array}{rclcl}\ny_1 &= &a + bx_1 &= &a+2bx_2\\;,\\\\\ny_2 &= & &  & a + bx_2 \\;,\n\\end{array}\\end{equation*}\\] and subtracting gives us \\(y_1-y_2 = bx_2\\), which implies from the bottom equation that \\(a = 2y_2-y_1\\). We can think of \\(N_2\\) as being the number of periods we want to use in the binomial model, in which case \\(y_2\\) would be our estimate of the option value. Richardson extrapolation here means also running the binomial model for half as many periods (\\(N_1 = N_2/2\\)) and adding the difference of the estimates \\(y_2-y_1\\) to the estimate \\(y_2\\).\nRichardson extrapolation can be viewed as cancelling the first-order term in the Taylor series expansion of \\(f\\). We have \\[\\begin{align*}\ny_1 = f(x_1) &= f_0 + f'_0x_1 + \\text{higher order terms} \\\\\n& = f_0 + 2f'_0x_2 + \\text{higher order terms}\\;,\\\\\ny_2 = f(x_2) &= f_0 + f'_0x_2 + \\text{higher order terms}\\;.\n\\end{align*}\\] This implies \\[2y_2-y_1 = f_0 + \\text{difference of higher order terms}\\;.\\] Having eliminated the first-order term, one can hope to obtain a closer approximation to \\(f_0\\).\nWe now show hot to implement this in Pyhton.\nFirst we create a binomial valuation program that replaces (i) calculation of the intrinsic value at maturity and (ii) calculation of the value at the penultimate date as the larger of intrinsic value and the discounted value at maturity with (iii) calculation of the value at the penultimate date as the larger of intrinsic value and the Black-Scholes value of a European option with one period to maturity.\n\n\nCode\n# uses blackscholes(S0, K, r, q, sig, T, call = False)\n\ndef binomialbd(n,r,sig,S0,y,K,T):\n\n    # parameters\n    # number of steps\n    #n \n    # interest rate\n    #r \n    # volatility\n    #sig \n    # Initial Stock Price\n    #S0\n    # Strike Price\n        #K \n    # Maturity\n    #T \n    # dividend yield\n    # y\n\n    # calculate parameters for binomial model\n    dt = T/n\n    delt = np.exp(-y*dt)\n    a = np.exp(r*dt) * delt\n    u = np.exp(sig*np.sqrt(dt))\n    d = 1/u\n    pu = (a-d)/(u-d)\n    pd = 1-pu\n    # Build vector of ending values\n    # \n    \n    S = np.zeros(n)\n    AP = np.zeros(n)\n    \n    # Build vector of ending values\n    # at the next to last date (penultimate date)\n    vec = np.arange(n)\n    vec1 = np.ones(n)\n\n    S = S0 * u**(2*vec - (n-1)*vec1)\n\n    AP = np.maximum(K-S,blackscholes(S, K, r, q, sig, dt, call = False))\n    \n    \n    # Backward recursion in the loop\n    for i in range(n-1):\n        vec = np.arange(n-i-1)\n        vec1 = np.ones(n-i-1)\n        # Possible Stock prices at times-i period\n        S = S0 * u**(2*vec-(n-i-1)*vec1+1)\n    \n    #     S = S0 * u**(2*vec-(n-i))\n        # P calculates the value of early exercise\n        P = np.maximum(K*vec1 - S, 0)\n        # PP calculates value of waiting using payoffs from next period\n        PP = (pu*AP[1:(n-i)] + pd*AP[0:(n-i-1)])/a\n        # AP is the max of ealry exercise and waiting\n        AP = np.maximum(P,PP)\n        \n\n    \n    \n    \n    return AP[0]          \n\n\nNow we create a program that uses Richardson extrapolation from a binomial model with N periods and a binomial model with N/2 periods to estimate the value from a binomial model with an infinite number of periods. We use the previous program as our binomial model. The number of time steps \\(n\\) must be even so \\(n/2\\) is an integer. In the following we initally use \\(n=20\\), which is smaller than the the number of steps in the previous binomial american option routines.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n\n\n#inputs\n#number of steps= n; must be an even number\nn=20\n# interest rate\nr=.1\n# volatility\nsig=.2\n# initial stock price\nS0=42\n# dividend yield\ny=0\n# Strike price \nK=42\n# expiration\nT=0.5\n\nif 2*int(n/2) == n:\n\n    y2=binomialbd(n,r,sig,S0,y,K,T)\n    y1=binomialbd(int(n/2),r,sig,S0,y,K,T)\n    \n    extrapolate= 2*y2-y1\n    print('The extrapolated value=',extrapolate)\n\nelse:\n    print('n must be even you big dummy!!')   \n\n\nThe extrapolated value= 1.6495917266169138",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:curse",
    "href": "Chapter_Binomial.html#sec-s:curse",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.6 Binomial Valuation of Basket and Spread Options",
    "text": "14.6 Binomial Valuation of Basket and Spread Options\n By combining binomial models, we can value options or other derivatives on multiple assets. We will illustrate for an option on two assets. This is the most important case, and the extension to more than two assets is straightforward.\nConsider two stocks with constant dividend yields \\(q_i\\) and constant volatilities \\(\\sigma_i\\). Suppose the two Brownian motions driving the two stocks have a constant correlation coefficient \\(\\rho\\). We will denote the price of stock \\(i\\) (\\(i=1,2\\)) in the up state in each period by \\(u_iS_i\\) and the price in the down state by \\(d_iS_i\\), where \\(S_i\\) is the price at the beginning of the period, and \\(u_i\\) and \\(d_i\\) are parameters to be specified. In each period, there are four possible combinations of returns on the two stocks: up for both stocks, up for stock 1 and down for stock~2, down for stock 1 and up for stock 2, and down for both stocks. Denote the probabilities of these four combinations by \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\) respectively. Thus, there are eight parameters in the binomial model: the number \\(N\\) of periods (which defines the length of each period as \\(\\Delta t=T/N\\) where \\(T\\) is the option maturity), the up and down parameters \\(u_i\\) and \\(d_i\\) for each stock, and three probabilities (the fourth probability being determined by the condition that the probabilities sum to one).\nGiven the period length \\(\\Delta t\\), we want to choose the up and down parameters and the probabilities to match (or approximately match in an appropriate sense) the means, variances and covariances of the returns \\(\\Delta S_i/S_i\\) or the continuously-compounded returns \\(\\Delta \\log S_i\\). There are two means, two variances and one covariance, so there are five restrictions to be satisfied and seven parameters. It is convenient to take \\(d_i = 1/u_i\\), leaving five restrictions and five free parameters.\nAs discussed in Section 14.2, there are multiple ways to define the binomial model so that it converges to the continuous-time model as the number of periods is increased. As an example, we will describe here the suggestion of Trigeorgis (Trigeorgis 1991), which matches the means, variances and covariance of the continuously-compounded returns. Letting \\(p_i\\) denote the probability of the up state for stock \\(i\\), matching the means and variances implies, as in Section 14.2, \\[\\begin{align*}\n\\log u_i&=\\sqrt{\\sigma_i^2\\Delta t + \\nu_i^2(\\Delta t)^2}\\; ,\\\\\np_i &= \\frac{1}{2}+\\frac{\\nu_i\\Delta t}{2\\log u_i}\\;.\n\\end{align*}\\] where \\(\\nu_i=r-q_i-\\sigma_i^2/2\\). In terms of the notation \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\), the probability of the up state for stock 1 is \\(p_1=p_{uu}+p_{ud}\\) and the probability of the up state for stock 2 is \\(p_2=p_{uu}+p_{du}\\). Therefore,\n\\[\np_{uu}+p_{ud} = \\frac{1}{2}+\\frac{\\nu_1\\Delta t}{2\\log u_1}\\;,\n\\qquad(14.16)\\]\n\\[\np_{uu}+p_{du} = \\frac{1}{2}+\\frac{\\nu_2\\Delta t}{2\\log u_2}\\;.\n\\qquad(14.17)\\]\nIn the continuous time model, over a discrete time period \\(\\Delta t\\), the covariance of \\(\\Delta \\log S_1\\) and \\(\\Delta \\log S_2\\) is \\(\\rho\\sigma_1\\sigma_2\\Delta t\\). In the binomial model, with \\(d_i=1/u_i\\), we have \\[\n\\\\mathrm{E} \\big[\\Delta \\log S_1 \\times \\Delta \\log S_2\\big] = (p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2\\;.\n\\] Given that \\(\\\\mathrm{E}[\\Delta\\log S_i] =\\nu_i\\Delta t\\), this implies a covariance of \\[\n(p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2 - \\nu_1\\nu_2(\\Delta t)^2\\;.\n\\] Matching the covariance in the binomial model to the covariance in the continuous-time model therefore implies \\[\np_{uu}-p_{ud}-p_{du}+p_{dd} =\\frac{\\rho\\sigma_1\\sigma_2\\Delta t + \\nu_1\\nu_2(\\Delta t)^2}{\\log u_1\\log u_2}\\;.\n\\qquad(14.18)\\]\nWe can solve the system Equation 14.16 - Equation 14.18, together with the condition that the probabilities sum to one, to obtain the probabilities \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\). This solution and a Python function for valuing an American spread call option are given later. This function operates much like the binomial valuation of American options described earlier. The primary difference is that the value of the option at maturity depends on both stock prices, so we have to consider each possible combination of stock prices. In an \\(N\\)–period model, there are \\(N+1\\) nodes at the final date for each of the two stocks, and hence \\((N+1)^2\\) possible combinations of nodes. In fact, at each date \\(n\\) (\\(n=0,\\ldots,N\\)) there are \\((n+1)^2\\) combinations of nodes to be considered.\nThe computation time required for a spread call option is therefore roughly the square of the time required for a standard call.\nLikewise, in an \\(N\\)–period model for a basket option written on three assets, there are \\((n+1)^3\\) combinations of nodes to be considered at date \\(n\\); if there are five assets, there are \\((n+1)^5\\) combinations, etc. Thus, the computation time required increases exponentially with the number of assets. This can be a serious problem. For example, with five assets and \\(N=99\\), we would have \\(100^5\\) (10 billion) combinations. As this suggests, problems with multiple assets quickly become intractable in a binomial framework. This is called the curse of dimensionality.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#exercises",
    "href": "Chapter_Binomial.html#exercises",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.7 Exercises",
    "text": "14.7 Exercises\n\nExercise 14.1 Consider an at-the-money European call option on a dividend-reinvested stock with six months to maturity. Take the initial stock price to be $50, the interest rate to be 5% and $=$30%. Compute the value in a binomial model with \\(N=10, 11, \\ldots, 20\\) and plot the values against \\(N\\). Plot your results. Is convergence monotone?\n\n\nExercise 14.2 Consider the same option as in the previous problem. Roughly what value of \\(N\\) is needed to get penny accuracy? (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)\n\n\nExercise 14.3 Repeat the two previous problems only instead of the Cox, Ross Rubenstein model, use the Jarrow Rudd model.\n\n\nExercise 14.4 The early exercise premium is the difference between the value of an American option and the value of a European option with the same parameters. Compute the early exercise premium for an American put and various values for the interest rate, exercise price, and stock parameters. Under what circumstances is the early exercise premium relatively large?\n\n\nExercise 14.5 A shout option is an option where the holder is entitled to shout at any time before the expiration of the option. Upon shouting, the holder receives the immediate exercise value paid at expiration, plus an at the money option with the same expiration as the original option. The payoff to this option if the holder shouts at time \\(\\tau\\) is thus given as \\(\\max(0, S(\\tau)-K, S_T-K )\\) where \\(K\\) is the original strike price.\n1) Show that it is better to shout at some time where \\(S(\\tau)&gt;K\\) than to never shout at all. 2) Modify the code for an American put to find the optimal exercise boundary for a shout option. Hint: The payoffs on the last nodes of the tree are simply \\((S_T - K)^+\\). Then work backwards. The `immediate exercise value’ which is the present value of \\(S_t-K\\), (\\(e^{-r(T-t)} (S_t -K)\\)) plus the Black Scholes value (use a python function) of an at the money option with expiration \\(T-t\\). Choose the maximum of these values at each node. For each time store the highest price at which you exersize. The first node (time 0) then gives the price. Plot the exercise boundary.\n\n\n\n\n\n\nBroadie, M., and J. Detemple. 1997. “American Option Valuation: New Bounds, Approximations, and a Comparison of Existing Methods.” Review of Financial Studies 9: 1211–50.\n\n\nCox, J., S. Ross, and M. Rubinstein. 1979. “Option Pricing: A Simplified Approach.” Journal of Financial Economics 7: 229–63.\n\n\nJackson, M., and M. Staunton. 2001. Advanced Modelling in Finance Using Excel and VBA. Wiley, New York.\n\n\nJarrow, R., and A. Rudd. 1983. Option Pricing. Dow Jones-Irwin, Homewood, Illinois.\n\n\nLeisen, D. P. J., and M. Reimer. 1996. “Binomial Models for Option Valuation—Examining and Improving Convergence” 3: 319–46.\n\n\nTrigeorgis, A. 1991. “A Log-Transformed Binomial Analysis Method for Valuing Complex Multi-Option Investments.” Journal of Financial and Quantitative Analysis 26: 309–26.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Appendix_Binomial.html",
    "href": "Appendix_Binomial.html",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "",
    "text": "15.1 Basics of the Binomial Tree Model\nThe binomial tree model is a discrete-time framework used to price derivative securities. It is widely used in financial engineering for valuing options and other contingent claims. This model is particularly useful because it provides an intuitive approach to pricing and allows for easy incorporation of various features such as early exercise in American options.\nThe binomial tree model is based on the assumption that, over a small time step, the price of an underlying asset can move up or down by a certain factor. The model is constructed iteratively to estimate the fair value of derivatives such as options.\nAn \\(n\\) period binomial tree model can be described as follows:\n\\[\nS_{t+\\Delta t} = S_t \\times u_t \\quad \\text{(up move)}\n\\] or \\[\nS_{t+\\Delta t} = S_t \\times d_t \\quad \\text{(down move)}\n\\]\n\\[\np_t = \\frac{e^{r_t \\Delta t} - d_t}{u_t - d_t}\n\\]\nwhere $ r_t $ is the risk-free rate from \\(t\\) to \\(t+\\Delta t\\).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Appendix_Binomial.html#basics-of-the-binomial-tree-model",
    "href": "Appendix_Binomial.html#basics-of-the-binomial-tree-model",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "",
    "text": "There are \\(n+1\\) time points with \\(t=0, \\Delta t, 2 \\Delta t, ..., n\\Delta t\\), where \\(\\Delta t\\) is the time step.\nAt each time point \\(t\\), the price of the underlying asset either goes up by a factor \\(u_t&gt;1\\) with probability \\(p_t\\in(0,1)\\) or goes down by a factor \\(d_t&lt;1\\) with probability \\(1-p_t\\).\nGiven an initial stock price \\(S_0\\), the price of the underlying asset evolves as:\n\n\n\nThe absence of arbitrage ensures the model can be solved using risk-neutral valuation, where the risk-neutral probability of an up move is:\n\n\n\n\nExample: Three-Period Recombining Binomial Tree\nThis is an example of a three-period recombining binomial tree: \\(n=3\\), \\(u=1.1\\), \\(d=1/u\\), \\(\\Delta t=1\\):\n\n\nCode\nimport plotly.graph_objects as go\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1):\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t  # Time step on x-axis\n            y = 2 * j - t  # Centered y-axis positioning for symmetry\n            nodes[(x, y)] = round(S0 * (u ** j) * (d ** (t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = 2 * j - t\n            edges.append(((x, y), (x + 1, y + 1)))  # Up move\n            edges.append(((x, y), (x + 1, y - 1)))  # Down move\n\n    fig = go.Figure()\n\n    # Add edges to the plot\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        fig.add_trace(go.Scatter(x=x_coords, y=y_coords, mode='lines', line=dict(color='black'), showlegend=False))\n\n    # Add nodes to the plot\n    x_vals = [key[0] for key in nodes.keys()]\n    y_vals = [key[1] for key in nodes.keys()]\n    labels = [str(nodes[key]) for key in nodes.keys()]\n\n    fig.add_trace(go.Scatter(\n        x=x_vals, y=y_vals, mode='markers+text',\n        marker=dict(size=20, color='lightblue'),\n        text=labels, textposition=\"top center\",\n        showlegend=False\n    ))\n\n    fig.update_layout(\n        title=\"3-Period Symmetric Binomial Tree (u=1.1, d=1/u)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        plot_bgcolor='white',\n        width=700,\n        height=500\n    )\n\n    fig.show()\n\nplot_symmetric_binomial_tree()\n\n\n                                                \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1, vertical_scale=0.5, title_pad=20):\n    \"\"\"\n    Plots a 3-period symmetric binomial tree using Matplotlib,\n    with options to compress the vertical spacing and add space between the title and the plot.\n\n    :param S0: initial stock price\n    :param u: up factor\n    :param vertical_scale: compresses or expands the vertical spacing\n    :param title_pad: extra spacing between the title and the tree (in points)\n    \"\"\"\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)  # scale the vertical distance\n            nodes[(x, y)] = round(S0 * (u**j) * (d**(t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)\n            # Up move\n            edges.append(((x, y), (x + 1, y + vertical_scale)))\n            # Down move\n            edges.append(((x, y), (x + 1, y - vertical_scale)))\n\n    # Create a Matplotlib figure\n    fig, ax = plt.subplots(figsize=(7, 5))\n\n    # Plot edges\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes\n    x_vals = [k[0] for k in nodes.keys()]\n    y_vals = [k[1] for k in nodes.keys()]\n    labels = [str(nodes[k]) for k in nodes.keys()]\n    ax.scatter(x_vals, y_vals, s=300, color='lightblue')\n\n    # Add text labels above each node\n    for x, y, label in zip(x_vals, y_vals, labels):\n        ax.text(x, y + 0.3 * vertical_scale, label, ha='center', va='bottom')\n\n    # Title with extra spacing set by 'pad'\n    ax.set_title(\n        f\"3-Period Symmetric Binomial Tree (u={u}, d={round(d,2)})\",\n        pad=title_pad\n    )\n\n    # Style the plot\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n\n    plt.show()\n\n# Example usage: extra spacing of 20 points between the caption and the tree\nplot_symmetric_binomial_tree(vertical_scale=0.5, title_pad=20)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Appendix_Binomial.html#approximation-of-continuous-stochastic-processes",
    "href": "Appendix_Binomial.html#approximation-of-continuous-stochastic-processes",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "15.2 Approximation of Continuous Stochastic Processes",
    "text": "15.2 Approximation of Continuous Stochastic Processes\nA binomial tree is a discrete-time stochastic process with two possible outcomes at each time step. In its simplest form, at every step the process moves either up or down by a fixed factor or amount, with specified probabilities. This construction can be used to approximate almost any continuous stochastic processes. The main idea is as follows:\n\nDiscrete Steps:\nIn a binomial tree, time is divided into small increments (say, \\(\\Delta t\\)). At each time step, the process moves up by a factor \\(u\\) or down by a factor \\(d\\). This is analogous to a random walk where at each step you move one unit to the right or left.\nProbabilities and Expected Change:\nBy choosing the probabilities (say \\(p\\) for an up move and \\(1-p\\) for a down move) appropriately, you can control the drift and variance of the process. For a symmetric random walk, you might set \\(p = 0.5\\). More generally, one can adjust these parameters so that, over many steps, the binomial model matches the first two moments (mean and variance) of the random walk you want to approximate.\nConvergence to a Continuous Process:\nAs you make the time steps smaller (i.e., \\(\\Delta t \\to 0\\)) and choose \\(u\\) and \\(d\\) appropriately (for example, \\(u = e^{\\sigma\\sqrt{\\Delta t}}\\) and \\(d = e^{-\\sigma\\sqrt{\\Delta t}}\\) for volatility \\(\\sigma\\)), the binomial process converges in distribution to a continuous-time process, such as Brownian motion (or a geometric Brownian motion if you’re modeling stock prices).\nExample:\nSuppose you have a simple random walk starting at 0. At each time step:\n\nWith probability \\(0.5\\), add 1 (up move).\nWith probability \\(0.5\\), subtract 1 (down move).\n\nThis is a binomial tree where the position after \\(n\\) steps is given by: \\[\nX_n = X_0 + (\\text{number of up moves}) - (\\text{number of down moves}).\n\\] As \\(n\\) grows, by the Central Limit Theorem, the distribution of \\(X_n\\) becomes approximately normal, just like a random walk with Gaussian increments.\nApplication in Finance:\nIn financial modeling, the binomial tree is used to approximate the price evolution of an asset. The tree method provides a simple numerical technique to value options and other derivatives by stepping through the possible future asset prices and then discounting back to the present.\n\nIn summary, the binomial tree model can approximate a continuous stochastic process by discretizing time into small intervals with two possible outcomes at each step. With the right choice of parameters and as the step size decreases, the binomial process can approximate well the behavior of the continuous stochastic process, while keeping the numerical valuation of simple.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Appendix_Binomial.html#a-generalized-n-period-tree",
    "href": "Appendix_Binomial.html#a-generalized-n-period-tree",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "15.3 A Generalized \\(n\\)-Period Tree",
    "text": "15.3 A Generalized \\(n\\)-Period Tree\nWe can generalize the above basic binomial tree to a more general one where each node at any time \\(t\\) can have a variable number of branches and the branching pattern can vary across both time steps and nodes. This flexible structure can be useful for pricing more complex derivative securities.\n\nDefinition of a Generalized \\(n\\)-period tree\n\n1. Tree Structure\nWe define the tree as a directed graph \\(T = (N, E)\\), where:\n\n\\(N\\) is the set of nodes.\n\\(E \\subseteq N \\times N\\) is the set of edges, representing transitions between nodes across periods.\n\nEach node is indexed by:\n\\[\nN_{t,i}, \\quad t = 0, 1, \\dots, n, \\quad i = 1, \\dots, |N_t|\n\\]\nwhere:\n\n\\(t\\) represents the time point,\n\\(i\\) represents the node index at time \\(t\\),\n\\(|N_t|\\) denotes the number of nodes at time \\(t\\).\n\n\n\n\n2. Variable Branching\nEach node \\(N_{t,i}\\) has \\(B_{t,i}\\) branches, which represents the number of children (next-period nodes) it connects to. The total number of nodes at time \\(t+1\\) is then:\n\\[\n|N_{t+1}| = \\sum_{i=1}^{|N_t|} B_{t,i}\n\\]\nEach edge represents a transition probability \\(P_{t,i,j}\\) from node \\(N_{t,i}\\) at time \\(t\\) to node \\(N_{t+1, j}\\) at time \\(t+1\\), satisfying:\n\\[\n\\sum_{j=1}^{B_{t,i}} P_{t,i,j} = 1, \\quad \\forall i, t\n\\]\nwhere \\(P_{t,i,j}\\) is the probability of transitioning from \\(N_{t,i}\\) to \\(N_{t+1,j}\\).\n\n\n\n3. Node Values and Transition Rule\nEach node has a value \\(S_{t,i}\\), which can represent an evolving variable (e.g., stock price, state variable). The value transition function is defined as:\n\\[\nS_{t+1,j} = f(S_{t,i}, a_{t,i,j})\n\\]\nwhere:\n\n\\(S_{t,i}\\) is the value at node \\(N_{t,i}\\),\n\\(a_{t,i,j}\\) is a transition factor specific to the branch from \\(N_{t,i}\\) to \\(N_{t+1,j}\\),\n\\(f\\) is a value update function, often modeled as: \\[\nS_{t+1,j} = S_{t,i} \\times a_{t,i,j}\n\\]\n\nExample: Consider a 3-period tree with variable branching:\n\nPeriod 0: 1 node (\\(B_{0,1} = 2\\))\nPeriod 1: 2 nodes, each with different branching (\\(B_{1,1} = 3, B_{1,2} = 2\\))\nPeriod 2: 5 nodes, each branching further (\\(B_{2,1} = 2, B_{2,2} = 2, B_{2,3} = 1, B_{2,4} = 3, B_{2,5} = 2\\)).\n\nThe node count evolves as:\n\\[\n|N_1| = B_{0,1} = 2, \\quad\n|N_2| = B_{1,1} + B_{1,2} = 3 + 2 = 5, \\quad\n|N_3| = 2 + 2 + 1 + 3 + 2 = 10\n\\]\nThus, a generalized tree dynamically adjusts the branching structure.\nSpecial Cases\n\nBinomial Tree (\\(B_{t,i} = 2\\)): Each node has exactly two branches, leading to an up/down model.\nTrinomial Tree (\\(B_{t,i} = 3\\)): Each node has three possible transitions (e.g., up, middle, down).\nAdaptive Trees: \\(B_{t,i}\\) can depend on volatility or other dynamic parameters.\n\n\n\n\nA Graphical Illustration of a Generalized 3-Period Tree\nHere is a 3-period example with variable branching:\n\n\nCode\nimport plotly.graph_objects as go\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_symmetric():\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # next_index[t] tracks how many nodes have been created at period t so far\n    next_index = defaultdict(int)\n    next_index[0] = 1  # We have 1 node at t=0\n\n    # transitions[(t, i)] = list of factors for each branch out of node (t, i)\n    transitions = {\n        (0, 0): [1.1, 0.9],       # At t=0, i=0 =&gt; 2 branches\n        (1, 0): [1.2, 1.0, 0.8],  # At t=1, i=0 =&gt; 3 branches\n        (1, 1): [1.1, 0.85],      # At t=1, i=1 =&gt; 2 branches\n        (2, 0): [1.3, 0.9],       # At t=2, i=0 =&gt; 2 branches\n        (2, 1): [1.2, 1.0],       # At t=2, i=1 =&gt; 2 branches\n        (2, 2): [1.1],            # At t=2, i=2 =&gt; 1 branch\n        (2, 3): [1.15, 0.95, 0.85], # t=2, i=3 =&gt; 3 branches\n        (2, 4): [1.1, 0.9]        # t=2, i=4 =&gt; 2 branches\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_value = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_value = round(base_value * factor, 2)\n            nodes[(child_t, child_i)] = child_value\n\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Count how many nodes per period =&gt; assign symmetrical y-coordinates\n    nodes_in_period = defaultdict(list)\n    for (t, i), val in nodes.items():\n        nodes_in_period[t].append(i)\n\n    # For each period t, sort node indexes, then map them to symmetrical positions around 0\n    coords = {}  # coords[(t, i)] = y_position\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n\n        # We'll assign positions from 0..(count-1), then shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            # E.g., if count=5, positions -&gt; 0,1,2,3,4 =&gt; shift by -2 =&gt; -2,-1,0,1,2\n            shift = -(count - 1) / 2\n            y = idx + shift\n            coords[(t, node_i)] = y\n\n    # 3. Build the plot\n    fig = go.Figure()\n\n    # Add edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1, t2]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        fig.add_trace(go.Scatter(\n            x=x_coords,\n            y=y_coords,\n            mode='lines',\n            line=dict(color='black'),\n            showlegend=False\n        ))\n\n    # Add nodes (markers+text)\n    for (t, i), val in nodes.items():\n        fig.add_trace(go.Scatter(\n            x=[t],\n            y=[coords[(t, i)]],\n            mode='markers+text',\n            marker=dict(size=10, color='blue'),\n            text=[str(val)],\n            textposition='top center',\n            showlegend=False\n        ))\n\n    fig.update_layout(\n        title=\"3-Period Variable Branching Tree (Symmetric Layout)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        width=900,\n        height=600,\n        plot_bgcolor='white'\n    )\n\n    fig.show()\n\n# Call the plotting function\nplot_variable_branching_tree_symmetric()\n\n\n                                                \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0):\n    \"\"\"\n    Plots a 3-period variable branching tree in a narrower vertical \n    layout and a longer horizontal layout.\n\n    :param vertical_scale: Factor (&lt;1 = narrower, &gt;1 = taller) for vertical spacing\n    :param horizontal_scale: Factor (&gt;1 = longer, &lt;1 = shorter) for horizontal spacing\n    \"\"\"\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # Track how many nodes created at each period t\n    next_index = defaultdict(int)\n    next_index[0] = 1\n\n    # transitions: dict[(t, i)] -&gt; list of factors from node (t,i)\n    transitions = {\n        (0, 0): [1.1, 0.9],\n        (1, 0): [1.2, 1.0, 0.8],\n        (1, 1): [1.1, 0.85],\n        (2, 0): [1.3, 0.9],\n        (2, 1): [1.2, 1.0],\n        (2, 2): [1.1],\n        (2, 3): [1.15, 0.95, 0.85],\n        (2, 4): [1.1, 0.9]\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_val = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_val = round(base_val * factor, 2)\n            nodes[(child_t, child_i)] = child_val\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Assign symmetrical y-coords for each period\n    nodes_in_period = defaultdict(list)\n    for (t, i) in nodes.keys():\n        nodes_in_period[t].append(i)\n\n    coords = {}\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n        # positions =&gt; 0..(count-1), shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            shift = -(count - 1) / 2\n            y = (idx + shift) * vertical_scale\n            coords[(t, node_i)] = y\n\n    # 3. Build the Matplotlib figure\n    fig, ax = plt.subplots(figsize=(12, 4))  # Wider figure\n\n    # Plot edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1 * horizontal_scale, t2 * horizontal_scale]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes + text\n    for (t, i), val in nodes.items():\n        x_ = t * horizontal_scale\n        y_ = coords[(t, i)]\n        ax.scatter(x_, y_, s=100, color='blue')\n        ax.text(x_, y_ + 0.2 * vertical_scale, str(val),\n                ha='center', va='bottom')\n\n    ax.set_title(\"3-Period Variable Branching Tree (Scaled)\")\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n    plt.show()\n\n# Example usage: narrower by vertical_scale=0.5, longer by horizontal_scale=2.0\nplot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Appendix_MonteCarlo.html",
    "href": "Appendix_MonteCarlo.html",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "",
    "text": "16.1 History and Applications of Monte Carlo Simulations\nMonte Carlo simulations are a class of computational algorithms that use repeated random sampling to obtain numerical results. Random number generation by a computer typically relies on deterministic algorithms, known as pseudo-random number generators (PRNGs), which produce a sequence of values that only appear random. These algorithms start from an initial seed and repeatedly transform it with a mathematical function to produce a new number each time. Although true randomness cannot be achieved purely with deterministic code, PRNGs are sufficient for many applications such as simulations and gaming. In cases where a higher degree of randomness is required—for example, in cryptography—computers gather real-world data (e.g., from hardware noise) to generate true random numbers, which do not follow a purely deterministic pattern.\nMonte Carlo methods are widely used in fields such as finance, engineering, physics, and risk management to solve complex problems that involve stochastic elements and are too difficult or inefficient to solve analytically or by other numrical methods. They are particularly useful when solving problems that involve: - High-dimensional spaces. - Uncertainty and randomness. - Complex integrations or optimizations that are difficult to solve analytically.\nBy simulating a large number of possible outcomes, Monte Carlo methods provide an approximation to a solution that is often more practical than attempting to derive an exact answer.\nMonte Carlo methods were first developed during the 1940s by scientists working on nuclear weapons research, including John von Neumann and Stanislaw Ulam. The name “Monte Carlo” was inspired by the famous casino in Monaco, reflecting the method’s reliance on randomness and probability.\nMonte Carlo simulations have since been applied in various domains:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Appendix_MonteCarlo.html#history-and-applications-of-monte-carlo-simulations",
    "href": "Appendix_MonteCarlo.html#history-and-applications-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "",
    "text": "Finance: Option pricing, portfolio risk management, and credit risk modeling.\nPhysics and Engineering: Particle simulations, fluid dynamics, and reliability analysis.\nHealthcare and Epidemiology: Disease spread modeling and risk assessment.\nBusiness and Economics: Decision-making under uncertainty, supply chain risk management.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Appendix_MonteCarlo.html#principle-of-monte-carlo-simulations",
    "href": "Appendix_MonteCarlo.html#principle-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.2 Principle of Monte Carlo Simulations",
    "text": "16.2 Principle of Monte Carlo Simulations\nThe principle of Monte Carlo simulations is based on the concept of using randomness to approximate deterministic problems. The core idea is to use random sampling to generate a large number of possible scenarios, analyze the outcomes, and estimate probabilities or expected values. This method is particularly useful when dealing with systems that have inherent uncertainty or when an exact analytical solution is difficult to obtain.\nSteps Involved in a Monte Carlo Simulation:\n\nDefine the Problem: Identify the mathematical or physical system being modeled.\nGenerate Random Inputs: Use random number generators to create sample inputs that represent possible states of the system.\nPerform Simulations: Compute the outcome for each randomly generated input using a defined model.\nAggregate Results: Analyze the distribution of outcomes to derive probabilities, expected values, or other statistical measures.\nInterpret and Apply Findings: Use the insights obtained to make informed decisions or refine the model.\n\nExample Illustration:\nIf we want to estimate the probability of a financial portfolio achieving a certain return, we can: - Generate random market conditions (e.g., stock prices, interest rates). - Compute portfolio returns under each condition. - Analyze the distribution of simulated returns to assess risk and return characteristics.\nMonte Carlo methods leverage the Law of Large Numbers, which states that as the number of simulations increases, the estimate converges to the true expected value.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Appendix_MonteCarlo.html#implementing-monte-carlo-simulations-in-python",
    "href": "Appendix_MonteCarlo.html#implementing-monte-carlo-simulations-in-python",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.3 Implementing Monte Carlo Simulations in Python",
    "text": "16.3 Implementing Monte Carlo Simulations in Python\nPython provides several libraries to implement Monte Carlo simulations effectively, including numpy, scipy, and matplotlib. Below, we demonstrate multiple examples of Monte Carlo simulations.\nEstimating π using Monte Carlo Simulation\nA classic example of Monte Carlo methods is estimating the value of π by simulating random points inside a unit square and counting how many fall inside a quarter circle.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_pi(num_samples):\n    \"\"\"\n    Estimate the value of π using the Monte Carlo method.\n    \n    - Generates `num_samples` random points inside a square [-1,1] x [-1,1].\n    - Determines how many points fall inside the unit circle.\n    - Uses the ratio of points inside the circle to estimate π.\n    - Visualizes the simulation with a scatter plot.\n    \"\"\"\n    # Generate random points\n    x = np.random.uniform(-1, 1, num_samples)\n    y = np.random.uniform(-1, 1, num_samples)\n\n    # Check if points are inside the unit circle\n    inside_circle = x**2 + y**2 &lt;= 1\n\n    # Estimate π\n    pi_estimate = (inside_circle.sum() / num_samples) * 4\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=(6,6))\n\n    # Plot points\n    ax.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label=\"Inside Circle\")\n    ax.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label=\"Outside Circle\")\n\n    # Draw square boundary\n    square_x = [-1, 1, 1, -1, -1]\n    square_y = [-1, -1, 1, 1, -1]\n    ax.plot(square_x, square_y, color='black', linewidth=2, label=\"Square Boundary\")\n\n    # Draw circle boundary\n    circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2, label=\"Unit Circle\")\n    ax.add_patch(circle)\n\n    # Set limits and labels\n    ax.set_xlim(-1.1, 1.1)\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_aspect('equal')\n    ax.legend()\n    ax.set_title(f\"Monte Carlo Estimation of π: {pi_estimate:.4f}\")\n\n    # Show plot\n    plt.show()\n\n    \n\n# Run simulation\nmonte_carlo_pi(10000)\n\n\n\n\n\n\n\n\n\nMonte Carlo Simulation for Portfolio Returns\nMonte Carlo simulations can be used to estimate the expected return of an investment portfolio over time.\nAssumptions in this simulation:\n\nLog-normal distribution of returns: Asset returns follow a normal distribution when compounded over time.\nIndependence of daily returns: Returns are randomly sampled from the normal distribution and do not exhibit autocorrelation.\nConstant mean and volatility: The expected return (mean) and volatility (standard deviation) are assumed to remain constant over the time horizon.\nNo external shocks: The model does not account for external factors like market crashes, policy changes, or economic shifts.\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_portfolio_returns(initial_investment=100000, num_simulations=10000, time_horizon=252, mu=0.07, sigma=0.2):\n    np.random.seed(42)  # For reproducibility\n    simulated_returns = np.random.normal(mu / time_horizon, sigma / np.sqrt(time_horizon), (num_simulations, time_horizon))\n    portfolio_values = initial_investment * np.cumprod(1 + simulated_returns, axis=1)\n    expected_return = np.mean(portfolio_values[:, -1])\n    \n    plt.figure(figsize=(10,6))\n    plt.plot(portfolio_values.T, alpha=0.1, color='blue')\n    plt.title('Monte Carlo Simulation of Portfolio Returns')\n    plt.xlabel('Trading Days')\n    plt.ylabel('Portfolio Value')\n    plt.show()\n    \n    return expected_return\n\nexpected_return = monte_carlo_portfolio_returns()\nprint(f'Expected Portfolio Value after One Year: ${expected_return:.2f}')\n\n\n\n\n\n\n\n\n\nExpected Portfolio Value after One Year: $107047.67",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Appendix_MonteCarlo.html#advantages-and-limitations-of-monte-carlo-simulations",
    "href": "Appendix_MonteCarlo.html#advantages-and-limitations-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.4 Advantages and Limitations of Monte Carlo Simulations",
    "text": "16.4 Advantages and Limitations of Monte Carlo Simulations\nAdvantages - Versatility: Can be applied to a wide range of problems in different fields. - Scalability: Can handle complex and high-dimensional problems that are difficult to solve analytically. - Flexibility: Works well with stochastic processes and probabilistic modeling.\nLimitations - Computationally Expensive: Requires large numbers of simulations for accurate results. - Dependent on Randomness: The accuracy of results improves with more iterations, but random variability exists. - Model Sensitivity: Results can be sensitive to the assumptions and distributions used in the simulation.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  }
]