[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pricing and Hedging Derivative Securities: Theory and Methods",
    "section": "",
    "text": "Preface\n\n\n\n\n\n\nCode/Plots To Do\n\n\n\n\n\n\nKB: add this plot at end of Section 10.3: https://learn-investments.rice-business.org/futures-options/black-scholes-values\nKB: add this plot to Section 10.4: https://learn-investments.rice-business.org/futures-options/monte-carlo\nKB: add this plot to Chapter 12: https://learn-investments.rice-business.org/futures-options/delta-hedges\nKB: add this plot to Section 10.5: https://learn-investments.rice-business.org/futures-options/binomial-trees\nKB: add left panel of this plot to Section 22.5: https://learn-investments.rice-business.org/futures-options/binomial-convergence\nKB: add this plot to Chapter 11: https://learn-investments.rice-business.org/futures-options/american-boundary\nKB: add this plot to Chapter 11: https://learn-investments.rice-business.org/futures-options/europeans-americans\nKB: left panel in interactive Ito Approximation should have legend inside the figure to avoid shrinking the figure\nKB: add import Black_Scholes_Call and uncomment lines in Asians and Other Exotics code blocks\nKB: substitute root for bisection and multivariate_normal for binomial_prob\nKB: convert plots to plotly\nKB: add imports of libraries in each code block\n\n\n\n\n\n\n\n\n\n\nWriting To Do\n\n\n\n\n\n\nKB: add exercises in Ito chapter that use Ito’s formula\nKB: move explanation of digitals and share digitals from Chapter 10 (Black-Scholes) to Chapter 4 (Digitals)\nKB: check exercises in chapters that have been split into multiple parts\nKB: add discussions of approximations for Asians, baskets, and spreads in Asians chapter.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Chapter_Options.html",
    "href": "Chapter_Options.html",
    "title": "1  Options",
    "section": "",
    "text": "1.1 Intrinsic Value and Time Value\nFinancial options are rights to buy and sell assets at pre-specified prices. The rights are traded on exchanges and also as private contracts (called over-the-counter or OTC). A call option is a right to buy an asset. A put option is a right to sell an asset. The pre-specified price is called the exercise price, the strike price, or simply the strike. The asset to which an option pertains is called the underlying asset, or, more briefly, the underlying.\nHere is a snapshot of market statistics regarding call options on Apple stock (AAPL) traded on the Chicago Board Options Exchange (CBO\\E). We are accessing the data courtesy of Yahoo Finance.\nThe maturity date for the particular contracts that are displayed is shown in the text above the table. Many different maturities are traded throughout each day. The data shown is 15 minutes delayed (and obviously more than 15 minutes if the code is executed outside trading hours).\nThe first column shows the strike prices of the calls and puts that are available for trading. The exchange chooses which strikes people can trade and at which maturities. As the price of AAPL stock moves, the exchange will introduce new strikes to maintain a bracket around the stock price. Typically, interest in trading the strikes that become further away from the stock price will decline, except for people closing positions. Positions are closed when a trader makes an offsetting trade: buying the same maturity and strike if they sold before or selling if they bought before. The offsetting trade cancels the option or obligation created by the initial trade, and the trader gains or loses the difference between the selling and buying prices.\nWhen a strike is first introduced for trading, no one has a position in it. Positions are created by trade. We say that a buyer is long the option, and a seller is short. The standard contract size is 100 shares, so a buyer of one contract is long options on 100 shares of the underlying asset (AAPL in this example), and a seller is short options on 100 shares. The number of longs always equals the number of shorts. If the first trade is for 1 contract, we say that open interest is 1 contract, meaning that there is 1 long and 1 short. Subsequent trades increase open interest if new positions are created or reduce open interest if existing positions are closed. Open interest is shown in the penultimate column of the table.\nWhen a trade is made on an exchange, the exchange clearinghouse becomes the counterparty to both sides. For example, anyone who is long a call option has an option to buy the underlying asset at the strike from the clearinghouse. Simlarly, anyone who is short a call option has an obligation to deliver the underlying asset to the clearinghouse and receive the strike, should the clearinghouse exercise the option. The clearinghouse exercises options when an option of the same strike and maturity is exercised against it. This causes the underlying asset to be passed through the clearinghouse from the short party to the long party when the long party exercises. The strike is passed through in the opposite direction. The short party against whom the clearinghouse exercises is chosen randomly among the people who are short that particular option. The risk of a short party defaulting when an option is exercised is thus borne by the clearinghouse. The clearinghouse wishes to minimize this risk and therefore requires a seller of an option to post collateral in a margin account. This procedure provides the long party assurance that the option will be honored, which would otherwise be impossible with anonymous trade. It also makes it possible for contracts to be cancelled by making offsetting trades with a different counterparty than the counterparty to the original trade.\nThe second column of the table shows the bid prices. The bid price is the highest price at which other traders are willing to buy (it is what traders are bidding for the option, as in bidding to buy a house). So, if you submitted an order to sell at the market price (called a market order), you would trade at the bid, assuming the bid did not change before your order reached the exchange’s computers. Thus, the bid price is what you would pay for the right to buy AAPL at the strike price at any time up to and including the maturity date.\nThe ask price is the lowest price at which others are willing to sell (similar to the asking price for a house). The difference between the ask price and the bid price is called the bid-ask spread. An alternative to submitting a market order and trading at the bid or ask is to submit a limit order. A limit order specifies a limit price: a buyer will not pay more than her specified limit price, and a seller will not receive less than his specified limit price. A limit order provides a trader the opportunity to receive a better price than the current market price, but the downside is that the limit order may never execute.\nFor call options, bid and ask prices are lower for higher strikes. It is better to have the right to buy AAPL at $100 a share than to have the right to buy it at $200 per share, so the market price of the former is higher than the price of the latter.\nThe fourth column of the table shows the most recent transaction price. For strikes away from the current AAPL price, the most recent transaction may have been several days ago. The change and %change are the changes during the current trading day relative to the last price of the prior day (more precisely, it is relative to the settlement price, which is discussed below). The volume is the number of contracts traded on the most recent day on which the strike traded. Implied volatility, shown in the last column, is discussed in Chapter 10.",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#investing-in-options",
    "href": "Chapter_Options.html#investing-in-options",
    "title": "1  Options",
    "section": "1.2 Investing in Options",
    "text": "1.2 Investing in Options",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#hedging-with-options",
    "href": "Chapter_Options.html#hedging-with-options",
    "title": "1  Options",
    "section": "1.3 Hedging with Options",
    "text": "1.3 Hedging with Options",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#selling-options-for-income",
    "href": "Chapter_Options.html#selling-options-for-income",
    "title": "1  Options",
    "section": "1.4 Selling Options for Income",
    "text": "1.4 Selling Options for Income",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#option-spreads",
    "href": "Chapter_Options.html#option-spreads",
    "title": "1  Options",
    "section": "1.5 Option Spreads",
    "text": "1.5 Option Spreads\n\n\n\nFigure 1.1: The value at maturity of a portfolio of options is plotted, assuming all of the options have the same maturity. Enter positive quantities for long positions in options and negative quantities for short positions. Long or short positions in the underlying asset can also be included. Cash means a position in a risk-free asset sufficient to deliver the specified amount of cash at the option maturity, for example, a long or short position in a zero-couponbond that matures at the option maturity.",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#put-call-parity",
    "href": "Chapter_Options.html#put-call-parity",
    "title": "1  Options",
    "section": "1.6 Put-Call Parity",
    "text": "1.6 Put-Call Parity",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#american-options",
    "href": "Chapter_Options.html#american-options",
    "title": "1  Options",
    "section": "1.7 American Options",
    "text": "1.7 American Options",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Options.html#dividends",
    "href": "Chapter_Options.html#dividends",
    "title": "1  Options",
    "section": "1.8 Dividends",
    "text": "1.8 Dividends",
    "crumbs": [
      "Part I: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Binomial_Tree.html",
    "href": "Chapter_Intro_Binomial_Tree.html",
    "title": "3  Introduction",
    "section": "",
    "text": "3.1 Basics of the Binomial Tree Model\nThe binomial tree model is a discrete-time framework used to price derivative securities. It is widely used in financial engineering for valuing options and other contingent claims. This model is particularly useful because it provides an intuitive approach to pricing and allows for easy incorporation of various features such as early exercise in American options.\nThe binomial tree model is based on the assumption that, over a small time step, the price of an underlying asset can move up or down by a certain factor. The model is constructed iteratively to estimate the fair value of derivatives such as options.\nAn \\(n\\) period binomial tree model can be described as follows:\n\\[\nS_{t+\\Delta t} = S_t \\times u_t \\quad \\text{(up move)}\n\\] or \\[\nS_{t+\\Delta t} = S_t \\times d_t \\quad \\text{(down move)}\n\\]\n\\[\np_t = \\frac{e^{r_t \\Delta t} - d_t}{u_t - d_t}\n\\]\nwhere $ r_t $ is the risk-free rate from \\(t\\) to \\(t+\\Delta t\\).",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Binomial_Tree.html#basics-of-the-binomial-tree-model",
    "href": "Chapter_Intro_Binomial_Tree.html#basics-of-the-binomial-tree-model",
    "title": "3  Introduction",
    "section": "",
    "text": "There are \\(n+1\\) time points with \\(t=0, \\Delta t, 2 \\Delta t, ..., n\\Delta t\\), where \\(\\Delta t\\) is the time step.\nAt each time point \\(t\\), the price of the underlying asset either goes up by a factor \\(u_t&gt;1\\) with probability \\(p_t\\in(0,1)\\) or goes down by a factor \\(d_t&lt;1\\) with probability \\(1-p_t\\).\nGiven an initial stock price \\(S_0\\), the price of the underlying asset evolves as:\n\n\n\nThe absence of arbitrage ensures the model can be solved using risk-neutral valuation, where the risk-neutral probability of an up move is:\n\n\n\n\nExample: Three-Period Recombining Binomial Tree\nThis is an example of a three-period recombining binomial tree: \\(n=3\\), \\(u=1.1\\), \\(d=1/u\\), \\(\\Delta t=1\\):\n\n\nCode\nimport plotly.graph_objects as go\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1):\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t  # Time step on x-axis\n            y = 2 * j - t  # Centered y-axis positioning for symmetry\n            nodes[(x, y)] = round(S0 * (u ** j) * (d ** (t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = 2 * j - t\n            edges.append(((x, y), (x + 1, y + 1)))  # Up move\n            edges.append(((x, y), (x + 1, y - 1)))  # Down move\n\n    fig = go.Figure()\n\n    # Add edges to the plot\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        fig.add_trace(go.Scatter(x=x_coords, y=y_coords, mode='lines', line=dict(color='black'), showlegend=False))\n\n    # Add nodes to the plot\n    x_vals = [key[0] for key in nodes.keys()]\n    y_vals = [key[1] for key in nodes.keys()]\n    labels = [str(nodes[key]) for key in nodes.keys()]\n\n    fig.add_trace(go.Scatter(\n        x=x_vals, y=y_vals, mode='markers+text',\n        marker=dict(size=20, color='lightblue'),\n        text=labels, textposition=\"top center\",\n        showlegend=False\n    ))\n\n    fig.update_layout(\n        title=\"3-Period Symmetric Binomial Tree (u=1.1, d=1/u)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        plot_bgcolor='white',\n        width=700,\n        height=500\n    )\n\n    fig.show()\n\nplot_symmetric_binomial_tree()\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1, vertical_scale=0.5, title_pad=20):\n    \"\"\"\n    Plots a 3-period symmetric binomial tree using Matplotlib,\n    with options to compress the vertical spacing and add space between the title and the plot.\n\n    :param S0: initial stock price\n    :param u: up factor\n    :param vertical_scale: compresses or expands the vertical spacing\n    :param title_pad: extra spacing between the title and the tree (in points)\n    \"\"\"\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)  # scale the vertical distance\n            nodes[(x, y)] = round(S0 * (u**j) * (d**(t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)\n            # Up move\n            edges.append(((x, y), (x + 1, y + vertical_scale)))\n            # Down move\n            edges.append(((x, y), (x + 1, y - vertical_scale)))\n\n    # Create a Matplotlib figure\n    fig, ax = plt.subplots(figsize=(7, 5))\n\n    # Plot edges\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes\n    x_vals = [k[0] for k in nodes.keys()]\n    y_vals = [k[1] for k in nodes.keys()]\n    labels = [str(nodes[k]) for k in nodes.keys()]\n    ax.scatter(x_vals, y_vals, s=300, color='lightblue')\n\n    # Add text labels above each node\n    for x, y, label in zip(x_vals, y_vals, labels):\n        ax.text(x, y + 0.3 * vertical_scale, label, ha='center', va='bottom')\n\n    # Title with extra spacing set by 'pad'\n    ax.set_title(\n        f\"3-Period Symmetric Binomial Tree (u={u}, d={round(d,2)})\",\n        pad=title_pad\n    )\n\n    # Style the plot\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n\n    plt.show()\n\n# Example usage: extra spacing of 20 points between the caption and the tree\nplot_symmetric_binomial_tree(vertical_scale=0.5, title_pad=20)",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Binomial_Tree.html#a-generalized-n-period-tree",
    "href": "Chapter_Intro_Binomial_Tree.html#a-generalized-n-period-tree",
    "title": "3  Introduction",
    "section": "3.2 A Generalized \\(n\\)-Period Tree",
    "text": "3.2 A Generalized \\(n\\)-Period Tree\nWe can generalize the above basic binomial tree to a more general one where each node at any time \\(t\\) can have a variable number of branches and the branching pattern can vary across both time steps and nodes. This flexible structure can be useful for pricing more complex derivative securities.\n\nDefinition of a Generalized \\(n\\)-period tree\n\n1. Tree Structure\nWe define the tree as a directed graph \\(T = (N, E)\\), where:\n\n\\(N\\) is the set of nodes.\n\\(E \\subseteq N \\times N\\) is the set of edges, representing transitions between nodes across periods.\n\nEach node is indexed by:\n\\[\nN_{t,i}, \\quad t = 0, 1, \\dots, n, \\quad i = 1, \\dots, |N_t|\n\\]\nwhere:\n\n\\(t\\) represents the time point,\n\\(i\\) represents the node index at time \\(t\\),\n\\(|N_t|\\) denotes the number of nodes at time \\(t\\).\n\n\n\n\n2. Variable Branching\nEach node \\(N_{t,i}\\) has \\(B_{t,i}\\) branches, which represents the number of children (next-period nodes) it connects to. The total number of nodes at time \\(t+1\\) is then:\n\\[\n|N_{t+1}| = \\sum_{i=1}^{|N_t|} B_{t,i}\n\\]\nEach edge represents a transition probability \\(P_{t,i,j}\\) from node \\(N_{t,i}\\) at time \\(t\\) to node \\(N_{t+1, j}\\) at time \\(t+1\\), satisfying:\n\\[\n\\sum_{j=1}^{B_{t,i}} P_{t,i,j} = 1, \\quad \\forall i, t\n\\]\nwhere \\(P_{t,i,j}\\) is the probability of transitioning from \\(N_{t,i}\\) to \\(N_{t+1,j}\\).\n\n\n\n3. Node Values and Transition Rule\nEach node has a value \\(S_{t,i}\\), which can represent an evolving variable (e.g., stock price, state variable). The value transition function is defined as:\n\\[\nS_{t+1,j} = f(S_{t,i}, a_{t,i,j})\n\\]\nwhere:\n\n\\(S_{t,i}\\) is the value at node \\(N_{t,i}\\),\n\\(a_{t,i,j}\\) is a transition factor specific to the branch from \\(N_{t,i}\\) to \\(N_{t+1,j}\\),\n\\(f\\) is a value update function, often modeled as: \\[\nS_{t+1,j} = S_{t,i} \\times a_{t,i,j}\n\\]\n\nExample: Consider a 3-period tree with variable branching:\n\nPeriod 0: 1 node (\\(B_{0,1} = 2\\))\nPeriod 1: 2 nodes, each with different branching (\\(B_{1,1} = 3, B_{1,2} = 2\\))\nPeriod 2: 5 nodes, each branching further (\\(B_{2,1} = 2, B_{2,2} = 2, B_{2,3} = 1, B_{2,4} = 3, B_{2,5} = 2\\)).\n\nThe node count evolves as:\n\\[\n|N_1| = B_{0,1} = 2, \\quad\n|N_2| = B_{1,1} + B_{1,2} = 3 + 2 = 5, \\quad\n|N_3| = 2 + 2 + 1 + 3 + 2 = 10\n\\]\nThus, a generalized tree dynamically adjusts the branching structure.\nSpecial Cases\n\nBinomial Tree (\\(B_{t,i} = 2\\)): Each node has exactly two branches, leading to an up/down model.\nTrinomial Tree (\\(B_{t,i} = 3\\)): Each node has three possible transitions (e.g., up, middle, down).\nAdaptive Trees: \\(B_{t,i}\\) can depend on volatility or other dynamic parameters.\n\n\n\n\nA Graphical Illustration of a Generalized 3-Period Tree\nHere is a 3-period example with variable branching:\n\n\nCode\nimport plotly.graph_objects as go\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_symmetric():\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # next_index[t] tracks how many nodes have been created at period t so far\n    next_index = defaultdict(int)\n    next_index[0] = 1  # We have 1 node at t=0\n\n    # transitions[(t, i)] = list of factors for each branch out of node (t, i)\n    transitions = {\n        (0, 0): [1.1, 0.9],       # At t=0, i=0 =&gt; 2 branches\n        (1, 0): [1.2, 1.0, 0.8],  # At t=1, i=0 =&gt; 3 branches\n        (1, 1): [1.1, 0.85],      # At t=1, i=1 =&gt; 2 branches\n        (2, 0): [1.3, 0.9],       # At t=2, i=0 =&gt; 2 branches\n        (2, 1): [1.2, 1.0],       # At t=2, i=1 =&gt; 2 branches\n        (2, 2): [1.1],            # At t=2, i=2 =&gt; 1 branch\n        (2, 3): [1.15, 0.95, 0.85], # t=2, i=3 =&gt; 3 branches\n        (2, 4): [1.1, 0.9]        # t=2, i=4 =&gt; 2 branches\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_value = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_value = round(base_value * factor, 2)\n            nodes[(child_t, child_i)] = child_value\n\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Count how many nodes per period =&gt; assign symmetrical y-coordinates\n    nodes_in_period = defaultdict(list)\n    for (t, i), val in nodes.items():\n        nodes_in_period[t].append(i)\n\n    # For each period t, sort node indexes, then map them to symmetrical positions around 0\n    coords = {}  # coords[(t, i)] = y_position\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n\n        # We'll assign positions from 0..(count-1), then shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            # E.g., if count=5, positions -&gt; 0,1,2,3,4 =&gt; shift by -2 =&gt; -2,-1,0,1,2\n            shift = -(count - 1) / 2\n            y = idx + shift\n            coords[(t, node_i)] = y\n\n    # 3. Build the plot\n    fig = go.Figure()\n\n    # Add edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1, t2]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        fig.add_trace(go.Scatter(\n            x=x_coords,\n            y=y_coords,\n            mode='lines',\n            line=dict(color='black'),\n            showlegend=False\n        ))\n\n    # Add nodes (markers+text)\n    for (t, i), val in nodes.items():\n        fig.add_trace(go.Scatter(\n            x=[t],\n            y=[coords[(t, i)]],\n            mode='markers+text',\n            marker=dict(size=10, color='blue'),\n            text=[str(val)],\n            textposition='top center',\n            showlegend=False\n        ))\n\n    fig.update_layout(\n        title=\"3-Period Variable Branching Tree (Symmetric Layout)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        width=900,\n        height=600,\n        plot_bgcolor='white'\n    )\n\n    fig.show()\n\n# Call the plotting function\nplot_variable_branching_tree_symmetric()\n\n\n                            \n                                            \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0):\n    \"\"\"\n    Plots a 3-period variable branching tree in a narrower vertical \n    layout and a longer horizontal layout.\n\n    :param vertical_scale: Factor (&lt;1 = narrower, &gt;1 = taller) for vertical spacing\n    :param horizontal_scale: Factor (&gt;1 = longer, &lt;1 = shorter) for horizontal spacing\n    \"\"\"\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # Track how many nodes created at each period t\n    next_index = defaultdict(int)\n    next_index[0] = 1\n\n    # transitions: dict[(t, i)] -&gt; list of factors from node (t,i)\n    transitions = {\n        (0, 0): [1.1, 0.9],\n        (1, 0): [1.2, 1.0, 0.8],\n        (1, 1): [1.1, 0.85],\n        (2, 0): [1.3, 0.9],\n        (2, 1): [1.2, 1.0],\n        (2, 2): [1.1],\n        (2, 3): [1.15, 0.95, 0.85],\n        (2, 4): [1.1, 0.9]\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_val = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_val = round(base_val * factor, 2)\n            nodes[(child_t, child_i)] = child_val\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Assign symmetrical y-coords for each period\n    nodes_in_period = defaultdict(list)\n    for (t, i) in nodes.keys():\n        nodes_in_period[t].append(i)\n\n    coords = {}\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n        # positions =&gt; 0..(count-1), shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            shift = -(count - 1) / 2\n            y = (idx + shift) * vertical_scale\n            coords[(t, node_i)] = y\n\n    # 3. Build the Matplotlib figure\n    fig, ax = plt.subplots(figsize=(12, 4))  # Wider figure\n\n    # Plot edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1 * horizontal_scale, t2 * horizontal_scale]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes + text\n    for (t, i), val in nodes.items():\n        x_ = t * horizontal_scale\n        y_ = coords[(t, i)]\n        ax.scatter(x_, y_, s=100, color='blue')\n        ax.text(x_, y_ + 0.2 * vertical_scale, str(val),\n                ha='center', va='bottom')\n\n    ax.set_title(\"3-Period Variable Branching Tree (Scaled)\")\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n    plt.show()\n\n# Example usage: narrower by vertical_scale=0.5, longer by horizontal_scale=2.0\nplot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0)",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Chapter_Intro_Binomial_Tree.html#conclusion",
    "href": "Chapter_Intro_Binomial_Tree.html#conclusion",
    "title": "3  Introduction",
    "section": "3.3 Conclusion",
    "text": "3.3 Conclusion\nThe binomial tree model provides an effective method for pricing derivative securities. Basic binomial trees reduce computational complexity, while generalized trees may be necessary for more complex option pricing models. In further chapters, we will explore the valuation of European and American options using these models.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html",
    "href": "Chapter_Brownian.html",
    "title": "4  Brownian Motion",
    "section": "",
    "text": "4.1 Brownian Paths\nBrownian motion is a fundamental tool for modeling variables that change randomly over time. Consider predicting a future stock price. We don’t know today what the price will be tomorrow, nor what it will be the following day, nor what it will be the day after that. We can regard the price three days from now as today’s price plus the change from today to tomorrow plus the change from tomorrow to the following day plus the change from that day to the next. Thus, there are three random changes in this small example. A simple way to model this situation is to assume that each change is a normally distributed random variable with some mean and variance. Thus, the price in three days is viewed as today’s price plus the sum of three normal increments.\nRather than predicting daily changes as in the previous paragraph, we might be interested in predicting hourly changes or even minute-to-minute changes. This will lead to more, but smaller, increments. A Brownian motion is a model of changes at all frequencies, with all changes being normally distributed.\nWe will ultimately deal with different means and different variances, but we start with what is called a standard Brownian motion, which is similar to beginning the study of normal random variables by studying a standard normal variable, that is, a normal random variable with a zero mean and a unit variance. The definition of a standard Brownian motion is that its change over any time interval\nThe last bullet point reflects the fact that things are more uncertain the further into the future we look.1\nWe call a variable that changes randomly over time a stochastic process. A path of a stochastic process is a random function of time, recording how it evolves over time. We can plot an approximate path of a Brownian motion by summing up normally distributed changes. We take an interval of time \\([0, t]\\) and split it up as \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] where the times \\(t_i\\) are equally spaced, meaning that \\(t_i-t_{i-1} = t/n\\), which we will call \\(\\Delta t\\). We generate \\(n\\) normally distributed random variables with zero means and variance equal to \\(\\Delta t\\) and define the approximate Brownian motion, which we call \\(B\\), as the cumulative sum of the normal variables. By convention, we start any Brownian motion at \\(B_0=0\\). Our approximation fits the definition of a standard Brownian motion, except that we have limited the frequency of the changes to \\(n\\) changes within the interval. By taking \\(n\\) larger, we can always get a better approximation.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\n\n# generate dB for each time step\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\n\n# B starts at 0 and is cumulative sum of the dB\nB = np.zeros(n+1)\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Approximate Brownian Motion',\n    template='plotly_white',\n    height=300,\n)\n\nfig.show()\n\n\n\n\nFigure 4.1: A path of an approximate Brownian motion with 1,000 normally distributed steps.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#binomial-approximation",
    "href": "Chapter_Brownian.html#binomial-approximation",
    "title": "4  Brownian Motion",
    "section": "4.2 Binomial Approximation",
    "text": "4.2 Binomial Approximation\nWe can also generate an approximate path of a Brownian motion by taking only up or down steps of a fixed size at each date, rather than using normally distributed steps. We call this a binomial model. A binomial model approximates the normally distributed increments of a Brownian Motion due to the Central Limit Theorem, which says that an appropriately scaled sum of a large number of random variables has approximately a normal distribution. The binomial approximation is often useful for pricing options, especially American options, as we will see.\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\nsqdt = np.sqrt(dt)\n\n# generate dB for each time step\ndB = np.random.choice([-sqdt, sqdt], size=n)\nB = np.zeros(n+1)\n\n# Brownian path starts at 0 and is cumulative sum of the dB\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Binomial Process',\n    template='plotly_white',\n    height=300,\n)\n\nfig.show()\n\n\n\n\nFigure 4.2: A path of an approximate Brownian motion with 1,000 binomial steps.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#sec-s:quadraticvariation",
    "href": "Chapter_Brownian.html#sec-s:quadraticvariation",
    "title": "4  Brownian Motion",
    "section": "4.3 Nonzero Quadratic Variation",
    "text": "4.3 Nonzero Quadratic Variation\nFigure 4.1 and Figure 4.2 illustrate a distinctive characteristic of a Brownian motion: it jiggles rapidly, moving up and down in a very erratic way. The name Brownian motion derives from the botanist Robert Brown’s observations of the erratic behavior of particles suspended in a fluid. The plot of other functions with which we may be familiar will be much smoother. This is captured in the concept of quadratic variation.\nConsider a discrete partition \\[0=t_0 &lt; t_1 &lt; t_2 &lt; \\cdots &lt; t_n=t\\] of the time interval \\([0,t]\\) as before. Let \\(B\\) be a Brownian motion and calculate the sum of squared changes \\[\\sum_{i=1}^n (\\Delta B_{t_i})^2\\; ,\\] where \\(\\Delta B_{t_i}\\) denotes the change \\(B_{t_i}-B_{t_{i-1}}.\\) If we consider finer partitions with the length of each time interval \\(t_i-t_{i-1}\\) going to zero, the limit of the sum is called the quadratic variation of the process. For a Brownian motion, the quadratic variation over an interval \\([0,t]\\) is equal to \\(t\\) with probability one. Here is a plot of the quadratic variation (that is, the cumulative sum of squared changes) of the previous approximation of a Brownian motion. The plot shows that the approximation has quadratic variation through each date \\(s \\le t\\) that is approximately equal to \\(s\\).\n\n\nCode\n# using the approximate path created in the previous code block\n# quadratic variation is cumulative sum of squared changes\n\ndQ = dB**2\nQ = np.zeros(n+1)\nQ[1:] = dQ.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=Q, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;' \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Quadratic Variation',\n    template='plotly_white',\n    height=300\n)\nfig.show()\n\n\n\n\nFigure 4.3: Quadratic variation of an approximate Brownian motion path with 1,000 normally distributed steps.\n\n\n                                                \n\n\n\n\nTo better visualize the convergence of the quadratic variation of a Brownian motion as the number \\(n\\) of subdivisions of the interval \\([0, t]\\) grows, we encourage readers to interact with the plot below, which simulates a handful of approximate Brownian paths and their quadratic variations.\n\n\n\nFigure 4.4: Convergence of quadratic variation of approximate Brownian motions.\n\n\n\n\n\n\n\nThe typical functions with which we are familiar are continuously differentiable. If \\(x\\) is a continuously differentiable function of time, then the quadratic variation of \\(x\\) is zero. A simple example is a linear function: \\(x_s = as\\) for all \\(s\\) for a constant \\(a\\). Then, using the previous partition of the interval \\([0, t]\\), the sum of squared changes of the function from \\(0\\) to \\(t\\) is \\[\\sum_{i=1}^n (\\Delta x_{t_i})^2 = \\sum_{i=1}^n  [a\\,\\Delta t]^2 = na^2 (\\Delta t)^2 = na^2 \\left(\\frac{t}{n}\\right)^2 = \\frac{a^2t^2}{n} \\rightarrow 0\\] as \\(n \\rightarrow \\infty\\).\nFor example, if \\(a=1\\) and \\(n=1000\\), then the sum of squared changes from date \\(0\\) to date \\(1\\) is \\(1000 \\times 0.001^2 = 0.001\\). Essentially the same argument shows that the quadratic variation of any continuously differentiable function is zero, because such a function is approximately linear at each point. Thus, the jiggling of a Brownian motion, which leads to the nonzero quadratic variation, is quite unusual.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#infinite-total-variation",
    "href": "Chapter_Brownian.html#infinite-total-variation",
    "title": "4  Brownian Motion",
    "section": "4.4 Infinite Total Variation",
    "text": "4.4 Infinite Total Variation\nTo explain exactly how unusual the nonzero quadratic variation is, it is helpful to consider total variation, which is defined in the same way as quadratic variation but with the squared changes \\((\\Delta B_{t_i})^2\\) replaced by the absolute values of the changes \\(|\\Delta B_{t_i}|.\\) A general mathematical theorem states that, if the quadratic variation of a continuous function is nonzero, then its total variation is infinite. Therefore, each path of a Brownian motion has infinite total variation (with probability one). This means that, to draw a true path of a Brownian motion on a blackboard, we would need an infinite amount of chalk!\nIf we zoom in close enough in Figure 4.1, we can see the linear steps \\(\\Delta B\\). However, if we could zoom in on a segment of a path of a true Brownian motion, it would look much the same as the entire picture does to the naked eye—no matter how small the segment, we would still see the characteristic jiggling. That jiggling, even at microscopic scales, is the source of the infinite variation.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#continuous-martingales-and-levys-theorem",
    "href": "Chapter_Brownian.html#continuous-martingales-and-levys-theorem",
    "title": "4  Brownian Motion",
    "section": "4.5 Continuous Martingales and Levy’s Theorem",
    "text": "4.5 Continuous Martingales and Levy’s Theorem\nOne may well question why we should be interested in this curious mathematical object. The reason is that asset pricing inherently involves martingales (variables that evolve randomly over time in such a way that their expected changes are always zero), as our fundamental pricing formula (Equation 7.28) establishes. Furthermore, continuous processes (variables whose paths are continuous functions of time) are much more tractable mathematically than are processes that can jump at some instants. So, we are led to a study of continuous martingales. An important fact is that any non-constant continuous martingale must have infinite total variation. So, the normal functions with which we are familiar are left behind once we enter the study of continuous martingales.\nThere remains perhaps the question of why we focus on Brownian motion within the world of continuous martingales. The answer here is that any continuous martingale is really just a transformation of a Brownian motion. This is a consequence of the following important fact, which is known as Levy’s theorem: \n\n\n\n\n\n\n4.6\n\n\n\nA continuous martingale is a Brownian motion if and only if its quadratic variation over each time interval \\([s, t]\\) equals \\(t-s\\).\n\n\nThus, among continuous martingales, a Brownian motion is distinguished by the condition that its quadratic variation over each time interval is equal to the length of the interval. This is really just a normalization. A different continuous martingale may have a different quadratic variation, but it can be converted to a Brownian motion by changing the clock speed to measure time according to the quadratic variation. Furthermore, many continuous martingales can be constructed as stochastic integrals with respect to a Brownian motion. We take up that topic in the next chapter.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#sec-s:correlation",
    "href": "Chapter_Brownian.html#sec-s:correlation",
    "title": "4  Brownian Motion",
    "section": "4.7 Correlation of Brownian Motions",
    "text": "4.7 Correlation of Brownian Motions\nConsider two standard Brownian motions \\(B_1\\) and \\(B_2\\). The relation between the two Brownian motions is determined by their covariance or correlation. Given dates \\(s&lt;t\\), we know that both changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\) are normally distributed with zero means and variances equal to \\(t-s\\), given information at date \\(s\\). There is a stochastic process \\(\\rho\\) such that the covariance of these two normally distributed random variables, given the information at date \\(s\\), is \\[\\mathbb{E}_s \\left[\\int_s^t \\rho_u\\,\\mathrm{d}u\\right]\\; .\\] The process \\(\\rho\\) is called the correlation process of the two Brownian motions. The correlation of the changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\), given information at date \\(s\\), is \\[\\frac{\\text{covariance}}{\\text{product of standard deviations}}  = \\frac{\\mathbb{E}_s\\int_s^t \\rho_u \\,\\mathrm{d}u}{\\sqrt{t-s} \\sqrt{t-s}} = \\frac{1}{t-s}\\mathbb{E}_s\\int_s^t \\rho_u \\,\\mathrm{d}u\\; .\\] Thus, the correlation is the expected average value of \\(\\rho_u\\). In particular, when \\(\\rho\\) is constant, the correlation of the changes is \\(\\rho\\).\nThe two Brownian motions are independent if \\(\\rho=0\\). In this case, knowledge of one Brownian motion – even knowledge of its future values – will not help to predict the other.\nJust as we computed quadratic variation by taking a limit of sums of squared changes, we compute what is called joint variation by taking a limit of sums of products of changes. For the two Brownian motions, the joint variation over an interval \\([0, t]\\) is \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n \\Delta B_{1t_i} \\times \\Delta B_{2t_i} \\] given increasingly fine partitions \\(0=t_0 &lt; \\cdots &lt; t_n=t\\) as before. The joint variation of two Brownian motions equals the integral of their correlation process; that is, the joint variation over \\([0, t]\\) equals \\(\\int_0^t \\rho_s\\,\\mathrm{d}s\\), with probability one. Thus, the expected joint variation equals the covariance.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#section-1",
    "href": "Chapter_Brownian.html#section-1",
    "title": "4  Brownian Motion",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nConsider a discrete partition \\(0=t_0 &lt; t_1 &lt; \\cdots t_n=t\\) of the time interval \\([0,t]\\) with \\(t_i - t_{i-1} = \\Delta t = t/n\\) for each \\(i\\). Consider the function \\[X_t=\\mathrm{e}^t\\; .\\] Write a function that computes and plots \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\), where \\[\\Delta X_{t_i} = X_{t_i}-X_{t_{i-1}} = \\mathrm{e}^{t_i} - \\mathrm{e}^{t_{i-1}}\\; .\\]\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous problem for the function \\(X_t = t^3\\). In both this and the previous problem, can you tell what happens to \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\) as \\(n \\rightarrow \\infty\\)?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nWrite a function to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^2\\) from a partition of an interval \\([0, t]\\), for given \\(t\\) and \\(n\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous problem to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^3\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous problem, computing instead \\(\\sum_{i=1}^n |\\Delta B_{t_i}|\\) where \\(| \\cdot |\\) denotes the absolute value. What happens to this sum as \\(n \\rightarrow \\infty\\)?",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Brownian.html#footnotes",
    "href": "Chapter_Brownian.html#footnotes",
    "title": "4  Brownian Motion",
    "section": "",
    "text": "A formal definition of a Brownian motion would include a specification of the information that we have for predicting the future. The definition given here is correct when the only information is the past history of the Brownian motion.↩︎",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html",
    "href": "Chapter_Ito.html",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "5.1 Examples\nWe use the changes of a Brownian motion to model randomness. We build other stochastic processes using those changes. The general idea is \\[\\text{change} = \\text{mean} + \\text{std dev} \\times \\text{change in Brownian motion}\\,.\\] The mathematical foundations for our construction were created by K. Ito. The key concepts are the Ito integral, Ito processes, and Ito’s formula (also called Ito’s lemma). Using these foundations, we can build quite general processes from changes in Brownian motions, including processes with non-normal distributions.\nWe begin with some simple examples. Consider a discrete partition of a time interval: \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] with equally spaced times. Let \\(\\Delta t\\) denote the difference between successive times.\nFirst, let’s drop the randomness entirely. Consider the equation \\[X_{t_i} -  X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t \\qquad(5.1)\\] for a constant \\(\\mu\\). Thus, we have “change \\(\\,=\\,\\) mean,” where the mean is proportional to the previous value with proportionality factor \\(\\mu \\Delta t\\). Figure 5.1 presents a plot of \\(X\\), for particular values of \\(X_0\\), \\(\\mu\\), and \\(\\Delta t\\).\nIf we increase \\(n\\), making \\(\\Delta t\\) smaller, then \\(X\\) converges to the solution of the ordinary differential equation \\[\\,\\mathrm{d}X_t = \\mu X_t\\,\\mathrm{d}t\\,. \\qquad(5.2)\\] Equation 5.2 has a known solution, which is \\[X_t = X_0 \\mathrm{e}^{\\mu t}\\,. \\qquad(5.3)\\] To verify this, we only need to differentiate \\(X\\) defined in Equation 5.3: \\[\\frac{\\,\\mathrm{d}X_t}{\\,\\mathrm{d}t} = \\mu X_0 \\mathrm{e}^{\\mu t} = \\mu X_t\\,.\\] The function presented in Equation 5.3 is also shown in Figure 5.1.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nn = 10   # number of subdivisions\nt = 1     # last date\nDeltat = t/n\nX1 = np.ones(n+1)\nfor i in range(1, n+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat\n\nX2 = np.exp(mu * np.arange(0, t+Deltat, Deltat))\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n\n\n\n\nFigure 5.1: The functions \\(X\\) satisfying Equation 5.1 (difference equation) and Equation 5.3 (differential equation) for X0 = 1, mu = 1, and Delta t = 0.1.\nNow, let’s include randomness. Let’s make the noise proportional to the value of \\(X\\), So, let \\(B\\) be a standard Brownian motion and consider the equation \\[X_{t_i} - X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t + \\sigma X_{t_{i-1}} \\Delta B_{t_i} \\qquad(5.4)\\] where \\(\\sigma\\) is another constant, and \\(\\Delta B_{t_i} = B_{t_i} - B_{t_{i-1}}\\). A solution \\(X\\) of this equation has random paths, due to the random noise \\(\\Delta B_{t_i}\\). An example of a path is shown in Figure 5.2. Ito showed how we can take the limit of this equation as we make \\(\\Delta t\\) smaller and make sense of the equation \\[\n\\,\\mathrm{d}X_t = \\mu X_t\\,\\mathrm{d}t + \\sigma X_t \\,\\mathrm{d}B_t\\,.\n\\qquad(5.5)\\] The solution \\(X\\) of Equation 5.5 is \\[X_t = \\mathrm{e}^{(\\mu  - \\sigma^2/2)t + \\sigma B_t}\\,. \\qquad(5.6)\\] An approximate path of this process \\(X\\) is also shown in Figure 5.2. It is generated by taking \\(\\Delta t\\) very small, just as we generated approximate paths of Brownian motions in Chapter 4. We can show that \\(X\\) defined in Equation 5.6 satisfies Equation 5.5 by differentiating, as we showed that \\(X\\) defined in Equation 5.3 satisfies Equation 5.2. However, we first need to explain Ito’s formula, which is a formula for differentiating functions of Brownian motions and, more generally, functions of Ito processes.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nsigma = 1\nt = 1\n\n# Brownian path\nn = 1000   \ndt = t/n\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\nB = np.zeros(n+1)\nB[1:] = np.cumsum(dB)\n\n# Brownian path with discrete steps\nn_discrete = 10\nDeltat = t/n_discrete\nB_discrete = B[::int(n/n_discrete)]\nDeltaB = np.diff(B_discrete)\n\n# X in discrete-time \nX1 = np.ones(n_discrete+1)\nfor i in range(1, n_discrete+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat + sigma * X1[i-1] * DeltaB[i-1]\n\n# Continuous-time\nX2 = np.exp((mu - 0.5 * sigma**2) * np.arange(0, t+dt, dt) + sigma * B)\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+dt, dt), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n\n\n\n\nFigure 5.2: Paths of the processes satisfying Equation 5.4 (difference equation) and Equation 5.6 (differential equation) for X0 = 1, mu = 1, Delta t = 0.1, and sigma = 1.\nThe functions and processes \\(X\\) defined in this section have important interpretations. Equation 5.1 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t\\). This could represent the value of a savings account that earns interest of \\(\\mu \\Delta t\\) in each period of length \\(\\Delta t\\). This is the common way of calculating, for example, monthly interest, where \\(\\mu\\) is called the annual rate of interest and \\(\\Delta t\\) would be \\(1/12\\). The limiting Equation 5.3 is called continuous compounding of interest.\nSimilarly, Equation 5.4 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t + \\sigma \\Delta B\\). This represents a random rate of return – for example, the return of a stock. The expected rate of return in this case is \\(\\mu \\Delta t\\), and the variance of the rate of return is \\(\\sigma^2 \\Delta t\\). The limiting Equation 5.3 is called continuous compounding of returns.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:discreteito",
    "href": "Chapter_Ito.html#sec-s:discreteito",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "Theory Extra\n\n\n\n\n\nTo see how one might guess that Equation 5.3 is the solution of Equation 5.2, we can examine the logarithm of \\(X\\). A general rule gives us \\(\\,\\mathrm{d}\\log X = \\,\\mathrm{d}X / X\\), so \\(\\,\\mathrm{d}\\log X = \\mu \\,\\mathrm{d}t\\). We can integrate both sides of this to obtain \\(\\log X_t - \\log X_0 = \\mu t\\). Now, rearranging and exponentiating gives \\(X_t = X_0\\mathrm{e}^{\\mu t}\\). Later, we follow similar steps to see that Equation 5.6 is the solution of Equation 5.5.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itoprocesses",
    "href": "Chapter_Ito.html#sec-s:itoprocesses",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.2 Ito Processes",
    "text": "5.2 Ito Processes\nThe meaning of Equation 5.2 is that, for all \\(t  &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\,\\mathrm{d}s\\,.\\] We assume the reader is familiar with integrals, so we do not explain this further. The function of time \\(X\\) defined in Equation 5.3 satisfies this equation. Similarly, the meaning of Equation 5.5 is that, for all \\(t &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\,\\mathrm{d}s + \\int_0^t \\sigma X_s \\,\\mathrm{d}B_s\\,.\\] The first integral in this formula is an ordinary integral. The second is an Ito integral, which is to be explained. The sum of an ordinary integral and an Ito integral is called an Ito process. An Ito process always has continuous paths.\nLet’s depart from the example of the previous section and consider a process \\(X\\) satisfying, for all \\(t&gt;0\\), \\[X_t = \\int_0^t \\alpha_s\\,\\mathrm{d}s + \\int_0^t \\theta_s \\,\\mathrm{d}B_s\\,. \\qquad(5.7)\\] where \\(\\alpha\\) and \\(\\theta\\) can be stochastic processes. The example of the previous section fits this form, because we could take \\(\\alpha_s = \\mu X_s\\) and \\(\\theta_s = \\sigma X_s\\). The definition of the Ito integral \\[\\int_0^t \\theta_s \\,\\mathrm{d}B_s\\] is relatively complicated. It is enough for our purposes to know that it can be approximated by a discrete sum \\[\\sum_{i=1}^n \\theta_{t_{i-1}}(B_{t_i} - B_{t_{i-1}})\\,,\\] given a partition \\[ 0 = t_0 &lt; \\cdots &lt; t_n = t\\,,\\] when \\(n\\) is large and the time between successive dates is small. The Ito integral exists provided \\(\\theta\\) does not anticipate the future (so \\(\\theta_{t_{i-1}}\\) is independent of the increment \\(B_{t_i}- B_{t_{i-1}}\\)) and provided \\(\\theta\\) does not explode to \\(\\pm \\infty\\) in finite time, so \\[\\int_0^t \\theta_s^2 \\,\\mathrm{d}s &lt; \\infty\\] for all \\(t &gt; 0\\), with probability one.\nWe also write Equation 5.7 as \\[\n\\,\\mathrm{d}X_t = \\alpha_t\\,\\mathrm{d}t + \\theta_t \\,\\mathrm{d}B_t\\,.\n\\qquad(5.8)\\] We interpret this as “change \\(=\\) mean \\(+\\) noise” with \\(\\alpha_t \\,\\mathrm{d}t\\) being the mean and \\(\\theta_t\\,\\mathrm{d}B_t\\) being the mean-zero random noise. The quantity \\(\\alpha_t\\) is also called the drift of the process \\(X\\) at time \\(t\\). The coefficient \\(\\sigma_t\\) is called the diffusion coefficient of \\(X\\) at time \\(t\\). If \\(\\alpha\\) and \\(\\theta\\) are constant, it is standard to refer to an Ito process \\(X\\) as a \\((\\alpha,\\theta)\\)–Brownian motion. When they are constant, we obtain \\[X_t= X_0 + \\alpha t + \\theta B_t\\,.\\]\nAn Ito process as in Equation 5.7 can be a martingale only if \\(\\alpha=0\\). This should seem sensible, because \\(\\alpha\\,\\mathrm{d}t\\) is the expected change in \\(X\\), and a process is a martingale only if its expected change is zero. This observation plays a fundamental role in deriving asset pricing formulas. Conversely, if \\(\\alpha=0\\) and \\[\n\\mathbb{E}\\left[\\int_0^t \\theta^2_s\\,\\mathrm{d}s\\right] &lt; \\infty\n\\qquad(5.9)\\] for each \\(t\\), then the Ito process is a continuous martingale, and the variance of its date–\\(t\\) value, calculated with the information available at date \\(0\\), is: \\[\\mathrm{var}(X_t) = \\mathbb{E}\\left[\\int_0^t \\theta^2_t\\,\\mathrm{d}s\\right]\\; .\\]",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "href": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.3 Quadratic and Joint Variation of Ito Processes",
    "text": "5.3 Quadratic and Joint Variation of Ito Processes\nThe quadratic variation of the Ito process \\(X\\) defined in Equation 5.8 through each date \\(t\\) is \\[\n\\int_0^t \\theta^2_s\\,\\mathrm{d}s\n\\] with probability one.\nTo compute the quadratic variation of an Ito process, we use the following simple and important rules (for the sake of brevity, we drop the subscript \\(t\\) from \\(B_t\\) here and sometimes later). These rules should be regarded as mnemonic devices. The calculations we do with them lead to the correct results, but the objects have no real mathematical meaning.\n\n\n\n\n\n\n5.4\n\n\n\n\\[\n(\\,\\mathrm{d}t)^2 = 0\\;,\n\\qquad(5.10)\\]\n\\[\n(\\,\\mathrm{d}t)(\\,\\mathrm{d}B) =0\\;,\n\\qquad(5.11)\\]\n\\[\n(\\,\\mathrm{d}B)^2 =\\,\\mathrm{d}t\\;.\n\\qquad(5.12)\\]\n\n\nWe apply these rules to compute the quadratic variation of \\(X\\) as follows:\n\n\n\n\n\n\n5.5\n\n\n\nIf \\(\\,\\mathrm{d}X = \\alpha\\,\\mathrm{d}t + \\theta\\,\\mathrm{d}B\\) for a Brownian motion \\(B\\), then \\[\\begin{align*}\n(\\,\\mathrm{d}X)^2 &= (\\alpha\\,\\mathrm{d}t+\\theta\\,\\mathrm{d}B)^2\\\\\n&= \\alpha^2(\\,\\mathrm{d}t)^2 + 2\\alpha\\theta(\\,\\mathrm{d}t)(\\,\\mathrm{d}B) + \\theta^2(\\,\\mathrm{d}B)^2\\\\\n&= \\theta^2\\,\\mathrm{d}t\\;.\n\\end{align*}\\]\n\n\nWe integrate \\((\\,\\mathrm{d}X)^2\\) over a time interval to compute the quadratic variation of \\(X\\) over that period as: \\[\n\\int_0^t (\\,\\mathrm{d}X_s)^2 = \\int_0^t \\theta^2_s\\,\\mathrm{d}s\\;.\n\\qquad(5.13)\\] In a more formal mathematical presentation, one normally writes \\(\\,\\mathrm{d}\\langle X,X\\rangle\\) for what we are writing here as \\((\\,\\mathrm{d}X)^2\\). This is the differential of the quadratic variation process, and the quadratic variation through date \\(t\\) is \\[\n\\langle X,X\\rangle _t = \\int_0^t \\,\\mathrm{d}\\langle X,X\\rangle_s = \\int_0^t \\sigma^2_s\\,\\mathrm{d}s\\;.\n\\] Our mnenomic device of squaring differentials leads us to the correct formula.\nNow consider two Ito processes: \\[\n\\,\\mathrm{d}X_{1t} = \\mu_{1t}\\,\\mathrm{d}t + \\sigma_{1t}\\,\\mathrm{d}B_{1t}\\;,\n\\qquad(5.14)\\]\n\\[\n\\,\\mathrm{d}X_{2t} = \\mu_{2t}\\,\\mathrm{d}t + \\sigma_{2t}\\,\\mathrm{d}B_{2t}\\;,\n\\qquad(5.15)\\]\nwhere \\(B_1\\) and \\(B_2\\) are standard Brownian motions. We calculate the product of differentials of Ito processes as follows.\n\n\n\n\n\n\nCalculation Rule\n\n\n\nIf \\(X_1\\) and \\(X_2\\) are Ito processes as in Equation 5.14 and Equation 5.15, then \\[(\\,\\mathrm{d}X_1)(\\,\\mathrm{d}X_2) = (\\sigma_{1}\\,\\mathrm{d}B_{1})(\\sigma_{2}\\,\\mathrm{d}B_{2})= \\sigma_1\\sigma_2\\rho\\,\\mathrm{d}t\\] where \\(\\rho\\) is the correlation process of the two Brownian motions.\n\n\nThe real meaning of this rule is that it is possible to calculate the joint variation (i.e., limit of sum of products of changes) of the two Ito processes from \\(0\\) to \\(t\\) as \\[\\int_0^t (\\,\\mathrm{d}X_{1s})(\\,\\mathrm{d}X_{2s}) = \\int_0^t (\\sigma_{1s}\\,\\mathrm{d}B_{1s})(\\sigma_{2s}\\,\\mathrm{d}B_{2s}) = \\int_0^t \\sigma_{1s}\\sigma_{2s}\\rho_s\\,\\mathrm{d}s\\,.\n\\qquad(5.16)\\] The last integral in this equation is the correct formula for the quadratic variation. As with squaring differentials, taking products of differentials is a mnemonic device to get us to the correct formula. A somewhat more precise definition than our previous description of the stochastic integral \\(\\int_0^t \\sigma_{1,t} dB_{1t}\\) is when Equation 5.9 holds, the stochastic integral is the (unique) martingale with joint variation with any other Ito process given by Equation 5.16.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itosformula",
    "href": "Chapter_Ito.html#sec-s:itosformula",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.6 Introduction to Ito’s Formula",
    "text": "5.6 Introduction to Ito’s Formula\nFirst we recall some facts of the ordinary calculus. If \\(y=f(x)\\) and \\(x_t = g(t)\\) with \\(f\\) and \\(g\\) being continuously differentiable functions, then \\[\\frac{\\,\\mathrm{d}y}{\\,\\mathrm{d}t} = \\frac{\\,\\mathrm{d}y}{\\,\\mathrm{d}x}\\times \\frac{\\,\\mathrm{d}x}{\\,\\mathrm{d}t} = f'(x_t)g'(t)\\; .\\] This implies that, for each \\(t&gt;0\\), \\[y_t = f(x_t) = y_0 + \\int_0^t \\frac{\\,\\mathrm{d}y}{\\,\\mathrm{d}s}\\,\\mathrm{d}s = y_0 + \\int_0^t f'(x_s)g'(s)\\,\\mathrm{d}s\\; .\\] Substituting \\(\\,\\mathrm{d}x_s = g'(s)\\,\\mathrm{d}s\\), we can also write this as \\[\ny_t = f(x_t) = y_0 + \\int_0^t f'(x_s)\\,\\mathrm{d}x_s\\,,\n\\qquad(5.17)\\] or, in differential form, \\[\ndy_t = f'(x_t)\\,\\mathrm{d}x_t \\,.\n\\qquad(5.18)\\] What people frequently remember about integrals from their calculus courses is that there are a lot of tricky substitutions that can be made to simplify the calculation of various integrals. We won’t need those in this book. All we will use are equations of the form of Equation 5.17, which is a special case of the Fundamental Theorem of Calculus, which says that a function is the integral of its derivative. Intuitively, we can think of Equation 5.17 as saying that the change in \\(y\\) over a discrete interval (from \\(0\\) to \\(t\\)) is the continuous sum (integral) of its infinitesimal changes.\nLet’s contrast Equation 5.17 with a special case of Ito’s formula for the calculus of Ito processes. If \\(B\\) is a Brownian motion and \\(Y = f(B)\\) for a twice-continuously differentiable function \\(f\\), then \\[\\,\\mathrm{d}Y_t = f'(B_t)\\,\\mathrm{d}B_t + \\frac{1}{2}f''(B_t)\\,\\mathrm{d}t  \\,.\n\\qquad(5.19)\\] Comparing Equation 5.19 to Equation 5.18, we see that Ito’s formula has an extra term involving the second derivative \\(f''\\).\nEquation 5.19 implies that \\(Y=f(B)\\) is an Ito process with drift \\(f''(B_t)/2\\) and diffusion coefficient \\(f'(B_t)\\). The real meaning of Equation 5.19 is the integrated form: \\[\nY_t = f(B_t) = Y_0 + \\int_0^t f'(B_s)\\,\\mathrm{d}B_s + \\frac{1}{2}\\int_0^t f''(B_s)\\,\\mathrm{d}s\\;.\n\\qquad(5.20)\\] Thus, the change in \\(Y\\) over a discrete interval is again the continuous sum of its infinitesimal changes, but now the infinitesimal changes are given by Equation 5.19. Note that the first integral in Equation 5.20 is an Ito integral.\nTo gain some intuition for the extra term in Ito’s formula, we return to the ordinary calculus. Given dates \\(s&lt;t\\), the derivative defines a linear approximation of the change in \\(y\\) from \\(s\\) to \\(t\\); that is, setting \\(\\Delta x = x_t-x_s\\) and \\(\\Delta y = y_t - y_s\\), we have the approximation \\[\\Delta y \\approx f'(x_s) \\,\\Delta x\\; .\\] A better approximation is given by the second-order Taylor series expansion \\[\\Delta y \\approx f'(x_s)\\,\\Delta x + \\frac{1}{2} f''(x_s)\\,(\\Delta x)^2\\; .\\] An interpretation of Equation 5.17 is that the linear approximation works perfectly for infinitesimal time periods \\(\\,\\mathrm{d}s\\), because we can compute the change in \\(y\\) over the time interval \\([0,t]\\) by summing up the infinitesimal changes \\(f'(x_s)\\,\\mathrm{d}x_s\\). In other words, the second-order term \\(\\frac{1}{2} f''(x_s)\\,(\\Delta x)^2\\) vanishes when we consider very short time periods.\nThe second-order Taylor series expansion in the case of \\(Y=f(B)\\) is \\[\\Delta Y \\approx f'(B_s)\\,\\Delta B + \\frac{1}{2} f''(B_s)\\,(\\Delta B)^2\\; .\\] For example, given a partition \\(0=t_0 &lt; t_1 &lt; \\cdots &lt; t_n=t\\) of the time interval \\([0,t]\\), we have, with the same notation we have used earlier,\n\\[\nY_t = Y_0 + \\sum_{i=1}^n \\Delta Y_{t_i}  \n\\approx Y_0 + \\sum_{i=1}^n f'(B_{t_{i-1}})\\,\\Delta B_{t_i} + \\frac{1}{2} \\sum_{i=1}^n f''(B_{t_{i-1}})\\,(\\Delta B_{t_i})^2\\;.\n\\qquad(5.21)\\]\nIf we make the time intervals \\(t_i-t_{i-1}\\) shorter, letting \\(n \\rightarrow \\infty\\), then we cannot expect that the extra term here will disappear, leading to the result of the ordinary calculus shown in Equation 5.17, because we know that \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n (\\Delta B_{t_i})^2 = t\\; ,\\] whereas for the continuously differentiable function \\(x_t = g(t)\\), the same limit is zero. In fact it seems sensible to interpret the limit of \\((\\Delta B)^2\\) as \\((\\,\\mathrm{d}B)^2 =\\,\\mathrm{d}t\\). This is perfectly consistent with Ito’s formula: if we take the limit in Equation 5.21, replacing the limit of \\((\\Delta B_{t_i})^2\\) with \\((\\,\\mathrm{d}B)^2 = \\,\\mathrm{d}t\\), we obtain Equation 5.20.\nTo see the accuracy of Ito’s approximation over different time steps, as well as the impact of the second-derivative term \\(\\int_0^t (1/2)f''(B_s)\\,\\mathrm{d}s\\), we encourage readers to interact with the plot below. It examines the function \\(f(x)=\\mathrm{e}^{x}\\) (for which we have \\(f'(x)=\\mathrm{e}^x\\) and \\(f''(x) = \\mathrm{e}^x\\)). It simulates an approximate path of a Brownian motion as we have done before. It then compares the true value of \\(\\mathrm{e}^{B_{t_i}}\\) to the Ito expansion \\[\\mathrm{e}^{B_t}=1 + \\int_0^t \\mathrm{e}^{B_s} \\,\\mathrm{d}B_s + \\frac{1}{2}\\int_0^t \\mathrm{e}^{B_s} \\,\\mathrm{d}s\\] using the discretization \\[\\Delta \\mathrm{e}^{B_{t_i}}= \\mathrm{e}^{B_{t_{i-1}}} \\Delta B_{t_i} + \\frac{1}{2} \\mathrm{e}^{B_{t_{i-1}}} \\Delta t \\,.\\] Notice that the discretization is just a second-order Taylor series expansion. The discretization approximates the true value better if we take \\(n\\) larger and \\(\\Delta t\\) smaller. The important take-away from the figure is that the cumulative second-derivative terms in the discretization do not vanish as we take \\(n\\) larger but instead continue to contribute significantly to the approximation.\n\n\n\nFigure 5.3: Accuracy of Ito Approximation",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#univariate-itos-formula",
    "href": "Chapter_Ito.html#univariate-itos-formula",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.7 Univariate Ito’s Formula",
    "text": "5.7 Univariate Ito’s Formula\nWe extend the example in the previous section slightly. Consider a process \\(Y\\) defined as \\(Y_t = f(t, B_t)\\) for some function \\(f\\). The following rule states that \\(Y\\) is an Ito process with drift equal to \\[\\frac{\\partial f}{\\partial t} + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial B^2}\\] and diffusion coefficient equal to \\(\\partial f/\\partial B\\). This is what we need to remember to make calculations. The real meaning of \\((\\,\\mathrm{d}B)^2\\) is \\(\\,\\mathrm{d}t\\), so we can (and will) substitute that in the following rule, but it may be easier to remember \\((\\,\\mathrm{d}B)^2\\). This becomes more important when we consider more complex examples in the next sections.\n\n\n\n\n\n\n5.8 Ito’s Formula 1\n\n\n\nIf \\(f(t, B)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(B\\) and \\(Y_t= f(t, B_t)\\) for a standard Brownian motion \\(B\\), then \\[\\,\\mathrm{d}Y = \\frac{\\partial f(t, B)}{\\partial t}\\,\\mathrm{d}t + \\frac{\\partial f(t, B)}{\\partial B}\\,\\mathrm{d}B + \\frac{1}{2} \\frac{\\partial^2 f(t, B)}{\\partial B^2}(\\,\\mathrm{d}B)^2\\,.\n\\qquad(5.22)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe can apply Calculation Rule \\(\\ref{ruleito1}\\) to finish the discussion in Section 5.1 regarding the process defined in Equation 5.6. We want to show that it satisfies Equation 5.5. We do that by differentiating and applying the above rule. For \\(f(t, B) = \\mathrm{e}^{(\\mu - \\sigma^2/2)t + \\sigma B}\\), we have \\[\\frac{\\partial f}{\\partial t} = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)f(t, B)\\,,\\quad \\frac{\\partial f}{\\partial B} = \\sigma f(t, B)\\,, \\quad \\frac{\\partial^2 f}{\\partial B^2} = \\sigma^2f(t, B)\\,.\\] Therefore, \\[\\,\\mathrm{d}Y = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)Y\\,\\mathrm{d}t + \\sigma Y \\,\\mathrm{d}B + \\frac{1}{2}\\sigma^2 Y\\,(\\,\\mathrm{d}B)^2 = \\mu Y\\,\\mathrm{d}t + \\sigma Y \\,\\mathrm{d}B\\] This verifies Equation 5.5.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#extension-to-functions-of-ito-processes",
    "href": "Chapter_Ito.html#extension-to-functions-of-ito-processes",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.9 Extension to Functions of Ito Processes",
    "text": "5.9 Extension to Functions of Ito Processes\nNow consider the more general case \\(Y_t = f(t, X_t)\\) where \\(X\\) is an Ito process. As explained before, this means that \\[\\,\\mathrm{d}X_t = \\alpha_t\\,\\mathrm{d}t + \\theta_t \\,\\mathrm{d}B_t\n\\qquad(5.23)\\] for some stochastic processes \\(\\alpha\\) and \\(\\theta\\), where \\(B\\) is a standard Brownian motion. Then, from our previous rules, \\((\\,\\mathrm{d}X)^2 = \\theta^2\\,\\mathrm{d}t\\). Ito’s formula in this more general case takes the same form as Calculation Rule \\(\\ref{ruleito1}\\), replacing the Brownian motion \\(B\\) with the Ito process \\(X\\).\n\n\n\n\n\n\n5.10 Ito’s Formula 2\n\n\n\nIf \\(f(t, X)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X\\) and \\(Y_t= f(t, X_t)\\) where \\(X\\) is an Ito process, then \\[\\,\\mathrm{d}Y = \\frac{\\partial f(t, X)}{\\partial t}\\,\\mathrm{d}t + \\frac{\\partial f(t, X)}{\\partial X}\\,\\mathrm{d}X + \\frac{1}{2} \\frac{\\partial^2 f(t, X)}{\\partial X^2}(\\,\\mathrm{d}X)^2\\,.\n\\qquad(5.24)\\]\n\n\nWe can write Equation 5.24 in terms of \\(\\,\\mathrm{d}t\\) and \\(\\,\\mathrm{d}B\\) terms by substituting from Equation 5.23 and using \\((\\,\\mathrm{d}X)^2 = \\theta^2\\,\\mathrm{d}t\\). This produces \\[\\,\\mathrm{d}Y = \\left(\\frac{\\partial f(t, X)}{\\partial t} + \\alpha\\frac{\\partial f(t, X)}{\\partial X} + \\frac{1}{2}\\theta^2 \\frac{\\partial^2 f(t, X)}{\\partial X^2}\\right)\\,\\mathrm{d}t + \\theta\\frac{\\partial f(t, X)}{\\partial X}\\,\\mathrm{d}B\\,.\\]\nHere are some important examples of Ito’s formula.\n\n\n\n\n\n\n5.11 Ito’s Formula for Powers\n\n\n\nIf \\(Y = X^\\alpha\\) for a constant \\(\\alpha\\), then \\[\\,\\mathrm{d}Y = \\alpha X^{\\alpha-1}\\,\\mathrm{d}X + \\frac{1}{2}\\alpha (\\alpha - 1)X^{\\alpha-2}(\\,\\mathrm{d}X)^2\\,.\\] This is equivalent to \\[\\frac{\\,\\mathrm{d}Y}{Y} = \\alpha \\frac{\\,\\mathrm{d}X}{X} + \\frac{\\alpha(\\alpha-1)}{2}\\left(\\frac{\\,\\mathrm{d}X}{X}\\right)^2\\,.\n\\] {#ito-powerformula}\n\n\n\n\n\n\n\n\n5.12 Ito’s Formula for Exponentials\n\n\n\nIf \\(Y=\\mathrm{e}^X\\), then \\[\\frac{\\,\\mathrm{d}Y}{Y}=\\,\\mathrm{d}X + \\frac{(\\,\\mathrm{d}X)^2}{2}\\;.\n\\qquad(5.25)\\]\n\n\n\n\n\n\n\n\n5.13 Ito’s Formula for Logarithms\n\n\n\nIf \\(Y=\\log X\\), then \\[\n\\,\\mathrm{d}Y=\\frac{\\,\\mathrm{d}X}{X} - \\frac{1}{2}\\left(\\frac{\\,\\mathrm{d}X}{X}\\right)^2\\;.\n\\qquad(5.26)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe showed in Example \\(\\ref{example:ito1}\\) that \\(X\\) defined in Equation 5.6 satisfies Equation 5.5, but it is also useful to see how we can start from Equation 5.5 and deduce that Equation 5.6 is the solution. We can do that by taking logarithms, as we did in the non-random case in Section 11.3. Set \\(Y_t = \\log X_t\\). Then, using Calculation Rule \\(\\ref{rule:ito-log}\\) and substituting from Equation 5.5, we have \\[\\,\\mathrm{d}\\log X = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\,.\\] There is no \\(X\\) on the right-hand side of this, so we can simply integrate to compute \\(\\log X_t\\) as \\[\\log X_t = \\log X_0 + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\,.\\] Exponentiating gives Equation 5.6.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#extension-to-functions-of-multiple-ito-processes",
    "href": "Chapter_Ito.html#extension-to-functions-of-multiple-ito-processes",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "5.14 Extension to Functions of Multiple Ito Processes",
    "text": "5.14 Extension to Functions of Multiple Ito Processes\nUsing Calculation Rule \\(\\ref{rule:ito-product-diffs}\\) for products of differentials, we can state Ito’s formula for a function of time and two Ito processes as follows.\n\n\n\n\n\n\n5.15 Ito’s Formula 3\n\n\n\nIf \\(Y_t = f(t, X_{1t}, X_{2t})\\) where \\(X_1\\) and \\(X_2\\) are Ito processes and \\(f\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X_1\\) and \\(X_2\\), then \\[\\begin{multline}\n\\,\\mathrm{d}Y =  \\frac{\\partial f}{\\partial t}\\,\\mathrm{d}t + \\frac{\\partial f}{\\partial X_1}\\,\\mathrm{d}X_1 +  \\frac{\\partial f}{\\partial X_2}\\,\\mathrm{d}X_2 + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial X_1^2}\\,(\\,\\mathrm{d}X_1)^2 +  \\frac{1}{2}  \\frac{\\partial^2 f}{\\partial X_2^2}\\,(\\,\\mathrm{d}X_2)^2 \\\\\n+ \\frac{\\partial^2 f}{\\partial X_1\\partial X_2}\\,(\\,\\mathrm{d}X_1)(\\,\\mathrm{d}X_2)\\;.\n\\end{multline} \\qquad(5.27)\\]\n\n\nThis is analogous to a second-order Taylor series expansion in the variables \\(X_1\\) and \\(X_2\\). A similar formula applies to functions of more two Ito processes. We just need to include a term for each \\(\\,\\mathrm{d}X_i\\), each \\((\\,\\mathrm{d}X_i)^2\\) and each \\((\\,\\mathrm{d}X_i)(\\,\\mathrm{d}X_j)\\).\nHere are some important examples. We switch notation from \\(X_1\\) and \\(X_2\\) to \\(X\\) and \\(Y\\) and from \\(Y\\) to \\(Z\\) so we can drop the subscripts. These formulas follow from Calculation Rule \\(\\ref{rule-itoformula3}\\) by taking \\(f(x,y)=xy\\) or \\(f(x,y)=y/x\\).\n\n\n\n\n\n\n5.16 Ito’s Formula for Products\n\n\n\nIf \\(Z=XY\\), then \\(\\,\\mathrm{d}Z=X\\,\\mathrm{d}Y+Y\\,\\mathrm{d}X + (\\,\\mathrm{d}X)(\\,\\mathrm{d}Y)\\). We can write this as \\[\n\\frac{\\,\\mathrm{d}Z}{Z}=\\frac{\\,\\mathrm{d}X}{X} + \\frac{\\,\\mathrm{d}Y}{Y} + \\left(\\frac{\\,\\mathrm{d}X}{X}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)\\;.\n\\qquad(5.28)\\]\n\n\n\n\n\n\n\n\n5.17 Ito’s Formula for Ratios\n\n\n\nIf \\(Z=Y/X\\), then \\[\\frac{\\,\\mathrm{d}Z}{Z} = \\frac{\\,\\mathrm{d}Y}{Y} -\\frac{\\,\\mathrm{d}X}{X} - \\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)\\left(\\frac{\\,\\mathrm{d}X}{X}\\right) + \\left(\\frac{\\,\\mathrm{d}X}{X}\\right)^2\\;.\n\\qquad(5.29)\\]\n\n\n\n\n\n\n\n\n5.18 Ito’s Formula for Compounding and Discounting\n\n\n\nLet\n\\[Y_t =\\exp\\left(\\int_0^t q_s\\,\\mathrm{d}s\\right)\\] for some (possibly random) process \\(q\\) and define \\(Z=XY\\) for any Ito process \\(X\\). Calculation Rule \\(\\ref{rule:ito-product}\\) gives us \\[\n\\frac{\\,\\mathrm{d}Z}{Z}=q\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}X}{X}\\;.\n\\qquad(5.30)\\] This is the same as in the usual calculus.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#section-2",
    "href": "Chapter_Ito.html#section-2",
    "title": "5  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nIto’s Lemma can be used in different ways to get the same answer. For example, let \\(X_t = a t + b B_t\\) and use Ito’s lemma on the function \\(e^{X_t}\\). Alternatively, let \\(f(t, B_t) = e^{a t + bB_t}\\). Use Ito’s lemma on \\(f(,)\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nLet \\(\\,\\mathrm{d}X_t = \\mu X_t \\,\\mathrm{d}t + \\sigma X_t \\,\\mathrm{d}B_t\\). Use Ito’s lemma to find \\(\\log(X_t)\\) . What is the expected value and variance of \\(\\log(X_t)\\) ?",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html",
    "href": "Chapter_GBM.html",
    "title": "6  Geometric Brownian Motion",
    "section": "",
    "text": "6.1 Reinvesting Dividends\nA random variable is lognormally distributed if it can be written as \\(\\tilde{y}=  e^{\\tilde{x}}\\) where \\(\\tilde{x}\\) is distributed according to a normal distribution with mean \\(m\\) and standard deviation \\(s\\). The expected value of \\(\\tilde{y}\\) is given by \\(\\mathbb{E}[\\tilde{y}] = e^{m+\\frac{s^2}{2}}\\).\nAn important stochastic process is geometric Brownian motion given by \\[\nS_t=S_0\\exp\\left(\\mu t- \\sigma^2 t/2 + \\sigma B_t\\right)\n\\qquad(6.2)\\]\nfor constants \\(\\mu\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion. Note that for each time \\(t\\), the random variable \\(S_t\\) in ?eq-exponential is a lognormal random variable. Using the product rule and the rule for exponentials, we obtain \\[\n\\frac{\\,\\mathrm{d}S}{S} = \\mu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B\\;.\n\\qquad(6.3)\\]\nWhen we see an equation of the form Equation 6.3, we should recognize Equation 6.2 as the solution.\nThe process \\(S\\) is called a geometric Brownian motion. In keeping with the discussion of Section 5.2, we interpret Equation 6.3 as stating that \\(\\mu\\,\\mathrm{d}t\\) is the expected rate of change of \\(S\\) and \\(\\sigma^2\\,\\mathrm{d}t\\) is the variance of the rate of change in an instant \\(\\,\\mathrm{d}t\\). We call \\(\\mu\\) the drift and \\(\\sigma\\) the volatility. The geometric Brownian motion will grow at the average rate of \\(\\mu\\), in the sense that \\(\\mathbb{E}[S_t] = \\mathrm{e}^{\\mu t}S_0\\); one way to verify this uses the formula for the mean of a lognormal random variable.\nTaking the natural logarithm of Equation 6.2 gives an equivalent form of the solution: \\[\n\\log S_t= \\log S_0+\\left(\\mu -\\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\;.\n\\qquad(6.4)\\] This shows that \\(\\log S_t - \\log S_0\\) is a \\((\\mu-\\sigma^2/2,\\sigma)\\)–Brownian motion. Given information at time \\(t\\), the logarithm of \\(S(u)\\) for \\(u&gt;t\\) is normally distributed with mean \\((u-t)(\\mu-\\sigma^2/2)\\) and variance \\((u-t)\\sigma^2\\). Because \\(S\\) is the exponential of its logarithm, \\(S\\) can never be negative. For this reason, a geometric Brownian motion is a better model for stock prices than is a Brownian motion.\nThe differential of Equation 6.4 is \\[\n\\,\\mathrm{d}\\log S_t = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t+ \\sigma\\,\\mathrm{d}B_t\\;.\n\\qquad(6.5)\\]\nWe conclude:\nOver a discrete time interval \\(\\Delta t\\), Equation 6.5 implies that the change in the logarithm of \\(S\\) is \\[\n\\Delta \\log S = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\Delta t+ \\sigma\\,\\Delta B\\;.\n\\qquad(6.6)\\]\nIf \\(S\\) is the price of a dividend-reinvested asset, then over the time period \\(t_{i-1}\\) to \\(t_i\\), with \\(t_i-t_{i-1}=\\Delta t\\), we have \\[\n\\Delta \\log S = r_i\\,\\Delta t\\;,\n\\qquad(6.7)\\]\nwhere \\(r_i\\) is the continuously compounded annualized rate of return during the period \\(\\Delta t\\). This follows from the definition of the continuously compounded rate of return as the constant rate over the time period \\(\\Delta t\\) that would cause \\(S\\) to grow (or fall) from \\(S_{t_{i-1}}\\) to \\(S_{t_i}\\). To be precise, \\(r_i\\) is defined by \\[\\frac{S_{t_i}}{S_{t_{i-1}}} = \\mathrm{e}^{r_i\\Delta t}\\; ,\\] which is equivalent to Equation 6.7. Thus, the geometric Brownian motion model (Equation 6.3)implies that the continuously compounded annualized rate of return over a period of length \\(\\Delta t\\) is given by \\[r_i = \\mu -\\frac{1}{2}\\sigma^2+ \\frac{\\sigma\\Delta B}{\\Delta t}\\; .\\] This means that \\(r_i\\) is normally distributed with mean \\(\\mu-\\sigma^2/2\\) and variance \\(\\sigma^2/\\Delta t\\). Given historical data on the rates of return, the parameters \\(\\mu\\) and \\(\\sigma\\) can be estimated by standard methods (see Chapter 17).\nWe can simulate a path of \\(S\\) by simulating the changes \\(\\Delta \\log S\\). The random variable \\(\\sigma \\Delta B\\) in Equation 6.6 has a normal distribution with zero mean and variance equal to \\(\\sigma^2\\Delta t\\). We simulate it as \\(\\sigma\\sqrt{\\Delta t}\\) multiplied by a standard normal. The code below simulates \\(n=10000\\) paths with \\(m=1000\\) time steps. There are some features of the simulation which will prove useful later. The drift \\(\\mu\\) is labelled the interest rate \\(r=0.1\\). Other parameters are \\(\\sigma = 0.2\\), and \\(T=0.5\\). The drift of the log stock price is labelled \\(drift=r-\\frac{\\sigma^2}{2}\\). The plot output is one of the simulated sample paths. In practice, if we are only interested in the terminal value of the stock price we would use many fewer subdivisions, \\(n=1\\). Given a simulated mean zero normal random variable, \\(z\\), changing the sign to \\(-z\\) is also a simulated normal random variable with zero mean and the same standard deviation. As a result, we have two simulations for the stock price labelled \\(St\\) and \\(St1\\), but we only plot one sample path for \\(St\\).\nThe plot below is the distribution of the simulated stock price at \\(T\\).\nFrequently, we will assume that the asset underlying a derivative security pays a constant dividend yield, which we will denote by \\(q\\). This means, for an asset with price \\(S_t\\), that the dividend in an instant \\(\\,\\mathrm{d}t\\) is \\(q S_t\\,\\mathrm{d}t\\). If the dividends are reinvested in new shares, the number of shares will grow exponentially at rate \\(q\\). To see this, consider the portfolio starting with a single share of the asset and reinvesting dividends until some date \\(T\\). Let \\(X_t\\) denote the number of shares resulting from this strategy at any time \\(t\\leq T\\). Then the dividend received at date \\(t\\) is \\(q S_tX_t\\,\\mathrm{d}t\\), which can be used to purchase \\(q X_t\\,\\mathrm{d}t\\) new shares. This implies that \\(\\,\\mathrm{d}X_t=q X_t\\,\\mathrm{d}t\\), or \\(\\,\\mathrm{d}X_t/\\,\\mathrm{d}t = q X_t\\), and it is easy to check (and very well known) that this equation is solved by \\(X_t=\\mathrm{e}^{q t}X_0\\). In our case, with \\(X_0=1\\), we have \\(X_t=\\mathrm{e}^{q t}\\).\nThe dollar value of the trading strategy just described will be \\(X_tS_t = \\mathrm{e}^{q t}S_t\\). Denote this by \\(V_t\\). This is the value of a dividend-reinvested portfolio, because all dividends are reinvested. From the Compounding/Discounting example in ?sec-s:examples, we know that \\[\n\\frac{\\,\\mathrm{d}V}{V} = q\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}S}{S}\\;.\n\\qquad(6.8)\\]\nThis means that the rate of return on the portfolio is the dividend yield \\(q\\,\\mathrm{d}t\\) plus the return \\(\\,\\mathrm{d}S/S\\) due to capital gains.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#the-exponential-martingale",
    "href": "Chapter_GBM.html#the-exponential-martingale",
    "title": "6  Geometric Brownian Motion",
    "section": "6.2 The Exponential Martingale",
    "text": "6.2 The Exponential Martingale\nWhile geometric Brownian motion is an important stochastic process to model stock prices, the process with drift equal to zero given by \\[X_t = \\exp\\left(-\\frac{\\kappa^2}{2} + \\kappa B_t\\right)\\]\nsatisfies \\(\\mathbb{E}[X_t]=1\\) and \\(\\mathbb{E}[X_t|X_s]=X_s\\) and is an important example of a strictly positive martingale. Again, these facts can be verified using the formula for the expected value of a lognormal random variable. Notice that we can write \\[\\,\\mathrm{d}X_t= \\kappa X_t \\,\\mathrm{d}B_t\\;,\\] which agrees with the martingale characterization of \\(\\int_0^t \\sigma(X_t,t) \\,\\mathrm{d}B_t\\).",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#sec-tailprobs",
    "href": "Chapter_GBM.html#sec-tailprobs",
    "title": "6  Geometric Brownian Motion",
    "section": "6.3 Tail Probabilities of Geometric Brownian Motions",
    "text": "6.3 Tail Probabilities of Geometric Brownian Motions\nFor each of the numeraires discussed in the previous section, we have \\[\n\\,\\mathrm{d}\\log S = \\alpha\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;,\n\\qquad(6.9)\\]\nfor some \\(\\alpha\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion under the probability measure associated with the numeraire. Specifically, \\(\\sigma=\\sigma\\), \\(B=B^*\\), and\n\nfor the risk-neutral probability, \\(\\alpha = r-q-\\sigma^2/2\\),\nwhen \\(\\mathrm{e}^{qt}S_t\\) is the numeraire, \\(\\alpha = r-q +\\sigma^2/2\\),\nwhen another risky asset price \\(Y\\) is the numeraire, \\(\\alpha = r-q+\\rho\\sigma\\phi-\\sigma^2/2\\).\n\nWe will assume in this section that \\(\\alpha\\) and \\(\\sigma\\) are constants. The essential calculation in pricing options is to compute \\(\\text{prob}(S_t&gt;K)\\) and \\(\\text{prob}(S_t&lt;K)\\) for a constant \\(K\\) (the strike price of an option), where \\(\\text{prob}\\) denotes the probabilities at date \\(0\\) (the date we are pricing an option) associated with a particular numeraire.\nEquation 6.9 gives us \\[\\log S_t = \\log S_0 + \\alpha T + \\sigma B_t\\; .\\] Given this, we deduce\n\\[\nS_t &gt; K  \\quad\\Longleftrightarrow\\quad \\log S_t &gt; \\log K\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\sigma B_t &gt; \\log K - \\log S_0-\\alpha T\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\frac{B_t}{\\sqrt{T}} &gt; \\frac{\\log K - \\log S_0-\\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log S_0-\\log K + \\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(6.10)\\]\nThe random variable on the left-hand side of Equation 6.10 has the standard normal distribution—it is normally distributed with mean equal to zero and variance equal to one. As is customary, we will denote the probability that a standard normal is less than some number \\(d\\) as \\(\\mathrm{N}(d)\\). We conclude:\n\n\n\n\n\n\n6.4\n\n\n\nAssume \\(\\,\\mathrm{d}\\log S = \\alpha\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&gt;K) = \\mathrm{N}(d)\\;,\n\\qquad(6.11)\\]\nwhere \\[\nd = \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(6.12)\\]\n\n\nThe probability \\(\\text{prob}(S_t&lt;K)\\) can be calculated similarly, but the simplest way to derive it is to note that the events \\(S_t&gt;K\\) and \\(S_t&lt;K\\) are complementary—their probabilities sum to one (the event \\(S_t=K\\) having zero probability). Therefore \\(\\text{prob}(S_t&lt;K) = 1-\\mathrm{N}(d)\\). This is the probability that a standard normal is greater than \\(d\\), and by virtue of the symmetry of the standard normal distribution, it equals the probability that a standard normal is less than \\(-d\\). Therefore, we have:\n\n\n\n\n\n\n6.5\n\n\n\nAssume \\(\\,\\mathrm{d}\\log S = \\alpha\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&lt;K) = \\mathrm{N}(-d)\\;,\n\\qquad(6.13)\\]\nwhere \\(d\\) is defined in Equation 6.12.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#sec-s:volatilities",
    "href": "Chapter_GBM.html#sec-s:volatilities",
    "title": "6  Geometric Brownian Motion",
    "section": "6.6 Products and Ratios of Geometric Brownian Motions",
    "text": "6.6 Products and Ratios of Geometric Brownian Motions\nAs mentioned in Chapter 6, when we encounter an equation of the form \\[\\frac{\\,\\mathrm{d}S}{S} = \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\] where \\(B\\) is a Brownian motion, we will say \\(\\sigma\\) is the volatility of \\(S\\). We will occasionally need to compute the volatilities of products or ratios of random processes. These computations follow directly from Ito’s formula.\nSuppose \\[\\frac{\\,\\mathrm{d}X}{X} = \\mu_x\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B_x \\qquad \\text{and} \\qquad\n\\frac{\\,\\mathrm{d}Y}{Y} = \\mu_y\\,\\mathrm{d}t + \\sigma_y\\,\\mathrm{d}B_y\\; ,\\] where \\(B_x\\) and \\(B_y\\) are Brownian motions with correlation \\(\\rho\\), and \\(\\mu_x\\), \\(\\mu_y\\), \\(\\sigma_x\\), \\(\\sigma_y\\), and \\(\\rho\\) may be quite general random processes.\n\nProducts\nIf \\(Z=XY\\), then Equation 5.28 gives us \\[\n\\frac{\\,\\mathrm{d}Z}{Z} = (\\mu_x+\\mu_y+\\rho\\sigma_x\\sigma_y)\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B_x + \\sigma_y\\,\\mathrm{d}B_y\\;.\n\\qquad(6.14)\\]\nThe instantaneous variance of \\(\\,\\mathrm{d}Z/Z\\) is calculated, using the rules for products of differentials, as \\[\\begin{align*}\n\\left(\\frac{\\,\\mathrm{d}Z}{Z}\\right)^2 &= (\\sigma_x\\,\\mathrm{d}B_x + \\sigma_y\\,\\mathrm{d}B_y)^2\\\\\n&= (\\sigma_x^2 + \\sigma_y^2 + 2\\rho\\sigma_x\\sigma_y)\\,\\mathrm{d}t\\;.\n\\end{align*}\\] As will be explained below, the volatility is the square root of the instantaneous variance (dropping the \\(\\,\\mathrm{d}t\\)). This implies:\n\n\n\n\n\n\n6.7\n\n\n\nThe volatility of \\(XY\\) is \\[\n\\sqrt{\\sigma_x^2 + \\sigma_y^2 + 2\\rho\\sigma_x\\sigma_y}\\;.\n\\qquad(6.15)\\]\n\n\n\n\nRatios\nIf \\(Z=Y/X\\), then Equation 5.29 gives us \\[\n\\frac{\\,\\mathrm{d}Z}{Z} = (\\mu_y-\\mu_x-\\rho\\sigma_x\\sigma_y+\\sigma_x^2)\\,\\mathrm{d}t + \\sigma_y\\,\\mathrm{d}B_y - \\sigma_x\\,\\mathrm{d}B_x\\;.\n\\qquad(6.16)\\]\nThe instantaneous variance of \\(\\,\\mathrm{d}Z/Z\\) is therefore \\[\\begin{align*}\n\\left(\\frac{\\,\\mathrm{d}Z}{Z}\\right)^2 &= (\\sigma_y\\,\\mathrm{d}B_y - \\sigma_x\\,\\mathrm{d}B_x)^2\\\\\n&= (\\sigma_x^2 + \\sigma_y^2 - 2\\rho\\sigma_x\\sigma_y)\\,\\mathrm{d}t\\;.\n\\end{align*}\\] This implies:\n\n\n\n\n\n\n6.8\n\n\n\nThe volatility of \\(Y/X\\) is\n\\[\n\\sqrt{\\sigma_x^2 + \\sigma_y^2 - 2\\rho\\sigma_x\\sigma_y}\\;.\n\\qquad(6.17)\\]\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nTo understand why taking the square root of \\((\\,\\mathrm{d}Z/Z)^2\\) (dropping the \\(\\,\\mathrm{d}t\\)) gives the volatility, consider for example the product case \\(Z=XY\\). Define a random process \\(B\\) by \\(B_0=0\\) and \\[\n\\,\\mathrm{d}B = \\frac{\\sigma_x}{\\sigma}\\,\\mathrm{d}B_x + \\frac{\\sigma_y}{\\sigma}\\,\\mathrm{d}B_y\\;,\n\\] {#eq-foreign}\nwhere \\(\\sigma\\) is the volatility defined in Equation 6.15. Then we can write Equation 6.14 as \\[\n\\frac{\\,\\mathrm{d}Z}{Z} = \\left(\\mu_x +\\mu_y+ \\rho\\sigma_x\\sigma_y\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;. \\qquad(6.18)\\]\nFrom the discussion in Section 5.2, we know that \\(B\\) is a continuous martingale. We can compute its quadratic variation from \\[\\begin{align*}\n(\\,\\mathrm{d}B)^2 &= \\left(\\frac{\\sigma_x\\,\\mathrm{d}B_x + \\sigma_s\\,\\mathrm{d}B_s}{\\sigma}\\right)^2\\\\\n&= \\frac{(\\sigma_x^2 + \\sigma_s^2 + 2\\rho\\sigma_x\\sigma_s)\\,\\mathrm{d}t}{\\sigma^2}\\; ,\\\\\n&= \\,\\mathrm{d}t\\;.\n\\end{align*}\\] By Levy’s theorem (see Section 4.3), any continuous martingale with this quadratic variation is necessarily a Brownian motion. Therefore, Equation 6.18 shows that \\(\\sigma\\) is the volatility of \\(Z\\) as defined at the beginning of the section.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#stochastic-coefficients",
    "href": "Chapter_GBM.html#stochastic-coefficients",
    "title": "6  Geometric Brownian Motion",
    "section": "6.9 Stochastic Coefficients",
    "text": "6.9 Stochastic Coefficients\nSome of our analysis, especially in the Stochastic Volatility and Fixed Income Chpaters, will require stochastic coefficients. The risk free rate is locally risk free but can be stocastic. In other words, the value of an investment in this asset follows \\[\\,\\mathrm{d}R(t) = r_t R(t) \\,\\mathrm{d}t . \\] The riskless rate \\(r_t\\) may be modelled as an Ito process. The investment is locally riskfree since there is no \\(dB\\) term. The explicit solution is \\[R(t)= R(0) \\exp\\left(\\int_0^t r_s ds\\right). \\] Correspondingly, we can write the risky asset price as \\[ \\,\\mathrm{d}S(t) = \\mu_t S(t) \\,\\mathrm{d}t + \\sigma_t S(t) \\,\\mathrm{d}B_t \\] where \\(\\mu\\) and \\(\\sigma\\) can also be modelled as Ito processes. The explicit solution is \\[ S(t)= S(0) \\exp\\left(\\int_0^t \\left(\\mu_s - \\frac{\\sigma_s}{2} \\right) \\,\\mathrm{d}s + \\int_0^t \\sigma_s \\,\\mathrm{d}B_s \\right). \\] Importantly, this solution is nonnegative if \\(S(0)&gt;0\\). More importantly, the prouct and ratio rules remain valid even when the coefficients are stochastic, although some regularity is required to ensure various integrals are defined.",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GBM.html#section-4",
    "href": "Chapter_GBM.html#section-4",
    "title": "6  Geometric Brownian Motion",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nUse Ito’s Lemma to derive the stochastic differential equation for \\(S_t^2\\). Argue that \\(S(t)^2\\) is geometric Brownian motion if \\(\\mu\\) and \\(\\sigma\\) are constants and find \\(\\mathbb{E}[S(t)^2]\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUse the facts \\(e^{x+y}=e^x \\times e^y\\) and \\(\\frac{e^x}{e^y} = e^{x-y}\\) to deduce the drift and volatility of the product and ratio of two geometric Brownian motions.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider a discrete partition \\(0=t_0 &lt; t_1 &lt; \\cdots t_N=T\\) of the time interval \\([0,T]\\) with \\(t_i - t_{i-1} = \\Delta t = T/N\\) for each \\(i\\). Consider a geometric Brownian motion \\[\\frac{\\,\\mathrm{d}Z}{Z} = \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\; .\\] An approximate path \\(\\tilde{Z}_t\\) of the geometric Brownian motion can be simulated as \\[\n\\Delta \\tilde{Z}_{t_i} = \\tilde{Z}_{t_{i-1}} \\big[ \\mu\\,\\Delta t + \\sigma\\,\\Delta B\\big]\\;.\n\\qquad(6.19)\\] Modify the code to generate both a path \\(Z_t\\) and an approximate path \\(\\tilde{Z}_t\\) according to Equation 6.19, using the same \\(\\Delta B\\) for both paths and taking \\(\\tilde{Z}_0 = Z_0\\). Plot both paths in the same figure. How well does the approximation work for large \\(N\\)? Warning:\nFor \\(N\\) larger than about \\(100 T\\), the approximation will look perfect—you won’t be able to tell that there are two plots in the figure. One reason this is true is an exact formula is \\[\nZ_{t_i} = Z_{t_{i-1}} \\exp\\left[ \\left(\\mu -\\frac{\\sigma^2}{2}\\right)\\,\\Delta t + \\sigma\\,\\Delta B\\right]\\;.\n\\qquad(6.20)\\] and using Taylor’s Theorem for small \\(\\Delta t\\), \\(e^{\\left(\\mu-\\frac{\\sigma^2}{2}\\right) \\Delta t} \\approx 1+ \\left(\\mu-\\frac{\\sigma^2}{2}\\right) \\Delta t\\) and \\(e^{\\sigma \\Delta B_t} \\approx 1+ \\sigma \\Delta B_t +\\frac{1}{2}\\sigma^2 (\\Delta B_t)^2\\) and \\((\\,\\mathrm{d}B_t)^2=\\Delta t\\).",
    "crumbs": [
      "Part II: Mathematical Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html",
    "href": "Chapter_Arbitrage.html",
    "title": "7  Foundations",
    "section": "",
    "text": "7.1 Fundamental Ideas\n~setting back to normal\nThis chapter introduces the change of measure (or change of numeraire or martingale) method for valuing derivative securities. The method is illustrated in a finite state and a two-state model and then extended to more general (continuum of states) models. Computations in the more general model require the continuous-time mathematics developed in Part II of the book.\nThe pricing and hedging results in this book are not tied to any particular currency. However, for specificity, the discussion will generally be in terms of dollars. Multiple currencies are addressed in Chapter 12.\nThe fundamental concept underlying most finance theory, from Miller-Modigliani to the Black Scholes model, is linear pricing. The concept of linear pricing is essentially the same as asking what is the price of five apples and six oranges. Of course, this is the price of one apple times five plus the price of one orange times six. However, instead of pricing bundles of commodities today, we will find prices of dollars in different contigencies at times in the future.\nAn arbitrage opportunity is a trading strategy that produces nonnegative cash flows at all times in all contingencies with a strictly positive cash flow at some time in some contingency. If such an opportunity were to exist, traders would exploit it until prices adjust to eliminate this possibility. Although simple this has powerful implications.\nConsider a world where there are \\(S\\) possible states of the world at timme \\(t\\). No arbritrage then implies the following properties.\nThis conclusion generalizes to other models, including models in which the stock price takes a continuum of possible values, interpreting “sum” in that case as an integral. We discuss more general models later in this chapter.\nWe can think of any security as a portfolio of what are called Arrow securities (in recognition of the seminal work of Kenneth Arrow (Arrow 1964)). An Arrow security’s payoff is tied to a specific state of the world, paying $1 at time t if the state in question occurs and paying nothing otherwise. Since state prices are the prices of these primitive Arrow securities, given these state prices, we can value any security. The state prices can be found by inverting the pricing relationship for prices of traded securities; in other words use traded securities to find the prices of securities that pay off a dollar in each time state contingency. While in general this can be challenging, the procedure is easily illlustrated in the binomial model that we examine next.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#fundamental-ideas",
    "href": "Chapter_Arbitrage.html#fundamental-ideas",
    "title": "7  Foundations",
    "section": "",
    "text": "If \\(X\\) and \\(Y\\) are time \\(t\\) random cash flows, the time 0 price today of the random cash flow \\(aX+bY\\) is t \\(a\\) times the time 0 price of \\(X\\) plus \\(b\\) times the time zero price of \\(Y\\). If \\(P()\\) is a pricing function that gives us the price of a random cash flow today, then \\(P(aA+bB)=aP(A) + bP(B)\\). In other words, the pricing operator is linear. This follows because if this fails to hold, there is an arbitrage assuming an agent can buy and sell any quantities at these prices. Since the pricing operator is linear, it must have the form \\(P(X) = \\sum_{s=1}^S \\pi_s X(s)\\). We call \\(\\pi_s\\) the price of a dollar at time \\(t\\) in state \\(s\\) or a state price.\nThe price of any positive non zero random cash flow at time \\(t\\) is strictly positive. Again, this follows from no arbitrage (think how much of an asset paying a positive dividend you would want if the cost were free or even if you were paid to take the asset). This implies the state prices are strictly positive.\nThe pricing operator obeys time value of money: \\(1=\\sum_{s=1}^S \\pi_s e^{rt}\\), where \\(r\\) is the continuously compounded yield to maturity of a bond maturing at \\(t\\). This is the present value rule, in other words, the present value of the future value \\(e^{rt}\\) is one or, equivalently, the present value of a dollar paid at \\(t\\) is \\(e^{-rt}\\).\nThe pricing operator must be consistent with observable prices. The price \\(S(0)\\) of a traded asset with random cash flows at time \\(t\\) is given by \\(S(0)= \\sum_{s=1}^S \\pi_s S_s\\) where \\(S_s\\) is the random cash flow in state \\(s\\).\n\n\n\n\n\n\n\nKey Principle\n\n\n\nIn the absence of arbitrage opportunities, there exist positive state prices such that the price of any security is the sum across the states of the world of its payoff multiplied by the state price.\n\n\n\n\n\nFundamental Ideas in a Simple Setting\nIn this section we consider the following very simple framework. There is a stock with price \\(S\\) today (which we call date \\(0\\)). At the end of some period of time of length \\(t\\), the stock price will take one of two values: either \\(S_u\\) or \\(S_d\\), where \\(S_u &gt; S_d\\). If the stock price equals \\(S_u\\) we say we are in the up state of the world, and if it equals \\(S_d\\) we say we are in the down state. The stock does not pay a dividend prior to \\(t\\). There is also a risk-free asset earning a continuously compounded rate of interest \\(r\\).\nWe can relax the assumption that the stock does not pay a dividend prior to \\(t\\). We do that by assuming we are enrolled in a dividend-reinvestment program, so we receive additional shares of the asset instead of receiving cash dividends. Of course, if a company does not operate a dividend-reinvestment program, then we can simulate one on our own by buying shares with cash dividends received. In our model, we start with one share at date \\(0\\) with price \\(S_0\\), and we consider the future value – either \\(S_u\\) or \\(S_d\\) – of owning more than one share at date \\(t\\), because the number of shares grows through reinvestment of dividends. We call this future value a “dividend-reinvested asset” because of this property and we formulate valuation principles for such assets throughout the book.\nAssume \\[\n\\frac{S_u}{S} &gt; \\mathrm{e}^{rt} &gt; \\frac{S_d}{S}\\;.\n\\qquad(7.1)\\] This condition means that the rate of return on the stock in the up state is greater than the risk-free rate, and the rate of return on the stock in the down state is less than the risk-free rate. If it were not true, there would be an arbitrage opportunity: if the rate of return on the stock were greater than the risk-free rate in both states, then one should buy an infinite amount of the stock on margin, and conversely if the rate of return on the stock were less than the risk-free rate in both states, then one should short an infinite amount of stock and put the proceeds in the risk-free asset. So what we are assuming is that there are no arbitrage opportunities in the market for the stock and risk-free asset.\n\n\nState prices\nIt is a simple matter to solve for state prices in this model. We have two equations and two unknowns.\n\\[ 1 = \\pi_u e^{rt} + \\pi_d e^{rt} \\] \\[ S = \\pi_u S_u + \\pi_d S_d \\]\nSolving these equations gives \\(\\pi_u  = \\frac{S-e^{-rt}S_d}{S_u - S_d}\\) and \\(\\pi_d = \\frac{e^{-rt}S_u-S}{S-u - S_d}\\). Notice the requirement that \\(\\pi_s &gt; 0\\) is precisely the no arbitrage condition Equation 7.1 in the previous section.\nA somewhat more enlightening description of the state prices is that \\(\\lambda_u\\) is the price of an Arrow securtity that pays \\(1\\) if the stock price goes up and nothing if the stock price goes down. We can solve for a portfolio of the stock and the risk-free asset that has these payoffs. Let \\(A\\) be the number of shares of stock and \\(B\\) be the amount borrow or lent at time zero. Then this portfolio will have the desired payoffs if \\[A S_u + B e^{rt} = 1\\] and \\[A S_d + B e^{rt} =0\\].\nSolving we get \\(A= \\frac{1}{S_u - S_d}\\) and \\(B = -e^{-rt}\\frac{S_d}{S_u - S_d}\\). The time zero cost of this portfolio is \\(AS +B = \\frac{S - e^{-rt} S_d}{S_u - S_d} = \\pi_u\\). A similar exercise reveals \\(\\pi_d\\) is the time 0 price of a portfoio with payofss 0 if the stock price goes up and 1 if the stock price goes down.\nGiven the state prices, we can value any derivative security whose payoffs depend on the stock price and the risk free asset. For example, consider a European call option on the stock with maturity \\(t\\) and strike \\(K\\). A call option gives the owner the right (but not the obligation) to buy the stock at the fixed price called the strike. The value of this at the option maturity \\(t\\) is the excess of the stock price over \\(K\\) if the excess is positive and is zero otherwise, which we write as \\(C_u=\\max(0,S_u-K)\\) in the up state and \\(C_d=\\max(0,S_d-K)\\) in the down state. Therefore, the value of the call option today, \\(C\\), is given by \\[C = \\pi_u C_u + \\pi_d C_d = \\].\n\n\nOption Deltas and Replication\nThe more traditional way to derive option prices is by finding a portfolio that replicates the option payoff and then the initial cost of the portfolio must be the option price by no arbitrage. We now show this is consistent with the state price approach. We again consider a European call option on the stock with maturity \\(t\\) and strike \\(K\\). The value of this at the option maturity \\(t\\) is the excess of the stock price over \\(K\\) if the excess is positive and is zero otherwise, which we write as \\(C_u=\\max(0,S_u-K)\\) in the up state and \\(C_d=\\max(0,S_d-K)\\) in the down state.\nThe delta of the call option is defined to be the difference between the call values in the up and down states divided by the difference between the underlying values; that is, \\(\\delta = (C_u-C_d)/(S_u-S_d)\\). Multiplying by \\(S_u-S_d\\) gives us \\(\\delta(S_u-S_d) = C_u-C_d\\) and rearranging yields \\(\\delta S_u - C_u = \\delta S_d-C_d\\), which is critical to what follows. Consider purchasing \\(\\delta\\) shares of the stock at date \\(0\\) and borrowing \\[\\mathrm{e}^{-rt}(\\delta S_u-C_u) = \\mathrm{e}^{-rt}(\\delta S_d-C_d)\\] dollars at date \\(0\\). Then you will owe \\[\\delta S_u-C_u = \\delta S_d-C_d\\] dollars at date \\(t\\), and hence the value of the portfolio at date \\(t\\) in the up state will be \\[\\text{value of delta shares} - \\text{dollars owed} = \\delta S_u - (\\delta S_u-C_u) = C_u\\; ,\\] and the value of the portfolio at date \\(t\\) in the down state will be \\[\\text{value of delta shares} - \\text{dollars owed} = \\delta S_d - (\\delta S_d-C_d) = C_d\\;\\;.\\] Thus, this portfolio of buying delta shares and borrowing money (i.e., buying delta shares on margin) replicates the call option. Consequently, the value \\(C\\) of the option at date \\(0\\) must be the date–0 cost of the portfolio; i.e., \\[\nC = \\text{cost of delta shares} - \\text{dollars borrowed}\\] \\[ = \\delta S - \\mathrm{e}^{-rt}(\\delta S_u-C_u)\\;.\n\\qquad(7.2)\\]\n\n\n\n\n\n\nExample\n\n\n\n\n\nSuppose a stock price today is \\(S=100\\), and suppose that the price at a future date \\(t\\) will be either \\(S_u=110\\) or \\(S_u=90\\). The following figure depicts this situation.\n\n\n\n\n\nConsider a call option with a strike of \\(K=105\\) that matures at \\(t\\). The value of being able to buy a stock at \\(105\\) and sell it for \\(110\\) is \\(5\\), and the value of being able to buy at \\(105\\) and sell at \\(90\\) is zero, so the value of the call option at date \\(t\\) is as shown below. Our goal is to answer the question: What is the call worth at date \\(0\\)?\n\n\n\n\n\nWe calculate the option \\(\\delta\\) as described above: \\[\\frac{C_u - C_d}{S_u-S_d} = \\frac{5-0}{110-90} = \\frac{1}{4}\\,.\\] The following shows the value of \\(\\delta\\) shares at date \\(0\\) and at date \\(t\\).\n\n\n\n\n\nThe critical feature of this figure is that the difference between the up and down values at date \\(t\\) is the same as the difference between the up and down values of the call; that is, it is \\(5\\) dollars. This is guaranteed by our formula for \\(\\delta\\). The portfolio of \\(\\delta\\) shares is worth more than the call at date \\(t\\), but if we owed \\(22.50\\), then the value of the portfolio after paying back the loan would match the call value. At an interest rate of 5% (as a rate from date \\(0\\) to date \\(t\\) instead of continuous compounding, for simplicity), we could borrow \\(21.43\\) and then owe \\(22.50\\). This is depicted in the following.\n\n\n\n\n\nIf we subtract the previous figure from the figure showing the value of \\(\\delta\\) shares, we obtain the figure below. What it means is that if we invest \\(3.57\\) of our own money, and borrow \\(21.43\\), then we can buy \\(\\delta\\) shares, and, after paying back the loan with interest, our portfolio value will match the value of the call option. In other words, we can replicate the call option by buying \\(\\delta\\) shares of the stock on margin. Because we can create the call option value at date \\(t\\) by investing \\(3.57\\) of our own money at date \\(0\\), the price of the call option at date \\(0\\) should be \\(3.57\\). If the price of the call option were different, then there would be an arbitrage opportunity. This is the calculation that is made in Equation 7.2.\n\n\n\n\n\n\n\n\n\n\nState Prices\nWe now rewrite the option pricing Equation 7.2 in terms of state prices. By substituting for \\(\\delta\\) in Equation 7.2, we can rearrange Equation 7.2 as\n\\[\nC = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times C_u + \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times C_d\\; .\n\\qquad(7.3)\\]\nA little algebra also shows that \\[\nS = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times\nS_u + \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times S_d\\; ,\n\\qquad(7.4)\\]\nand \\[\n1 = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\times \\mathrm{e}^{rt}+ \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\times \\mathrm{e}^{rt}\\;.\n\\qquad(7.5)\\]\nIt is convenient to denote the factors appearing in these equations as \\[\n\\pi_u = \\frac{S-\\mathrm{e}^{-rt}S_d}{S_u-S_d} \\quad \\text{and} \\quad \\pi_d = \\frac{\\mathrm{e}^{-rt}S_u-S}{S_u-S_d}\\;.\n\\qquad(7.6)\\]\nThe numbers \\(\\pi_u\\) and \\(\\pi_d\\) are called the state prices, for reasons that will be explained below.\nWith these definitions, we can write Equation 7.3–Equation 7.5 as\n\\[\nC = \\pi_uC_u + \\pi_dC_d\\;,\n\\qquad(7.7)\\]\n\\[\nS = \\pi_uS_u+\\pi_dS_d\\;,\n\\qquad(7.8)\\]\n\\[\n1 = \\pi_u\\mathrm{e}^{rt} + \\pi_d \\mathrm{e}^{rt}\\;.\n\\qquad(7.9)\\]\nThese equations have the following interpretation: the value of a security today is its value in the up state times \\(\\pi_u\\) plus its value in the down state times \\(\\pi_d\\). This applies to Equation 7.9 by considering an investment of $1 today in the risk-free asset—it has value 1 today and will have value \\(\\mathrm{e}^{rt}\\) in both the up and down states at date \\(t\\). Moreover, this same equation holds for any other derivative asset – for example, a put option – for the same \\(\\pi_u\\) and \\(\\pi_d\\) defined in Equation 7.6.\nWe can think of any security as a portfolio of what are called Arrow securities (in recognition of the seminal work of Kenneth Arrow (Arrow 1964)). In this model, one of the Arrow securities pays $1 at date \\(t\\) if the up state occurs and the other pays $1 at date \\(t\\) if the down state occurs. For example, the stock is equivalent to a portfolio consisting of \\(S_u\\) units of the first Arrow security and \\(S_d\\) units of the second, because the stock is worth \\(S_u\\) dollars in the up state and \\(S_d\\) dollars in the down state. Equation 7.7–Equation 7.9 show that \\(\\pi_u\\) is the price of the first Arrow security and \\(\\pi_d\\) is the price of the second. For example, the right-hand side of Equation 7.8 is the value of the stock at date \\(0\\) viewed as a portfolio of Arrow securities when the Arrow securities have prices \\(\\pi_u\\) and \\(\\pi_d\\). Because the stock clearly is such a portfolio, its price today must equal the value of that portfolio, which is what Equation 7.8 asserts.\nAs mentioned before, the prices \\(\\pi_u\\) and \\(\\pi_d\\) of the Arrow securities are called the state prices, because they are the prices of receiving $1 in the two states of the world. The state prices should be positive, because the payoff of each Arrow security is nonnegative in both states and positive in one. A little algebra shows that the conditions \\(\\pi_u&gt;0\\) and \\(\\pi_d&gt;0\\) are exactly equivalent to our no-arbitrage assumption Equation 7.1.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#risk-neutral-probability",
    "href": "Chapter_Arbitrage.html#risk-neutral-probability",
    "title": "7  Foundations",
    "section": "7.2 Risk-Neutral Probability",
    "text": "7.2 Risk-Neutral Probability\nWe have our basic pricing formula \\[ P(X)= \\sum_{s=1}^S \\pi_s X_s \\] Let \\(p_s = \\pi_s e^{rt}\\). Then \\(\\sum_{s=1}^S p_s = 1\\) and \\(p_s&gt;0\\). Therefore, we can think of \\(p_s\\) as probabilities. We refer to \\(p_s\\) as risk neutral probabilities. Given this we can write \\[P(X)= \\sum_{s=1}^S p_s e^{-rt} X_s \\] which can be thought of the expected discounted value of the future cash flows. The risk neutral probabilities are so-called since we discount by the risk-free rate. However, the risk neutral probabilities should not be confused with actual probabilities since they are really prices.\nUnlike the Capital Asset Pricing Model, for example, there is no risk premium in the discount rate. This is the calculation we would do to price assets under the actual probabilities if investors were risk neutral (or for zero-beta assets). So, we can act as if investors are risk neutral by adjusting the probabilities.1 Of course, we are not really assuming investors are risk neutral. We have simply embedded any risk premia in the probabilities.\nNotice the expected return using the risk neutral probabilities for any investement is the risk free rate: \\[\\frac{\\sum_{s=1}^S p_s X_s}{P(X)} = e^{rt}\\], so it is important to realize that the risk neutral probabilities are distinct from the actual probabilities used in portfolio theory.\n\nRisk-Neutral Probability in the Binomial Model\nTo apply Key Principle \\(\\ref{principle:stateprices}\\) in the most convenient way, we manipulate the state prices so we can interpret the sums on the right-hand sides of Equation 7.7–Equation 7.9 in terms of expectations. The expectation (or mean) of a random variable is of course its probability-weighted average value.\nSet \\(p_u = \\pi_u\\mathrm{e}^{rt}\\) for the up state and \\(p_d = \\pi_d\\mathrm{e}^{rt}\\) for the down state. Equation 7.7–Equation 7.9 can be written as\n\\[\nC = \\mathrm{e}^{-rt}[p_uC_u+p_dC_d]\\;,\n\\qquad(7.10)\\]\n\\[\nS = \\mathrm{e}^{-rt}[p_uS_u+p_dS_d]\\;,\n\\qquad(7.11)\\]\n\\[\n1= p_u+p_d\\;.\n\\qquad(7.12)\\]\nThe numbers \\(p_u\\) and \\(p_d\\) are called the risk-neutral probabilities of the up and down states. The numbers are both positive (because the state prices are positive under our no-arbitrage assumption) and Equation 7.12 states that they sum to one, so it is indeed sensible to consider them as (artificial) probabilities. Equation 7.10 and Equation 7.11 state that the value of a security today is its expected value at date \\(t\\) discounted at the risk-free rate, when we take the expectation using the risk-neutral probabilities. Thus, these are present value formulas.\nIt follows from Equation 7.11 that the expected return of the stock under the risk-neutral probabilities is the risk-free return; that is, \\[\\frac{p_uS_u + p_dS_d}{S} = \\mathrm{e}^{rt}\\,.\\] This is a general fact: expected returns relative to the risk-neutral probabilities equal the risk-free return.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#martingale-pricing",
    "href": "Chapter_Arbitrage.html#martingale-pricing",
    "title": "7  Foundations",
    "section": "7.3 Martingale Pricing",
    "text": "7.3 Martingale Pricing\nA martingale is a stochastic process for which the expected value of tomorrow’s value is today’s value. In the context of our model discounted values of non-dividend paying trading strategies are martingales, that is if \\(X(0)\\) is today’s value of a portfolio with payoffs random \\(X\\) at time \\(t\\), \\[  \\frac{X(0))}{R(0))} = \\sum_{s=1}^S p_s \\frac{X_s}{e^{r t}} = \\mathbb{E}^R\\left[\\frac{X}{R_t}\\right] \\] where \\(R(0) = 1\\), the initial investment in the risk free asset. In this sense, the discounted value today is the expected discounted discounted value in one period, where the expectation uses the risk neutral probabilities.\n’’\n\nMartingales\nEquation 7.10 and Equation 7.11 can be written in an equivalent form, which, though somewhat less intuitive, generalizes more readily. First, let’s introduce some notation for the price of the risk-free asset. Considering an investment of $1 today that grows to \\(\\mathrm{e}^{rt}\\) at date \\(t\\), it is sensible to take the price today to be \\(R=1\\) and the price in the up and down states at date \\(t\\) to be \\(R_u=R_d=\\mathrm{e}^{rt}\\).2 In terms of this notation, Equation 7.10–Equation 7.12 can be written as:\n\\[\n\\frac{C}{R} = p_u \\frac{C_u}{R_u} + p_d \\frac{C_d}{R_d}\\;,\n\\qquad(7.13)\\]\n\\[\n\\frac{S}{R} = p_u \\frac{S_u}{R_u} + p_d \\frac{S_d}{R_d}\\;,\n\\qquad(7.14)\\]\n\\[\n1=p_u+p_d\\;.\n\\qquad(7.15)\\]\nEquation 7.13 and Equation 7.14 each state that the price of a security today divided by the price of the risk-free asset equals the expected future value of the same ratio, when we take expectations using the risk-neutral probabilities. In other words, the mean of the date–\\(t\\) value of the ratio is equal to the ratio today.\nA variable that changes randomly over time with the expected future value being always equal to the current value is called a martingale. Thus, we have shown that the ratio of the stock price to the price of the risk-free asset is a martingale when using the risk-neutral probabilities.\nThe ratio of one price to another is the value of the first (numerator) asset when we are using the second (denominator) asset as the numeraire. The term numeraire means a unit of measurement. For example, the ratio \\(C/R\\) is the value of the call when we use the risk-free asset as the unit of measurement: it is the number of units of the risk-free asset for which one call option can be exchanged (to see this, note that \\(C/S\\) shares is worth \\(C/R \\times R = C\\) dollars, so \\(C/R\\) units of the risk-free asset is worth the same as one call). Thus, we have shown that asset prices using the risk-free asset as numeraire are martingales relative to the risk-neutral probabilities.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#change-of-numeraire",
    "href": "Chapter_Arbitrage.html#change-of-numeraire",
    "title": "7  Foundations",
    "section": "7.4 Change of Numeraire",
    "text": "7.4 Change of Numeraire\nOur choice of the risk free asset to derive risk neutral probabilities was somewhat arbitrary. In fact any strictly positive non-dividend paying trading strategy can be used as a numeraire. In other words instead of quoting the price of apples and oranges in dollars, we can quote prices in numbers of oranges. One apple is equal to the price of one apple in dollars divided by the price of oranges in dollars and one dollar is equal to one divided by the price of oranges. In our model, instead of measuring payoffs in units of an investment in the risk free asset, we can measure payoffs in different units. We explain this as follows.\nThe price of any non dividend paying asset or dividend reinvested trading strategy with strictly positive value is \\[Y(0) = \\sum_{s=1}^S \\pi_s Y_s \\] Rearranging, we can define probabilities \\(\\text{prob}^Y_s = \\frac{\\pi_s}{Y(0)}\\). Then we have \\(\\sum_{s=1}^S \\text{prob}^Y_s =1\\) and we can write the price of the risk free asset and any traded security as \\[1 = Y(0) \\sum_{s=1}^S \\text{prob}^Y_s \\frac{e^{rt}}{Y_s} = Y(0) \\mathbb{E}^Y\\left[\\frac{e^{rt}}{Y} \\right]\\] \\[S(0) = Y(0) \\sum_{s=1}^S \\text{prob}^Y \\frac{S_s}{Y_s}  = Y(0) \\mathbb{E}^Y\\left[\\frac{S}{Y}\\right] \\] Notice \\(\\frac{S}{Y}\\) is a martingale using the probabilities \\(\\text{prob}_s^Y\\). The ratio \\(\\frac{S}{Y}\\) is the number of shares of \\(Y\\) that security \\(S\\) is worth. Therefore, using the probabilities \\(p_s^Y\\), the value of the number of shares of \\(Y\\) an investment is worth follows a martingale.\n\n\n\n\n\n\nKey Principle\n\n\n\nIf there are no arbitrage opportunities, then for each dividend-reinvested asset, there exists a probability measure such that the ratio of any other dividend-reinvested asset price to the first (numeraire) asset price is a martingale.\n\n\nAn assignment of probabilities to events is called a probability measure, or simply a measure (because it measures the events, in a sense). Thus, we have described two different probability measures: one using the risk-free asset as numeraire and one using the stock as numeraire. The probability measure using the risk-free asset as numeraire defined in the previous section is universally called the risk-neutral probability. When we use one of these probabilities, we commonly say that we are changing numeraires.\nWe have applied this statement to the risk-free asset, which pays dividends (interest). However, the price \\(R_s=\\mathrm{e}^{rt}\\) for all \\(s=1,\\dots,S\\), includes the interest, so no interest has been withdrawn—the interest has been reinvested—prior to the maturity \\(t\\) of the option. This is what we mean by a dividend-reinvested asset. In general, we apply the formulas developed in this and the following section to dividend-paying assets by considering the portfolios in which dividends are reinvested.\n\nOther Numeraires in the Binomial Model\nNote that the risk-neutral probabilities are the state prices multiplied by the gross return on the risk-free asset. Analogously, define numbers \\(\\text{prob}^S_u = \\pi_uS_u/S\\) and \\(\\text{prob}^S_d = \\pi_dS_d/S\\). Substituting for \\(\\pi_u\\) and \\(\\pi_d\\) in Equation 7.7–Equation 7.9 and continuing to use the notation \\(R\\) for the price of the risk-free asset, we obtain\n\\[\n\\frac{C}{S} = \\text{prob}^S_u \\frac{C_u}{S_u} + \\text{prob}^S_d \\frac{C_d}{S_d}\\;,\n\\qquad(7.16)\\]\n\\[\n1 = \\text{prob}^S_u + \\text{prob}^S_d\\;,\n\\qquad(7.17)\\]\n\\[\n\\frac{R}{S} = \\text{prob}^S_u \\frac{R_u}{S_u} + \\text{prob}^S_d \\frac{R_d}{S_d}\\;.\n\\qquad(7.18)\\]\nEquation 7.17 establishes that we can view the \\(\\text{prob}^S\\)’s as probabilities (like the risk-neutral probabilities, they are positive because the state prices are positive). Equation 7.16 and Equation 7.18 both state that the ratio of a security price to the price of the stock is a martingale when we use the \\(\\text{prob}^S\\)’s’ as probabilities. Thus, asset prices using the stock as numeraire are martingales when we use the \\(\\text{prob}^S\\) probabilities.\n\n\nPractical Implementation\nFor this exposition, it was convenient to first calculate the state prices and then calculate the various probabilities. However, that is not the most efficient way to proceed in most applications. In a typical application, we would view the prices of the stock and risk-free asset in the various states of the world as given, and we would be attempting to compute the value of the call option. Note that t Equation 7.7–Equation 7.9, Equation 7.13–Equation 7.15, and Equation 7.16–Equation 7.18 are all equivalent. In each case we would consider that there are three unknowns—the value \\(C\\) of the call option and either two state prices or two probabilities. In each case the state prices or probabilities can be computed from the last two equations in the set of three equations and then the call value \\(C\\) can be computed from the first equation in the set. All three sets of equations produce the same call value.\nIn fact, as we will see, it is not even necessary to calculate the probabilities. The fact that ratios of dividend-reinvested asset prices to the numeraire asset price are martingales tell us enough about the probabilities to calculate derivative values without having to calculate the probabilities themselves.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#stochastic-discount-factor",
    "href": "Chapter_Arbitrage.html#stochastic-discount-factor",
    "title": "7  Foundations",
    "section": "7.5 Stochastic Discount Factor",
    "text": "7.5 Stochastic Discount Factor\nUp until now, no mention of the true proabilities has been made. However, another pricing formula that is commonly encountered is to use a stochastic discount factor. Denote the actual probability of state \\(s\\) as \\(\\text{prob}_s\\).If we define \\(m_s = \\frac{\\pi_s}{\\text{prob}_s}\\), we can write \\[ P(X) = \\sum_{s=1}^S \\text{prob}_s m_s X_s = \\mathbb{E}\\left[m X\\right] \\].\nWe call the random variable \\(m\\) the stochastic discount factor. We can calculate an asset value as the expectation of its future value discounted (multiplied) by the the stochastic factor \\(m\\).\nA further decomposition of \\(m\\) is useful. Notice that \\[ 1 = \\mathbb{E}\\left[m e^{rt}\\right] \\] so in a sense to be made precise later, \\(m e^{rt}\\) is a martingale when we identify the time 0 value of \\(m\\) as 1. Therefore, we can write the price of any asset with time \\(t\\) value \\(X\\) as \\[  P(X) = \\mathbb{E}\\left[m e^{rt} \\frac{X}{e^{rt}}\\right] = \\sum_{s=1}^S \\text{prob}_s m_s e^{rt} \\frac{X_s}{e^{rt}} =\\mathbb{E}^R\\left[\\frac{X}{e^{rt}}\\right]\\] Therefore, the risk neutral probabilities are \\[p_s = \\text{prob}_s m_s e^{rt} \\] and the random variable \\(m e^{rt}\\) changes the probability measure from the true probability measure to the risk neutral measure: for any random variable \\(Z\\), \\(\\mathbb{E}[m e^{rt} Z] = \\mathbb{E}^R[Z]\\).\n\nStochastic Discount Factor in the Binomial Model\nWe now consider yet another reformulation of the pricing relations Equation 7.7–Equation 7.9. This formulation generalizes more easily to pricing when there are a continuum of states.\nLet \\(\\text{prob}_u\\) denote the actual probability of the up state and \\(\\text{prob}_d\\) denote the probability of the down state. These probabilities are irrelevant for pricing derivatives in the two-state up-and-down model, but we use them to write the pricing relations Equation 7.7–Equation 7.9 as expectations with respect to the actual probabilities. To do this, we can define \\[\\begin{align*}\nm_u &= \\frac{\\pi_u}{\\text{prob}_u}\\; ,\\\\\nm_d &= \\frac{\\pi_d}{\\text{prob}_d}\\;.\n\\end{align*}\\] Then Equation 7.7–Equation 7.9 can be written as\n\\[\nC = \\text{prob}_um_uC_u + \\text{prob}_dm_dC_d\\;,\n\\qquad(7.19)\\]\n\\[\nS = \\text{prob}_um_uS_u + \\text{prob}_dm_dS_d\\;,\n\\qquad(7.20)\\]\n\\[\nR = \\text{prob}_um_uR_u + \\text{prob}_dm_dR_d\\;.\n\\qquad(7.21)\\]\nThe right-hand sides are expectations with respect to the actual probabilities. For example, the right-hand side of Equation 7.19 is the expectation of the random variable that equals \\(m_uC_u\\) in the up state and \\(m_dC_d\\) in the down state. The risk-neutral probabilities can be calculated from \\(m_u\\) and \\(m_d\\) as \\(p_u=\\text{prob}_um_uR_u/R\\) and \\(p_d=\\text{prob}_dm_dR_d/R\\). Likewise, the probabilities using the stock as the numeraire can be calculated from \\(m_u\\) and \\(m_d\\) as \\(\\text{prob}^S_u=\\text{prob}_um_uS_u/S\\) and \\(\\text{prob}^S_d=\\text{prob}_dm_dS_d/S\\).\nThe random variable \\(m\\) the stochastic discount factor. Equation 7.20–Equation 7.21 show that we can calculate an asset value as the expectation of its future value discounted (multiplied) by the the stochastic factor \\(m\\).",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#more-general-models",
    "href": "Chapter_Arbitrage.html#more-general-models",
    "title": "7  Foundations",
    "section": "7.6 More General Models",
    "text": "7.6 More General Models\nNow, we drop the assumption that there are a finite number of possible future prices of the stock and allow a general distribution with potentially a continuum of possible values. Denote the future price as \\(S_t\\). Our principle regarding the stochastic discount factor developed in the preceding section can in general be expressed as:3\n\n\n\n\n\n\nKey Principle\n\n\n\nIf there are no arbitrage opportunities, then there exists for each date \\(t\\) a strictly positive random variable \\(m_t\\), called a stochastic discount factor, such that the date–\\(0\\) value of any dividend-reinvested asset with price \\(P\\) is \\[\nP_0 = \\mathbb{E}[m_tP_t]\\;.\n\\qquad(7.22)\\]\n\n\nHere, \\(\\mathbb{E}[m_tS_t]\\) denotes the expectation of the random variable \\(m_tS_t\\). In a two-state model (or in any model with only a finite number of states of the world), the concept of an expectation is clear: it is just a weighted average of outcomes, the weights being the probabilities. In the two-state model, the right-hand side of Equation 7.20 is the same as the right-hand side of Equation 7.22.4\nTo convert from state prices to probabilities corresponding to different numeraires, we follow the same procedure as at the end of the previous section: we multiply together (i) the probability of the state, (ii) the value of \\(m_t\\) in the state, and (iii) the gross return of the numeraire in the state. If there is a continuum of states, then the actual probability of any individual state is typically zero, so this multiplication produces a zero probability. However, we can nevertheless add up these probabilities to define the probability of any event \\(A\\), an event being a set of states of the world. To do this, let \\(1_A\\) denote the random variable that takes the value 1 when \\(A\\) is true and which is zero otherwise. Then the probability of \\(A\\) using \\(S\\) as the numeraire is defined as \\[\n\\mathbb{E}\\left[1_Am_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(7.23)\\]\nThis makes sense as a probability because it is nonnegative and because, if \\(A\\) is the set of all states of the world, then its probability is \\(\\mathbb{E}[m_tS_t/S_0]\\), which equals one by virtue of Equation 7.22. From Equation 7.23 for the probability of any event \\(A\\), it can be shown that the expectation of any random variable \\(X\\) using \\(S\\) as the numeraire is \\[\n\\mathbb{E}\\left[Xm_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(7.24)\\]\nDifferent numeraires lead to different probability measures and hence to different expectations. To keep this straight, we use the numeraire as a superscript on the expectation symbol: for example, \\(\\mathbb{E}^S\\) denotes expectation with respect to the probability measure that corresponds to \\(S\\) being the numeraire. Also, we use the symbol \\(\\text{prob}^S(A)\\) to denote the probability of an event \\(A\\) when we use \\(S\\) as the numeraire. So, Equation 7.23 and Equation 7.24 are written as\n\\[\n\\text{prob}^S(A) = \\mathbb{E}\\left[1_Am_t\\frac{S_t}{S_0}\\right]\\;,\n\\qquad(7.25)\\]\n\\[\n\\mathbb{E}^S[X] = \\mathbb{E}\\left[Xm_t\\frac{S_t}{S_0}\\right]\\;.\n\\qquad(7.26)\\]\n\nFundamental Pricing Formula\nOur key result in the two-state up-and-down example considered earlier was that the ratio of the price of any dividend-reinvested asset to the price of the numeraire asset is not expected to change when we use the probability measure corresponding to the numeraire. We now demonstrate the same result in this more general model. Recall that \\(t\\) denotes an arbitrary but fixed date at which we have defined the probabilities using \\(S\\) as the numeraire in Equation 7.23. At each date \\(s&lt;t\\), let \\(\\mathbb{E}^P_s\\) denote the expectation given information at time \\(s\\) and using a dividend-reinvested asset price \\(P\\) as the numeraire (we continue to write the expectation at date \\(0\\) without a subscript; i.e., \\(\\mathbb{E}^S\\) has the same meaning as \\(\\mathbb{E}^S_0\\)). Let \\(Y\\) denote the price of another dividend-reinvested asset. We will show that \\[\n\\frac{Y_s}{P_s} = \\mathbb{E}^P_s \\left[\\frac{Y_t}{P_t}\\right]\\;.\n\\qquad(7.27)\\]\nThus, the expected future (date–\\(t\\)) value of the ratio \\(Y/P\\) always equals the current (date–\\(s\\)) value when we change probability measures using \\(P\\) as the numeraire. As discussed in the preceding section, the mathematical term for a random variable whose expected future value always equals its current value is martingale. Thus, we can express Equation 7.27 as stating that the ratio \\(Y/P\\) is a martingale when we compute expectations using the probability measure that corresponds to \\(S\\) being the numeraire.\nThe usefulness of Equation 7.27 is that it gives us a formula for the asset price \\(Y_s\\) at any time \\(s\\)—and recall that this formula holds for every dividend-reinvested asset. The formula is obtained from Equation 7.27 by multiplying through by \\(P_s\\):\n\n\n\n\n\n\nKey Principle\n\n\n\nIn the absence of arbitrage opportunities, prices \\(P\\) and \\(Y\\) of dividend-reinvested assets satisfy, for all \\(s&lt;t\\), \\[\nY_s = P_s\\mathbb{E}^P_s \\left[\\frac{Y_t}{P_t}\\right]\\;.\n\\qquad(7.28)\\]\n\n\nWe call Equation 7.28 the fundamental pricing formula. It is at the heart of modern pricing of derivative securities. It is a present value relation: the value at time \\(s\\) of the asset with price \\(Y\\) is the expectation, under the appropriate probability measure, of its value \\(Y_t\\) at time \\(t\\) discounted by the (possibly random) factor \\(P_s/P_t\\).\nFor example, assume the risk free rate is constant. Letting \\(P_s = R_s\\) denote the value \\(\\mathrm{e}^{rs}\\) of the risk-free asset and using it as the numeraire, Equation 7.28 becomes \\[\nY_s = \\mathrm{e}^{rs}\\\\E^R_s\\left[\\frac{Y_t}{\\mathrm{e}^{rt}}\\right] = \\mathrm{e}^{-r(t-s)}\\mathbb{\\mathbb{E}}^R_s [Y_t]\\;,\n\\qquad(7.29)\\]\nwhich means that the value \\(Y_s\\) is the expected value of \\(Y_t\\) discounted at the risk-free rate for the remaining time \\(t-s\\), when the expectation is computed under the risk-neutral probability.\nNotice that this implies \\(m_t e^{rt}\\) is a martingale. This tells us how to change probabilities as follows: for any time \\(t\\) random variable5, \\(Z\\), \\[E[m_t e^{rt} Z] = E^R[Z] \\] Similar remarks also apply to any dividend reinvested trading strategy, \\(X\\), \\(m_t X_t\\) is a martingale. Then \\[E[m_t X_t Z] = X(0) E^X[Z]\\].\nWe end this section with a proof of Equation 7.27.6\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nConsider any time \\(s&lt;t\\) and any event \\(A\\) that is distinguishable by time \\(s\\). Consider the trading strategy of buying one share of the asset with price \\(Y\\) at time \\(s\\) when \\(A\\) has happened and financing this purchase by short selling \\(Y_s/P_s\\) shares of the asset with price \\(P\\). Each share of this asset that you short brings in \\(P_s\\) dollars, so shorting \\(Y_s/P_s\\) shares brings in \\(Y_s\\) dollars, exactly enough to purchase the desired share of the first asset. Hold this portfolio until time \\(t\\) and then liquidate it. Liquidating it generates \\[1_A\\left(Y_t-\\frac{Y_s}{P_s}P_t\\right)\\] dollars. The multiplication by the random variable \\(1_A\\) is because we only implement this strategy when \\(A\\) occurs (i.e., when \\(1_A=1\\)). Consider the security that pays this number of dollars at time \\(t\\). Because we obtained it with a trading strategy that required no investment at any time, its price at time \\(0\\) must be \\(0\\). We already observed that we can represent the price in terms of state prices, so we conclude that \\[\\mathbb{E}\\left[m_t1_A\\left(Y_t-\\frac{Y_s}{P_s}P_t\\right)\\right] = 0\\;\\;.\\] When we divide by \\(P_0\\), this still equals zero. Factoring \\(P_t\\) outside the parentheses gives \\[\\mathbb{E}\\left[1_A\\frac{P_t}{P_0}m_t\\left(\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right)\\right] = 0\\;\\;.\\] We see from Equation 7.26 for expectations using \\(P\\) as the numeraire that we can write this as \\[\\mathbb{E}^P\\left[1_A\\left(\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right)\\right]=0\\;.\\] This is true for any event \\(A\\) distinguishable at time \\(s\\), so the expectation of \\(Y_t/P_t-Y_s/P_s\\) must be zero given any information at time \\(s\\) when we use \\(P\\) as the numeraire; i.e., \\[\\mathbb{E}^P_s\\left[\\frac{Y_t}{P_t}-\\frac{Y_s}{P_s}\\right]=0\\; ,\\] or, equivalently \\[\\mathbb{E}^P_s\\left[\\frac{Y_t}{P_t}\\right] = \\frac{Y_s}{P_s}\\;.\\]",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#multiple-cash-flows",
    "href": "Chapter_Arbitrage.html#multiple-cash-flows",
    "title": "7  Foundations",
    "section": "7.7 Multiple Cash Flows",
    "text": "7.7 Multiple Cash Flows\nOur valuation formulae work for dividend paying assets or trading strategies that make periodic payments. We simply sum up the value of the individual cash flows. If a stock pays dividends \\(D_t\\) up to and including time \\(T\\) and the stock price at time \\(T\\) is \\(S(T)\\) then the stock price is given by \\[S(0)= \\mathbb{E}\\left[\\sum_{t=1}^T m_t D_t + M_T S(T)\\right] \\]",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#further-discussion",
    "href": "Chapter_Arbitrage.html#further-discussion",
    "title": "7  Foundations",
    "section": "7.8 Further Discussion",
    "text": "7.8 Further Discussion\nHow do the probabilities of different events change when we change probability measures? Which events become more likely and which become less likely? These are natural questions to ask. Let’s consider the risk-neutral probability assuming the risk free rate is constant. Equation 7.29 can be rearranged as \\[\\frac{\\mathbb{E}^{R}_s[Y_t]}{Y_s} = \\mathrm{e}^{r(t-s)}\\,.\\] This means that the expected return on on the dividend-reinvested asset with price \\(Y\\) is the risk-free rate. Stocks generally have positive risk premia, meaning they are expected to return more than the risk-free rate. Hence, when we shift from the actual probabilities to the risk-neutral probability, we are decreasing expected returns. How does this happen? It is because we increase the probabilities of bad events (low stock returns) and decrease the probabilities of good events (high stock returns).\nIn Example \\(\\ref{example:binomial}\\), it is easy to calculate that the risk-neutral probabilities are \\(p_u=0.75\\) and \\(p_d=0.25\\). To value the call option, we did not need to specifythe actual probabilities, but if the expected return of the stock is higher than the risk-free return – that is, if the stock has a positive risk premium – then it must be the case that \\(p_u &gt; 0.75\\). For example, if the expected return is 8%, then \\(p_u=0.9\\). Thus, if the stock has a positive risk premium, then the risk-neutral probability of the stock falling is higher than the actual probability.\nThe usual way to value risky assets is to discount expected future values at a risk-adjusted rate that is higher than the risk-free rate. What we have shown is that we can instead value risky assets by adjusting the probabilities and discounting at the risk-free rate. Instead of increasing the discount rate relative to the risk-free rate, we increase the probabilities of bad events. These are alternative ways of valuing risky assets.\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function in which the user inputs \\(S\\), \\(S_d\\), \\(S_u\\), \\(K\\), \\(r\\) and \\(t\\). Check that the no-arbitrage condition Equation 7.1 is satisfied. Compute the value of a call option in each of the following ways:\n\nCompute the delta and use Equation 7.2.\nCompute the state prices and use Equation 7.7.\nCompute the risk-neutral probabilities and use Equation 7.10.\nCompute the probabilities using the stock as numeraire and use Equation 7.16.\n\nVerify that all of these methods produce the same answer.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nIn a two-state model, a put option is equivalent to \\(\\delta_p\\) shares of the stock, where \\(\\delta_p = (P_u-P_d)/(S_u-S_d)\\) (this will be negative, meaning a short position) and some money invested in the risk-free asset. Derive the amount of money \\(x\\) that should be invested in the risk-free asset to replicate the put option. The value of the put at date \\(0\\) must be \\(x+\\delta_pS\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the result of the previous exercise, repeat Problem~\\(\\ref{e_binomialcall}\\) for a put option.\n\n\n\n\n\n\n\nArrow, K. J. 1964. “The Role of Securities in the Optimal Allocation of Risk Bearing.” Review of Economic Studies 31: 91–96.\n\n\nCox, J., and S. Ross. 1976. “The Valuation of Options for Alternative Stochastic Processes.” Journal of Financial Economics 3: 145–66.\n\n\nGeman, H., N. El Karoui, and J.-C. Rochet. 1995. “Changes of Numeraire, Changes of Probability Measure and Option Pricing.” Journal of Applied Probability 32: 443–58.\n\n\nHarrison, J. M., and D. Kreps. 1979. “Martingales and Arbitrage in Multiperiod Securities Markets.” Journal of Economic Theory 20: 381–408.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Arbitrage.html#footnotes",
    "href": "Chapter_Arbitrage.html#footnotes",
    "title": "7  Foundations",
    "section": "",
    "text": "This fundamental idea is due to Cox and Ross (Cox and Ross 1976).↩︎\nAll of the equations appearing below are also true if instead we take \\(R=\\mathrm{e}^{-rt}\\) and \\(R_u=R_d=1\\).↩︎\nWe have proven this in the two-state model, but we will not prove it in general. As is standard in the literature, we simply adopt it as an assumption. A general proof is in fact difficult and requires a definition of no arbitrage that is considerably more complicated than the simple assumption Equation 7.1 that is sufficient in the two-state up-and-down model.↩︎\n In general the expectation (or mean) of a random variable is an intuitive concept, and an intuitive understanding is sufficient for this book, so we will not give a formal definition. It should be understood that we are assuming implicitly, whenever necessary, that the expectation exists (which is not always the case). In this regard, it is useful to note in passing that a product of two random variables \\(XY\\) has a finite mean whenever \\(X\\) and \\(Y\\) have finite variances.↩︎\nIn other words a random variable whose value is known at time \\(t\\)↩︎\nThe proof is due to Harrison and Kreps (Harrison and Kreps 1979). See also Geman, El Karoui and Rochet (Geman, El Karoui, and Rochet 1995). We omit here technical assumptions regarding the existence of expectations.↩︎",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Foundations</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html",
    "href": "Chapter_Deltas.html",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "",
    "text": "8.1 State Prices\nIn principle, once we know the state prices or stochastic discount factor we can find the value of any future cash flows and derivatives. In the binomial model in Chapter 7 we found the state prices by replicating the pay offs to Arrow securities using the stock and the bond. However in the continuous time setting, we must have a way of deriving this information. In this chapter, we will see that through dynamic trading strategies, we can replicate the payoffs of derivative securities. This allows us to find prices of digital options which essentially allow us to find state prices. We first discuss the classic Merton argument for replicating the payoff of a call option.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#replicating-portfolios",
    "href": "Chapter_Deltas.html#replicating-portfolios",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "8.2 Replicating Portfolios",
    "text": "8.2 Replicating Portfolios\nIn addition to the original Black Scholes derivation, another derivation of the Black Scholes formula is provided by Merton. He asked the question whether by trading the stock and the risk free asset whether the payoff to a European call option can be replicated.\nFor this Chapter, we assume that the stock price follows \\[ \\,\\mathrm{d}S(t) = (\\mu - q) S(t) \\,\\mathrm{d}t + \\sigma S(t) \\,\\mathrm{d}B(t) \\] where owning the stock entitles the owner to a flow of dividends \\(q S(t) \\,\\mathrm{d}t\\).\nLet \\(\\delta_t\\) be the number of shares of the stock held at time \\(t\\) and \\(\\alpha_t\\) the number of shares of an initial investment of one dollar in the risk free asset. Then the portfolio value, \\(W_t\\) is \\(W_t= \\alpha_t R(t) + \\delta_t S(t)\\) where \\(R(t)= e^{rt}\\) is the time \\(t\\) value of an initial time \\(0\\) investment of one dollar in the risk free asset. The portfolio should start with an initial value, \\(W_0\\), should not have any cash inflows or outflows and have a terminal value equal to a call payoff so the changes in value are completely dictated by the changes in the value of the assets. That is, assuming continuous trading, \\[  d W_t = \\delta_t d S(t) + \\delta_t q S(t) dt + \\alpha_t  d R(t) = \\delta_t \\left(\\mu S(t) dt  + \\sigma S(t) d B_t\\right)  + \\alpha_t r R(t) dt\\] with terminal condition \\[ W_T = \\alpha_T R(T) + \\delta_T S(T) = (S(T) - K)^{+} \\] The problem is to find \\(\\delta_t\\) and \\(\\alpha_t\\) for all times and states. If we can accomplish this, then by `no-arbitrage’ the call price must be the value of the initial investment. Assume the call price is a function of the stock price and time: \\(C(t,S(t))\\). Then by Ito’s Lemma \\[ d C(t,S(t)) = \\left(\\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (\\mu-q) S(t) + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S_t^2 \\right) dt + \\frac{\\partial C}{\\partial S} \\sigma S(t) dB_t \\] It should be apparent that we want to hold \\(\\delta = \\frac{\\partial C}{\\partial S}\\), which is called the delta of the call option. By doing so, we match the diffusion term in the change in wealth and the change in the call option. Then matching the drift terms in both expressions \\[ \\frac{\\partial C}{\\partial S} \\mu S(t) + \\alpha_t r R(t) = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (\\mu-q) S(t) + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t)^2\\] which can be solved to give \\[ \\alpha_t r R(t) =r \\left(W_t -\\frac{\\partial C}{\\partial S} S(t) \\right)  = \\frac{\\partial C}{\\partial t}-\\frac{\\partial C}{\\partial S} q S(t)  + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t^2\\] which gives the equation \\[r W_t = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S}(r-q) S(t)+\\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S(t)^2\\] with a boundary condition \\(W_T = (S(T)-K)^{+}\\). However, no-arbitrage suggests \\(W_t = C(t,S(t))\\) which gives us the partial differential equation \\[r C = \\frac{\\partial C}{\\partial t} + \\frac{\\partial C}{\\partial S} (r-q) S+\\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S^2\\] with a boundary condition \\(C(T,S_T)= (S_T - K)^{+}\\). Close observation of the right hand side we see this is the drift term of Ito expansion for \\(C\\) if we work in the risk neutral measure. The right hand side then says in the risk neutral measure, the call option earns the risk free return. This is a partial differential equation and a fairly tedious set of calcuations show the Black Scholes formula, the risk neutral expected discounted payoff is a solution (in fact it is the only positive solution).1 The risk neutral expectation can be found as in Chapter XX : \\[C= e^{-q (T-t)} S(t) N(d_1) - K e^{r(T-t)} N(d_2)\\] \\[ d_1= ~~;~~ d_2= . \\] which is the Black Scholes formula adjusted for dividends.\nHowever, there is nothing special about a call option. The same argument will apply for any European style option. The only difference is the terminal condition. This procedure allows us to replicate the payoff of any European option even for those which might not be traded. We can solve for the replication strategy for digital options by solving the PDE with a boundary condition given by the digital option payoff. The solution to the PDE with the terminal condition is given by the risk neutral expectaion of the the discounted terminal conadition (payoffs). This observation had a profound effect on practice.\n\nPortfolio Insurance\nA particularly popular example is portfolio insurance. Recall, that a protective put position buys a put and buys a share and the payoff at the expiration of the put is given by \\(\\max(K,S_T)\\). The reason for the name protective put is apparent since the position can pay off no less than \\(K\\). The cost of this insurance is the price of the put. However, if the put is not traded, we can synthetically replicate this payoff using the prodedure above assuming we can trade continuously. The basic recipe is to start with inital wealth equal to that for a protective put position: \\(W_0 = P(0,S_0)+S_0\\). The delta of the protective put position can be calcuated to be the delta of the put plus 1 which is \\(N(d_1)\\), where \\(d_1\\) is calculated at each point in time. However, in practice we cannot trade continuously. A simple discrete strategy would rebalance at intervals \\(\\Delta t\\). The strategy calculates \\(N(d_1)\\) at time 0 and holds \\(P(0,S_0)+S_0 - N(d_1)S_0\\) dollars in the risk free asset and \\(N(d_1)\\) shares of the asset. Thereafter these holdings are adjusted. The change in portfolio value over the interval \\(\\Delta t\\) is \\[\\Delta W= W_{i \\Delta t}- W_{(i-1)\\Delta t} \\] \\[\n= (P((i-1)\\Delta t,S_{(i-1)\\Delta t})+S_{(i-1)\\Delta t} - N(d_1-)S_{(i-1)\\Delta t})(R_{i\\Delta t}-R_{(i-1)\\Delta t}) + N(d1-)(S_{i\\Delta t}-S_{(i-1)\\Delta t})\n\\] where \\(N(d1-)\\) is the delta chosen at time \\((i-1)\\Delta t\\). The question is if the Black Scoles model is correct, how accurate can a discrete rebalancing scheme be? This is simulated in the following code:\n\n\nCode\nimport numpy as np\n# from bsfunctions import *\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\nfrom scipy import stats\n# incs = np.genfromtxt('incs.csv',delimiter=\",\",skip_header=1)\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate.\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return np.exp(-q*T)*S0 * -norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ndef blackscholes_delta(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate.\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if type(call) == bool:\n        if call:\n            return np.exp(-q*T)*norm.cdf(d1,0,1)\n        else:\n            return np.exp(-q*T)*norm.cdf(-d1,0,1)\n    else:\n        print(\"Not a valid value for call\")\n\n# parameters\n# number of paths\n# n = incs.shape[1]\nn = 100000\n# number of divisions\n# m = incs.shape[0]\nm = 100\n# interest rate\nr = .1\n# dividend yield\nq=0.0\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n\n# seed for random generator\nseed= 1234\n# define a random generator\nrg = np.random.RandomState(seed)\n# initialize\n\n\n# generate normal random vairables\ndt= T/m\nvol=sig*np.sqrt(dt)\nincs = rg.normal(0,vol,[m,n])\n\n\ntline = np.linspace(0,T,m+1)\n\n\nSt = np.zeros((m+1,n))\n#St1 = np.zeros((m+1,n))\n\nV_vec = np.zeros((m+1,n))\n\ndelta = np.zeros((m,n))\n\nput= blackscholes(S0,K,r, q, sig,T,call=False)\n\nincs_cumsum =  np.concatenate((np.zeros((1,n)),incs),axis=0).cumsum(axis=0)\nV_vec = np.zeros((m+1,n))\nt_mat =  np.repeat(tline.reshape((m+1,1)), n, axis=1)\ndrift_cumsum = (mu -q -0.5*sig**2) * t_mat\n\nSt = S0 * np.exp(incs_cumsum + drift_cumsum)\n\ndelta = blackscholes_delta(St[:-1,:],K,r, q, sig,T-t_mat[:-1,:])\n\nV_vec[0,:] = S0 + put\n\nfor i in range(1,m+1):\n    V_vec[i,:] = V_vec[i-1,:] + (np.exp(r*dt)-1) * (V_vec[i-1,:] - delta[i-1,:] * St[i-1,:])+ delta[i-1,:] * (St[i,:]-St[i-1,:])\n\n# Uses actual simulated changes in riskfree and stock price not the dt and dB approximations \n# plot ST versus VT\nplt.scatter(St[m,:],V_vec[m,:])\nplt.xlabel('Stock Price at Maturity')\nplt.ylabel('Value of Portfolio Insurance')\nplt.show()\n\n\n\n\n\n\n\n\n\nWith \\(m=100\\) rebalancing dates over \\(T=0.5\\) for the parameters chosen the repliacting strategy does a pretty good job. The hedging errors occur when the stock price is close to the strike price. This is not surprising since the delta changes (measured by the gamma) fastest around this point. A gamma hedge would potentially improve the performance.\nThe portfolio insurance rebalancing scheme involves sell stock and buying bonds when the stock price goes down and buying stocks and selling bonds when the stock price goes up. This can be destabilizing and was identified as a contributor to the 1987 stock market crash.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#sec-s_deltahedging",
    "href": "Chapter_Deltas.html#sec-s_deltahedging",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "8.3 Delta Hedging",
    "text": "8.3 Delta Hedging\nThe ability to create a fully hedged (risk-free) portfolio of the stock and an option is the essence of the arbitrage argument underlying the Black-Scholes formula, as we saw in Chapter 7 for the binomial model. For a call option, such a portfolio consists of delta shares of the underlying asset and a short call option, or a short position of delta shares of the underlying and a long call option. These portfolios have no instantaneous exposure to the price of the underlying. To create a perfect hedge, the portfolio must be adjusted continuously, because the delta changes when the price of the underlying changes and when time passes. In practice, any hedge will therefore be imperfect, even if the assumptions of the model are satisfied.\nWe first consider the continuous-time hedging argument. Consider a European call option with maturity \\(T\\), and let \\(C(S,t)\\) denote the value of the option at date \\(t&lt;T\\) when the stock price is \\(S\\) at date \\(t\\). Consider a portfolio that is short one call option and long \\(\\delta\\) shares of the underlying asset and that has a (short) cash position equal to \\(C-\\delta S\\). This portfolio has zero value at date \\(t\\).\nThe change in the value of the portfolio in an instant \\(\\mathrm{d} t\\) is \\[\n-\\mathrm{d} C + \\delta \\,\\mathrm{d} S + q \\delta S\\,\\mathrm{d} t+(C-\\delta S)r\\,\\mathrm{d} t\\;.\n\\qquad(8.1)\\]\nThe first term reflects the change in the value of the option, the second term is the capital gain or loss on \\(\\delta\\) shares of stock, the third term is the dividends received on \\(\\delta\\) shares of stock, and the fourth term is the interest expense on the short cash position.\nOn the other hand, we know from Ito’s formula that\n\\[\n\\mathrm{d} C = \\frac{\\partial C}{\\partial S}\\,\\mathrm{d} S + \\frac{\\partial C}{\\partial t}\\,\\mathrm{d} t + \\frac{1}{2}\\frac{\\partial^2C}{\\partial S^2} (\\mathrm{d} S)^2  \n\\] \\[\n= \\delta \\,\\mathrm{d} S + \\Theta \\,\\mathrm{d} t + \\frac{1}{2}\\Gamma \\sigma^2S^2\\,\\mathrm{d} t\\;.\n\\qquad(8.2)\\] where we call \\(\\Theta = \\frac{\\partial C}{\\partial t}\\) the time decay and \\(\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}\\) is the Gamma or convexity.\nSubstituting Equation 8.2 into Equation 8.1 shows that the change in the value of the portfolio is \\[\n-\\Theta \\,\\mathrm{d} t - \\frac{1}{2}\\Gamma \\sigma^2S^2\\,\\mathrm{d} t+ q \\delta S\\,\\mathrm{d} t+(C-\\delta S)r\\,\\mathrm{d} t\\;.\n\\qquad(8.3)\\]\nSeveral aspects of this are noteworthy. First, as noted earlier, the delta hedge (being long \\(\\delta\\) shares of the underlying) eliminates the exposure to changes in the price of the underlying—there is no \\(\\mathrm{d} S\\) term in Equation 10.6. Second, \\(\\Theta\\) will be negative, because it captures the time decay in the option value; being short the option means the portfolio will profit from time decay at rate \\(-\\Theta\\). Third, this portfolio is short gamma. We can also say it is short convexity, the term convexity referring to the convex shape of the option value as a function of the price of the underlying, which translates mathematically to a positive second derivative (gamma). The volatility in the stock makes convexity valuable, and a portfolio that is short convexity will suffer losses. Finally, the portfolio is earning dividends but paying interest.\nIt is straightforward to check, from the definitions of \\(\\Theta\\), \\(\\Gamma\\) and \\(\\delta\\), that the sum of the terms in Equation 10.6 is zero. The time decay in the option value and dividends received on the shares of the underlying exactly offset the losses due to convexity and interest. Therefore, the delta hedge is a perfect hedge. The portfolio, which has a zero cost, neither earns nor loses money. This is true not only on average but for every possible change in the stock price.\nTo see how well this works with only discrete adjustments to the hedge, one can simulate the changes in \\(S\\) over time and sum the gains and losses over discrete rebalancing periods. One should input the actual (not risk-neutral) expected rate of return on the asset to compute the actual distribution of gains and losses.2",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#sec-s_gammahedging",
    "href": "Chapter_Deltas.html#sec-s_gammahedging",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "8.4 Gamma Hedging",
    "text": "8.4 Gamma Hedging\nTo attempt to improve the performance of a discretely rebalanced delta hedge, one can use another option to create a portfolio that is both delta and gamma neutral. Being delta neutral means hedged as in the previous section—the portfolio value has no exposure to changes in the underlying asset price. In other words, it means that the derivative of the portfolio value with respect to the price of the underlying (the portfolio delta) is zero. Being gamma neutral means that the delta of the portfolio has no exposure to changes in the underlying price, which is equivalent to the second derivative of the portfolio value with respect to the price of the underlying (the portfolio gamma) being zero. If the delta truly did not change, then there would be no need to rebalance continuously, and hence no hedging error introduced by only adjusting the portfolio at discrete times rather than continuously. However, there is certainly no guarantee that a discretely-rebalanced delta/gamma hedge will perform better than a discretely rebalanced delta hedge. \nA delta/gamma hedge can be constructed as follows. Suppose we have written (shorted) a call option and we want to hedge both the delta and gamma using the underlying asset and another option, for example, another call option with a different strike. In practice, one would want to use a liquid option for this purpose, which typically means that the strike of the option will be near the current value of the underlying (i.e., the option used to hedge would be approximately at the money).\nLet \\(\\delta\\) and \\(\\Gamma\\) denote the delta and gamma of the written option and let \\(\\delta'\\) and \\(\\Gamma'\\) denote the delta and gamma of the option used to hedge. Consider holding \\(a\\) of shares of the stock and \\(b\\) units of the option used to hedge in conjunction with the short option. The delta of the stock is one (\\(\\mathrm{d} S/\\mathrm{d} S = 1\\)), so to obtain a zero portfolio delta we need\n\\[\n0 = - \\delta + a + b\\delta'.\n\\qquad(8.4)\\]\nThe gamma of the stock is zero (\\(\\mathrm{d}^2 S/\\mathrm{d} S^2 = d\\,1/\\mathrm{d} S = 0\\)), so to obtain a zero portfolio gamma we need\n\\[\n0 = - \\Gamma + b\\Gamma'\\;.\n\\qquad(8.5)\\]\nEquation Equation 10.8 shows that we should hold enough of the second option to neutralize the gamma of the option we have shorted; i.e., \\[\\\nb= \\frac{\\Gamma}{\\Gamma'}\n\\] Equation Equation 10.7 shows that we should use the stock to delta hedge the portfolio of options; i.e., \\[\na=\\delta - \\frac{\\Gamma}{\\Gamma'}\\delta'\\;.\n\\]\n\nDiscretely-Rebalanced Delta Hedges\nTo compute the real-world distribution of gains and losses from a discretely-rebalanced delta hedge, we input the expected rate of return \\(\\mu\\). We consider adjusting the hedge at dates \\(0=t_0&lt;t_1&lt;\\cdots&lt;t_N=T\\), with \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\). The changes in the natural logarithm of the stock price between successive dates \\(t_{i-1}\\) and \\(t_i\\) are simulated as \\[\\Delta \\log S = \\left(\\mu-q-\\frac{1}{2}\\sigma^2\\right)\\,\\Delta t + \\sigma\\,\\Delta B\\; ,\\] where \\(\\Delta B\\) is normally distributed with mean zero and variance \\(\\Delta t\\). The random variables \\(\\Delta B\\) are simulated as standard normals multiplied by \\(\\sqrt{\\Delta t}\\). We begin with the portfolio that is short a call, long \\(\\delta\\) shares of the underlying, and short \\(\\delta S-C\\) in cash. After the stock price changes, say from \\(S\\) to \\(S'\\), we compute the new delta \\(\\delta'\\). The cash flow from adjusting the hedge is \\((\\delta-\\delta')S'\\). Accumulation (or payment) of interest on the cash position is captured by the factor \\(e^{r\\Delta t}\\). Continuous payment of dividends is modelled similarly: the dividends earned during the period \\(\\Delta t\\) is taken to be \\(\\delta S\\left(e^{q\\Delta t}-1\\right)\\). The cash position is adjusted due to interest, dividends, and the cash flow from adjusting the hedge. At date \\(T\\), the value of the portfolio is the cash position less the intrinsic value of the option.\nTo describe the distribution of gains and losses, we compute percentiles of the distribution. You should see that the hedge becomes more nearly perfect as the number of periods \\(N\\) is increased. Note that this is true regardless of the \\(\\mu\\) that is input, which reaffirms the point that option values and hedges do not depend on the expected rate of return of the underlying. The percentile is calculated taking into account the dicreteness of the sample.3\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\nimport scipy.optimize as optimize\n\ndef simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, pct):\n    \"\"\"\n    Inputs:\n    S0 = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    mu = expected rate of return\n    N = number of time periods\n    M = number of simulations\n    pct = percentile to be returned\n    \"\"\"\n    dt = T / N\n    SigSqrdt = sigma * np.sqrt(dt)\n    drift = (mu - q - 0.5 * sigma ** 2) * dt\n    Comp = np.exp(r * dt)\n    Div = np.exp(q * dt) - 1\n    LogS0 = np.log(S0)\n   # Call0 = black_scholes_call(S0, K, r, sigma, q, T)\n    Call0 = blackscholes(S0,K,r, q, sigma,T)\n    Delta0 = blackscholes_delta(S0,K,r, q, sigma,T)\n   # Delta0 = black_scholes_call_delta(S0, K, r, sigma, q, T)\n    Cash0 = Call0 - Delta0 * S0\n    Profit = np.zeros(M)\n\n    for i in range(M):\n        LogS = LogS0\n        Cash = Cash0\n        S = S0\n        Delta = Delta0\n\n        for j in range(1, N):\n            LogS += drift + SigSqrdt * np.random.randn()\n            NewS = np.exp(LogS)\n            NewDelta = blackscholes_delta(NewS, K, r, q, sigma, T - j * dt)\n            Cash = Comp * Cash + Delta * S * Div - (NewDelta - Delta) * NewS\n            S = NewS\n            Delta = NewDelta\n\n        LogS += drift + SigSqrdt * np.random.randn()\n        NewS = np.exp(LogS)\n        HedgeValue = Comp * Cash + Delta * S * Div + Delta * NewS\n        Profit[i] = HedgeValue - max(NewS - K, 0)\n\n    return np.percentile(Profit, pct * 100)\n\n# Example usage (you can replace these with input values)\nS = 100  # Initial stock price\nK = 100  # Strike price\nr = 0.05  # Risk-free rate\nsigma = 0.2  # Volatility\nq = 0.02  # Dividend yield\nT = 1  # Time to maturity in years\n# CallPrice = 10  # Call price for implied volatility calculation\n\n# Simulate delta hedging profit\nS0 = 100  # Initial stock price\nmu = 0.1  # Expected rate of return\nM = 1000  # Number of simulations\nN = 252  # Number of time periods\npct = 0.95  # Percentile to be returned\n\ndelta_hedge_profit = simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, pct)\nprint(f\"Delta Hedge Profit (95th percentile): {delta_hedge_profit}\")\n\n\nDelta Hedge Profit (95th percentile): 0.7532458224317945\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nThe basic premise which underlies our analysis is that we can use traded assets to replicate payoffs in any state time contingency. On the surface this would seem to be a stretch. For example, it seems implausible that we could find the value of a security which pays off in the event Martians land on earth. Fortuneately, we are only concerned with relevant events. For example, suppose we model the stock price using two sources of uncwertainty governed by two independent Brownian motions \\(B_{1,t}\\) and \\(B_{2,t}\\) and write \\[ \\,\\mathrm{d}S(t) = \\mu S(t) \\,\\mathrm{d}t + \\sigma_1 S(t) \\,\\mathrm{d}B_{1,t} + \\sigma_2 S(t) \\,\\mathrm{d}B_{2,t} . \\] Then defining \\(\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2}\\) and \\(B_t = \\frac{\\sigma_1}{\\sigma} B_{1,t} + \\frac{\\sigma_2}{\\sigma} B_{2,t}\\), \\(B_t\\) is a Brownian motion by Levy’s theorem and \\[ \\,\\mathrm{d}S(t) = \\mu S(t) \\,\\mathrm{d}t + \\sigma S(t) \\,\\mathrm{d}B_t .\\] We can value options on the stock. However, we can not find state prices which depend on \\(B_{1,t}\\) and \\(B_{2,t}\\) by themselves; this would require more securities. Later in Chapter XX we will study stochastic volatility models where \\(\\sigma\\) depends on a differnt Brownian motion. In this setting, we need more assets to dynamically replicate pay offs. However, we can overcome this difficulty by either trading another asset or choosing the risk neutral measure to match traded options prices.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#exercises",
    "href": "Chapter_Deltas.html#exercises",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "8.5 Exercises",
    "text": "8.5 Exercises\n\nExercise 8.1 Create Python code which inputs \\(K\\), \\(r\\), \\(\\sigma\\), \\(q\\) and \\(T\\). Compute the delta of a call option for stock prices \\(S = .01K\\), \\(.02K\\), , \\(1.99K\\), \\(2K\\) (i.e., \\(S = iK/100\\) for \\(i=1, \\ldots 200\\)) and plot the delta against the stock price.\n\n\nExercise 8.2 The delta of a digital option that pays $1 when \\(S(T)&gt;K\\) is \\[\\frac{\\mathrm{e}^{-rT}\\mathrm{n}(d_2)}{\\sigma S\\sqrt{T}}\\; .\\] Repeat the previous problem for the delta of this digital. Given that in reality it is costly to trade (due to commissions, the bid-ask spread and possible adverse price impacts for large trades), do you see any problems with delta hedging a short digital near maturity if it is close to being at the money?\n\n\nExercise 8.3 Modify the Python code for replicating portfolio insurance to simulate a discrete replication of a digital option using the delta in the previous problem. Run the code for \\(10,20,100,1000\\) rebalancing dates. When does the strategy do a good job and when does it fail?\n\n\nExercise 8.4 Repeat Exercise 8.1 for the gamma of a call option.\n\n\n\nExercise 8.5 Consider delta and gamma hedging a short call option, using the underlying and a put with the same strike and maturity as the call. Calculate the position in the underlying and the put that you should take, using the analysis in Section 8.4. Will you ever need to adjust this hedge? Relate your result to put-call parity.\n\n\nExercise 8.6 The delta of a share digital that pays one share when \\(S(T)&gt;K\\) is \\[\\mathrm{e}^{-qT}\\mathrm{N}(d_1) + \\frac{\\mathrm{e}^{-qT}\\mathrm{n}(d_1)}{\\sigma \\sqrt{T}}\\; .\\] Repeat Exercise 8.1 for the delta of this share digital.\n\n\nExercise 8.7  \nModify the function Simulated_Delta_Hedge_Profit to compute percentiles of gains and losses for an investor who writes a call option and constructs a delta and gamma hedge using the underlying asset and another call option. Include the exercise price of the call option used to hedge as an input, and assume it has the same time to maturity as the option that is written. Hint: In each period , the updated cash position can be calculated as\nwhere denotes the number of shares of the stock held, denotes the number of units held of the option that is used for hedging, and denotes the price of the option used for hedging (computed from the Black-Scholes formula each period). This expression embodies the interest earned (paid) on the cash position, the dividends received on the shares of stock and the cash inflows (outflows) from adjusting the hedge. At the final date , the value of the hedge is\nand the value of the overall portfolio is the value of the hedge less\nwhere denotes the strike price of the option used to hedge and denotes the strike of the option that was written.\n\n\nExercise 8.8 Suppose an investor invests in a portfolio with price \\(S\\) and constant dividend yield \\(q\\). Assume the investor is charged a constant expense ratio \\(\\alpha\\) (which acts as a negative dividend) and at date \\(T\\) receives either his portfolio value or his initial investment, whichever is higher. This is similar to a popular type of variable annuity. Letting \\(D\\) denote the number of dollars invested in the contract, the contract pays \\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}\\right)\n\\qquad(8.6)\\] at date \\(T\\).\nWe can rearrange the expression Equation 10.9 as\n\\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}\\right) = D + \\max\\left(0, \\frac{D\\mathrm{e}^{(q-\\alpha)T}S(T)}{S(0)}-D\\right)\n\\] \\[\n= D + \\mathrm{e}^{-\\alpha T}D\\max\\left(0,\\frac{\\mathrm{e}^{qT}S(T)}{S(0)}-\\mathrm{e}^{\\alpha T}\\right)\\;.\n\\qquad(8.7)\\]\nThus, the contract payoff is equivalent to the amount invested plus a certain number of call options written on the gross holding period return \\(\\mathrm{e}^{qT}S(T)/S(0)\\). Note that \\(Z(t) = \\mathrm{e}^{qt}S(t)/S(0)\\) is the date–\\(t\\) value of the portfolio that starts with \\(1/S(0)\\) units of the asset (i.e., with a $1 investment) and reinvests dividends. Thus, the call options are call options on a non-dividend paying portfolio with the same volatility as \\(S\\) and initial price of $1. This implies that the date–0 value of the contract to the investor is \\(\\mathrm{e}^{-rT}D\\) plus\n\nCreate a Python function to compute the fair expense ratio; i.e., find \\(\\alpha\\) such that the date–0 value of the contract is equal to \\(D\\). Hint: Use scipy minimize or brute force iteration. You can use \\(\\alpha=0\\) as a lower bound. Because the value of the contract is decreasing as \\(\\alpha\\) increases, you can find an upper bound by iterating until the value of the contract is less than \\(D\\).\nHow does the fair expense ratio vary with the maturity \\(T\\)? Why?",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_Deltas.html#footnotes",
    "href": "Chapter_Deltas.html#footnotes",
    "title": "8  Delta Hedges, Replication, and PDEs",
    "section": "",
    "text": "Essentially, this can be called the Feynman Kac solution to the PDE.↩︎\nIt is useful to recall risk neutral probabilities really represent prices, not actual probability of events.↩︎\nIf numsims = 11 and pct =0.1, the percentile function returns the second lowest element in the series. The logic is that 10% of the numbers, excluding the number returned, are below the number returned—i.e., 1 out of the other 10 are below—and 90% of the others are above. In particular, if pct = 0.5, the percentile function returns the median. When necessary, the function interpolates; for example, if numsims = 10 and pct=0.1, then the number returned is an interpolation between the lowest and second lowest numbers.↩︎",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Delta Hedges, Replication, and PDEs</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html",
    "href": "Chapter_DigitalsMeasures.html",
    "title": "9  Digitals and Measures",
    "section": "",
    "text": "9.1 Digitals\nThis chapter studies the building blocks of calls and puts – digitals and share digitals – and values them using Ito’s formula and measure changes. Let \\(S\\) denote a dividend-reinvested asset price. We call the date at which we are valuing securities date \\(0\\).\nA digital (or binary) option pays a fixed amount in a certain event and zero otherwise. Consider a digital that pays $1 at some date \\(T\\) if \\(S_T&gt;K\\), where \\(K\\) is a number that is fixed by the contract. This means that the digital pays \\(x\\) dollars at date \\(T\\) where \\(x\\) is defined as \\[\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\qquad(9.1)\\]\nWhat is the digital worth at date \\(0\\)? Using Equation 7.29, the value of the digital at date \\(0\\) is \\(\\mathrm{e}^{-rT}\\\\E^R[x]\\). Note that \\[\\begin{align*}\n\\mathbb{E}^R[x] \\;&=\\; 1 \\times \\text{prob}^R(x=1)\\; + \\;0 \\times \\text{prob}^R(x\\!\\!=\\!\\!0) \\\\\n\\;&=\\; \\text{prob}^R(x=1)\\\\\n\\;&=\\; \\text{prob}^R\\big(S_T &gt; K\\big)\\;.\n\\end{align*}\\] So, the value of the digital is the risk-neutral probability of the digital finishing in the money discounted at the risk-free rate.\nConsider now a different digital that pays when the underlying asset price is less than \\(K\\) at date \\(T\\). So, it pays \\(y\\) dollars at date \\(T\\) where \\[\\begin{equation*}\ny =  \\begin{cases} 1 & \\text{if $S_T&lt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] Using Equation 7.29 again, the value of this digital at date \\(0\\) is \\[\\mathrm{e}^{-rT}\\\\E^R[y] = \\mathrm{e}^{-rT}\\text{prob}^R(y=1) = \\mathrm{e}^{-rT}\\text{prob}^R\\big(S_T&lt;K\\big)\\; .\\] Again, this is the risk-neutral probability of the digital finishing in the money discounted at the risk-free rate.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#share-digitals",
    "href": "Chapter_DigitalsMeasures.html#share-digitals",
    "title": "9  Digitals and Measures",
    "section": "9.2 Share Digitals",
    "text": "9.2 Share Digitals\nNow consider a contract that pays a share of the underlying asset at date \\(T\\) when \\(S_T \\geq K\\). The value of this contract at date \\(T\\) is \\(xS_T\\) where \\(x\\) is defined in Equation 9.1. Our fundamental pricing formula (Equation 7.28) tells us that the value of the share digital at date \\(0\\) is \\[Z_0 E^Z \\left[\\frac{xS_T}{Z_T}\\right]\\; ,\\] for any non-dividend-paying asset price \\(Z\\). We want to choose the numeraire to simplify the calculation of the expectation. We get the most simplification by setting \\(Z=S\\). The value of the share digital at date \\(0\\) is \\[S_0 E^S \\left[x\\right] = S_0\\text{prob}^S(x=1) = S_0\\text{prob}^S\\big(S_T&gt;K\\big)\\,.\\] Thus, to value the share digital, we need to calculate the probability of it finishing in the money when we use \\(S\\) as the numeraire.\nWe can also consider a digital that pays 1 share of the underlying asset when \\(S_T&lt;K\\). By the same reasoning, the value of this share digital at date \\(0\\) is \\[S_0\\text{prob}^S\\big(S_T&lt;K\\big)\\,.\\] To finish the valuation of either a digital or a share digital, we need to know the distribution of \\(S_T\\) under different probability measures.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#changing-measures-changes-drifts",
    "href": "Chapter_DigitalsMeasures.html#changing-measures-changes-drifts",
    "title": "9  Digitals and Measures",
    "section": "9.3 Changing Measures Changes Drifts",
    "text": "9.3 Changing Measures Changes Drifts\nWhen we change probability measures, we cannot expect a process \\(B\\) that was a Brownian motion to remain a Brownian motion. The expected change in a Brownian motion must always be zero, but when we change probabilities, the expected change of \\(B\\) is likely to become nonzero. However, the Brownian motion \\(B\\) will still be an Ito process under the new probability measure. In fact, every Ito process under one probability measure is an Ito process under the new probability measure, and the diffusion coefficient of the Ito process is unaffected by the change in probabilities.1 Changing probabilities only changes the drift of an Ito process.\nThis should not be surprising. Section 4.3 explains that a Brownian motion \\(B\\) can be defined as a continuous martingale with paths that jiggle in such a way that the quadratic variation over any interval \\([0,T]\\) is equal to \\(T\\). Changing the probabilities will change the probabilities of the various paths (so it may affect the expected change in \\(B\\)) but it will not affect how each path jiggles. So, under the new probability measure, \\(B\\) should still be like a Brownian motion but it may have a nonzero drift. If we consider a general Ito process, the reasoning is the same. The diffusion coefficient \\(\\sigma\\) determines how much each path jiggles, and this is unaffected by changing the probability measure. Furthermore, instantaneous covariances—the \\((\\,\\mathrm{d}X)(\\,\\mathrm{d}Y)\\) terms—between Ito processes are unaffected by changing the probability measure. Only drifts are affected. We now calculate the changes in drifts when we switch to the risk-neutral probability or use \\(S\\) as the numeraire.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#risk-neutral-probability",
    "href": "Chapter_DigitalsMeasures.html#risk-neutral-probability",
    "title": "9  Digitals and Measures",
    "section": "9.4 Risk-Neutral Probability",
    "text": "9.4 Risk-Neutral Probability\nAssume \\[\\frac{\\,\\mathrm{d}S}{S} = \\mu\\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}B \\qquad(9.2)\\] where \\(B\\) is a Brownian motion and \\(\\mu\\) and \\(\\sigma\\) can be quite general stochastic processes. Also, the instantaneous risk-free rate \\(r\\) can be a quite general stochastic process, and we set \\[R_t = \\mathrm{e}^{\\int_0^t r_s\\,\\mathrm{d}s}\\] as before.\nThe Key Principle \\(\\ref{principle-fundamental}\\) tells us that, in the absence of arbitrage opportunities, there is a probability measure (called the risk-neutral probability) with respect to which \\(S/R\\) is a martingale.\nSetting \\(Y=S/R\\), we have, from Calculation Rule \\(\\ref{rule:compounding}\\) that \\[\\frac{\\,\\mathrm{d}Y}{Y} = \\frac{\\,\\mathrm{d}S}{S} - r\\,\\mathrm{d}t\\,.\\] Because \\(Y\\) is a martingale under the risk-neutral probability, it cannot have a drift under that probability measure, so the drift of \\(S\\) must be the risk-free rate under that probability measure. So, we have shown the following.\n\n\n\n\n\n\nKey Principle\n\n\n\nThe expected rate of return of any asset under the risk-neutral probability must be the risk-free rate.\n\n\nBecause the change of measure does not affect the volatility, we also have:\n\n\n\n\n\n\nCalculation Rule\n\n\n\nIf \\(S\\) is a dividend-reinvested asset price satisfying Equation 9.2, then \\[\n\\frac{\\,\\mathrm{d}S}{S} =r\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B^*\\;,\n\\qquad(9.3)\\] where \\(B^*\\) is a Brownian motion under the risk-neutral probability.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#underlying-as-the-numeraire",
    "href": "Chapter_DigitalsMeasures.html#underlying-as-the-numeraire",
    "title": "9  Digitals and Measures",
    "section": "9.5 Underlying as the Numeraire",
    "text": "9.5 Underlying as the Numeraire\nWhen we change measures using \\(S\\) is the numeraire, the process \\(Z_t\\) defined as \\[Z_t = \\frac{R_t}{S_t} = \\frac{\\exp\\left(\\int_0^t r_s\\,\\mathrm{d}s\\right)}{S_t}\\] is a martingale. Using the rule for ratios, we have \\[\\frac{\\,\\mathrm{d}Z}{Z} =r\\,\\mathrm{d}t - \\frac{\\,\\mathrm{d}S}{S} + \\left(\\frac{\\,\\mathrm{d}S}{S}\\right)^2 = (r + \\sigma^2)\\,\\mathrm{d}t - \\frac{\\,\\mathrm{d}S}{S}\\; .\\] Because the drift of \\(\\,\\mathrm{d}Z/Z\\) must be zero, this implies that the drift of \\(\\,\\mathrm{d}S/\nS\\) is \\((r + \\sigma^2_s)\\,\\mathrm{d}t\\). We conclude that:\n\n\n\n\n\n\n9.6\n\n\n\nIf \\(S\\) is a dividend-reinvested asset price satisfying Equation 9.2, then \\[\n\\frac{\\,\\mathrm{d}S}{S} = (r+ \\sigma^2_s)\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B^*\\;,\n\\qquad(9.4)\\] where \\(B^*\\) is a Brownian motion when \\(S\\) is the numeraire.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#constant-parameters-and-the-values-of-digitals",
    "href": "Chapter_DigitalsMeasures.html#constant-parameters-and-the-values-of-digitals",
    "title": "9  Digitals and Measures",
    "section": "9.7 Constant Parameters and the Values of Digitals",
    "text": "9.7 Constant Parameters and the Values of Digitals\nNow assume that \\(r\\) and \\(\\sigma\\) are constants. We continue to allow \\(\\mu\\) to be a quite general stochastic process. We want to calculate the risk-neutral probabilities of \\(S_T&gt;K\\) and \\(S_T&lt;K\\). With the assumption that \\(r\\) and \\(\\sigma\\) are constants, Calculation Rule \\(\\ref{rule:riskneutral}\\) implies that \\(S\\) is a geometric Brownian motion under the risk-neutral probability.\nNow using the formulas Equation 6.11–Equation 6.12, with \\(\\alpha = r-\\sigma^2/2\\), we have \\(\\text{prob}^R\\big(S_T &gt; K\\big) = \\mathrm{N}(d_2)\\) where \\[\nd_2 = \\frac{\\log S_0 - \\log K +\\left(r-\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(9.5)\\]\nThe notation \\(d_2\\) is standard notation from the Black-Scholes formula (?sec-c_blackscholes), and we use it—rather than a simple \\(d\\)—to distinguish the number Equation 9.5 from a similar number—to be called \\(d_1\\) of course—that we will see in the next section.\nWe conclude:\n\n\n\n\n\n\n9.8\n\n\n\nIf the interest rate and volatility are constant, then the value of a digital option that pays $1 when \\(S_T&gt;K\\) is \\(\\mathrm{e}^{-rT}\\mathrm{N}(d_2)\\), where \\(d_2\\) is defined in Equation 9.5. The value of a digital option that pays $1 when \\(S_T&lt;K\\) is \\(\\mathrm{e}^{-rT}\\mathrm{N}(-d_2)\\).",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#constant-parameters-and-the-values-of-share-digitals",
    "href": "Chapter_DigitalsMeasures.html#constant-parameters-and-the-values-of-share-digitals",
    "title": "9  Digitals and Measures",
    "section": "9.9 Constant Parameters and the Values of Share Digitals",
    "text": "9.9 Constant Parameters and the Values of Share Digitals\nContinue to assume that \\(r\\) and \\(\\sigma\\) are constants. Under these assumptions, Calculation Rule \\(\\ref{rule:underlying_numeraire}\\) implies that \\(S\\) is a geometric Brownian motion with drift \\(r+\\sigma^2\\) when \\(S\\) is used as the numeraire. Using the formulas Equation 6.11–Equation 6.12, with \\(\\alpha = r + \\sigma^2/2\\), we obtain \\(\\text{prob}^S\\big(S_T &gt; K\\big) = \\mathrm{N}(d_1)\\) where \\[\nd_1 = \\frac{\\log S_0 - \\log K+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}= d_2 + \\sigma\\sqrt{T}\\;.\n\\qquad(9.6)\\]\n\n\n\n\n\n\n9.10\n\n\n\nIf the interest rate and volatility are constant, then the value of a security that pays \\(S_T\\) when \\(S_T&gt;K\\) and zero otherwise is \\(S_0\\mathrm{N}(d_1)\\), where \\(d_1\\) is defined in Equation 9.6, and the value of a security that pays \\(S_T\\) when \\(S_T &lt; K\\) and zero otherwise is \\(S_0\\mathrm{N}(-d_1)\\).",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#another-risky-asset-as-the-numeraire",
    "href": "Chapter_DigitalsMeasures.html#another-risky-asset-as-the-numeraire",
    "title": "9  Digitals and Measures",
    "section": "9.11 Another Risky Asset as the Numeraire",
    "text": "9.11 Another Risky Asset as the Numeraire\nWe have now studied the dynamics of the dividend-reinvested asset price \\(S\\) when the risk-free asset and \\(S\\) are used as the numeraires. In subsequent chapters, we will need to know the dynamics of \\(S\\) when another risky asset is used as the numeraire.\nSuppose \\(Y\\) is another dividend-reinvested asset price and \\[\\frac{\\,\\mathrm{d}Y}{Y} = \\theta\\,\\mathrm{d}t + \\phi \\,\\mathrm{d}W \\qquad(9.7)\\]\nwhere \\(W\\) is a standard Brownian motion. Let \\(\\rho\\) denote the correlation process of \\(B\\) and \\(W\\). We allow \\(r\\), \\(\\mu\\), \\(\\sigma\\), \\(\\theta\\), \\(\\phi\\), and \\(\\rho\\) to be quite general stochastic processes. Using \\(Y\\) as the numeraire, \\(Z_1\\) defined as \\(R/Y\\) and \\(Z_2\\) defined as \\(S/Y\\) are martingales. Applying the rule for ratios, we have \\[\\frac{\\,\\mathrm{d}Z_1}{Z_1} = r\\,\\mathrm{d}t - \\frac{\\,\\mathrm{d}Y}{Y} +  \\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)^2\\,.\\] Setting the drift to be zero tells us that the drift of \\(\\,\\mathrm{d}Y/Y\\) is \\(r + \\phi^2\\). The rule for ratios also gives \\[\\frac{\\,\\mathrm{d}Z_2}{Z_2} = \\frac{\\,\\mathrm{d}S}{S} - \\frac{\\,\\mathrm{d}Y}{Y}  - \\left(\\frac{\\,\\mathrm{d}S}{S}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right) + \\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)^2 \\,.\\] Setting the drift to be zero and using the fact that the drift of \\(\\,\\mathrm{d}Y/Y\\) is \\(r+\\phi^2\\), we conclude that the drift of \\(\\,\\mathrm{d}S/S\\) is \\(r + \\sigma\\phi\\rho\\). This produces the following:\n\n\n\n\n\n\n9.12\n\n\n\nIf \\(S\\) is a dividend-reinvested asset price satisfying Equation 9.2 and \\(Y\\) is a dividend-reinvested asset price satisfying Equation 9.7, then\n\\[\n\\frac{\\,\\mathrm{d}S}{S} = (r+ \\sigma\\phi\\rho)\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B^*\\;,\n\\qquad(9.8)\\] where \\(B^*\\) denotes a Brownian motion under the probability measure corresponding to \\(Y\\) being the numeraire.\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\nIt is natural to ask at this point: What is the Brownian motion \\(B^*\\) and where did it come from? We have argued that once we know the drift, and the fact that the volatility does not change, we can immediately write down, for example, \\[\\frac{\\,\\mathrm{d}S}{S} = (r-q)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B^*\\] for a Brownian motion \\(B^*\\) under the risk-neutral probability. To answer this question, we will give here the definition of \\(B^*\\) under the risk-neutral probability. The definition shows that we are justified in writing down Equation 9.3–Equation 9.8, but we will not repeat the definition each time we make a statement of this sort.\nWe showed that \\(Z\\) is a martingale under the risk-neutral probability, where \\(Z\\) satisfies \\[\n\\frac{\\,\\mathrm{d}Z}{Z} = (q-r)\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}S}{S} = (q-r+\\mu)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;.\n\\qquad(9.9)\\]\nDefine \\(B^*_0 = 0\\) and \\[\n\\,\\mathrm{d}B^* = \\left(\\frac{q-r+\\mu}{\\sigma}\\right)\\,\\mathrm{d}t + \\,\\mathrm{d}B\\;.\n\\qquad(9.10)\\]\nThen \\[\\,\\mathrm{d}B^* = \\frac{1}{\\sigma}\\left(\\frac{\\,\\mathrm{d}Z}{Z}\\right)\\] and hence is a continuous martingale under the risk-neutral probability. We can compute its quadratic variation as \\[(\\,\\mathrm{d}B^*)^2 = \\left(\\frac{q-r+\\mu}{\\sigma}\\right)^2(\\,\\mathrm{d}t)^2 + 2\\left(\\frac{q-r+\\mu}{\\sigma}\\right)(\\,\\mathrm{d}t)(\\,\\mathrm{d}B) + (\\,\\mathrm{d}B)^2 = \\,\\mathrm{d}t\\; .\\] Therefore, by Levy’s theorem (Section 4.3), \\(B^*\\) is a Brownian motion under the risk-neutral probability. From Equation 9.9 and Equation 9.10 we have \\[(q-r)\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}S}{S} = \\sigma\\,\\mathrm{d}B^* \\quad \\Longleftrightarrow \\quad \\frac{\\,\\mathrm{d}S}{S} = (r-q)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B^*\\;,\\] as in Equation 9.3.",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_DigitalsMeasures.html#footnotes",
    "href": "Chapter_DigitalsMeasures.html#footnotes",
    "title": "9  Digitals and Measures",
    "section": "",
    "text": "To be a little more precise, this is true provided sets of states of the world having zero probability continue to have zero probability when the probabilities are changed. Because of the way we change probability measures when we change numeraires (cf. Equation 7.23) this will always be true for us.↩︎",
    "crumbs": [
      "Part III: Arbitrage Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Digitals and Measures</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html",
    "href": "Chapter_BlackScholes.html",
    "title": "10  Black-Scholes",
    "section": "",
    "text": "10.1 European Call and Put Values\nThis chapter explains the very important Black-Scholes formulas for the values of European calls and puts. Options are written on asset prices, not dividend-reinvested asset prices, with which we have been primarily dealing to this point. U.S. companies pay dividends quarterly (if they pay dividends). If the option will mature before the next dividend is paid (to be more precise, if it matures before the next ex-dividend date, which is when the stock begins trading without right to the subsequent dividend) then dividends are not an issue. We discuss a model suitable for valuing options that mature after one or more upcoming dividend payments in Chapter 11. In this chapter, we make a simplifying assumption. We assume that dividends are paid continuously at a rate proportional to the underlying asset price. the Black-Scholes model suitable for quarterly dividendsThe Black-Scholes assumptions are that the underlying asset pays a constant dividend yield \\(q\\) and has price \\(S\\) satisfying \\[\n\\frac{\\,\\mathrm{d}S}{S} = \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\n\\qquad(10.1)\\]\nfor a Brownian motion B. Here \\(\\sigma\\) is assumed to be constant (though we will allow it to vary in a non-random way at the end of the chapter) and \\(\\mu\\) can be a quite general random process. It is also assumed that there is a constant continuously-compounded risk-free rate \\(r\\).\nUnder these assumptions, we complete the discussion of ?sec-s:introoptions to derive option pricing formulas. Recall that, to price a European call option, all that remains to be done is to calculate the probabilities of the option finishing in the money when we use the risk-free asset and the underlying asset as numeraires. We do this using the results of ?sec-s:girsanov.\nIn ?sec-s:girsanov—see Equation 9.3—we learned that under the Black-Scholes assumption Equation 10.1 we have \\[\\frac{\\,\\mathrm{d}S}{S} =( r-q)\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B^*\\; ,\\] where \\(B^*\\) is a Brownian motion under the risk-neutral probability.1 on the volatility coefficients and on \\(B\\) and \\(B^*\\) to distinguish the Brownian motion driving \\(S\\) from the Brownian motion driving \\(Y\\) and to distinguish their volatilities are not needed here. In Chapter 6, we observed that this is equivalent to \\[\\,\\mathrm{d}\\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B^*\\; .\\]\nA European call option pays \\(S_T-K\\) at date \\(T\\) if \\(S_T&gt;K\\) and 0 otherwise. Again letting \\[\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;,\n\\end{cases}\n\\end{equation*}\\] the payoff of the call can be written as \\(xS_T-xK\\). This is equivalent to one share digital minus \\(K\\) digitals, with the digitals paying in the event that \\(S_T&gt;K\\). The share digital is worth \\(\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)\\) at date \\(0\\) and each digital is worth \\(\\mathrm{e}^{-rT}\\mathrm{N}(d_2)\\). Note that Equation 9.5 and ?eq-sharedigital_d1 for \\(d_1\\) and \\(d_2\\) imply \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\). Therefore, combining the results of the previous two sections yields the Black-Scholes formula:\nA European put option pays \\(K-S_T\\) at date \\(T\\) if \\(S_T&lt;K\\) and 0 otherwise. As before, let \\[\\begin{equation*}\ny =  \\begin{cases} 1 & \\text{if $S_T&lt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] The payoff of the put option is \\(yK-yS_T\\). This is equivalent to \\(K\\) digitals minus one share digital, all of the digitals paying when \\(S_T&lt;K\\). Thus, we have:\nThe values of the European put and call satisfy put-call parity, and we can also find one from the other by2 \\[\n\\mathrm{e}^{-rT}K + \\text{Call Price} = \\mathrm{e}^{-q T}S_0+ \\text{Put Price}\\;.\n\\qquad(10.4)\\]\nThe following figure shows how the Black-Scholes call and put values depend on the underlying asset price and other model parameters. The call and put values are computed with the following code.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    \n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef black_scholes_put(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-r * T) * K - np.exp(-q * T) * S)\n\n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(-d1)\n    N2 = norm.cdf(-d2)\n    return np.exp(-r * T) * K * N2 - np.exp(-q * T) * S * N1",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#european-call-and-put-values",
    "href": "Chapter_BlackScholes.html#european-call-and-put-values",
    "title": "10  Black-Scholes",
    "section": "",
    "text": "10.2\n\n\n\nThe value of a European call option at date \\(0\\) is \\[\n\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\qquad(10.2)\\]\nwhere \\(d_1\\) is defined in ?eq-sharedigital_d1 and \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\).\n\n\n\n\n\n\n\n\n\n10.3\n\n\n\nThe value of a European put option at date \\(0\\) is \\[\n\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2)-\\mathrm{e}^{-q T}S_0\\mathrm{N}(-d_1)\\;,\n\\qquad(10.3)\\]\nwhere \\(d_1\\) is defined in ?eq-sharedigital_d1 and \\(d_2 = d_1-\\sigma{\\sqrt{T}}\\).\n\n\n\n\n\n\n\n\nFigure 10.1: Black-Scholes Explorer",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#greeks",
    "href": "Chapter_BlackScholes.html#greeks",
    "title": "10  Black-Scholes",
    "section": "10.4 Greeks",
    "text": "10.4 Greeks\nThe derivatives (calculus derivatives, not financial derivatives!) of an option pricing formula with respect to the inputs are commonly called Greeks. The most important Greek is the option delta. This measures the sensitivity of the option value to changes in the value of the underlying asset. The following table shows the standard Greeks, with reference to the Black-Scholes pricing formula.\n\n\n\n\n\n\n\n\n\n\n\nInput\nInput Symbol\n\nGreek\n\nGreek Symbol\n\n\n\n\nStock price\n\\(S\\)\n\ndelta\n\n\\(\\delta\\)\n\n\ndelta\n\\(\\delta\\)\n\ngamma\n\n\\(\\Gamma\\)\n\n\n- Time to maturity\n\\(-T\\)\n\ntheta\n\n\\(\\Theta\\)\n\n\nVolatility\n\\(\\sigma\\)\n\nvega\n\n\\(\\cal{V}\\)\n\n\nInterest rate\n\\(r\\)\n\nrho\n\n\\(\\rho\\)\n\n\n\nThe second line of the above shows \\(\\delta\\) as an input.3 Of course, it is not an input but instead is calculated. Gamma, the derivative of \\(\\delta\\), is the second derivative of the option price with respect to the underlying asset price. The reason for calculating \\(\\Theta\\) as the derivative with respect to \\(-T\\) instead of \\(T\\) is that the time-to-maturity \\(T\\) decreasing (\\(-T\\) increasing) is equivalent to time passing, so \\(\\Theta\\) measures the change in the option value when time passes.\nWe can calculate these from the Black-Scholes formula using the chain rule from differential calculus. The derivative of the normal distribution function \\(\\mathrm{N}\\) is the normal density function \\(\\mathrm{n}d\\) defined as \\[\\mathrm{n}d(d) = \\frac{1}{\\sqrt{2\\pi}}\\mathrm{e}^{-d^2/2}\\; .\\] One can easily verify directly that \\[\n\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)=\\mathrm{e}^{-rT}K\\mathrm{n}d(d_2)\\;,\n\\qquad(10.5)\\]\nwhich simplifies the calculations for the Black-Scholes call option pricing formula. For this formula, the Greeks are as follows: \\[\\begin{align*}\n\\delta &= \\mathrm{e}^{-q T}\\mathrm{N}(d_1) + \\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\frac{\\partial d_1}{\\partial S} -\\mathrm{e}^{-rT}K\\mathrm{n}d(d_2)\\frac{\\partial d_2}{\\partial S}\\\\\n&= \\mathrm{e}^{-q T}\\mathrm{N}(d_1) + \\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\left(\\frac{\\partial d_1}{\\partial S}-\\frac{\\partial d_2}{\\partial S}\\right)\\\\\n&=\\mathrm{e}^{-q T}\\mathrm{N}(d_1)\\;,\\\\\n\\Gamma &=\\mathrm{e}^{-q T}\\mathrm{n}d(d_1)\\frac{\\partial d_1}{\\partial S}= \\mathrm{e}^{-q T}\\mathrm{n}d(d_1)\\frac{1}{S\\sigma\\sqrt{T}}\\;,\n\\end{align*}\\] \\[\\begin{align*}\n\\Theta &=-\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\frac{\\partial d_1}{\\partial T} +q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1) \\\\\n&\\quad + \\mathrm{e}^{-rT}K\\mathrm{n}d(d_2)\\frac{\\partial d_2}{\\partial T} -r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\left(\\frac{\\partial d_2}{\\partial T}-\\frac{\\partial d_1}{\\partial T}\\right)\\\\\n&\\quad + q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1)-r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=-\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\frac{\\sigma}{2\\sqrt{T}}+ q \\mathrm{e}^{-q T}S\\mathrm{N}(d_1)-r\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\\\\\n\\cal{V}&=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\frac{\\partial d_1}{\\partial \\sigma} - \\mathrm{e}^{-rT}K\\mathrm{n}d(d_2)\\frac{\\partial d_2}{\\partial \\sigma}\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\left(\\frac{\\partial d_1}{\\partial \\sigma}-\\frac{\\partial d_2}{\\partial \\sigma}\\right)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\sqrt{T}\\;,\\\\\n\\rho &=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\frac{\\partial d_1}{\\partial r} - \\mathrm{e}^{-rT}K\\mathrm{n}d(d_2)\\frac{\\partial d_2}{\\partial r} +T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=\\mathrm{e}^{-q T}S\\mathrm{n}d(d_1)\\left(\\frac{\\partial d_1}{\\partial r}-\\frac{\\partial d_2}{\\partial r}\\right)+T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\\\\n&=T\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;.\n\\end{align*}\\]\nWe can calculate the Greeks of a European put option from the call option Greeks and put-call parity: \\[\\text{Put Price} = \\text{Call Price} +\\mathrm{e}^{-rT}K- \\mathrm{e}^{-q T}S_0\\; .\\] For example, the delta of a put is the delta of a call (with the same strike and maturity) minus \\(\\mathrm{e}^{-q T}\\), and the gamma of a put is the same as the gamma of the corresponding call.\nTo see how the Greeks respond to changes in the various inputs to the Black-Scholes formula (e.g., interest rate (\\(r\\)), time to maturity (\\(T\\)) and volatility (\\(\\sigma\\))), we encourage readers to interact with the plot below. The code used for the calculations is here:\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef d1(S, K, r, sigma, T):\n    \"\"\"\n    Computes d1 used in Black-Scholes.\n    \"\"\"\n    return (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n\ndef d2(S, K, r, sigma, T):\n    \"\"\"\n    Computes d2 used in Black-Scholes.\n    \"\"\"\n    return d1(S, K, r, sigma, T) - sigma * np.sqrt(T)\n\ndef call_price(S, K, r, sigma, T):\n    \"\"\"\n    Black-Scholes price for a call option.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    return S * norm.cdf(d_1) - K * np.exp(-r * T) * norm.cdf(d_2)\n\ndef put_price(S, K, r, sigma, T):\n    \"\"\"\n    Black-Scholes price for a put option.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    return K * np.exp(-r * T) * norm.cdf(-d_2) - S * norm.cdf(-d_1)\n\ndef greeks(S, K, r, sigma, T, option_type=\"call\"):\n    \"\"\"\n    Return the main Greeks for Black-Scholes.\n\n    Parameters\n    ----------\n    S : float or numpy array\n        Underlying price.\n    K : float\n        Strike price.\n    r : float\n        Risk-free interest rate.\n    sigma : float\n        Volatility.\n    T : float\n        Time to maturity (in years).\n    option_type : str\n        'call' or 'put'.\n    \"\"\"\n    d_1 = d1(S, K, r, sigma, T)\n    d_2 = d2(S, K, r, sigma, T)\n    pdf_d1 = norm.pdf(d_1)\n    cdf_d1 = norm.cdf(d_1)\n    cdf_d2 = norm.cdf(d_2)\n    \n    if option_type == \"call\":\n        # Delta\n        delta = cdf_d1\n        # Gamma (same for call & put)\n        gamma = pdf_d1 / (S * sigma * np.sqrt(T))\n        # Vega (same for call & put, but typically scaled by 0.01 if desired in %)\n        vega = S * pdf_d1 * np.sqrt(T)\n        # Theta\n        theta = - (S * pdf_d1 * sigma) / (2 * np.sqrt(T)) \\\n                - r * K * np.exp(-r * T) * cdf_d2\n        # Rho\n        rho = K * T * np.exp(-r * T) * cdf_d2\n    else:  # put\n        # Delta\n        delta = cdf_d1 - 1\n        # Gamma (same for call & put)\n        gamma = pdf_d1 / (S * sigma * np.sqrt(T))\n        # Vega (same for call & put)\n        vega = S * pdf_d1 * np.sqrt(T)\n        # Theta\n        theta = - (S * pdf_d1 * sigma) / (2 * np.sqrt(T)) \\\n                + r * K * np.exp(-r * T) * norm.cdf(-d_2)\n        # Rho\n        rho = - K * T * np.exp(-r * T) * norm.cdf(-d_2)\n\n    return delta, gamma, vega, theta, rho\n\n\n\n\n\nFigure 10.2: Black-Scholes Greeks Explorer",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#sec-s:deltahedging",
    "href": "Chapter_BlackScholes.html#sec-s:deltahedging",
    "title": "10  Black-Scholes",
    "section": "10.5 Theta and Gamma in Delta Hedges",
    "text": "10.5 Theta and Gamma in Delta Hedges\nLet \\(C(t, S_t)\\) denote the value at date \\(t\\) of a European call option that matures at \\(T&gt;t\\) under the Black-Scholes assumption. This value is given by the Black-Scholes call formula, taking the initial underlying asset price to be \\(S_t\\) and the time to maturity to be \\(T-t\\). Ito’s formula tells us that\n\\[\n\\,\\mathrm{d}C = \\frac{\\partial C}{\\partial S}\\,\\mathrm{d}S + \\frac{\\partial C}{\\partial t}\\,\\mathrm{d}t + \\frac{1}{2}\\frac{\\partial^2C}{\\partial S^2} (\\,\\mathrm{d}S)^2  \n\\]\nUsing our notation for Greeks, this is \\[\n\\,\\mathrm{d}C = \\delta \\,\\mathrm{d}S + \\Theta \\,\\mathrm{d}t + \\frac{1}{2}\\Gamma (\\,\\mathrm{d}S)^2  = \\delta \\,\\mathrm{d}S - \\Theta \\,\\mathrm{d}t + \\frac{1}{2}\\Gamma \\sigma^2 S^2 \\,\\mathrm{d}t\\,.\n\\]\nIf we sell a call option and combine the proceeds with borrowed funds to buy \\(\\delta\\) shares of the underlying asset, as discussed in ?sec-c:deltas, then the change in the portfolio value is \\[\\delta (\\,\\mathrm{d}S + q S \\,\\mathrm{d}t) - (\\delta S - C)r\\,\\mathrm{d}t - \\,\\mathrm{d}C\\] which simplifies to \\[\\delta q S \\,\\mathrm{d}t - (\\delta S - C)r\\,\\mathrm{d}t - \\Theta \\,\\mathrm{d}t - \\frac{1}{2}\\Gamma \\sigma^2 S^2 \\,\\mathrm{d}t\\,.\n\\qquad(10.6)\\]\nSeveral aspects of this are noteworthy. First, as noted earlier, the delta hedge eliminates the exposure to changes in the price of the underlying—there is no \\(\\,\\mathrm{d}S\\) term in Equation 10.6. Second, \\(\\Theta\\) is negative, because it captures the time decay in the option value; being short the option means the portfolio will profit from time decay at rate \\(-\\Theta\\). Third, this portfolio is short gamma. We can also say it is short convexity, the term convexity referring to the convex shape of the option value as a function of the price of the underlying, which translates mathematically to a positive second derivative (gamma).4 The volatility in the stock makes convexity valuable, and a portfolio that is short convexity will suffer losses. Finally, the portfolio is earning dividends but paying interest.\nIt is straightforward to check, from the definitions of \\(\\Theta\\), \\(\\Gamma\\) and \\(\\delta\\) in the preceding section, that the sum of the terms in Equation 10.6 is zero. The time decay in the option value and dividends received on the shares of the underlying exactly offset the losses due to convexity and interest. Therefore, the delta hedge is a perfect hedge. The portfolio, which has a zero cost, neither earns nor loses money. This is true not only on average but for every possible change in the stock price.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#discretely-rebalanced-delta-hedges",
    "href": "Chapter_BlackScholes.html#discretely-rebalanced-delta-hedges",
    "title": "10  Black-Scholes",
    "section": "10.6 Discretely Rebalanced Delta Hedges",
    "text": "10.6 Discretely Rebalanced Delta Hedges\nIn practice of course, we cannot continuously rebalance to maintain a perfect delta hedge at every instant. There is risk when rebalancing at discrete times. We can model a discretely rebalanced delta hedge as follows. Consider equally spaced dates \\(0 = t_0 &lt; t_1 &lt; \\cdots &lt; t_n &lt; t_{n+1} = T\\). Let \\(\\Delta t\\) denote the time between successive dates. Suppose we set up a delta hedge at date \\(0\\) for a call option that we have sold. We sell the call at the Black-Scholes price \\(C(0, S_0)\\). We use the proceeds plus borrowed funds to buy \\(\\delta_0 = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)\\) shares, where \\(d_1\\) is the parameter at date 0 for the Black-Scholes call value and delta. We rebalance the hedge at each date \\(t_1, \\ldots, t_n\\), holding the short call position until it matures at date \\(T\\). Rebalancing means that we trade to re-establish the delta hedge based on the Black-Scholes call delta at that date, buying shares when the delta has gone up and selling shares when the delta has fallen. Let \\(\\delta_t\\) denote the Black-Scholes delta at each \\(t\\) and let $C_t denote the Black-Scholes call value \\(C(t, S_t)\\).\nOur cash position at date 0 is $ - (_0S_0 - C_0$. The cash position changes at each subsequent date due to (i) interest earned/paid on the cash position during the period, (ii) dividends received during the period on the shares owned, and (iii) cash paid or received when buying or selling stock to re-establish the delta hedge. Approximate the interest on cash in each time period as \\(r\\cdot \\Delta t\\) per dollar of cash at the beginning of the period. Approximate the dividends received in each time period as \\(q \\cdot \\Delta t\\) per dollar value of stock at the beginning of the period.\nThe portfolio starts at a zero value at date \\(0\\), because we used none of our own funds to put it on. Let \\(V_t\\) denote the portfolio value at date \\(t\\). The change in the portfolio value from \\(t_i\\) to \\(t_{i+1}\\) for each \\(i\\) is \\[V_{t_{i+1}} - V_{t_i} = - (\\delta_{t_i}S_{t_i} - V_{t_i})r\\Delta t + \\delta_{t_i}S_{t_i}q\\Delta t + \\delta_{t_i}\n(S_{t_{i+1}} - S_{t_i}) - (C_{t_{i+1}} - C_{t_i})\\,.\\] The terms on the right-hand side are (i) interest paid on borrowed funds, (ii) dividends received on shares owned, (iii) gain or loss on the shares owned, (iv) change in the value of the short call position. The following figure simulates stock price paths and computes the portfolio value at date \\(t_{n+1}=T\\). Of course, the call value at date \\(T\\) is its intrinsic value.\n\n\n\nFigure 10.3: Discretely Rebalanced Delta Hedge",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#sec-s:gammahedging",
    "href": "Chapter_BlackScholes.html#sec-s:gammahedging",
    "title": "10  Black-Scholes",
    "section": "10.7 Gamma Hedging",
    "text": "10.7 Gamma Hedging\nTo attempt to improve the performance of a discretely rebalanced delta hedge, we can use another option to create a portfolio that is both delta and gamma neutral. Being gamma neutral means that the marginal change in the portfolio delta is zero when the underlying price changes. This reduces the amount of rebalancing needed to maintain a delta hedge, so a discretely rebalanced delta/gamma hedge may be less risky than a discretely rebalanced delta hedge.\nA delta/gamma hedge can be constructed as follows. Suppose we have sold a call option and we want to hedge both the delta and gamma using the underlying asset and another option, for example, another call option with a different strike. In practice, one would want to use a liquid option for this purpose, which typically means that the strike of the option will be near the current value of the underlying (i.e., the option used to hedge would be approximately at the money).\nLet \\(\\delta\\) and \\(\\Gamma\\) denote the delta and gamma of the written option and let \\(\\delta'\\) and \\(\\Gamma'\\) denote the delta and gamma of the option used to hedge. Consider holding \\(a\\) of shares of the stock and \\(b\\) units of the option used to hedge in conjunction with the short option. The delta of the stock is one (\\(\\,\\mathrm{d}S/\\,\\mathrm{d}S = 1\\)), so to obtain a zero portfolio delta we need\n\\[\n0 = - \\delta + a + b\\delta'.\n\\qquad(10.7)\\]\nThe gamma of the stock is zero (\\(\\,\\mathrm{d}^2 S/\\,\\mathrm{d}S^2 = d\\,1/\\,\\mathrm{d}S = 0\\)), so to obtain a zero portfolio gamma we need\n\\[\n0 = - \\Gamma + b\\Gamma'\\;.\n\\qquad(10.8)\\]\nEquation 10.8 shows that we should hold enough of the second option to neutralize the gamma of the option we have shorted; i.e., \\[\\\nb= \\frac{\\Gamma}{\\Gamma'}\n\\] Equation 10.7 shows that we should use the stock to delta hedge the portfolio of options; i.e., \\[\na=\\delta - \\frac{\\Gamma}{\\Gamma'}\\delta'\\;.\n\\]",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#sec-s:impliedvolatility",
    "href": "Chapter_BlackScholes.html#sec-s:impliedvolatility",
    "title": "10  Black-Scholes",
    "section": "10.8 Implied Volatilities",
    "text": "10.8 Implied Volatilities\nAll of the inputs into the option pricing formulas are in theory observable, except for the volatility coefficient \\(\\sigma\\). We can estimate \\(\\sigma\\) from historical data (see Chapter 17), or estimate it from the prices of other options. The latter method exploits the fact that there is a one-to-one relationship between the price given by the Black-Scholes formula and the \\(\\sigma\\) that is input, so one can take the price as given and infer \\(\\sigma\\) from the formula. The \\(\\sigma\\) computed in this way is called the implied volatility. The implied volatility from one option can be used to price another (perhaps non-traded or less actively traded) option.\nEven if we acknowledge that the model is not correct, the computation of implied volatilities is still useful for characterizing market prices, because we can quickly describe an option as expensive or cheap depending on whether its implied volatility is large or small. Somewhat paradoxically, it is less easy to see if an option is expensive or cheap by looking at its price, because one must consider the price in the context of the exercise price and maturity. To some extent, the implied volatility normalizes the price relative to the exercise price and maturity. Of course, it does not always pay to sell expensive options or buy cheap options, unless they are expensive or cheap relative to an accurate model!\nIf we compute implied volatilities for options with the same maturity but different strikes, we will typically obtain different implied volatilities for different options. If we plot implied volatility against the strike, the pattern one normally sees for equities and equity indices is the implied volatility declining as the strike increases until the strike is somewhere near the current value of the underlying (so the option is at the money). The implied volatility then generally flattens out or increases slightly at higher strikes. The graph looks like a twisted smile (smirk). This pattern has been very pronounced in equity index option prices since the crash of 1987. This moneyness structure of implied volatilities is inconsistent with the Black-Scholes model. It suggests that the risk-neutral return distribution is not lognormal but instead exhibits a higher likelihood of extreme returns than the lognormal distribution (i.e., it has fat tails) with the likelihood of extreme negative returns being higher than the likelihood of extreme positive returns (i.e., it is skewed).",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#fundamental-pde",
    "href": "Chapter_BlackScholes.html#fundamental-pde",
    "title": "10  Black-Scholes",
    "section": "10.9 Fundamental PDE",
    "text": "10.9 Fundamental PDE",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#monte-carlo-approximation-of-black-scholes",
    "href": "Chapter_BlackScholes.html#monte-carlo-approximation-of-black-scholes",
    "title": "10  Black-Scholes",
    "section": "10.10 Monte-Carlo Approximation of Black-Scholes",
    "text": "10.10 Monte-Carlo Approximation of Black-Scholes",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#binomial-approximation-of-black-scholes",
    "href": "Chapter_BlackScholes.html#binomial-approximation-of-black-scholes",
    "title": "10  Black-Scholes",
    "section": "10.11 Binomial Approximation of Black-Scholes",
    "text": "10.11 Binomial Approximation of Black-Scholes",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#section-2",
    "href": "Chapter_BlackScholes.html#section-2",
    "title": "10  Black-Scholes",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nThe delta of a digital option that pays $1 when \\(S_T&gt;K\\) is \\[\\frac{\\mathrm{e}^{-rT}\\mathrm{n}d(d_2)}{\\sigma S\\sqrt{T}}\\; .\\] Repeat the previous problem for the delta of this digital. Given that in reality it is costly to trade (due to commissions, the bid-ask spread and possible adverse price impacts for large trades), do you see any problems with delta hedging a short digital near maturity if it is close to being at the money?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nModify the Python code for replicating portfolio insurance to simulate a discrete replication of a digital option using the delta in the previous problem. Run the code for \\(10,20,100,1000\\) rebalancing dates. When does the strategy do a good job and when does it fail?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 8.1 for the gamma of a call option.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUse put-call parity to derive the Greeks of a put option, and write a Python function that computes the value and Greeks.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider delta and gamma hedging a short call option, using the underlying and a put with the same strike and maturity as the call. Calculate the position in the underlying and the put that you should take, using the analysis in Section 10.7. Will you ever need to adjust this hedge? Relate your result to put-call parity.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nThe delta of a share digital that pays one share when \\(S_T&gt;K\\) is \\[\\mathrm{e}^{-qT}\\mathrm{N}(d_1) + \\frac{\\mathrm{e}^{-qT}\\mathrm{n}d(d_1)}{\\sigma \\sqrt{T}}\\; .\\] Repeat Exercise 8.1 for the delta of this share digital.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCompute the value of an at-the-money call option (\\(S=K\\)) using the Python code for volatilities \\(\\sigma = .01, .02, \\ldots, 1.0\\). Plot the call value against the volatility.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous problem for \\(S=1.2K\\) (an example of an in-the-money call option).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nThe file CBO\\EQuotes.txt (available at ) contains price data for call options on the S&P 500 index. The options expired in February, 2003, and the prices were obtained on January 22, 2003. The first column lists various exercise prices. The second column gives the bid price and the third column the ask price. Import this data into a Python program and compute and plot the implied volatility against the exercise price using this data. Use the ask price as the market price for the option. The options have 30 days to maturity (so \\(T=30/365\\)). At the time the quotes were downloaded, the S&P 500 was at 884.25. According to the CBO\\E, the dividend yield on the S&P 500 was 1.76%. Use 1.25% for the risk-free interest rate.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nAttempt to repeat the previous problem using the bid price as the market price of the option. If this doesn’t work, what is wrong? Does this indicate there is an arbitrage opportunity?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nSuppose an investor invests in a portfolio with price \\(S\\) and constant dividend yield \\(q\\). Assume the investor is charged a constant expense ratio \\(\\alpha\\) (which acts as a negative dividend) and at date \\(T\\) receives either his portfolio value or his initial investment, whichever is higher. This is similar to a popular type of variable annuity. Letting \\(D\\) denote the number of dollars invested in the contract, the contract pays \\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S_T}{S_0}\\right)\n\\qquad(10.9)\\] at date \\(T\\).\nWe can rearrange the expression Equation 10.9 as\n\\[\n\\max\\left(D,\\frac{D\\mathrm{e}^{(q-\\alpha)T}S_T}{S_0}\\right) = D + \\max\\left(0, \\frac{D\\mathrm{e}^{(q-\\alpha)T}S_T}{S_0}-D\\right)\n\\] \\[\n= D + \\mathrm{e}^{-\\alpha T}D\\max\\left(0,\\frac{\\mathrm{e}^{qT}S_T}{S_0}-\\mathrm{e}^{\\alpha T}\\right)\\;.\n\\qquad(10.10)\\]\nThus, the contract payoff is equivalent to the amount invested plus a certain number of call options written on the gross holding period return \\(\\mathrm{e}^{qT}S_T/S_0\\). Note that \\(Z_t = \\mathrm{e}^{qt}S_t/S_0\\) is the date–\\(t\\) value of the portfolio that starts with \\(1/S_0\\) units of the asset (i.e., with a $1 investment) and reinvests dividends. Thus, the call options are call options on a dividend-reinvested portfolio with the same volatility as \\(S\\) and initial price of $1. This implies that the date–0 value of the contract to the investor is \\(\\mathrm{e}^{-rT}D\\) plus\n\\(e^{-\\alpha*T}*D*\\)Black_Scholes_Call\\((1,e^{-\\alpha*T},r,sigma,q,T)\\)\n\nCreate a Python function to compute the fair expense ratio; i.e., find \\(\\alpha\\) such that the date–0 value of the contract is equal to \\(D\\). Hint: Modify the\n\nBlack_Scholes_Call_Implied_Vol\nfunction. You can use \\(\\alpha=0\\) as a lower bound. Because the value of the contract is decreasing as \\(\\alpha\\) increases, you can find an upper bound by iterating until the value of the contract is less than \\(D\\). 2. How does the fair expense ratio vary with the maturity \\(T\\)? Why?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nModify the function Simulated_Delta_Hedge_Profit to compute percentiles of gains and losses for an investor who writes a call option and constructs a delta and gamma hedge using the underlying asset and another call option. Include the exercise price of the call option used to hedge as an input, and assume it has the same time to maturity as the option that is written. Hint: In each period , the updated cash position can be calculated as\nCash = exp(r*dt)*Cash + a*S*(exp(q*dt)-1) - (Newa-a)*NewS - (Newb-b)*PriceHedge, where a denotes the number of shares of the stock held, b denotes the number of units held of the option that is used for hedging, and PriceHedge denotes the price of the option used for hedging (computed from the Black-Scholes formula each period). This expression embodies the interest earned (paid) on the cash position, the dividends received on the shares of stock and the cash inflows (outflows) from adjusting the hedge. At the final date N, the value of the hedge is\nexp(r*dt)*Cash + a*S*(exp(q*dt)-1) + a*NewS + b*np.max(NewS-KHedge,0),\nand the value of the overall portfolio is the value of the hedge less np.max(NewS-KWritten,0), where KHedge denotes the strike price of the option used to hedge and KWritten denotes the strike of the option that was written.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes.html#footnotes",
    "href": "Chapter_BlackScholes.html#footnotes",
    "title": "10  Black-Scholes",
    "section": "",
    "text": "There is no other risky asset price \\(Y\\) in this model, so the subscripts we used in ?sec-s:girsanov↩︎\nThe put-call parity relation follows from the fact that both the left and the right-hand sides are the prices of portfolios that have value \\(\\max(S_T,K)\\) at the maturity of the option. To see this for the left-hand side, note that \\(\\mathrm{e}^{-rT}K\\) is sufficient cash to accumulate to \\(K\\) at date \\(T\\), allowing exercise of the call when it is in the money and retention of the cash \\(K\\) otherwise. For the right-hand side, note that \\(\\mathrm{e}^{-q T}S_0\\) is enough cash to buy \\(\\mathrm{e}^{-q T}\\) shares of the stock at date \\(0\\) which, with reinvestment of dividends, will accumulate to one share at date \\(T\\), enabling exercise of the put if it is in the money or retention of the share otherwise.↩︎\nThe delta is frequently denoted by the upper case \\(\\Delta\\), but we will use the lower case, reserving the upper case for discrete changes, e.g., \\(\\Delta t\\). One may have noticed also that the symbol for vega is a little different from the others; this reflects the fact that vega is not actually a Greek letter.↩︎\nA curious reader may ask why we don’t say that the portfolio is long concavity instead of saying that it is short convexity. This is a mystery to your authors also.↩︎",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Black-Scholes</span>"
    ]
  },
  {
    "objectID": "Chapter_Americans.html",
    "href": "Chapter_Americans.html",
    "title": "11  American Options",
    "section": "",
    "text": "11.1 Calls are Better Alive than Dead",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>American Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Americans.html#binomial-valuation-of-american-options",
    "href": "Chapter_Americans.html#binomial-valuation-of-american-options",
    "title": "11  American Options",
    "section": "11.2 Binomial Valuation of American Options",
    "text": "11.2 Binomial Valuation of American Options",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>American Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Americans.html#sec-s:discrete",
    "href": "Chapter_Americans.html#sec-s:discrete",
    "title": "11  American Options",
    "section": "11.3 American Calls with Discrete Dividends",
    "text": "11.3 American Calls with Discrete Dividends\nIt can be optimal to exercise an American call option early if the underlying asset pays a dividend. The optimal exercise date will be immediately prior to the asset going ex-dividend. Consider a call option maturing at \\(T'\\) on an asset that will pay a known cash dividend \\(D\\) at a known date \\(T&lt;T'\\). We assume there is no continuous dividend payment, so \\(q=0\\). For simplicity, we assume that the date of the dividend payment is also the date that the asset goes ex-dividend; i.e., ownership of the asset at any date \\(t&lt;T\\) entitles the owner to receive the dividend at date \\(T\\). Under this assumption, it is reasonable also to assume that the stock price drops by \\(D\\) when the dividend is paid.\nThere is some ambiguity about how to define the asset price at the instant the dividend is paid—whether to include or exclude the dividend. We will let \\(S_T\\) denote the price including the dividend and denote the price excluding the dividend by \\(Z_T\\), so \\(Z_T = S_T-D\\). In fact, it is convenient to let \\(Z_t\\) denote the price stripped of the dividend value at all dates \\(t \\leq T\\), so we will define \\[\nZ_t = \\begin{cases}S_t-\\mathrm{e}^{-r(T-t)}D & \\text{if $t \\leq T$\\;,}\\\\\nS_t & \\text{if $t &gt; T$\\;.}\n\\end{cases}\n\\]\nNote that \\(Z\\) is the price of the following dividend-reinvested portfolio: buy one unit of the asset at date \\(0\\), borrow \\(\\mathrm{e}^{-rT}D\\) at date \\(0\\) to help finance the purchase, and use the dividend \\(D\\) at date \\(T\\) to retire the debt.\nIf we assume as usual that the asset price \\(S\\) has a constant volatility, then, using Equation 6.2 for a geometric Brownian motion and letting \\(B^*\\) denote a Brownian motion under the risk-neutral probability, we have \\[\\begin{align*}\nS_{T'} &= [S_T-D]\\exp\\left\\{(r-\\sigma^2/2)(T'-T)+\\sigma B^*_{T'}-\\sigma B^*_T\\right\\}\\\\\n&= \\left[S_0\\exp\\left\\{(r-\\sigma^2/2)T+\\sigma B^*_T\\right\\}-D\\right]\\\\\n&\\qquad \\times \\exp\\left\\{(r-\\sigma^2/2)(T'-T)+\\sigma B^*_{T'}-\\sigma B^*_T\\right\\}\\\\\n&=S_0\\exp\\left\\{(r-\\sigma^2/2)T'+\\sigma B^*_{T'}\\right\\} \\\\\n&\\qquad - D\\exp\\left\\{(r-\\sigma^2/2)(T'-T)+\\sigma B^*_{T'}-\\sigma B^*_T\\right\\}\\;.\n\\end{align*}\\] Thus, \\(S\\) will be a sum of lognormal random variables. A sum of lognormals is not itself lognormal, so \\(S\\) will not be lognormal, and we are unable to calculate the option value in a simple way.\nWe will assume instead that \\(Z\\) has a constant volatility \\(\\sigma\\). Thus, \\(Z\\) is the price of a dividend-reinvested portfolio, it satisfies the Black-Scholes assumptions, and we have \\(S_{T'}=Z_{T'}\\). To value a European option, we would simply use \\(Z_0=S_0-\\mathrm{e}^{-rT}D\\) as the initial asset price and \\(\\sigma\\) as the volatility.\n\nAmerican Call Payoff\nIf the call is not exercised before the dividend is paid at date \\(T\\), then its value at date \\(T\\) will be\nwhere Z \\(=Z_T\\). Hence, exercise is optimal when\nA lower bound for the Black-Scholes call value on the right-hand side is \\(Z_T-\\mathrm{e}^{-r(T'-T)}K\\). If \\(Z_T+D-K\\) is less than or equal to this lower bound, then exercise cannot be optimal. Thus, if \\(D-K\\) is less than or equal to \\(-\\mathrm{e}^{-r(T'-T)}K\\), then exercise will never be optimal. In this circumstance, the dividend is simply too small to offset the time value of money on the exercise price \\(K\\), and the value of the American call written on the asset with price \\(S\\) is the same as the value of the European call written on the dividend-reinvested portfolio with price \\(Z\\).\nOn the other hand, if \\(D-K &gt; -\\mathrm{e}^{-r(T'-T)}K\\), then exercise will be optimal for sufficiently large \\(Z_T\\). In this case, there is some \\(Z^*\\) such that the owner of the call will be indifferent about exercise, and exercise will be optimal for all \\(Z_T&gt;Z^*\\). This \\(Z^*\\) is defined by\nAs in the previous section, we can compute \\(Z^*\\) by bisection.\nDefine \\[\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $Z_T&gt;Z^*$\\;,}\\\\\n                               0 & \\text{otherwise\\;,}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $Z_T\\leq Z^*$ and $Z_{T'}&gt;K$\\;,}\\\\\n                               0 & \\text{otherwise\\;.}\n        \\end{cases}\n\\end{align*}\\] Then the American call option will pay \\([Z_T+D-K]x\\) at date \\(T\\) (due to early exercise) and \\([Z_{T'}-K]y\\) at date \\(T'\\) (due to exercise at maturity), if \\(D-K &gt; -\\mathrm{e}^{-r(T'-T)}K\\).\n\n\nNumeraires\nAssume for now that \\(D-K &gt; -\\mathrm{e}^{-r(T'-T)}K\\). The payoff \\((D-K)x\\) is the payoff of \\(D-K\\) digital options maturing at \\(T\\), and the payoff \\(Z_Tx\\) is the payoff of one share digital on the portfolio with price \\(Z\\). Therefore, the value of receiving \\([Z_T+D-K]x\\) at date \\(T\\) is \\[\nZ_0\\mathrm{N}(d_1) + \\mathrm{e}^{-rT}(D-K)\\mathrm{N}(d_2)\\; ,\n\\] where\n\\[\nd_1 = \\frac{\\log\\left(\\frac{Z_0}{Z^*}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\] \\[\n= \\frac{\\log\\left(\\frac{S_0-\\mathrm{e}^{-rT}D}{Z^*}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} \\;,\n\\qquad(11.1)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(11.2)\\]\nAs in the previous section,1 the value of receiving \\([Z_T-K]y\\) at date \\(T'\\) is \\[\nZ_0\\times \\text{prob}^Z(y=1) - \\mathrm{e}^{-rT'}K\\times \\text{prob}^R(y=1)\\; .\n\\] ### Calculating Probabilities The calculations are very similar to the calculations we did for a call option on a call. In fact, they are exactly the same as we would do for a put option on a call.\n\nThe event \\(y=1\\) is equivalent to \\[\n\\log Z_0 + \\left(r+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T \\leq \\log Z^*\n\\] and \\[\n\\log Z_0 + \\left(r+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K\\; ,\n\\]\n\nwhere \\(B^*\\) is a Brownian motion when the underlying asset (with price \\(Z\\)) is used as the numeraire. We can write this as \\[\n\\frac{B^*_T}{\\sqrt{T}}&lt;-d_1 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}} &lt; d_1'\\;,\n\\qquad(11.3)\\]\nwhere \\(d_1\\) is defined in Equation 11.1,\n\\[\nd_1' = \\frac{\\log\\left(\\frac{Z_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T'}{\\sigma\\sqrt{T'}}\n\\] \\[\n= \\frac{\\log\\left(\\frac{S_0-\\mathrm{e}^{-rT}D}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T'}{\\sigma\\sqrt{T'}}\n\\qquad(11.4)\\]\n\\[\nd_2'=d_1'-\\sigma\\sqrt{T'}\\;.\n\\qquad(11.5)\\]\nThe two standard normal variables on the left-hand sides in Equation 11.3 have a covariance equal to \\[\n-\\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_{T'}) = -\\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_T) = -\\sqrt{\\frac{T}{T'}}\\; .\n\\]\nHence, \\(\\text{prob}^Z(y=1)\\) is the probability that \\(a\\leq -d_1\\) and \\(b\\leq d_1'\\), where \\(a\\) and \\(b\\) are standard normal random variables with covariance (= correlation coefficient) of \\(-\\sqrt{T/T'}\\). We are writing this probability as \\(\\mathrm{M}\\!\\left(-d_1,d_1',-\\sqrt{T/T'}\\right)\\).\n\nThe calculation for \\(\\text{prob}^R(y=1)\\) is similar. The event \\(y=1\\) is equivalent to \\[\n\\log Z_0 + \\left(r+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T \\leq \\log Z^*\n\\] and \\[\n\\log Z_0 + \\left(r+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K\\; ,\n\\] where \\(B^*\\) now denotes a Brownian motion under the risk-neutral probability. These are equivalent to \\[\n\\frac{B^*_T}{\\sqrt{T}}\\leq -d_2 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}} &lt; d_2'\\;.\n\\qquad(11.6)\\]\n\nHence, \\(\\text{prob}^R(y=1)=\\mathrm{M}\\!\\left(-d_2,d_2',-\\sqrt{T/T'}\\right)\\).\n\n\nAmerican Call Pricing Formula\n\n\n\n\n\n\n11.4\n\n\n\nUnder our assumptions, the value of an American call option maturing at \\(T'\\) with a dividend payment of \\(D\\) at date \\(T&lt;T'\\) is as follows.\nIf \\[\nD-K \\leq -\\mathrm{e}^{-r(T'-T)}K\\;,\n\\] then the value of the call is given by the Black-Scholes formula \\[\n[S_0-\\mathrm{e}^{-rT}D]\\mathrm{N}(d_1')-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2')\\; ,\n\\]\nwhere \\(d_1'\\) and \\(d_2'\\) are defined in Equation 11.4 - Equation 11.5. On the other hand, if \\[\nD-K &gt; -\\mathrm{e}^{-r(T'-T)}K\\;,\n\\] then the value of the call is\n\\[\n\\begin{multline}\n[S_0-\\mathrm{e}^{-rT}D]\\mathrm{N}(d_1) + \\mathrm{e}^{-rT}(D-K)\\mathrm{N}(d_2)\\\\ +[S_0-\\mathrm{e}^{-rT}D]\\mathrm{M}\\!\\left(-d_1,d_1',-\\sqrt{T/T'}\\right) \\\\- \\mathrm{e}^{-rT'}K\\mathrm{M}\\!\\left(-d_2,d_2',-\\sqrt{T/T'}\\right)\\;,\n\\end{multline}\n\\qquad(11.7)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 11.1 - Equation 11.2 and \\(d_1'\\) and \\(d_2'\\) are defined in Equation 11.4 - Equation 11.5.\n\n\nTo value an American call when there is one dividend payment before the option matures, we input the initial asset price \\(S_0\\) and then compute \\(Z_0=X_0-\\mathrm{e}^{-rT}D\\). If \\(D-K \\leq -\\mathrm{e}^{-r(T'-T)}K\\), we return the Black-Scholes value of a European call written on \\(Z\\). Otherwise, we need to compute \\(Z^*\\) and our bisection algorithm requires an upper bound for \\(Z^*\\), which would be any value of \\(Z_T\\) such that exercise at \\(T\\) is optimal. It is not obvious what this should be, so we start with \\(K\\) and keep doubling this until we obtain a value of \\(Z_T\\) at which exercise would be optimal. Then, we use the bisection algorithm to compute \\(Z^*\\) and finally compute the option value Equation 11.7.\n\n\nCode\n\"\"\"\nimport numpy as np\n\nimport numpy as np\nfrom scipy.stats import norm\nimport scipy.optimize as optimize\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n\"\"\"\n\"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n\"\"\"\n\"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\n\ndef american_call_dividend(S, K, r, sigma, Div, TDiv, TCall):\n    LessDiv = S - np.exp(-r * TDiv) * Div\n    if Div / K &lt;= 1 - np.exp(-r * (TCall - TDiv)):\n        return black_scholes_call(LessDiv, K, r, sigma, 0, TCall)\n\n    upper = K\n    while upper + Div - K &lt; black_scholes_call(upper, K, r, sigma, 0, TCall - TDiv):\n        upper *= 2\n\n    tol = 1e-6\n    lower = 0\n    flower = Div - K\n    fupper = upper + Div - K - black_scholes_call(upper, K, r, sigma, 0, TCall - TDiv)\n    guess = 0.5 * lower + 0.5 * upper\n    fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\n    LessDivStar = guess\n\n    d1 = (np.log(LessDiv / LessDivStar) + (r + sigma ** 2 / 2) * TDiv) / (sigma * np.sqrt(TDiv))\n    d2 = d1 - sigma * np.sqrt(TDiv)\n    d1prime = (np.log(LessDiv / K) + (r + sigma ** 2 / 2) * TCall) / (sigma * np.sqrt(TCall))\n    d2prime = d1prime - sigma * np.sqrt(TCall)\n    rho = -np.sqrt(TDiv / TCall)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    M1 = binormal_prob(-d1, d1prime, rho)\n    M2 = binormal_prob(-d2, d2prime, rho)\n\n    return LessDiv * N1 + np.exp(-r * TDiv) * (Div - K) * N2 + LessDiv * M1 - np.exp(-r * TCall) * K * M2\n\n# Example usage\n\nS = 100\nK = 90\nr = 0.05\nsigma = 0.2\nDiv = 5\nTDiv = 0.5\nTCall = 1\nN = 10\n\nprint(\"American Call with Dividend:\", american_call_dividend(S, K, r, sigma, Div, TDiv, TCall))\n\"\"\"\n\n\n'\\n    if sigma == 0:\\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\\n    else:\\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\\n        d2 = d1 - sigma * np.sqrt(T)\\n        N1 = norm.cdf(d1)\\n        N2 = norm.cdf(d2)\\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\\n\\n\\ndef american_call_dividend(S, K, r, sigma, Div, TDiv, TCall):\\n    LessDiv = S - np.exp(-r * TDiv) * Div\\n    if Div / K &lt;= 1 - np.exp(-r * (TCall - TDiv)):\\n        return black_scholes_call(LessDiv, K, r, sigma, 0, TCall)\\n\\n    upper = K\\n    while upper + Div - K &lt; black_scholes_call(upper, K, r, sigma, 0, TCall - TDiv):\\n        upper *= 2\\n\\n    tol = 1e-6\\n    lower = 0\\n    flower = Div - K\\n    fupper = upper + Div - K - black_scholes_call(upper, K, r, sigma, 0, TCall - TDiv)\\n    guess = 0.5 * lower + 0.5 * upper\\n    fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\\n    while upper - lower &gt; tol:\\n        if fupper * fguess &lt; 0:\\n            lower = guess\\n            flower = fguess\\n            guess = 0.5 * lower + 0.5 * upper\\n            fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\\n        else:\\n            upper = guess\\n            fupper = fguess\\n            guess = 0.5 * lower + 0.5 * upper\\n            fguess = guess + Div - K - black_scholes_call(guess, K, r, sigma, 0, TCall - TDiv)\\n    LessDivStar = guess\\n\\n    d1 = (np.log(LessDiv / LessDivStar) + (r + sigma ** 2 / 2) * TDiv) / (sigma * np.sqrt(TDiv))\\n    d2 = d1 - sigma * np.sqrt(TDiv)\\n    d1prime = (np.log(LessDiv / K) + (r + sigma ** 2 / 2) * TCall) / (sigma * np.sqrt(TCall))\\n    d2prime = d1prime - sigma * np.sqrt(TCall)\\n    rho = -np.sqrt(TDiv / TCall)\\n    N1 = norm.cdf(d1)\\n    N2 = norm.cdf(d2)\\n    M1 = binormal_prob(-d1, d1prime, rho)\\n    M2 = binormal_prob(-d2, d2prime, rho)\\n\\n    return LessDiv * N1 + np.exp(-r * TDiv) * (Div - K) * N2 + LessDiv * M1 - np.exp(-r * TCall) * K * M2\\n\\n# Example usage\\n\\nS = 100\\nK = 90\\nr = 0.05\\nsigma = 0.2\\nDiv = 5\\nTDiv = 0.5\\nTCall = 1\\nN = 10\\n\\nprint(\"American Call with Dividend:\", american_call_dividend(S, K, r, sigma, Div, TDiv, TCall))\\n'",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>American Options</span>"
    ]
  },
  {
    "objectID": "Chapter_Americans.html#footnotes",
    "href": "Chapter_Americans.html#footnotes",
    "title": "11  American Options",
    "section": "",
    "text": "The only difference is that here \\(Z\\) is the price of a dividend-reinvested portfolio, so, in the notation of the previous section, we have \\(V_t=Z_t\\).↩︎",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>American Options</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html",
    "href": "Chapter_FX.html",
    "title": "12  FX and Quantos",
    "section": "",
    "text": "12.1 Currency Options\nWe will see in this chapter how to apply the Black-Scholes formulas to value currency options and options on foreign assets. We will also discuss currency forwards and futures, quanto forwards, and return swaps.\nFor concreteness, we will call one currency the domestic currency and the other the foreign currency. Let \\(X_t\\) denote the exchange rate at time \\(t\\) measured in units of the domestic currency per unit of the foreign currency. Exchange rates can be confusing, because we can look at them from the perspective of either currency, so it may help to keep in mind that \\(X_t\\) here means the price of a unit of the foreign currency, just as we might consider the price of a stock. When we speak of the cost or value of something without specifying the currency, it should be understood to be the domestic currency that we mean. If \\(S\\) is the price of a foreign asset, denominated in units of the foreign currency, we can convert it into a domestic asset price simply by multiplying by the exchange rate: \\(X_tS_t\\) is the price of the asset, denominated in the domestic currency. For example, if the domestic currency is dollars and the foreign currency is yen, then \\(S\\) is in units of yen and \\(X\\) is units of dollars per unit of yen, so \\(XS\\) is in units of dollars.\nThroughout the chapter, we will maintain assumptions similar to the Black-Scholes assumptions. There is a foreign asset with price \\(S\\) in the foreign currency. It has a constant dividend yield \\(q\\) and a constant volatility \\(\\sigma_s\\). The exchange rate has a constant volatility \\(\\sigma_x\\) and a constant correlation \\(\\rho\\) with the foreign asset. There is a domestic risk-free asset with constant interest rate \\(r\\) and a foreign risk-free asset with constant interest rate \\(r_f\\). The term risk free means of course that they are risk-free in their respective currencies. For example, an investment in the foreign risk-free asset is not risk free to a domestic investor, because of exchange rate risk.\nA European call option on the exchange rate \\(X\\) pays \\(\\max(0,X_T-K)\\) at its maturity \\(T\\), where \\(K\\) is the strike price (in domestic currency). The underlying asset should be regarded as the foreign risk-free asset, the domestic price of which fluctuates with the exchange rate. An investment in the foreign risk-free asset grows via reinvestment of interest at rate \\(r_f\\), just as the number of shares held of a stock grows via reinvestment of dividends at rate \\(q\\), if \\(q\\) is its constant dividend yield. In particular, the cost at date \\(0\\) of obtaining one unit of foreign currency at date \\(T\\) is the cost at date \\(0\\) of \\(\\mathrm{e}^{-r_fT}\\) units of foreign currency, which is \\(\\mathrm{e}^{-r_fT}X_0\\). Thus, the exchange rate is analogous to a stock price, with the foreign risk-free rate being its dividend yield. This means we can apply the Black-Scholes formulas to value currency calls and puts:",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#currency-options",
    "href": "Chapter_FX.html#currency-options",
    "title": "12  FX and Quantos",
    "section": "",
    "text": "12.2\n\n\n\nCalls and puts on foreign currency can be valued by the Black-Scholes formulas with inputs \\(X_0 =\\) initial asset price, \\(r =\\) risk-free rate, \\(\\sigma_x =\\) volatility, and \\(r_f =\\) dividend yield.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:foreignstrike",
    "href": "Chapter_FX.html#sec-s:foreignstrike",
    "title": "12  FX and Quantos",
    "section": "12.3 Options on Foreign Assets Struck in Foreign Currency",
    "text": "12.3 Options on Foreign Assets Struck in Foreign Currency\nAn option on a foreign asset, with the strike price defined in the foreign currency, can be priced with the Black-Scholes formula, assuming the volatility and dividend yields of the asset are constant and that the (foreign) interest rate is constant. This must be true, because we did not need to specify the currency (dollars, yen, etc.) when deriving the Black-Scholes formula. The value given by the Black-Scholes formula is in the same currency as the asset. To obtain a value in domestic currency for an option on a foreign asset, we simply multiply the Black-Scholes formula by the current exchange rate.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:domesticstrike",
    "href": "Chapter_FX.html#sec-s:domesticstrike",
    "title": "12  FX and Quantos",
    "section": "12.4 Options on Foreign Assets Struck in Domestic Currency",
    "text": "12.4 Options on Foreign Assets Struck in Domestic Currency\nA call option on a foreign asset with domestic strike price \\(K\\) on the foreign asset with price \\(S\\) pays \\[\n\\max(X_TS_T-K,0)\n\\] at its maturity \\(T\\). The underlying price \\(X_TS_T\\) is the value in domestic currency of the portfolio that with starts with \\(\\mathrm{e}^{-qT}\\) units of the asset and reinvests dividends until date \\(T\\). Thus, we can use the Black-Scholes formula to value it, taking the initial asset price to be \\(\\mathrm{e}^{-qT}X_0S_0\\) and the dividend rate to be zero (or taking the initial asset price to be \\(X_0S_0\\) and the dividend rate to be \\(q\\)). The volatility that should be input into the Black-Scholes formula is the volatility of the domestic currency price \\(\\mathrm{e}^{-q(T-t)}X_tS_t\\), which is the same as the volatility of \\(X_tS_t\\).\nAccording to Equation 6.15, the volatility of the domestic currency price \\(XS\\) is \\[\n\\sigma = \\sqrt{\\sigma_x^2+\\sigma_s^2+2\\rho\\sigma_x\\sigma_s}\\;.\n\\qquad(12.1)\\]\nWe conclude:\n\n\n\n\n\n\n12.5\n\n\n\nCalls and puts on foreign assets struck in domestic currency can be valued by the Black-Scholes formulas with inputs \\(X_0S_0 =\\) initial price, \\(r =\\) risk-free rate, Equation 12.1 = volatility, \\(q =\\) dividend yield.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:currencyforwards",
    "href": "Chapter_FX.html#sec-s:currencyforwards",
    "title": "12  FX and Quantos",
    "section": "12.6 Currency Forwards and Futures",
    "text": "12.6 Currency Forwards and Futures\nConsider a forward contract maturing at some date \\(T\\) on one unit of foreign currency. In keeping with our convention for options, we will always assume (without loss of generality) that a forward contract is written on a single unit of currency. Let \\(F_t\\) denote the forward price (in domestic currency) at date \\(t\\leq T\\). This means that someone who purchases (goes long) the contract at date \\(t\\) will receive a unit of foreign currency, worth \\(X_T\\), at date \\(T\\) and must pay \\(F_t\\) at date \\(T\\). The value of the long contract at date \\(T\\) is therefore \\(X_T - F_t\\). The value at date \\(T\\) of a short contract initiated at date \\(t\\) is the opposite: \\(F_t-X_T\\). Naturally, the forward price \\(F_t\\) is called the forward exchange rate. \nThe deepest market for currency is the inter-bank forward market, but futures contracts are also traded on exchanges. The difference between forwards and futures is that futures are marked to market daily. Thus, there are daily cash flows with a futures contract, whereas the only cash flows on a forward contract occur at the maturity of the forward. In both cases, there is no cash flow at the time the contract is bought/sold, so its market value is zero. In Section 13.12 we will discuss futures contracts further. In particular, we will show, assuming continuous marking to market, that if there is a constant (domestic) risk-free rate—or, more generally, if there is an instantaneous risk-free rate that changes over time in a non-random way—then futures prices must equal forward prices in the absence of arbitrage opportunities. Thus, our assumptions in this chapter imply that currency futures prices should equal currency forward prices. We will consider currency forwards in the remainder of this section.\nA forward contract on a traded asset can always be created synthetically simply by buying the asset and holding it, using borrowed money to finance the purchase and to finance any storage costs, assuming the storage costs can be estimated in advance. If the asset pays dividends or generates other positive cash flows, then we do not need to purchase the entire amount covered by the forward contract, because we can accumulate additional amounts of the asset by reinvesting the dividends. There are no storage costs on currency and its dividend yield is equal to the foreign risk-free rate. A forward contract on one unit of foreign currency maturing at date \\(T\\) can be created synthetically at date \\(0\\) by buying \\(\\mathrm{e}^{-r_fT}\\) units of foreign currency and borrowing the cost \\(\\mathrm{e}^{-r_fT}X_0\\) at the domestic risk-free rate. This will lead to ownership of one unit of foreign currency at date \\(T\\) and a liability, including interest, of \\(\\mathrm{e}^{(r-r_f)T}X_0\\) at date \\(T\\). Thus, the forward price at date \\(0\\) must be \\(F_0 = \\mathrm{e}^{(r-r_f)T}X_0\\); otherwise, one could arbitrage by buying the forward and selling the synthetic forward, or vice versa. More generally,\n\n\n\n\n\n\n12.7\n\n\n\nThe forward exchange rate at date \\(t\\), for a contract maturing at \\(T\\), must be \\[\nF_t = \\mathrm{e}^{(r-r_f)(T-t)}X_t\\;.\n\\qquad(12.2)\\]\n\n\nThe relation Equation 12.2 is called covered interest parity. The name stems from the fact that an investment in one of the risk-free assets (foreign or domestic) financed by borrowing in the other, with the currency risk hedged (covered) by a forward contract, is certain to generate zero value (otherwise, it would be an arbitrage opportunity).1 because ownership of the physical asset may produce abnormal profits during temporary shortages, an advantage that is not obtained by owning a forward contract on the asset, just as dividends are not received by the owner of a forward contract. Thus, one must consider the convenience of owning the physical asset as an advantage analogous to dividends.\nSuppose that one has made a commitment to pay a certain amount of foreign currency (perhaps to a foreign manufacturer) at some date in the future. The exchange rate risk that this commitment entails can obviously be hedged by buying the currency forward. However, one can also create a synthetic forward, by buying currency today and investing it in the foreign risk-free asset. The cash outflow can be incurred today, or it can be deferred by borrowing the cost of the currency at the domestic risk-free rate. In the latter case, we have created a true synthetic forward. In either case, we would call this a money market hedge because we have utilized the foreign money market (risk-free asset) to create the hedge.\nLater in this chapter we will construct replicating strategies for various contracts using the foreign risk-free asset and the domestic risk-free asset. One can interpret these replicating strategies as money market hedges or synthetic currency forwards. In practice, it will often be more convenient to use actual forwards rather than using the foreign risk-free asset. Using actual currency forwards produces an equivalent (given that we are not considering transaction costs) replicating strategy. Here is, in abstract, the way we convert from money market hedges to hedges using forwards. As we have discussed, \\[\\begin{align*}\n\\text{Long Currency Forward} &= \\text{Long Synthetic Currency Forward} \\\\\n&= \\text{Long Foreign Risk-Free Asset} \\\\\n&\\qquad + \\text{Short Domestic Risk-Free Asset}\\;.\n\\end{align*}\\] Subtracting a short position is the same as adding a long position, so we can rearrange this as \\[\\begin{multline*}\n\\text{Long Currency Forward} + \\text{Long Domestic Risk-Free Asset}\\\\=  \\text{Long Foreign Risk-Free Asset} \\; .\n\\end{multline*}\\] Thus, an investment in the foreign risk-free asset can be replaced in any replicating strategy by long currency forwards and an investment in the domestic risk-free asset.\nTo be more precise about the sizes of the investments, consider replacing a money market hedge with a forward hedge at some date \\(t\\) prior to the maturity of the forward and analyze the replacement per unit of the money market hedge (per unit of foreign currency invested in the foreign risk-free asset). One unit of foreign currency invested in the foreign risk-free asset at date \\(t\\) will grow to \\(\\mathrm{e}^{r_f(T-t)}\\) units by date \\(T\\). Thus, the corresponding forward contract should be on \\(\\mathrm{e}^{r_f(T-t)}\\) units of currency. The value at date \\(t\\) of both sides of the above equation should be the same, and the value of a forward contract at the date of initiation is zero, so the investment in the domestic risk-free asset should be the domestic currency equivalent of one unit of foreign currency, which is the exchange rate \\(X_t\\). Thus, we have\n\n\n\n\n\n\n12.8\n\n\n\n\\[\n\\begin{multline}\n\\text{$\\mathrm{e}^{r_f(T-t)}$ Long Currency Forwards} \\\\+  \\text{$X_t$ Long in the Domestic Risk-Free Asset}\\\\\n= \\text{1 Unit of Foreign Currency Long in the Foreign Risk-Free Asset}\\;.\n\\end{multline}\n\\qquad(12.3)\\]\n\n\nTo check this, consider holding the portfolios until date \\(T\\). As explained in the first paragraph of this section, the currency forwards will have value \\(\\mathrm{e}^{r_f(T-t)}[X_T-F_t]\\), which by covered interest parity is \\(\\mathrm{e}^{r_f(T-t)}X_T-\\mathrm{e}^{r(T-t)}X_t\\). When we include the long position in the domestic risk-free asset with accumulated interest, the value at date \\(T\\) of the portfolio on the left-hand side of Equation 12.3 is \\(\\mathrm{e}^{r_f(T-t)}X_T\\). On the other, the right-hand side of Equation 12.3 with accumulated interest will consist of \\(\\mathrm{e}^{r_f(T-t)}\\) units of foreign currency, also worth \\(\\mathrm{e}^{r_f(T-t)}X_T\\).",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:quantos",
    "href": "Chapter_FX.html#sec-s:quantos",
    "title": "12  FX and Quantos",
    "section": "12.9 Quantos",
    "text": "12.9 Quantos\nA quanto is a derivative written on a foreign asset the value of which is converted to domestic currency at a fixed exchange rate. In other words, the contract pays in the domestic currency and the exchange rate is part of the contract. Such contracts are very useful for investors who want to bet on foreign assets but do not want exposure to exchange rate risk. Such an investor could simply buy the foreign asset and hedge the currency risk by selling currency futures or forwards, but doing so is a bit tricky because the amount of currency that needs to be hedged depends on how well the foreign asset does. Thus, quantos can be desirable contracts. Of course, when an investor purchases a quanto, the problem of hedging the exchange rate risk has simply been transferred to the seller. In this and the following section, we will see how to value and how to replicate a contract that pays the price of a foreign asset at some future date \\(T\\) with the price translated into the domestic currency at a fixed exchange rate. The replicating strategy is the strategy that would be followed by the seller (or by an investor who wants to create a synthetic on his own). Specifically, in this section we will determine the value at date \\(0\\) (in domestic currency) of a contract that pays \\(\\bar{X}S_T\\) at date \\(T\\), where \\(\\bar{X}\\) is a fixed exchange rate. Later in the chapter, we will consider quanto forwards and quanto options.\nIn addition to being practically useful, this contract is an excellent example for demonstrating the methodology of pricing and hedging. The best way to proceed in problems of this general type is to first value the contract and then calculate the replicating strategy.2: we first derived the Black-Scholes formula and then found the replicating strategy (delta hedge) by differentiating the formula. As discussed in ?sec-s:introoptions, valuation is simplified by choosing a numeraire that will cancel the randomness in the contract payoff. Our numeraire must be a dividend-reinvested (domestic) asset price, so we can choose \\(Z_t=X_t\\mathrm{e}^{qt}S_t\\) to be the numeraire asset price. This is the value in the domestic currency of a strategy that is long one unit of the foreign asset at date \\(0\\) and which reinvests the dividends of the asset into new shares. As we will see immediately, using it as numeraire introduces randomness into the payoff through the exchange rate, and that poses some complications. Applying our fundamental pricing Equation 7.28, the value of the contract is\n\\[\nZ_0 \\\\E^Z \\left[\\frac{\\bar{X}S_T}{Z_T}\\right] = \\mathrm{e}^{-qT}X_0S_0\\\\E^Z \\left[\\frac{\\bar{X}S_T}{X_TS_T}\\right]\n\\] \\[\n= \\mathrm{e}^{-qT}\\bar{X}S_0\\\\E^Z \\left[\\frac{X_0}{X_T}\\right]\\;.\n\\qquad(12.4)\\]\nNow we need to evaluate \\(\\\\E^Z[X_0/X_T]\\), which is the expected growth of \\(1/X\\) when \\(Z\\) is used as the numeraire. We will show that \\[\n\\\\E^Z \\left[\\frac{X_0}{X_T}\\right] = \\exp\\left\\{(r_f - r-\\rho\\sigma_x\\sigma_s)T\\right\\}\\;.\n\\qquad(12.5)\\]\nThis implies:\n\n\n\n\n\n\n12.10\n\n\n\nThe value at date \\(0\\) of a contract that pays \\(\\bar{X}S_T\\) at date \\(T\\), where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign price of an asset with a constant dividend yield \\(q\\), is \\[\n\\exp\\left\\{(r_f - r-q-\\rho\\sigma_x\\sigma_s)T\\right\\}\\bar{X}S_0\\;.\n\\qquad(12.6)\\]\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will now prove Equation 12.5. The assumption that \\(S\\) and \\(X\\) have constant volatilities and correlation means that\n\\[\\begin{align*}\n\\frac{\\,\\mathrm{d}X}{X} &= \\mu_x\\,\\mathrm{d}t+\\sigma_x\\,\\mathrm{d}B_x\\;,\\\\\n\\frac{\\,\\mathrm{d}S}{S} &= \\mu_s\\,\\mathrm{d}t+\\sigma_s\\,\\mathrm{d}B_s\\;,\n\\end{align*}\\] for some (possibly random) \\(\\mu_x\\) and \\(\\mu_s\\), where \\(B_s\\) and \\(B_x\\) are Brownian motions with correlation equal to \\(\\rho\\). From Ito’s formula, we have \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}Z}{Z} &= q\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}(XS)}{XS}\\\\\n&= \\left(q+\\mu_x +\\mu_s+ \\rho\\sigma_x\\sigma_s\\right)\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B_x + \\sigma_s\\,\\mathrm{d}B_s \\\\\n&= \\left(q+\\mu_x +\\mu_s+ \\rho\\sigma_x\\sigma_s\\right)\\,\\mathrm{d}t + \\sigma\\left(\\frac{\\sigma_x}{\\sigma}\\,\\mathrm{d}B_x + \\frac{\\sigma_s}{\\sigma}\\,\\mathrm{d}B_s\\right) \\\\\n&= \\left(q+\\mu_x +\\mu_s+ \\rho\\sigma_x\\sigma_s\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;,\n\\end{align*}\\] where we define \\(\\sigma\\) in Equation 12.1 and \\(B\\) by \\(B_0=0\\) and \\[\\,\\mathrm{d}B = \\frac{\\sigma_x}{\\sigma}\\,\\mathrm{d}B_x + \\frac{\\sigma_s}{\\sigma}\\,\\mathrm{d}B_s\\; .\\] As discussed in Section 6.6, \\(B\\) is a Brownian motion and \\(\\sigma\\) is the volatility of \\(Z\\). Notice that the correlation of \\(X\\) and \\(Z\\) is \\[\\begin{align*}\n(\\,\\mathrm{d}B)(\\,\\mathrm{d}B_x) &= \\left(\\frac{\\sigma_x}{\\sigma}\\,\\mathrm{d}B_x + \\frac{\\sigma_s}{\\sigma}\\,\\mathrm{d}B_s\\right)(\\,\\mathrm{d}B_x)\\\\\n&= \\frac{\\sigma_x + \\rho\\sigma_s}{\\sigma}\\,\\mathrm{d}t\\;.\n\\end{align*}\\] Now we use Equation 9.8 in ?sec-s:girsanov which gives the drift of an asset when another risky asset is used as the numeraire. We use \\(Z\\) as the numeraire and \\(X\\) as the other asset, regarding \\(X\\) as the domestic price of an asset with dividend yield \\(r_f\\) as before. Therefore, we substitute \\(r_f\\) for \\(q\\) in Equation 9.8, substitute \\(\\sigma\\) for the volatility of the numeraire asset price, substitute \\(\\sigma_x\\) for the volatility of the other asset, and substitute \\((\\sigma_x+\\rho\\sigma_s)/\\sigma\\) for their correlation. This yields \\[\\frac{\\,\\mathrm{d}X}{X} = \\left(r-r_f+\\sigma_x^2+\\rho\\sigma_x\\sigma_s\\right)\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B^*_x\\; ,\\] where \\(B^*_x\\) is a Brownian motion when \\(Z\\) is the numeraire.\nNow we apply Ito’s formula for ratios to obtain \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}(1/X)}{1/X} &= -\\frac{\\,\\mathrm{d}X}{X} + \\left(\\frac{\\,\\mathrm{d}X}{X}\\right)^2\\\\\n&= \\left(r_f-r-\\rho\\sigma_x\\sigma_s\\right)\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B^*_x\\;.\n\\end{align*}\\] This implies that \\(1/X\\) is a geometric Brownian motion with growth rate \\(r_f-r-\\rho\\sigma_x\\sigma_s\\), from which Equation 12.5 follows.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:replicatingquantos",
    "href": "Chapter_FX.html#sec-s:replicatingquantos",
    "title": "12  FX and Quantos",
    "section": "12.11 Replicating Quantos",
    "text": "12.11 Replicating Quantos\nThe assets we will use to replicate the payoff \\(\\bar{X}S_T\\) are the foreign asset with price \\(S\\), the foreign risk-free asset, and the domestic risk-free asset. At the end of this section, we will explain how to replace the foreign risk-free asset with currency forwards, as discussed in Section 12.6. Before beginning the calculations, we can make the following intuitive observations:\n\nThe payoff \\(\\bar{X}S_T\\) has exposure to the foreign asset price \\(S\\), so the replicating portfolio must be long the foreign asset.\n\nThe payoff \\(\\bar{X}S_T\\) has no exposure to the exchange rate, so the replicating portfolio cannot have any exposure to the exchange rate either. Thus, the long position in the foreign risky asset must be offset by an equal short position in the foreign risk-free asset.\n\nAs a result of the previous observation, the value of the replicating portfolio, displayed in Equation 12.6, will equal the investment in the domestic risk-free asset.\n\nConsequently, our real task is to compute the number of shares of the foreign asset that should be held, the remainder of the replicating portfolio being thereby determined.\nThe value of the replicating portfolio at any date \\(t\\leq T\\) must be the value at date \\(t\\) of receiving the payoff \\(\\bar{X}S_T\\) at date \\(T\\). We have calculated this value at date \\(0\\), and, clearly, Equation 12.6 applies to general dates \\(t\\), when we replace the time \\(T\\) to maturity by \\(T-t\\) and the asset price \\(S_0\\) at the date of valuation by \\(S_t\\). That is, the value of the portfolio at any date \\(t\\leq T\\) must be \\(V_t\\) defined as \\[\nV_t = \\exp\\left\\{(r_f - r-q-\\rho\\sigma_x\\sigma_s)(T-t)\\right\\}\\bar{X}S_t\\;.\n\\qquad(12.7)\\]\nAs just noted, we will need to invest this amount in the domestic risk-free asset at date \\(t\\). What remains to be done is to calculate the size of the long position in the foreign risky asset and the offsetting short position in the foreign risk-free asset.\nFrom Ito’s formula, we have \\[\n\\frac{\\,\\mathrm{d}V}{V} = -(r_f - r-q-\\rho\\sigma_x\\sigma_s)\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}S}{S}\\;.\n\\qquad(12.8)\\]\nEquivalently, \\[\n\\,\\mathrm{d}V =(r+q-r_f+\\rho\\sigma_x\\sigma_s)V\\,\\mathrm{d}t + V\\frac{\\,\\mathrm{d}S}{S}\\;.\n\\qquad(12.9)\\]\nOn the other hand, consider a strategy that invests \\(a_t\\) units of the domestic currency in the foreign asset, \\(b_t\\) units of the domestic currency in the foreign risk-free asset, and \\(c_t\\) units of the domestic currency in the domestic risk-free asset. Let \\(W=a+b+c\\) denote the value of this portfolio. The return on the foreign asset, per unit of domestic currency invested, is\n\\[\n\\frac{\\,\\mathrm{d}(X\\mathrm{e}^{qt}S)}{X\\mathrm{e}^{qt}S} = q\\,\\mathrm{d}t+\\frac{\\,\\mathrm{d}X}{X} + \\frac{\\,\\mathrm{d}S}{S} + \\left(\\frac{\\,\\mathrm{d}X}{X} \\right)\\left( \\frac{\\,\\mathrm{d}S}{S}\\right)\n\\] \\[\n= (q+\\rho\\sigma_x\\sigma_s)\\,\\mathrm{d}t+\\frac{\\,\\mathrm{d}X}{X} + \\frac{\\,\\mathrm{d}S}{S}\\;.\n\\qquad(12.10)\\]\nSimilarly, the rate of return on the foreign risk-free asset is \\[\n\\frac{\\,\\mathrm{d}(\\mathrm{e}^{r_ft}X)}{\\mathrm{e}^{r_ft}X} = r_f\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}X}{X}\\;,\n\\qquad(12.11)\\]\nand of course the rate of return on the domestic risk-free asset is \\(r\\,\\mathrm{d}t\\). Therefore, the change in the value of the portfolio will be\n\\[\n\\,\\mathrm{d}W = a\\left[(q+\\rho\\sigma_x\\sigma_s)\\,\\mathrm{d}t+\\frac{\\,\\mathrm{d}X}{X} + \\frac{\\,\\mathrm{d}S}{S}\\right] + b\\left[r_f\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}X}{X}\\right] + cr\\,\\mathrm{d}t\n\\] \\[\n=( aq+a\\rho\\sigma_x\\sigma_s + br_f+cr)\\,\\mathrm{d}t +  (a+b)\\frac{\\,\\mathrm{d}X}{X} +a \\frac{\\,\\mathrm{d}S}{S}\\; .\n\\qquad(12.12)\\]\nThe change Equation 12.12 of the portfolio value will match the change Equation 12.9 of \\(V\\) if and only if \\[\na= V, \\qquad b= -V, \\qquad c = V\\;.\n\\qquad(12.13)\\]\nThis implies:\n\n\n\n\n\n\n12.12\n\n\n\nThe strategy that replicates the payoff \\(\\bar{X}S_T\\) at date \\(T\\) is to invest \\(V_t\\) units of domestic currency in the foreign asset, where \\(V_t\\) is defined in Equation 12.7. This will purchase \\[\n\\frac{V_t}{X_tS_t} = \\frac{\\bar{X}}{X_t}\\exp\\left\\{(r_f - r-q-\\rho\\sigma_x\\sigma_s)(T-t)\\right\\}\n\\qquad(12.14)\\]\nshares of the foreign asset. This position is financed entirely by borrowing at the foreign risk-free rate. On the other hand, the same amount \\(V_t\\) of the domestic currency is invested in the domestic risk-free asset.\n\n\nFrom our analysis at the end of Section 12.6, we know that the foreign risk-free asset in this replicating strategy can be replaced by currency forwards. The strategy here involves borrowing at the foreign risk-free rate, so we should replace long by short in Equation 12.3. Borrowing \\(V_t\\) units of domestic currency means borrowing \\(V_t/X_t\\) units of the foreign currency. Therefore, Equation 12.3 gives us:\n\n\n\n\n\n\n12.13\n\n\n\nAn equivalent strategy for replicating the payoff \\(\\bar{X}S_T\\) at date \\(T\\) is to invest \\(V_t\\) units of domestic currency in the foreign asset and to be short \\(\\mathrm{e}^{r_f(T-t)}V_t/X_t\\) currency forwards at date \\(t\\).\n\n\nAt the beginning of the previous section, we noted that an investor who wants to bet on a foreign asset but does not want the exchange rate exposure could simply buy the asset and sell the currency forward. This shows how much of the asset he should buy and how much currency he should sell forward.\nIt is important to note that this strategy involves continuously buying and selling forwards, just as it involves continuously trading the foreign asset. Buying at date \\(t\\) a forward contract sold at date \\(s&lt;t\\) cancels the delivery obligation on the contract sold at \\(s\\) and leaves a cash flow of \\(F_s-F_t\\) to be paid/received at the maturity date \\(T\\). Therefore, the strategy accumulates a liability or asset, depending on the direction the forward price moves, to be received at \\(T\\). On the other hand, maintaining an investment of \\(V_t\\) in the foreign asset will generate cash flows as the asset is sold or purchased over time. As Equation 12.14 shows, whether it is sold or purchased depends on the direction the exchange rate moves. These cash flows should be invested or borrowed at the domestic risk-free rate. Thus, there is a liability or asset to be received at date \\(T\\) that is not shown in the boxed statement immediately above, and there is an investment or liability in the domestic risk-free asset that is not shown. It can be demonstrated that these cancel each other: if profits are made from trading forwards, then they (more precisely, their present value) will be consumed by the cost of buying the foreign asset, and vice versa. Hedging with forwards (and with futures) is considered in more detail in Section 13.16.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:quantoforwards",
    "href": "Chapter_FX.html#sec-s:quantoforwards",
    "title": "12  FX and Quantos",
    "section": "12.14 Quanto Forwards",
    "text": "12.14 Quanto Forwards\nIn this section, we consider a contract similar to that of the previous section, except that it is a pure forward, meaning that the payment for the contract occurs at date \\(T\\). We maintain all of the assumptions of the previous section. The payment at date \\(T\\) is in domestic currency, and we define the quanto forward price in units of domestic currency. Specifically, a long quanto forward contract, initiated at date \\(t\\) and maturing at date \\(T\\) and initiated at the forward price \\(F^*_t\\) will pay \\[\\bar{X}S_T-F^*_t\\] at date \\(T\\). The forward price \\(F^*_t\\) should be the price that makes this contract have a value of 0 at date \\(t\\).\nWe already know how to replicate the underlying payoff \\(\\bar{X}S_T\\) of the forward contract at the cost \\(V_t\\) defined in Equation 12.7. Thus, the synthetic quanto forward is to purchase the replicating strategy and to borrow the cost \\(V_t\\) at the domestic risk-free rate. This leads to the liability \\(\\mathrm{e}^{r(T-t)}V_t\\) at date \\(T\\). Therefore, we have:\n\n\n\n\n\n\n12.15\n\n\n\nThe quanto forward price is \\[\nF^*_t = \\mathrm{e}^{r(T-t)}V_t = \\exp\\left\\{(r_f - q-\\rho\\sigma_x\\sigma_s)(T-t)\\right\\}\\bar{X}S_t\\;.\n\\qquad(12.15)\\]\n\n\nNotice that borrowing \\(V\\) in domestic currency to finance the replicating strategy of the previous section — i.e., the domestic currency investments described in Equation 12.13 — means eliminating the domestic risk-free investment \\(c=V\\) required in the previous section. The replicating strategy for the quanto forward is simply to invest \\(V\\) in the foreign asset and to finance the investment entirely by borrowing at the foreign risk-free rate. As in the previous section, borrowing at the foreign risk-free rate can be replaced by borrowing at the domestic risk-free rate and selling currency forwards.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:quantooptions",
    "href": "Chapter_FX.html#sec-s:quantooptions",
    "title": "12  FX and Quantos",
    "section": "12.16 Quanto Options",
    "text": "12.16 Quanto Options\nConsider now a European call option on a foreign asset, with strike \\(K\\) set in the domestic currency and the value of the foreign asset being converted to domestic currency at a fixed exchange rate \\(\\bar{X}\\). This is called a quanto call. We maintain all the assumptions of the previous two sections.\nThe value of the quanto call at maturity is \\(\\max(0, \\bar{X}S_T-K)\\). To value this, we make use of what we learned in Section 12.9. Namely, the portfolio with value \\(V\\) defined in Equation 12.7 replicates the payoff \\(\\bar{X}S_T\\): in each state of the world, \\(V_T = \\bar{X}S_T\\). Therefore, the quanto call is equivalent to a standard European call on the portfolio with domestic currency price \\(V\\). The value is therefore given by the Black-Scholes formula. From Equation 12.8 for the dynamics of \\(V\\), we see that the volatility of \\(V\\) is the same as that of \\(S\\); therefore, we should input \\(\\sigma_s\\) as the volatility in the Black-Scholes formula. Furthermore, the portfolio \\(V\\) is dividend-reinvested (it is the value of a claim to \\(\\bar{X}S_T\\) at date \\(T\\) with no interim cash flows), so the dividend rate in the Black-Scholes formula should be zero. Thus, we have:\n\n\n\n\n\n\n12.17\n\n\n\nThe value of a quanto call is\n\\[\\begin{multline}\nV_0\\mathrm{N}(d_1) - \\mathrm{e}^{-rT}K\\mathrm{N}(d_2) \\\\= \\exp\\left\\{(r_f - r-q-\\rho\\sigma_x\\sigma_s)T\\right\\}\\bar{X}S_0\\mathrm{N}(d_1) - \\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\end{multline}\\] {#eq-quantocall21}\nwhere\n\\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_s^2\\right)T}{\\sigma_s\\sqrt{T}}\n\\] \\[\n= \\frac{\\log\\left(\\frac{\\bar{X}S_0}{K}\\right)+\\left(r_f-q-\\rho\\sigma_x\\sigma_s+\\frac{1}{2}\\sigma_s^2\\right)T}{\\sigma_s\\sqrt{T}}\\; ,\n\\] \\[\nd_2 = d_1 - \\sigma_s\\sqrt{T}\\;.\n\\]\nLikewise, the value of a quanto put is given by the Black-Scholes formula: \\[\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2) - V_0\\mathrm{N}(-d_1)\\; .\\]\n\n\nNotice that this is simply the Black-Scholes call option formula with inputs \\(V_0=\\) initial asset price, \\(K=\\) exercise price, \\(r=\\) interest rate, \\(\\sigma_s=\\) volatility, \\(0=\\) dividend yield, and \\(T=\\) time to maturity.\nWe can hedge a written quanto call the same way we hedge a written ordinary call: we buy delta shares of the underlying and borrow the difference between the cost of the delta shares and the option value. However, for the quanto call, the underlying should be regarded as the portfolio with value \\(V\\) described in Section 12.9. This portfolio consists of investing \\(V_0\\) units of domestic currency in the foreign asset, borrowing the same amount at the foreign risk-free rate, and investing \\(V_0\\) units of domestic currency in the domestic risk-free asset. The delta of the call is \\(\\mathrm{N}(d_1)\\), so the hedge consists of investing \\(\\mathrm{N}(d_1)V_0\\) units of domestic currency in the foreign asset, borrowing the same amount at the foreign risk-free rate, and investing \\(\\mathrm{N}(d_1)V_0\\) in the domestic risk-free asset. The difference between the cost of this portfolio and the value of the option is \\[\\mathrm{N}(d_1)V_0 - [V_0\\mathrm{N}(d_1) - \\mathrm{e}^{-rT}K\\mathrm{N}(d_2)] = \\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\; .\\] This amount is to be borrowed at the domestic risk-free rate. Thus, the net investment in the domestic risk-free asset is \\[\\mathrm{N}(d_1)V_0 - \\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\; ,\\] which is just the value of the option. To summarize:\n\n\n\n\n\n\n12.18\n\n\n\nTo delta-hedge a written quanto call, one should invest \\(\\mathrm{N}(d_1)V_0\\) units of domestic currency in the foreign asset, borrow the same amount at the foreign risk-free rate, and invest the value of the option in the domestic risk-free asset.\n\n\nAs in Section 12.11, borrowing \\(\\mathrm{N}(d_1)V_0\\) units of domestic currency at the foreign risk-free rate can be replaced by borrowing the same amount at the domestic risk-free rate and selling \\(\\mathrm{e}^{r_fT}\\mathrm{N}(d_1)V_0/X_0\\) currency forwards. This results in:\n\n\n\n\n\n\n12.19\n\n\n\nAn equivalent delta hedge for a written quanto call is to invest \\(\\mathrm{N}(d_1)V_0\\) units of domestic currency in the foreign asset, sell \\(\\mathrm{e}^{r_fT}\\mathrm{N}(d_1)V_0/X_0\\) currency forward contracts at the market forward price \\(F_0\\), and borrow \\(\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\) at the domestic risk-free rate.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#sec-s:returnswaps",
    "href": "Chapter_FX.html#sec-s:returnswaps",
    "title": "12  FX and Quantos",
    "section": "12.20 Return Swaps",
    "text": "12.20 Return Swaps\nThere are many types and applications of return swaps, but here is one important example that involves the concepts discussed in this chapter. Suppose an investor wants to receive at date \\(T\\) the difference in the rates of return of two assets that are denominated in different currencies. The return will be calculated on a given notional principal. For example, an investor may want to receive at the end of a year the Nikkei rate of return minus the rate of return on the S&P 500, calculated on a $1 million notional principal. If the Nikkei earns 15% over the year and the S&P earns 10%, then the payment to the investor is 5% of $1 million. If the reverse happens—the Nikkei earns 10% and the S&P earns 15%—then the investor must pay 5% of $1 million to the counterparty.\nTo model this, let \\(S_f\\) denote the price of a foreign asset and \\(S_d\\) the price of a domestic asset. Assume they have constant dividend yields \\(q_f\\) and \\(q_d\\). If the returns are calculated excluding dividends, as is likely to be the case, then the payment to the investor is \\[\\left(\\frac{S_f_T-S_f_0}{S_f_0} - \\frac{S_d_T-S_d_0}{S_d_0}\\right)  A = \\left(\\frac{S_f_T}{S_f_0} - \\frac{S_d_T}{S_d_0}\\right)  A\\; ,\\] where \\(A\\) denotes the notional principal. Of course, the investor may want the reverse swap, and we consider this particular case only for concreteness.\nThe swap may have nonzero market value at date \\(0\\), which means that some payment will have to be made upfront. To eliminate this, we can add a swap spread into the contract, affecting the cash flow at date \\(T\\). This is a constant number \\(a\\) (which may be positive or negative), and including it changes the payment to the investor to \\[\n\\left(a+\\frac{S_f_T}{S_f_0} - \\frac{S_d_T}{S_d_0}\\right)  A\\;.\n\\qquad(12.16)\\]\nThe question we will address here is: what is the fair swap spread; i.e., for what number \\(a\\) does the cash flow Equation 12.16 have zero market value at date \\(0\\)?\nIf the value is zero, then it is zero for any notional principal \\(A\\), so we can conveniently take \\(A=1\\). The cash flow consists of three pieces, all of which are to be received/paid at date \\(T\\): the constant \\(a\\), the gross return on the foreign asset, and the gross return on the domestic asset. The value at date \\(0\\) of receiving \\(a\\) units of domestic currency is obviously \\(\\mathrm{e}^{-rT}a\\). As we have observed several times before, the value at date \\(0\\) of receiving \\(S_d_T\\) units of domestic currency at date \\(T\\) is \\(\\mathrm{e}^{-q_d t}S_d_0\\), because this is the cost of enough shares to accumulate to one share at date \\(T\\) via reinvestment of dividends. Therefore, the value at date \\(0\\) of receiving \\(S_d_T/S_d_0\\) at date \\(T\\) is \\(\\mathrm{e}^{-q_dT}S_d_0/S_d_0 = \\mathrm{e}^{-q_dT}\\).\nWhat remains is to calculate the value of receiving \\(S_f_T/S_f_0\\) units of domestic currency at date \\(T\\). We can do this by interpreting \\(1/S_f_0\\) as the fixed exchange rate \\(\\bar{X}\\) in the definition of a quanto.3 We need to assume as before that the foreign asset price \\(S_f\\) and the exchange rate have constant volatilities and a constant correlation. Denoting the volatilities by \\(\\sigma_s\\) and \\(\\sigma_x\\) and the correlation by \\(\\rho\\) as before, equation~Equation 12.6 shows that the value of receiving \\(\\bar{X}S_f_T = S_f_T/S_f_0\\) units of domestic currency at date \\(T\\) is \\[\\exp\\left\\{(r_f - r-q_f-\\rho\\sigma_x\\sigma_s)T\\right\\}\\; .\\] Adding up the pieces, the value at date \\(0\\) of the cash flow Equation 12.16 (with \\(A=1\\)) is \\[\\mathrm{e}^{-rT}a + \\exp\\left\\{(r_f - r-q_f-\\rho\\sigma_x\\sigma_s)T\\right\\} - \\mathrm{e}^{-q_dT}\\; ,\\] so we conclude:\n\n\n\n\n\n\n12.21\n\n\n\nThe fair swap spread, which equates the value at date \\(0\\) of receiving the cash flow Equation 12.16 at date T to zero, is \\[\na = \\exp\\left\\{(r-q_d)T\\right\\} - \\exp\\left\\{(r_f -q_f-\\rho\\sigma_x\\sigma_s)T\\right\\}\\;.\n\\qquad(12.17)\\]\n\n\nWhen we use numerical methods to value American and path-dependent options, as in ?sec-c:introcomputation, we typically focus on the dynamics of asset prices under the risk-neutral probability. To apply these results to currency options or options on foreign assets, we need to know the dynamics of the exchange rate under the risk-neutral probability. Because we can view the exchange rate as the domestic price of an asset with the foreign risk-free rate \\(r_f\\) being its dividend yield, we have already calculated these dynamics in equation~Equation 9.3 of ?sec-s:girsanov. The result is:\n\n\n\n\n\n\n12.22\n\n\n\nThe exchange rate \\(X\\) must satisfy \\[\n\\frac{\\,\\mathrm{d}X}{X} = (r-r_f)\\,\\mathrm{d}t + \\sigma_x\\,\\mathrm{d}B^*_x\n\\qquad(12.18)\\]\nfor some process \\(\\sigma_x\\), where \\(B^*_x\\) is a Brownian motion under the risk-neutral probability.\n\n\nThis equation has an interesting interpretation in terms of uncovered interest parity, which is the theory that differences in interest rates across currencies will be offset on average by appreciation/depreciation of the currencies. In other words, it is the theory that the strategy of borrowing in low-interest-rate currencies to invest in high-interest-rate currencies will not earn money on average because of depreciation of the high-interest-rate currency relative to the low-interest-rate currency. It is well known that this theory is not always true in reality. However, equation~Equation 12.18 shows that it is true when we calculate expectations using the risk-neutral probability.\nTo see the interpretation of equation~Equation 12.18 as uncovered interest parity, suppose that the foreign interest rate \\(r_f\\) is lower than the domestic rate \\(r\\). Then one may be tempted to borrow at the foreign rate and invest at the domestic rate. This would create a short position in the foreign currency. Equation 12.18 states that the exchange rate is expected (under the risk-neutral probability) to appreciate at the rate \\(r-r_f\\); thus, repayment of the foreign currency will be more expensive in terms of domestic currency, offsetting the interest rate differential.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#section-13",
    "href": "Chapter_FX.html#section-13",
    "title": "12  FX and Quantos",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nCreate a python code to compare the values of call options on foreign assets that are (i) struck in foreign currency or (ii) struck in domestic currency. Prompt the user to input \\(X_0\\), \\(S_0\\), \\(K\\), \\(r\\), \\(r_f\\), \\(\\sigma_x\\), \\(\\sigma_s\\), \\(\\rho\\), \\(q\\) and \\(T\\). Take the strike price of the option struck in foreign currency to be \\(K\\) and take the strike price of the option struck in domestic currency to be \\(X_0K\\) (so \\(K\\) is interpreted as an amount in foreign currency). You should be able to confirm, for example, that if \\(r=r_f\\) and \\(\\rho \\geq 0\\) then the option struck in domestic currency is more valuable.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the preceding problem comparing (i) call options struck in foreign currency, versus (ii) quanto call options. Use the same inputs as in the preceding problem and take the fixed exchange rate in the quanto to be \\(\\bar{X}=X_0\\). You should be able to confirm, for example, that if \\(r=r_f\\) and \\(\\rho \\geq 0\\) then the option struck in foreign currency is more valuable.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a python code in which the user inputs \\(r\\) and \\(r_f\\) and the exchange rate. Compute the forward exchange rate at maturities \\(T=0.1, 0.2, \\dots, 2.0\\) and plot the forward rate against the maturity in a scatter plot. A market is said to be in contango if this curve is upward sloping and to be in backwardation if this curve is downward sloping. For currencies, what determines whether the market is in contango or in backwardation?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function to simulate a path of the exchange rate and the forward exchange rate under the risk-neutral probability, prompting the user to input \\(X_0\\), \\(r\\), \\(r_f\\), \\(\\sigma_x\\), and the maturity \\(T\\) of the forward contract.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function to simulate a path of the exchange rate under the actual probability measure, prompting the user to input \\(X_0\\), \\(\\sigma_x\\), and the expected rate of growth \\(\\mu\\) of the exchange rate under the actual probability measure. Prompt the user also to input \\(S_0\\), \\(r\\), \\(r_f\\), \\(\\sigma_s\\), \\(q\\), \\(\\rho\\), a fixed exchange rate \\(\\bar{X}\\), a maturity \\(T\\), and a number of periods \\(N\\). Calculate the gain/loss from the portfolio that promises to pay \\(\\bar{X}S_T\\) at date \\(T\\) and uses a discretely rebalanced hedge, rebalancing at dates \\(t_1,\\ldots t_N=T\\), where \\(t_i-t_{i-1} = T/N\\), similar to the calculation in the function Simulated_Delta_Hedge_Profit. Use the money-market hedge, which means investing \\(V_0\\) at date \\(0\\), holding the number of shares of the foreign asset shown in Equation 12.14 at each date \\(t_i\\), and having a short position in the foreign risk-free asset of the same value at each date \\(t_i\\). Cash flows generated at each date from buying/selling the foreign asset and lending/borrowing at the foreign risk-free rate should be withdrawn/deposited in the domestic risk-free asset. Note: Because of discrete rebalancing, this is not a perfect hedge, and the investment in the domestic risk-free asset will not always equal \\(V_t\\).\n\n\n\n\nExercise 12.1 Repeat the previous exercise using the forward contract hedge discussed in Section 12.11. The cash flows generated from trading forwards cannot be withdrawn/deposited in the domestic risk-free asset, because they do not materialize until the maturity of the forward. You will have to create a variable to keep track of the net asset/liability and include it in the valuation at date \\(T\\).\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive the money-market hedge and the forward contract hedge for a written quanto put.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nSuppose a customer has contracted with you for a return swap in which the customer will receive the cash flow Equation 12.16 for some number \\(a\\), where \\(A=1\\). How can you hedge this?",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_FX.html#footnotes",
    "href": "Chapter_FX.html#footnotes",
    "title": "12  FX and Quantos",
    "section": "",
    "text": "A relation analogous to covered interest parity holds for any forward contract if the underlying asset has a constant dividend yield and storage costs that are a constant proportion of the value of the units stored. For commodities, the term dividend yield must be interpreted in a broad sense, and is usually called convenience yield, ↩︎\nWe did the same thing in Chapter 10↩︎\nTo make sense of the units, note that the cash flow of \\(S_f_T/S_f_0\\) units of domestic currency can be calculated as \\(S_f_T\\) units of foreign currency times \\(1/S_f_0\\) units of domestic currency per unit of foreign currency. Therefore, the units of \\(1/S_f_0\\) can be taken to be the units of an exchange rate.↩︎",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>FX and Quantos</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html",
    "href": "Chapter_Merton.html",
    "title": "13  Merton, Black, and Margrabe",
    "section": "",
    "text": "13.1 Margrabe’s Formula\nIn this chapter, we will derive three important generalizations of the Black-Scholes formula. We will derive them from the Black-Scholes formula, which shows that all of the formulas are equivalent. We will start with Margrabe’s (Margrabe 1978) formula for an option to exchange one asset for another. Standard calls and puts are special cases, involving the exchange of cash for an asset or an asset for cash. From Margrabe’s formula, we will derive Black’s (Black 1976) formulas for options on forward and futures contracts. Then, from Black’s formulas, we will derive Merton’s (Merton 1973) formulas for calls and puts in the absence of a constant risk-free rate.\nUnless explicitly stated otherwise, we will not assume in this chapter the existence of a risk-free asset (or even an instantaneously risk-free asset as described in Chapter 7). This implies that the market is incomplete and there are many risk-neutral probabilitys. Nevertheless, we can price exchange options, forward and futures options, and stock options by arbitrage. Understanding this issue is not essential for deriving the formulas in this chapter—as mentioned, they will all be derived from the Black-Scholes formula—but the issue is nonetheless important. It is discussed in the final section of the chapter.\nNaturally, all of the option-pricing formulas discussed in this chapter are quite similar. The similarity can be seen from the Black-Scholes formula for a call option, which we can write as follows (replacing \\(d_1\\) by \\(x\\) and \\(d_2\\) by \\(y\\)): \\[\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(x) - \\mathrm{e}^{-rT}K\\mathrm{N}(y)\\;,\n\\qquad(13.1)\\]\nwhere\n\\[\nx=\\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\qquad(13.2)\\]\n\\[\ny = x -\\sigma\\sqrt{T}\\;.\n\\qquad(13.3)\\]\nNote that \\(\\mathrm{e}^{-qT}S_0\\) is the present value at date \\(0\\) of the stock that would be acquired if the option is exercised, because it is the cost that one must pay at date \\(0\\) to have one share of the stock at date \\(T\\) with no withdrawal of dividends in the interim. Obviously, \\(\\mathrm{e}^{-rT}K\\) is the present value of the cash that is paid if the option is exercised. Moreover, \\(x\\) is equal to \\[\\frac{\\log \\left(\\frac{\\mathrm{e}^{-qT}S_0}{\\mathrm{e}^{-rT}K} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\] and the logarithm in the numerator is of the ratio of present values. All of the option pricing formulas in this chapter have the same form: the present value of the asset to be acquired multiplied by \\(\\mathrm{N}(x)\\) minus the present value of the asset to be delivered multiplied by \\(\\mathrm{N}(y)\\). Moreover in each case \\(x\\) is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\) all divided by \\(\\sigma\\sqrt{T}\\), and in each case \\(y\\) is defined by Equation 13.3. Notice that the Black-Scholes put option formula has this structure also. The Black-Scholes put option formula is \\[\n\\mathrm{e}^{-rT}K\\mathrm{N}(x) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(y)\\;,\n\\qquad(13.4)\\]\nwhere\n\\[\nx =-d_2\n=  - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q-\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\] \\[\n=\\frac{\\log \\left(\\frac{\\mathrm{e}^{-rT}K}{\\mathrm{e}^{-qT}S_0} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.5)\\]\n\\[\ny=-d_1\n= - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n=x - \\sigma\\sqrt{T}\\;.\n\\] This similarity is discussed further in later, where the pricing formulas are implemented in Python.\nConsider two assets with prices \\(S_1\\) and \\(S_2\\) and a European option to exchange asset 2 for asset 1 at date \\(T\\). The value of the option at maturity is \\[\\max(0,S_1_T-S_2_T)\\; .\\] Note that there is no real difference between a put and a call: the exchange option can be viewed as a call on the first asset with random strike \\(S_2_T\\) or as a put on the second asset with random strike \\(S_1_T\\).\nAssume the assets pay constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\,\\mathrm{d}S_i}{S_i} = \\mu_i\\,\\mathrm{d}t+\\sigma_i\\,\\mathrm{d}B_i\\] where each \\(B_i\\) is a Brownian motion under the actual probability measure. As before, the drifts \\(\\mu_i\\) can be quite general random processes. We also allow the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the Brownian motions to be random processes; however, we make the assumption that \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\n\\qquad(13.6)\\]\nis a constant. As shown in Equation 6.17, \\(\\sigma\\) is the volatility of \\(S_1/S_2\\) (and also \\(S_2/S_1\\)). So, the assumption we are making is that the volatility of the ratio of the asset prices is constant. In Section 13.15, we will relax this assumption to allow \\(\\sigma\\) to be time-varying (though still non-random).\nThe following is the formula of Margrabe (Margrabe 1978):\nMargrabe’s derivation is a very simple argument based on the Black-Scholes formula. We noted in Chapter 12 that the Black-Scholes formula does not depend on the currency—if the underlying asset and risk-free asset are dollar denominated, the formula gives the dollar value of an option; if they are yen denominated, the formula gives the yen value of an option, etc. So we can take the currency to be units of the second asset; i.e., we will use the second asset as numeraire. With this numeraire, the value of the first asset is \\(S_1/S_2\\). The value of the exchange option at maturity is \\[\\max(0,S_1_T-S_2_T) = S_2_T\\max\\left(0,\\frac{S_1_T}{S_2_T}-1\\right)\\; .\\] This is the value in the natural currency (e.g., dollars). The value using the second asset as numeraire is obtained by dividing by \\(S_2_T\\), so it is \\[\\max\\left(0,\\frac{S_1_T}{S_2_T}-1\\right)\\; .\\] This is the value of a standard call option, the underlying being the first asset measured in units of the second. We can apply the Black-Scholes formula to obtain the value of the option (in units of the second asset) at date \\(0\\). Multiplying this value by \\(S_2_0\\) will give the option value in the natural currency.\nThe risk-free rate when the second asset is the numeraire is the dividend yield on the second asset \\(q_2\\). To see this, note that the price of the second asset is always equal to one; moreover, an investment in the second asset will accumulate at the rate \\(q_2\\) via reinvestment of dividends. Therefore, \\(q_2\\) is a risk-free rate of return.\nThe dividend yield on the first asset remains \\(q_1\\). To see this, note that the dividend paid in the natural currency is \\(q_1S_1_t\\,\\mathrm{d}t\\) in an instant \\(\\,\\mathrm{d}t\\) and the value of this dividend using the second asset as numeraire is \\([q_1S_1_t/S_2_t]\\,\\mathrm{d}t\\), which is the fraction \\(q_1\\,\\mathrm{d}t\\) of the value \\(S_1_t/S_2_t\\) of the first asset using the second asset as numeraire.\nThe volatility of the first asset using the second as numeraire is the volatility of the ratio \\(S_1_t/S_2_t\\), which is \\(\\sigma\\) defined in Equation 13.6. Applying the Black-Scholes formula with these inputs yields Margrabe’s formula directly.1.\nIn terms of programming, we could of course write entirely separate programs for the options discussed so far and those to be discussed in this chapter but it will become clear that they have common structure. As discussed in the introduction to this chapter, each is the present value of what is received upon exercise multiplied by \\(\\mathrm{N}(x)\\) minus the present value of what is delivered upon exercise multiplied by \\(\\mathrm{N}(y)\\) and \\(x\\) in each case is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\), all divided by \\(\\sigma\\sqrt{T}\\). Thus, we first write a code for a generic option price. Later we use this generic option price function to price other options.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\n\n\n\n# Example usage\nP1 = 100\nP2 = 90\nsigma = 0.2\nT = 1\n\nprint(\"Generic Option:\", generic_option(P1, P2, sigma, T))\n\n\nGeneric Option: 13.589108116054796\nNow we can use the following one-line programs to value exchange options.\nCode\ndef margrabe(S1, S2, sigma, q1, q2, T):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    T = time to maturity\n    \"\"\"\n    P1 = np.exp(-q1 * T) * S1\n    P2 = np.exp(-q2 * T) * S2\n    return generic_option(P1, P2, sigma, T)\n\n# Example usage\nS1 = 100\nS2 = 90\nsigma = 0.2\nq1 = 0.01\nq2 = 0.02\n\nprint(\"Margrabe Option:\", margrabe(S1, S2, sigma, q1, q2, T))\n\n\nMargrabe Option: 14.05169829758782\nWe could also have calculated the Black-Scholes call formula as \\[\n\\text{Generic\\_Option}(Exp(-q*T)*S, Exp(-r*T)*K, sigma, T)\n\\]\nand the Black-Scholes put formula as\n\\[\n\\text{Generic\\_Option}(Exp(-r*T)*K, Exp(-q*T)*S, sigma, T).\n\\]",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:margrabe",
    "href": "Chapter_Merton.html#sec-s:margrabe",
    "title": "13  Merton, Black, and Margrabe",
    "section": "",
    "text": "13.2\n\n\n\nThe value of a European option to exchange two assets at date \\(T\\) is \\[\n\\mathrm{e}^{-q_1 T}S_1_0\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T}S_2_0\\mathrm{N}(d_2)\\;,\n\\qquad(13.7)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1_0}{S_2_0}\\right)+\\left(q_2-q_1+\n\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.8)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(13.9)\\]",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:black",
    "href": "Chapter_Merton.html#sec-s:black",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.3 Black’s Formula",
    "text": "13.3 Black’s Formula\nBlack (Black 1976) gives formulas for the values of options on futures contracts when interest rates are deterministic (i.e., non-random). It is well known (and we will establish this in Section 13.12) that, when interest rates are deterministic, futures prices should equal forward prices, so Black’s formulas also yield formulas for the values of options on forward contracts when interest rates are deterministic. However, the formulas for options on forwards are valid more generally (even when interest rates vary randomly) and now a mention of Black’s formulas is more likely to be referring to the formulas for options on forwards, instead of the formulas for options on futures. In any case, we will start with the formulas for options on forwards and then in Section 13.13 derive the formulas for options on futures when interest rates are deterministic.\nWe consider a forward contract that matures at some date \\(T'\\) and a call or put option on the forward that matures at \\(T \\leq T'\\). The meaning of a call option on a forward is that exercise of the call creates a long position in the forward contract with forward price equal to the strike price of the option. The long forward contract means that the investor will receive the underlying asset at \\(T'\\) and pay the forward price (the strike of the option) at \\(T'\\). Thus, the strike price is not paid at the date of exercise but instead is paid when the underlying asset is delivered. Symmetrically, the exercise of a put creates a short position in the forward contract with forward price equal to the strike of the put, which means that the exerciser must deliver the underlying at \\(T'\\) and will receive the strike price at \\(T'\\).\nWe will denote the market forward price by \\(F_t\\). We assume the forward price satisfies \\[\n\\frac{\\,\\mathrm{d}F}{F} = \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;,\n\\qquad(13.10)\\]\nwhere \\(B\\) is a Brownian motion. As before, \\(\\mu\\) can be a quite general random process. We will assume in this section that the volatility \\(\\sigma\\) is a constant and generalize to a time-varying (but non-random) volatility in Section 13.15. In Section 13.5, we will discuss the relations of the forward price and its volatility to the price and volatility of the underlying.\nBlack’s formulas are particularly useful when interest rates are assumed to be random, as we will see in Part~\\(\\ref{p_fixedincome}\\) of the book when we study fixed income derivatives. Therefore, we do not assume here that there is a constant risk-free rate. Instead we will assume that there is a discount bond that pays $1 at date \\(T'\\). It is called a discount bond because its price is the appropriate discount factor for computing the present value of nonrandom cash flows at date \\(T'\\). Such a bond is also called a zero coupon bond because it does not pay any cash flows until \\(T'\\), when it pays its face value (which we take simply for convenience to be $1). We will let \\(P(t,T')\\) denote the price of the bond at date \\(t\\).^[In this section we could drop the \\(T'\\) in \\(P(t,T')\\) and simply write \\(P_t\\), because we only consider one maturity date, but we will use the same notation when discussing multiple maturities in Part~\\(\\ref{p_fixedincome].}\\)\nBlack’s formulas are: \n\n\n\n\n\n\n13.4\n\n\n\nThe values at date \\(0\\) of European options with strike \\(K\\) and maturity \\(T\\) on a forward contract with maturity \\(T'\\) are\n\\[\n\\text{Call Price} =P(0,T')F_0\\mathrm{N}(d_1)-P(0,T')K\\mathrm{N}(d_2)\\; ,\n\\qquad(13.11)\\]\n\\[\n\\text{Put Price} =P(0,T')K\\mathrm{N}(-d_2)-P(0,T')F_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(13.12)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.13)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(13.14)\\]\n\n\nBlack’s formulas are a simple consequence of Margrabe’s formula. To see this, we first need to describe the value of an option on a forward at the maturity date \\(T\\) of the option. Consider a call option. Exercise of the call results in a long forward position with forward price \\(K\\). The value of the long forward is given by its market price \\(F_T\\), but we must keep in mind that the forward price is not paid until the underlying is delivered at date \\(T'\\). So suppose that you exercise the call and then sell a forward contract at the market forward price \\(F_T\\). The delivery/receipt obligations of the long and short forwards cancel, leaving you with the obligation to pay \\(K\\) dollars at date \\(T'\\) and with an asset of \\(F_T\\) dollars to be received at date \\(T'\\). The value of the net cash flow at date \\(T\\) is \\(P(T,T')[F_T-K]\\). This is the value if exercised, so the value of the call at date \\(T\\) is \\[\n\\max\\big(0, P(T,T')[F_T-K]\\big) = \\max\\big(0,P(T,T')F_T-P(T,T')K\\big)\\;.\n\\qquad(13.15)\\]\nWe can write this as \\[\n\\max(0,S_1_T-S_2_T)\n\\qquad(13.16)\\]\nif we define \\[\nS_1_t = P(t,T')F_t \\quad \\text{and} \\quad S_2_t = P(t,T')K\n\\qquad(13.17)\\]\nfor \\(t=T\\) (and more generally for \\(t \\leq T\\)). Thus, the value at maturity of a call option on a forward is the value at maturity of an option to exchange the two assets with prices \\(S_1\\) and \\(S_2\\) (we will establish in a moment that \\(S_1\\) and \\(S_2\\) are actually asset prices). It follows that the value at date \\(0\\) of a call option on a forward is the value at date \\(0\\) of an option to exchange the two assets.\nNow consider a put option on a forward. Exercising the put and unwinding the short forward position by buying a forward at the market price \\(F_T\\) will leave one with a net cash flow of \\(K-F_T\\) to be received at the maturity date \\(T'\\) of the forward. Therefore the value of the put at maturity is \\[\n\\max(0,P(T,T')[K-F_T]) = \\max(S_2_T-S_1_T)\\;.\n\\qquad(13.18)\\]\nTherefore, the value at date \\(0\\) of the put option on a forward must be the value at date \\(0\\) of an exchange option, where asset one in Equation 13.17 is exchanged for asset two.\nThe key assumption in deriving Margrabe’s formula is that the volatility of the ratio of asset prices is a constant. For a call option on a forward, the relevant ratio is \\(S_1/S_2 = F/K\\). Because \\(K\\) is a constant, the volatility of the ratio is the volatility \\(\\sigma\\) of the forward price \\(F\\), which we have assumed to be constant. For a put option on a forward, the relevant ratio is \\(S_2/S_1 = K/F\\). Ito’s formula implies\n\\[\\begin{align*}\n\\frac{d(K/F)}{K/F} &= -\\frac{\\,\\mathrm{d}F}{F} + \\left(\\frac{\\,\\mathrm{d}F}{F}\\right)^2\\; ,\\\\\n&= (-\\mu +\\sigma^2)\\,\\mathrm{d}t - \\sigma\\,\\mathrm{d}B\\\\\n&= (-\\mu+\\sigma^2)\\,\\mathrm{d}t + \\sigma (-\\,\\mathrm{d}B),\n\\end{align*}\\] The purpose of the last equality displayed here is to emphasize that we should take the volatility of \\(K/F\\) to be the positive number \\(\\sigma\\). We can do this by using \\(-B\\) as the Brownian motion instead of \\(B\\).2 Thus, we can apply Margrabe’s formula to value calls and puts on forwards (once we verify that \\(S_1\\) and \\(S_2\\) are indeed asset prices).\nTo obtain Black’s Equation 13.11 for a call on a forward from Margrabe’s Equation 13.7, we simply substitute \\(S_1_0=P(0,T')F_0\\), \\(S_2_0=P(0,T')K\\), \\(q_1=0\\) and \\(q_2=0\\) in Margrabe’s formula. A put option is the reverse exchange, so Margrabe’s formula gives \\[\nP(0,T')K\\mathrm{N}(d^m_1) - P(0,T')F_0\\mathrm{N}(d^m_2)\\;,\n\\qquad(13.19)\\]\nwhere \\[\\begin{align*}\nd^m_1&= \\frac{\\log\\left(\\frac{P(0,T')K}{P(0,T')F_0}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\\\\nd^m_2 &=d^m_1-\\sigma\\sqrt{T}.\n\\end{align*}\\] We introduce the superscript \\(m\\) here to distinguish these numbers in Margrabe’s formula from the \\(d_1\\) and \\(d_2\\) defined in Equation 13.13 and Equation 13.14. Notice that \\[\\begin{align*}\nd^m_1& = -\\frac{\\log\\left(\\frac{F_0}{K}\\right)-\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} = -d_2\\\\\nd^m_2 &= -\\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} =-d_1,\n\\end{align*}\\] so Margrabe’s Equation 13.19 is the same as Black’s Equation 13.12 for a put option on a forward.\nWe still need to explain why \\(S_1\\) and \\(S_2\\) defined in Equation 13.17 are asset prices, in fact the prices of dividend-reinvested assets since we have taken \\(q_1=q_2=0\\) in applying Margrabe’s formula. The case of \\(S_2\\) should be clear: it is the price of \\(K\\) units of the discount bond maturing at \\(T'\\). The case of \\(S_1\\) is more subtle. It is the price of the following portfolio constructed at date \\(0\\) and held until date \\(T\\): go long one forward contract and buy \\(F_0\\) units of the discount bond maturing at \\(T'\\). The value at date \\(t\\) of the bonds in the portfolio is \\(F_0P(t,T')\\). The value at date \\(t\\) of the long forward contract can be seen by considering unwinding it by selling a forward at date \\(t\\) at the market price \\(F_t\\). This cancels the delivery/receipt obligations on the underlying and results in a net cash flow of \\(F_t-F_0\\) to be received at date \\(T'\\). The value at date \\(t\\) of this future cash flow is \\(P(t,T')[F_t-F_0]\\) and when we add this to the value of the bonds we obtain \\(P(t,T')F_t = S_1_t\\).\nPut-call parity for options on forwards is \\[\\text{Call Price}  + P(0,T')K = \\text{Put Price}  + P(0,T')F_0\\; .\\] The left-hand side is the cost of the call and \\(K\\) units of the discount bond, which have value \\(\\max(F_T,K)P(T,T')\\) at time \\(T\\). The right-hand side is the cost of the put option and \\(F_0\\) units of the discount bond, which, together with a long forward contract initiated at date \\(0\\), also have value \\(\\max(F_T,K)P(T,T')\\) at time \\(T\\).\nAs in the case of exchange option, we can also write one-line programs for pricing options on futures and forwards.\n\n\nCode\ndef black_call(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * F, P * K, sigma, T)\n\ndef black_put(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * K, P * F, sigma, T)\n\n\nF = 100\nK = 90\nP = 0.95\nsigma = 0.2\n\nprint(\"Black Call:\", black_call(F, K, P, sigma, T))\nprint(\"Black Put:\", black_put(F, K, P, sigma, T))\n\n\nBlack Call: 12.909652710252054\nBlack Put: 3.409652710252054",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:merton",
    "href": "Chapter_Merton.html#sec-s:merton",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.5 Merton’s Formula",
    "text": "13.5 Merton’s Formula\nNow we reconsider the Black-Scholes model but without assuming there is a constant risk-free rate. We assume instead that there is a discount bond maturing at the same date as the option. Letting \\(T\\) denote the maturity date of the option and discount bond, we write the price of the discount bond at dates \\(t \\leq T\\) as \\(P(t,T)\\). We continue to assume that the stock has a constant dividend yield \\(q\\) but we make a different assumption about volatility—instead of assuming that the volatility of the stock is constant, we assume that the volatility of its forward price is constant. We relax this to allow time-varying but non-random volatility of the forward price in Section 13.15.\nThe forward contract we consider is a forward contract for the stock maturing at the date \\(T\\) that the option matures. Let \\(F_t\\) denote the forward price for this contract at dates \\(0 \\leq t\\leq T\\). Because the forward price must equal the spot price at the maturity of a forward contract, we have \\(F_T=S_T\\). Consider a call option on the forward, with the call maturing at \\(T\\) also. In the notation of the previous section, we have \\(T'=T\\) and hence \\(P(T,T')=1\\) (the discount bond is worth $1 at maturity). Therefore the value Equation 13.15 of the call on the forward at its maturity \\(T\\) is \\[\\max(0,F_T-K) = \\max(0,S_T-K)\\; ,\\] which is the same as the value of the call on the stock. Therefore, the value at date \\(0\\) of the call on the stock must equal the value at date \\(0\\) of the call on the forward, and we can use Black’s Equation 13.11 for a call option on a forward to price a call option on the stock, assuming the forward price has a constant volatility.\nLikewise, the value at the maturity date \\(T\\) of a put option on the same forward contract is, from Equation 13.18, \\[\\max(0,K-F_T) = \\max(0,K-S_T)\\; .\\] Hence, we can use Black’s Equation 13.12 to price a put option on the stock, assuming the forward price has a constant volatility.\nIt is not necessary that the forward contract be traded, because we can create a synthetic forward using the stock. To create a synthetic forward at date \\(t\\) we buy \\(\\mathrm{e}^{-q(T-t)}\\) shares of the stock at cost \\(\\mathrm{e}^{-q(T-t)}S_t\\). With reinvestment of dividends, this will accumulate to one share at date \\(T\\). We finance the purchase of the stock by shorting \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) units of the discount bond. This results in a liability of \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at date \\(T\\), so the forward purchase is arranged by promising to pay \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at the delivery date; i.e., the forward price is^[If there is a constant risk-free rate \\(r\\), then it must be that \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), so Equation 13.20 becomes \\[F_t = \\mathrm{e}^{(r-q)(T-t)}S_t\\; ,\\] which is the same as the covered interest parity condition Equation 12.2—recall that we interpret the exchange rate as the price of an asset with dividend yield \\(q=r_f\\).} \\[\nF_t = \\frac{\\mathrm{e}^{-q(T-t)}S_t}{P(t,T)}\\;.\n\\qquad(13.20)\\]\nThe assumption we need to apply Black’s formulas is that \\[\n\\frac{\\,\\mathrm{d}F}{F} = \\mu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B\\;,\n\\qquad(13.21)\\]\nwhere \\(B\\) is a Brownian motion, \\(\\mu\\) can be a quite general random process, and \\(\\sigma\\) is a constant. At the end of this section, we will discuss the meaning of this assumption in terms of the volatilities of the stock and bond and their correlation.\nUnder this assumption, the following formulas originally due to Merton (Merton 1973) follow immediately from Black’s formulas Equation 13.11 - Equation 13.14 by substituting \\(F_0 = \\mathrm{e}^{-qT}S_0/P(0,T)\\).\n\n\n\n\n\n\n13.6\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price}  = \\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\;,\n\\qquad(13.22)\\]\n\\[\n\\text{Put Price} = P(0,T)K\\mathrm{N}(-d_2) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\qquad(13.23)\\]\nwhere \\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{KP(0,T)}\\right)-qT+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.24)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(13.25)\\]\n\n\n\nThese formulas are clearly similar to the Black-Scholes formulas. The similarities are made more apparent by writing the discount bond price in terms of its yield. The yield \\(y\\) of the discount bond is defined as \\[y = \\frac{-\\log P(0,T)}{T} \\qquad\\Longleftrightarrow \\qquad P(0,T) = \\mathrm{e}^{-yT}\\; .\n\\] Substituting this into the expressions above, we have:\n\n\n\n\n\n\n13.7\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price} =\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-yT}K\\mathrm{N}(d_2)\\;,\n\\qquad(13.26)\\]\n\\[\n\\text{Put Price} =\\mathrm{e}^{-yT}K\\mathrm{N}(-d_2)-\\mathrm{e}^{-q T}S_0\\mathrm{N}(-d_1),\n\\qquad(13.27)\\]\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(y-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.28)\\]\n\\[\nd_2 = d_1 - \\sigma\\sqrt{T}\\;.\n\\qquad(13.29)\\]\n\n\nThis shows that the Merton call and put formulas can be calculated from the Black-Scholes call and put functions given in Chapter 10 by inputting the yield of the discount bond as the risk-free rate and by inputting the volatility of the forward price as \\(\\sigma\\).\nIf one wants to assume that there is a constant risk-free rate, then the discount bond price will have to be \\(\\mathrm{e}^{-rT}\\) and its yield will be the risk-free rate \\(r\\). In this case, the forward price is \\(\\mathrm{e}^{(r-q)T}S_0\\) and it has the same volatility as \\(S\\). Making these substitutions, the Merton formulas Equation 13.26 - Equation 13.29 are the same as the Black-Scholes formulas. However, the Merton formulas are an important generalization. It is common practice to use the yield of the discount bond as the risk-free rate that is input into the Black-Scholes formulas. The Merton formulas justify this practice. It is less common to attempt to estimate the volatility of the forward price and use this (as one should since the risk-free rate really is not constant) as the volatility in the Black-Scholes-Merton formulas. However, this does little damage for pricing short-term options, because the volatility of the forward price—see Equation 13.30 below—will be approximately the same as the volatility of the underlying for short-term options, due to the low volatility of short-term bond prices. Moreover, when one computes an implied volatility from the Black-Scholes formula (using the discount bond yield as the risk-free rate), it should be regarded as the market’s view of the forward price volatility, and it is perfectly appropriate to input it into the Black-Scholes-Merton formulas to price another option (assuming of course that the forward price volatility can be regarded as constant).\nThe volatility of the forward price can be computed in terms of the volatilities and correlation of the stock and discount bond as follows. Assume that \n\\[\\begin{align*}\n\\frac{\\,\\mathrm{d}S}{S}& = \\mu_s\\,\\mathrm{d}t + \\sigma_s\\,\\mathrm{d}B_s\\; ,\\\\\n\\frac{\\,\\mathrm{d}P}{P}& = \\mu_p\\,\\mathrm{d}t + \\sigma_p\\,\\mathrm{d}B_p,\n\\end{align*}\\] where \\(B_s\\) and \\(B_p\\) are Brownian motions with correlation \\(\\rho\\). Then Equation 6.15 and Equation 6.17 show that the volatility of \\(F_t = \\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) is \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_s^2+\\sigma_p^2 - 2\\rho\\sigma_s\\sigma_p}\\;.\n\\qquad(13.30)\\]\nAs mentioned before, we will consider in Section 13.15 that the the volatility Equation 13.30 may vary over time in a non-random way.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#deferred-exchange-options",
    "href": "Chapter_Merton.html#deferred-exchange-options",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.8 Deferred Exchange Options",
    "text": "13.8 Deferred Exchange Options\nA call option on a forward can be viewed as an option to exchange \\(K\\) dollars (or, equivalently, \\(K\\) units of the discount bond maturing at the maturity date of the forward) for the underlying asset, with the exchange taking place at the maturity date of the forward. Therefore, it is an exchange option in which the exchange takes place at a fixed date after the option matures. We can easily extend Margrabe’s formula to value options to exchange other assets when the option maturity precedes the date of the exchange. \nAs in Section 13.1, consider two assets with prices \\(S_i\\) and constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\,\\mathrm{d}S_i}{S_i} = \\mu_i\\,\\mathrm{d}t + \\sigma_i\\,\\mathrm{d}B_i\\; ,\\] where the drifts \\(\\mu_i\\), the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the two Brownian motions can be general random processes. However, also as in Section 13.1, assume that the volatility \\[\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\\] of the ratio of asset prices is constant.\nConsider an option maturing at date \\(T\\) to exchange the second asset for the first asset at date \\(T'\\geq T\\). To understand the value of the option at date \\(T\\), suppose it is exercised. To unwind the positions in the two assets, one can sell a forward contract on the asset to be received and buy a forward contract on the asset to be delivered, with the forward contracts maturing at the date of the exchange. Then the difference \\(F_1_T-F_2_T\\) in the forward prices is a cash flow to be received/paid at the exchange date \\(T'\\) and its value at date \\(T\\) is \\(P(T,T')[F_1_T-F_2_T]\\). Therefore, the value of the option at its maturity \\(T\\) is \\[\\max(0,P(T,T')F_1_T - P(T,T')F_2_T)\\; .\\] As in Section 13.3, this valuation does not require the existence of traded forward contracts, because synthetic forwards can be created. Also as in Section 13.3 we know that \\[S^*_1_t = P(t,T')F_1_t \\quad \\text{and} \\quad S^*_2_t = P(t,T')F_2_t\\] are the prices of dividend-reinvested assets. Therefore, the option to exchange the assets at date \\(T'\\) must have the same value as an option to exchange at date \\(T\\) the assets with prices \\(S^*_i\\).\nWe recall here the arbitrage Equation 13.20 for the forward prices (making the change that here the forwards mature at \\(T'\\)): \\[F_i_t =  \\frac{\\mathrm{e}^{-q_i(T'-t)}S_i_t}{P(t,T')}\\; .\\] Thus, \\[S^*_i_t = \\mathrm{e}^{-q_i(T'-t)}S_i_t\\; .\\] This implies that the volatility of the ratio \\(S_1^*/S_2^*\\) is the same as the volatility of the ratio \\(S_1/S_2\\). Therefore, we can price a deferred exchange option from Margrabe’s formula, inputting the prices \\(S^*_i_0 = \\mathrm{e}^{-q_iT'}S_i_0\\) as the initial asset prices and zero as their dividend yields. This formula is:\n\n\n\n\n\n\n13.9\n\n\n\nThe value of a European option maturing at date \\(T\\) to exchange two assets at date \\(T'\\) is \\[\n\\mathrm{e}^{-q_1 T'}S_1_0\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T'}S_2_0\\mathrm{N}(d_2)\\;,\n\\qquad(13.31)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1_0}{S_2_0}\\right)+(q_2-q_1)T'+\n\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.32)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(13.33)\\]\n\n\n\n\nCode\ndef margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    Tmat = time to maturity of option\n    Texch = time until exchange &gt;= TOption\n    \"\"\"\n    P1 = np.exp(-q1 * Texch) * S1\n    P2 = np.exp(-q2 * Texch) * S2\n    return generic_option(P1, P2, sigma, Tmat)\n\n# Example usage\nS1 = 100\nS2 = 90\nq1 = 0.01\nq2 = 0.02\nsigma=0.2\nTmat = 1\nTexch = 2\n\nprint(\"Margrabe Deferred:\", margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch))\n\n\nMargrabe Deferred: 14.513318533107103",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:forwardhedging",
    "href": "Chapter_Merton.html#sec-s:forwardhedging",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.10 Greeks and Hedging",
    "text": "13.10 Greeks and Hedging\nThe Greeks for the Margrabe and Black formulas can be calculated in the same way that we calculated them in Chapter 10 for the Black-Scholes formula. In analogy with Equation 10.5, it can be shown for the Margrabe formula that \\[\\mathrm{e}^{-q_1T}S_1_0\\mathrm{n}d(d_1) = \\mathrm{e}^{-q_2T}S_2_0\\mathrm{n}d(d_2)\\; ,\\] and again this simplifies the calculations. This equation applies to the Black call formula by taking \\(q_1=q_2=0\\), \\(S_1_0=P(0,T')F_0\\), and \\(S_2_0=P(0,T')K\\), leading to \\[F_0\\mathrm{n}d(d_1) = K\\mathrm{n}d(d_2)\\; .\\] The Greeks for the Black call formula and the Margrabe formula are: \n\n\n\n\n\n\n13.11\n\n\n\n\\[\\begin{align*}\n&**Black Call** && **Margrabe**\\\\\n& & & \\\\\n\\frac{\\partial}{\\partial F} &= P(0,T')\\mathrm{N}(d_1)  % Black delta1\n&\\frac{\\partial}{\\partial S_1}&= \\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\\\ % Margrabe delta1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial P} &= F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)% Black delta2\n&\\frac{\\partial}{\\partial S_2}&=-\\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\\\ % Margrabe delta2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F^2} &= \\frac{P(0,T')\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}F_0}  % Black gamma1\n&\\frac{\\partial^2}{\\partial S_1^2}&= \\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_1_0}\\\\ % Margrabe gamma1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial P^2} &= 0 % Black gamma2\n&\\frac{\\partial^2}{\\partial S_2^2}&=\\frac{\\mathrm{e}^{-q_2T}\\mathrm{n}d(d_2)}{\\sigma\\sqrt{T}S_2_0}\\\\ %Margrabe gamma2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F \\partial P} &= \\mathrm{N}(d_1)&\\frac{\\partial^2}{\\partial S_1 \\partial S_2}% Black crossgamma\n&= -\\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_2_0}\\\\ % Margrabe crossgamma\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\\frac{\\partial}{\\partial T} &= -\\frac{\\sigma P(0,T')F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}%Black theta part1\n& -\\frac{\\partial}{\\partial T}&=q_1\\mathrm{e}^{-q_1T}S_1_0\\mathrm{N}(d_1)\\\\ %Margrabe theta part1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n& &&-q_2\\mathrm{e}^{-q_2T}S_2_0\\mathrm{N}(d_2)\\\\ % Margrabe theta part2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n&&&-\\frac{\\sigma \\mathrm{e}^{-q_1T}S_1_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\\\ % Margrabe theta part3\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial \\sigma} &= \\sqrt{T}P(0,T')F_0\\mathrm{n}d(d_1) % Black vega\n&\\frac{\\partial}{\\partial \\sigma}&=\\sqrt{T}\\mathrm{e}^{-q_1T}S_1_0\\mathrm{n}d(d_1) % Margrabe vega\n\\end{align*}\\]\n\n\nHedging for the Margrabe formula is much the same as for the Black-Scholes formula. We would delta-hedge a written exchange option by holding \\(\\delta_1=\\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\) shares of the first asset and \\(\\delta_2 =- \\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\) shares of the second asset (which means shorting the second asset). This position would be financed by borrowing at the risk-free rate (or shorting the discount bond). The same argument that we used in Section 10.5 shows that this zero-cost portfolio will have a zero return if continuously rebalanced.\nBecause the Black formulas are a special case of the Margrabe formula, we can delta-hedge options on forwards in the same way. Putting \\(q_1=q_2=0\\), \\(S_1_0=P(0,T')F_0\\) and \\(S_2_0=P(0,T')K\\), we would delta-hedge a written call option by buying \\(\\mathrm{N}(d_1)\\) shares of the first asset and shorting \\(\\mathrm{N}(d_2)\\) shares of the second, where \\(d_1\\) and \\(d_2\\) are defined in the Margrabe formulas Equation 13.8 and Equation 13.9 and equivalently in the Black formulas Equation 13.13 and Equation 13.14. This position would be financed by shorting the discount bond to raise the difference between the cost of the portfolio and the option value so that the cost of the total portfolio (including the short discount bond) equals the option value. However, the first asset here consists of a long forward contract plus \\(F_0\\) units of the discount bond, and the second asset is \\(K\\) units of the discount bond. Furthermore, we are using the discount bond to finance the position (including the buying and shorting of the discount bond!). We can conclude that buying \\(\\mathrm{N}(d_1)\\) units of the first asset means that we should buy \\(\\mathrm{N}(d_1)\\) forward contracts. This has zero cost. Therefore, the portfolio value will equal the value of the discount bonds, and this must equal the option value. So, we actually invest the option value\n\\[P(0,T')F_0\\mathrm{N}(d_1) - P(0,T')K\\mathrm{N}(d_2)\\; ,\\] in the discount bond, which means buying \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the bond.\nA more direct analysis of hedging options on forwards is possible and instructive. We will consider that topic further in Section 13.16.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:futuresforwards",
    "href": "Chapter_Merton.html#sec-s:futuresforwards",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.12 The Relation of Futures Prices to Forward Prices",
    "text": "13.12 The Relation of Futures Prices to Forward Prices\nThe difference between futures and forward contracts is that futures are marked to market, which means that daily gains and losses are posted to the investor’s margin account. Thus, there are interim cash flows on a futures contract, whereas the only cash flows on a forward contract are at the maturity of the forward. We will establish three useful facts in this section, the last of which follows from the first two:\n\nFutures prices are martingales under the risk-neutral probability.\nForward prices are martingales when we use the discount bond with the same maturity as the forward as the numeraire.\nWhen interest rates are non-random, futures prices equal forward prices.\n\nWe consider the idealized case in which the futures contract is continuously marked to market. Assume there is an instantaneously risk-free asset with rate of return \\(r\\), which could vary randomly over time, and define, as in Chapter 7, \\[R_t = \\exp\\left(\\int_0^t r_s\\,ds\\right)\\; ,\\] which is the value at date \\(t\\) of a $1 investment in the asset at date \\(0\\), with interest continuously reinvested. Let \\(T'\\) denote the maturity of the futures contract, and let \\(F^*_t\\) denote the futures price at dates \\(t \\leq T'\\) (the \\(^*\\) notation is to distinguish the futures price from the forward price \\(F\\)). Consider the portfolio strategy that starts with zero dollars and one long futures contract at price \\(F^*_0\\) and which continuously invests and withdraws from the risk-free asset the gains and losses on the futures contract. Let \\(V_t\\) denote the value of this portfolio at date \\(t\\). The change in the value of the portfolio at any instant is the interest earned (or paid, if \\(V&lt;0\\)) on the risk-free asset plus the gain/loss on the futures. This means that \\[\\,\\mathrm{d}V = rV\\,\\mathrm{d}t + \\,\\mathrm{d}F^*\\; .\\] Because all gains and losses on this portfolio are reinvested, \\(V\\) is the price of a dividend-reinvested asset. Therefore, under the risk-neutral probability (i.e., using \\(R\\) as the numeraire), the ratio \\(V/R\\) must be a martingale and hence have zero drift. From Ito’s formula, \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}(V/R)}{V/R} &= \\frac{\\,\\mathrm{d}V}{V} - \\frac{\\,\\mathrm{d}R}{R}\\\\\n&=\\frac{rV\\,\\mathrm{d}t + \\,\\mathrm{d}F^*}{V} - r\\,\\mathrm{d}t\\\\\n&= \\frac{\\,\\mathrm{d}F^*}{V}\\;.\n\\end{align*}\\] Thus, the drift of \\(V/R\\) being zero implies the drift of \\(F^*\\) is zero. We need to assume (and can assume) that \\(F^*\\) is an Ito process with finite expected quadratic variation—cf. condition Equation 5.9—in which case the absence of a drift implies that it is a martingale.\nNow we turn to fact (2). Consider a forward contract with maturity \\(T'\\) and a discount bond also maturing at \\(T'\\). Let \\(F_t\\) denote the forward price and let \\(P(t,T')\\) denote the price of the discount bond at dates \\(t \\leq T'\\). We observed in Section 13.3 that there is a dividend-reinvested asset with price \\(P(t,T')F_t\\). When we use the discount bond as the numeraire, the ratio \\(P(t,T')F_t/P(t,T') = F_t\\) must be a martingale, which is fact (2). Because of this fact, a probability measure corresponding to a discount bond being the numeraire is called a forward measure. \nSuppose now that interest rates are deterministic, that is, even if \\(r\\) varies over time, it does so in a non-random way. Then the discount bond price at date \\(0\\) must be the discount factor \\[P(0,T') = \\exp\\left(-\\int_0^{T'} r_t\\,\\mathrm{d}t\\right)\\; .\\] Equation 7.23 gives the probability of any event \\(A\\) when the discount bond is used as the numeraire as \\[\\text{prob}^P[A] = \\\\E\\left[1_A\\phi_{T'}\\frac{P(T',T')}{P(0,T')}\\right] = \\exp\\left(-\\int_0^{T'} r_t\\,\\mathrm{d}t\\right)\\\\E[1_A\\phi_{T'}]\\; ,\\] where \\(\\phi\\) denotes the state prices. On the other hand, the same equation gives the probability of \\(A\\) when \\(R\\) is used as the numeraire as \\[\\text{prob}^R[A] = \\\\E\\left[1_A\\phi_{T'}\\frac{R_{T'}}{R_0}\\right] = \\exp\\left(-\\int_0^{T'} r_t\\,\\mathrm{d}t\\right)\\\\E[1_A\\phi_{T'}]\\; .\\] Therefore, the two probability measures are the same, and consequently the expectations \\(\\\\E^P\\) and \\(\\\\E^R\\) are the same. Now using the fact that both the futures price and the forward price must equal the spot price at maturity, we have \\(F^*_{T'} = F_{T'}\\), and, from the martingale properties, \\[F^*_t = \\\\E_t^P[F^*_{T'}] = \\\\E_t^P[F_{T'}] = \\\\E_t^R[F_{T'}] = F_t\\; ,\\] which is fact (3).",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:futuresoptions",
    "href": "Chapter_Merton.html#sec-s:futuresoptions",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.13 Futures Options",
    "text": "13.13 Futures Options\nNow we consider options on futures contracts, assuming that interest rates are deterministic. We just showed that in this circumstance the futures price will equal the forward price for a contract of the same maturity. However, the values of options on a futures contract do not equal the values of options on the corresponding forward contract.\nThe difference is due to marking to market. Consider futures and forward contracts with maturity \\(T'\\) and options maturing at \\(T \\leq T'\\). Exercise of a call option on a futures contract will roll the investor into a long futures contract with futures price equal to the market futures price at that date. The difference \\(F^*_T-K\\) between the market futures price and the strike price of the option is immediately credited to the investor’s margin account. On the other hand, exercise of an option on a forward and sale of the forward results in a cash flow of \\(F_T - K\\) that is received at the maturity date \\(T'\\) of the forward. Therefore, the value at maturity of a call option on a futures contract is \\(\\max(0,F^*_T-K)\\), whereas, as noted before, the value of a call option on a forward at the maturity of the option is \\(P(T,T')\\max(0,F_T-K)\\)\nAs in the analysis of options on forwards, an options on a futures contract can be viewed as an exchange option, where one exchanges the asset with price \\(S_2_t = P(t,T)K\\) at date \\(t\\leq T\\) for the asset with price \\(S_1_t = P(t,T)F^*_t\\). The asset with price \\(S_2\\) is of course \\(K\\) units of the discount bond maturing at \\(T\\). Assuming interest rates are deterministic, we have \\(F^*_t = F_t\\), and we noted in Section 13.3 that \\(P(t,T)F_t\\) is the price of a dividend-reinvested asset. Thus, we can apply Margrabe’s formula to price call (and put) options on futures when interest rates are deterministic. Compared to options on forwards, the difference is that the discount bonds defining the prices \\(S_1\\) and \\(S_2\\) mature at the maturity date of the option rather than at the maturity date of the futures or forward contract. The result is:\n\n\n\n\n\n\n13.14\n\n\n\nWhen interest rates are deterministic and the futures price \\(F^*\\) has a constant volatility \\(\\sigma\\), the values of European calls and puts on a futures contract are\n\\[\n\\text{Call Price} =P(0,T)F^*_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\; ,\n\\qquad(13.34)\\]\n\\[\n\\text{Put Price} =P(0,T)K\\mathrm{N}(-d_2)-P(0,T)F^*_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(13.35)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F^*_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(13.36)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(13.37)\\]\n\n\nWe can calculate these values from the Black_Call and Black_Put functions by inputting the price of the discount bond maturing when the option matures rather than the price of the discount bond maturing when the forward/futures matures.\nWe will derive delta hedges for futures options in Section 13.16.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:volatility",
    "href": "Chapter_Merton.html#sec-s:volatility",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.15 Time-Varying Volatility",
    "text": "13.15 Time-Varying Volatility\nAll of the option pricing formulas in this chapter were derived from Margrabe’s formula, the main assumption of which is that the logarithm of the ratio of asset prices at date \\(T\\) is normally distributed with variance equal to \\(\\sigma^2T\\). As in ?sec-s:timevaryingvolatility regarding the Black-Scholes formulas, the formulas in this chapter can easily be adapted to allow a time-varying but non-random volatility. If the volatility is a non-random function \\(\\sigma_t\\) of time, then we define \\(\\sigma_{\\text{avg}}\\) to be the number such that \\[\n\\sigma_{\\text{avg}}^2 = \\frac{1}{T}\\int_0^T \\sigma^2_t\\,\\mathrm{d}t\\;.\n\\qquad(13.38)\\]\nWe should input \\(\\sigma_{\\text{avg}}\\) as (i) the volatility of the ratio of asset prices in Margrabe’s formula and the deferred exchange option formula if \\(\\sigma_t\\) is the volatility of the ratio at date \\(t\\) or as (ii) the volatility of the forward price in Black’s and Merton’s formulas if \\(\\sigma_t\\) is the volatility of the forward price at date \\(t\\).\nAs in ?sec-s:timevaryingvolatility, equation~Equation 13.38 enables one to interpret and apply different implied volatilities computed at different maturities. Another circumstance in which it can be useful is in conjunction with bond price models such as the Vasicek and extended Vasicek models described in Chapter 27 that imply a time-varying non-random volatility for discount bond prices.3 If we assume a constant volatility for the price of the underlying and a constant correlation between the underlying and the discount bond, then we will have a time-varying non-random forward price volatility via Equation 13.30, and we should input the average volatility \\(\\sigma_{\\text{avg}}\\) defined in Equation 13.38 for the forward price volatility in Black’s and Merton’s formulas. As mentioned in Section 13.5, this will be more important for long-term options than for short-term options.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:hedgingforwards",
    "href": "Chapter_Merton.html#sec-s:hedgingforwards",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.16 Hedging with Forwards and Futures",
    "text": "13.16 Hedging with Forwards and Futures\nIn Chapter 12, we considered hedging quanto contracts with currency forwards. In Section 13.10, we considered hedging options on forwards with forwards. To present a more complete analysis of these topics, we need to discuss the gains and losses that accrue from trading forwards.\nConsider dates \\(t&lt;u\\) and a forward contract with maturity \\(T\\). Suppose we purchase \\(x_t\\) forwards at date \\(t\\) and then change our position in forwards to \\(x(u)\\) at time \\(u\\). The purchase/sale of \\(x(u)-x_t\\) new contracts does not affect the portfolio value, so the change in the value of the portfolio is the change in the value of the \\(x_t\\) contracts purchased at date \\(t\\). These contracts were worth zero at date \\(t\\), because forward contracts have zero value at initiation. Selling them at date \\(u\\) cancels the obligation to deliver/receive the underlying, leaving one with a cash flow of \\(x_t[F(u)-F_t]\\) dollars to be received at date \\(T\\). The value of this cash flow at date \\(u\\) is \\(x_tP(u,T)[F(u)-F_t]\\). We can write this as \\[\\begin{align*}\nx_tP(u,T)[F(u)-F_t]  &= x_t\\big[P(t,T)[F(u)-F_t] + [P(u,T)-P(t,T)][F(u)-F_t]\\big]\\\\\n&= x_t\\big[P(t,T)\\,\\Delta F + (\\Delta P)(\\Delta F)\\big]\\;.\n\\end{align*}\\] This motivates the following definition:\n\n\n\n\n\n\n13.17\n\n\n\nThe change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\big[P(t,T)\\,\\mathrm{d}F_t + \\,\\mathrm{d}P(t,T)\\times \\,\\mathrm{d}F_t]\\;,\n\\qquad(13.39)\\]\nwhere \\(x_t\\) denotes the number of forward contracts held, \\(F_t\\) denotes the forward price, \\(P(t,T)\\) denotes the price of a discount bond maturing at \\(T\\), and \\(T\\) is the maturity of the forward contract.\n\n\nHedging with futures is a bit simpler, because the gains and losses are received instantaneously (daily, at least) rather than being deferred to the contract maturity. Letting \\(x_t\\) denote the number of futures contracts held at date \\(t\\) and \\(F^*_t\\) the futures price, the cash flow from the contracts is \\(x_t\\,\\mathrm{d}F^*_t\\). This is also the change in the value of the portfolio, because marking to market means that the contracts always have zero value.\nTo compare hedging with futures and forwards, assume there is a constant risk-free rate \\(r\\). Let \\(T\\) denote the maturity of the futures and forward contracts. Because there is a constant risk-free rate, we have \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), which implies \\((\\,\\mathrm{d}P)(\\,\\mathrm{d}F) =0\\). Moreover, futures prices equal forward prices. Thus,\n\n\n\n\n\n\n13.18\n\n\n\nIf there is a constant risk-free rate \\(r\\), the change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\mathrm{e}^{-r(T-t)}\\,\\mathrm{d}F_t\n\\qquad(13.40)\\]\nand the change in the value of a portfolio of futures contracts is \\[\nx_t\\,\\mathrm{d}F_t\\;,\n\\qquad(13.41)\\]\nwhere \\(x_t\\) denotes the number of futures/forward contracts held at date \\(t\\), \\(T\\) is the maturity of the futures and forward contracts and \\(F_t\\) is the futures (= forward) price at date \\(t\\).\n\n\nComparing Equation 13.40 and Equation 13.41, we see that if \\(x_t\\) is the number of forward contracts that should be held in a hedge, then \\[\ny_t = \\mathrm{e}^{-r(T-t)}x_t\n\\qquad(13.42)\\]\nis the number of futures contracts that should be held, because with this number of contracts we have \\[\\begin{align*}\n\\text{Change in Forward Portfolio} & = x_t\\mathrm{e}^{-r(T-t)}\\,\\mathrm{d}F_t\\\\\n& = y_t\\,\\mathrm{d}F_t\\\\\n& = \\text{Change in Futures Portfolio}\\;.\n\\end{align*}\\] In short, we don’t require as many futures contracts as forward contracts, and the scaling factor to convert from forwards to futures is just the present value factor \\(\\mathrm{e}^{-r(T-t)}\\).\nFor example, the result of Section 12.11 on replicating the payoff \\(\\bar{X}S_T\\) with forward contracts leads to the following:\n\n\n\n\n\n\n13.19\n\n\n\nTo replicate the payoff \\(\\bar{X}S_T\\) at date \\(T\\), where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset, one should invest \\(V_t\\) units of domestic currency in the foreign asset and be short \\(\\mathrm{e}^{(r_f-r)(T-t)}V_t/X_t\\) currency futures at date \\(t\\), where \\(V_t\\) is defined in Equation 12.7 and \\(X_t\\) is the spot exchange rate.\n\n\nWe can use Equation 13.42 to determine how to delta hedge futures options. As explained in Section 13.13, assuming non-random interest rates, futures options are more valuable than options on forwards because futures are marked to market upon exercise of an option. Specifically, Black’s formulas Equation 13.11 - Equation 13.14 for options on forwards and Equation 13.34 - Equation 13.37 for options on futures show that the values are the same except for the maturity of the discount bond appearing in the equations. With a constant risk-free rate \\(r\\), options maturing at \\(T\\) and futures/forwards maturing at \\(T'\\), the relation is \\[\\text{Value of Futures Option} = \\mathrm{e}^{r(T'-T)} \\times \\text{Value of Forward Option}\\; .\\] Because the scaling factor \\(\\mathrm{e}^{r(T'-T)}\\) does not change as time passes, this implies that as time passes we have\n\\[\n\\begin{multline}\n\\text{Change in Futures Option Value } \\\\= \\mathrm{e}^{r(T'-T)} \\times \\text{Change in Forward Option Value}\\;.\n\\end{multline}\n\\qquad(13.43)\\]\nWe can combine Equation 13.42 and Equation 13.43 to convert from a hedge of a forward option using forward contracts, which we discussed in Section 13.10, to a hedge of a futures option using futures contracts. For example, we concluded in Section 13.10 that we should be long \\(\\mathrm{N}(d_1)\\) forwards to hedge a short call option on a forward contract. Consequently, Equation 13.42 shows that we can hedge a short call option on a forward by being long \\(\\mathrm{e}^{-r(T'-t)}\\mathrm{N}(d_1)\\) futures, and then we see from Equation 13.43 that the hedge for a short call on a futures is being long \\[\\mathrm{e}^{r(T'-T)}\\mathrm{e}^{-r(T'-t)}\\mathrm{N}(d_1) = \\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\] futures contracts.\nIn Section 13.10, we derived the hedges for forward options by considering them as exchange options. We can use Equation 13.39 to confirm that our calculations were correct. Consider hedging a short call maturing at \\(T\\) on a forward contract maturing at \\(T'\\). We can assume interest rates vary randomly and use discount bonds in the hedge. We stated in Section 13.10 that we should hold \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the discount bond maturing at \\(T'\\) and we should go long \\(\\mathrm{N}(d_1)\\) forwards to hedge the short call. This is a zero-cost portfolio when we include the proceeds from selling the call. Using Equation 13.39, we see that the change in the value of the portfolio will be \\[\n-\\,\\mathrm{d}C + [F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)]\\,\\mathrm{d}P + \\mathrm{N}(d_1)[P(0,T')\\,\\mathrm{d}F + (\\,\\mathrm{d}P)(\\,\\mathrm{d}F)]\\;.\n\\qquad(13.44)\\]\nThe value of the call at date \\(t\\) will be a function of \\(t\\), \\(P(t,T')\\) and \\(F_t\\), which we write as \\(C(t,P,F)\\). From Ito’s formula, \\[\\begin{align*}\n\\,\\mathrm{d}C &= \\frac{\\partial C}{\\partial t}\\,\\mathrm{d}t + \\frac{\\partial C}{\\partial P}\\,\\mathrm{d}P + \\frac{\\partial C}{\\partial F}\\,\\mathrm{d}F \\\\  &\\qquad + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial P^2}\\, (\\,\\mathrm{d}P)^2   + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial F^2}\\, (\\,\\mathrm{d}F)^2 + \\frac{\\partial^2 C}{\\partial F \\partial P} (\\,\\mathrm{d}P)(\\,\\mathrm{d}F)\\;.\\\\\n&=\\Theta\\,\\mathrm{d}t + \\delta_P\\,\\mathrm{d}P + \\delta_F\\,\\mathrm{d}F  + \\frac{1}{2}\\Gamma_{PP} (\\,\\mathrm{d}P)^2 + \\frac{1}{2}\\Gamma_{FF} (\\,\\mathrm{d}F)^2  + \\Gamma_{FP}\\,(\\,\\mathrm{d}P)(\\,\\mathrm{d}F)\\;,\n\\end{align*}\\] where the \\(\\delta\\)’s and \\(\\Gamma\\)’s denote the first and second partial derivatives indicated by the subscripts. Inserting this formula into Equation 13.44 and making use of the formulas in the table in Section 13.10, we see that the \\(\\,\\mathrm{d}P\\) terms cancel because \\(\\delta_P = F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\). Furthermore, the \\(\\,\\mathrm{d}F\\) terms cancel because \\(\\delta_F = \\mathrm{N}(d_1)P(0,T')\\). Thus, there is no exposure in the portfolio to the two risky asset prices \\(P\\) and \\(F\\). Furthermore, \\(\\Gamma_{PP} = 0\\) and the \\((\\,\\mathrm{d}P)(\\,\\mathrm{d}F)\\) terms cancel because \\(\\Gamma_{FP} = \\mathrm{N}(d_1)\\). These substitutions simplify the change Equation 13.44 in the value of the portfolio to \\[-\\Theta\\,\\mathrm{d}t - \\frac{1}{2}\\Gamma_{FF} (\\,\\mathrm{d}F)^2  = \\frac{\\sigma P(0,T')F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\,\\mathrm{d}t  -  \\frac{P(0,T')\\mathrm{n}d(d_1)}{2\\sigma\\sqrt{T}F_0}\\,(\\,\\mathrm{d}F)^2\\; ,\\] which we can see to be zero because \\((\\,\\mathrm{d}F)^2 = \\sigma^2F^2\\,\\mathrm{d}t\\). Thus, the hedge is perfect when continuously rebalanced.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#sec-s:margrabecomplete",
    "href": "Chapter_Merton.html#sec-s:margrabecomplete",
    "title": "13  Merton, Black, and Margrabe",
    "section": "13.20 Market Completeness",
    "text": "13.20 Market Completeness\nA formal definition of market completeness must specify which state-contin-gent claims (random variables depending on the history of prices) can be replicated by trading the marketed assets—for example, one might want all of the claims with finite means to be replicable, or only all of the claims with finite variances, etc. A formal analysis of market completeness is not presented in this book, except for the binomial and trinomial models in Chapter 7. However, we have stated that stochastic volatility models are incomplete. This follows intuitively from the fact that a portfolio containing only one risky asset (the underlying) cannot be perfectly correlated with the two Brownian motions that determine the value of a derivative asset (the Brownian motions driving the price of the underlying and its volatility). In general, a market must include an instantaneously risk-free asset and as many risky assets as there are Brownian motions in order to be complete.\nThe exchange-option model of Margrabe—with two risky assets, two Brownian motions, and no risk-free asset—is obviously incomplete. For example, it is impossible to have exactly $100 at date \\(T\\). With no risk-free asset, there is simply no way to store money. This may seem far-fetched, but we might be interested in payoffs in real (i.e., inflation-adjusted) dollars, in which case the absence of a risk-free asset may be a normal situation. In any case, we have not assumed a risk-free asset exists, but we have priced options without appealing to equilibrium arguments. This deserves some clarification.\nAs mentioned above, a formal definition of market completeness must specify which contingent claims are to be replicable. The Margrabe model is complete for a certain set of contingent claims. Contingent claims of the form \\(S_2_TX_T\\) where \\(X_T\\) is a random variable depending on the relative prices \\(S_1_t/S_2_t\\) for \\(0 \\leq t\\leq T\\) can be replicated. Likewise, contingent claims of the form \\(S_1_TX_T\\) can be replicated. The payoffs of exchange options are of this form, so they can be priced by arbitrage, even though there are other contingent claims (for example, receiving exactly $100 at date \\(T\\)) that cannot be replicated and hence cannot be priced by arbitrage. Likewise, the Black and Merton models in which there is a zero-coupon bond but no instantaneously risk-free asset are examples of incomplete markets that are still sufficiently complete to price options by arbitrage (the options can be replicated). The proof that the Margrabe model is complete in the sense stated here follows from the change of numeraire argument used to derive Margrabe’s formula from the Black-Scholes formula (recall that the second asset is risk-free when we use it as the numeraire, so there is a risk-free asset under the new numeraire) and a proof that the Black-Scholes model is complete (which we have omitted, except to show that European options can be replicated).\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will conclude with a proof of the Margrabe formula that does not depend on the Black-Scholes formula. Let \\(x\\) denote the random variable taking the value 1 when \\(S_1_T&gt;S_2_T\\) and which is 0 otherwise. Then the value of the exchange option at maturity is \\(xS_1_T-xS_2_T\\). Let \\(V_i\\) denote the value of the portfolio beginning with \\(\\mathrm{e}^{-q_iT}\\) units of asset \\(i\\) at date \\(0\\) and reinvesting dividends, to accumulate to one share at date \\(T\\). Then \\(V_i_T=S_i_T\\) and from the fundamental pricing Equation 7.28 the value at date \\(0\\) of receiving \\(xS_i_T\\) at date \\(T\\) is \\[\\begin{align*}\nV_i_0\\\\E^{V_i}\\left[x\\frac{S_i_T}{V_i_T}\\right] &= \\mathrm{e}^{-q_iT}S_i_0\\\\E^{V_i}[x] \\\\\n&= \\mathrm{e}^{-q_iT}S_i_0\\times\\text{prob}^{V_i}\\big(V_1_T&gt;V_2_T\\big)\\; .\n\\end{align*}\\] We can write the value of receiving \\(xS_1_T\\) as \\[\\mathrm{e}^{-q_1T}S_1_0\\times\\text{prob}^{V_1}\\left(\\frac{V_2_T}{V_1_T} &lt; 1\\right)\\] and the value of receiving \\(xS_2_T\\) as \\[\\mathrm{e}^{-q_2T}S_2_0\\times\\text{prob}^{V_2}\\left(\\frac{V_1_T}{V_2_T} &gt; 1\\right)\\;.\\] Note that \\(V_2/V_1\\) is a martingale when we use \\(V_1\\) as the numeraire and \\(V_1/V_2\\) is a martingale when we use \\(V_2\\) as the numeraire. Because they are martingales, they have no drifts. The volatility of the ratios is given in Equation 13.6. Therefore, we have \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}(V_2/V_1)}{V_2/V_1} &= \\sigma \\,\\mathrm{d}B^*_1,\\\\\n\\frac{\\,\\mathrm{d}(V_1/V_2)}{V_1/V_2} &= \\sigma \\,\\mathrm{d}B^*_2,\n\\end{align*}\\] where \\(B^*_i\\) is a Brownian motion when \\(V_i\\) is used as the numeraire. Margrabe’s formula now follows from the tail probability formulas Equation 6.11–Equation 6.13.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#section-10",
    "href": "Chapter_Merton.html#section-10",
    "title": "13  Merton, Black, and Margrabe",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nDerive the Greeks of a call option on a futures contract.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the results of the previous exercise, show that the delta hedge of a written call on a futures contract that consists of \\(\\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\) long futures contracts and the value of the call invested in the risk-free asset is a riskless hedge.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive a formula (like put-call parity) for the value of an option to exchange asset~1 for asset~2 in terms of the value of an option to do the reverse exchange.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function Black_Call_Implied_Vol that uses bisection to compute an implied forward price volatility from Black’s formula and the market price of a call option on a forward.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing a synthetic forward argument, derive the forward price for a forward contract on a stock, where the forward matures at \\(T'\\) and the stock pays a single known cash dividend \\(D\\) at date \\(T&lt;T'\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the result of the previous exercise and Black’s formula, derive a formula for the value of a European call option on a stock that pays a single known cash dividend before the option matures.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nModify the function Simulated_Delta_Hedge_Profits to compute the percentiles of gains and losses for an investor who writes a call option on a forward contract and uses a discretely-rebalanced delta hedge. As in Exercise 12.1, you will need to create a variable to keep track of the net asset/liability from trading forwards and include it in the valuation at date \\(T\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider the portfolio that promises to pay \\(\\bar{X}S_T\\) at date \\(T\\) and replicates the payoff using currency forwards described in Section 12.11, where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset. Using Equation 13.39 of gains and losses from trading forwards, verify that the portfolio is riskless.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous exercise using the futures hedge described in Section 13.16.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nIt has been observed empirically that implied volatilities of stocks are upward biased estimates of future volatility. Given that there is not really a constant risk-free rate, implied volatilities should be interpreted as implied forward-price volatilities, whereas the empirical literature has measured future volatility as the subsequent volatility of the stock. What assumptions about bond volatilities and the correlation of bonds and stocks could explain the empirical finding; i.e., what assumptions imply that the volatility of the forward price exceeds the volatility of the stock?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nIn the continuous-time Ho-Lee model described in Chapter 27, the volatility of a discount bond with time \\(\\tau\\) to maturity is \\(\\sigma_r\\tau\\) for a constant \\(\\sigma_r\\). Under this assumption, calculate the average volatility of the forward price of a stock from date \\(0\\) to date \\(T\\), where \\(T\\) is the maturity of the forward contract. Assume the stock has a constant volatility \\(\\sigma_s\\) and the correlation between the stock and bond is a constant \\(\\rho\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nMaking the same assumptions as in the previous exercise, and using the result of that exercise and Merton’s formula, write a Python function to calculate the value of a call option on a stock. The inputs should be \\(S\\), \\(K\\), \\(P\\), \\(\\sigma_s\\), \\(\\sigma_r\\), \\(\\rho\\), \\(q\\), and \\(T\\).\n\n\n\n\n\n\n\nBlack, F. 1976. “The Pricing of Commodity Contracts.” Journal of Financial Economics 3: 167–79.\n\n\nMargrabe, W. 1978. “The Value of an Option to Exchange One Asset for Another.” Journal of Finance 33: 177–86.\n\n\nMerton, R. 1973. “Theory of Rational Option Pricing.” Bell Journal of Economics and Management Science 4: 141–83.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Merton.html#footnotes",
    "href": "Chapter_Merton.html#footnotes",
    "title": "13  Merton, Black, and Margrabe",
    "section": "",
    "text": "Of course, it is possible to give a direct proof, without relying on the Black-Scholes formula. A sketch is given in Section 13.20↩︎\nThis is really nothing more than the usual convention of defining the standard deviation of a random variable to be the positive square root of the variance.↩︎\nThe volatility of a discount bond price cannot be constant because it must go to zero as the bond approaches maturity.↩︎",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html",
    "href": "Chapter_Asians.html",
    "title": "14  Asians, Baskets, and Spreads",
    "section": "",
    "text": "14.1 Asian Options\nThis chapter addresses some “non-vanilla” options that are very important for hedging: Asian options, basket options, and spread options. More exotic options are studied in the following chapter.\nAn Asian option is an option the value of which depends on the average underlying asset price during the lifetime of the option. Average-price calls and puts are defined like standard calls and puts but with the final asset price replaced by the average price. Average-strike calls and puts are defined like standard calls and puts but with the exercise price replaced by the average asset price. A firm that must purchase an input at frequent intervals or will sell a product in a foreign currency at frequent intervals can use an average price option as an alternative to buying multiple options with different maturity dates. The average-price option will generally be both less expensive and a better hedge than purchasing multiple options.\nIn practice, the average price is computed by averaging over the prices sampled at a finite number of discrete dates. First, we consider the case of continuous sampling. With continuous sampling, the average price at date \\(T\\) for an option written at date \\(0\\) will be denoted by \\(A_T\\) and is defined as \\[\nA_T = \\frac{1}{T}\\int_0^T S_t\\,\\mathrm{d}t\\; .\n\\] To obtain a closed-form solution for the value of an option on the average price, we face essentially the same problem as for basket and spread options: a sum of lognormally distributed variables is not itself lognormally distributed. In this case, the integral, which is essentially a continuous sum of the prices at different dates, is not lognormally distributed.\nAn alternative contract would replace the average price with the geometric average. This is defined as the exponential of the average logarithm. We will denote this by \\(A_\\text{g}_T\\). The average logarithm is \\[\n\\frac{1}{T}\\int_0^T \\log S_t\\,\\mathrm{d}t\\; ,\n\\] and the geometric average is \\[\nA_\\text{g}_T = \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\,\\mathrm{d}t\\right)\\; .\n\\] The concavity of the logarithm function guarantees that \\[\n\\log \\frac{1}{T}\\int_0^T S_t &gt; \\frac{1}{T}\\int_0^T \\log S_t\\,\\mathrm{d}t \\; .\n\\] Therefore, \\[\\begin{align*}\nA_T &= \\exp\\left(\\log \\frac{1}{T}\\int_0^T S_t\\right)\\\\\n&&gt; \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\,\\mathrm{d}t\\right) \\\\\n&= A_\\text{g}_T\\; .\n\\end{align*}\\] Consequently, approximating the value of an average-price or average-strike option by substituting \\(A_\\text{g}_T\\) for \\(A_T\\) will produce a biased estimate of the value. Nevertheless, the geometric average\\(A_\\text{g}_T\\) and the arithmetic average \\(A_T\\) will be highly correlated, so \\(A_\\text{g}_T\\) forms a very useful for Monte-Carlo valuation of average-price and average-strike options, as will be discussed later. To implement the idea, we need a valuation formula for options written on \\(A_\\text{g}_T\\). We will derive this for an average-price call, in which \\(A_\\text{g}_T\\) substitutes for \\(A_T\\).\nSpecifically, consider a contract that pays \\[\n\\max(0,A_\\text{g}_T-K)\n\\] at its maturity \\(T\\). This is a geometric-average-price call,, and we will analyze it in the same way that we analyzed quanto options in Chapter 12. Let \\(V_t\\) denote the value at date \\(t\\) of receiving \\(A_\\text{g}_T\\) at date \\(T\\). This can be calculated, and the result will be given below. \\(V_t\\) is the value of a dividend-reinvested portfolio, and, by definition, \\(V_T=A_\\text{g}_T\\), so the geometric-average-price call is equivalent to a standard call with \\(V\\) being the price of the underlying. We will show that \\(V\\) has a time-varying but non-random volatility. Therefore, we can apply the Black-Scholes formula, inputting the average volatility as described in ?sec-s:timevaryingvolatility, to value the geometric-average-price call. We could attempt the same route to price average-price options, but we would find that the volatility of the corresponding value \\(V\\) would vary randomly, just as we found the basket portfolio to have a random volatility in the previous section.\nThe value \\(V_t\\) can be calculated as \\[\nV_t= \\mathrm{e}^{-r(T-t)}\\\\E^R_t\\big[A_\\text{g}_T\\big]\\; .\n\\] Define \\[\nA_g_t = \\exp\\left(\\frac{1}{t}\\int_0^t \\log S(u)\\,du\\right)\\;.\n\\]\nWe will verify at the end of this section that \\[\nV_t = \\mathrm{e}^{-r(T-t)}A_g_t^{\\frac{t}{T}}S_t^{\\frac{T-t}{T}}\\exp\\left(\\frac{(r-q-\\sigma^2/2)(T-t)^2}{2T} + \\frac{\\sigma^2(T-t)^3}{6T^2}\\right)\\;.\n\\qquad(14.1)\\]\nTwo points are noteworthy. First, the value at date \\(0\\) is\n\\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left(\\frac{(r-q-\\sigma^2/2)T}{2} + \\frac{\\sigma^2T}{6}\\right)\n\\] \\[\n=\\exp\\left(-\\frac{6r+6q + \\sigma^2}{12}T\\right)S_0\\;.\n\\qquad(14.2)\\]\nSecond, the volatility comes from the factor \\[\nS_t^{\\frac{T-t}{T}}\\;,\n\\] and, by Ito’s formula, \\[\n\\frac{ \\,\\mathrm{d}S^{\\frac{T-t}{T}}}{S^{\\frac{T-t}{T}}} = \\text{something}\\,\\mathrm{d}t + \\left(\\frac{T-t}{T}\\right)\\sigma\\,\\mathrm{d}B\\;.\n\\] This implies that the average volatility, in the sense of ?sec-s:timevaryingvolatility, is \\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{T}\\int_0^T \\left(\\frac{T-t}{T}\\right)^2\\sigma^2\\,\\mathrm{d}t}\n=\\frac{\\sigma}{\\sqrt{3}}\\;.\n\\] Applying the Black-Scholes formula yields:\nWe can also value a discretely-sampled geometric-average-price call by the same arguments. Consider dates \\(0&lt;t_0&lt; t_1 &lt; \\cdots t_N=T\\), where \\(t_i-t_{i-1}=\\Delta t\\) for each \\(i\\) and suppose the price is to be sampled at the dates \\(t_1,\\ldots,t_N\\). Now let \\(V_t\\) denote the value at date \\(t\\) of the contract that pays \\[\n\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right) = \\left(\\prod_{i=1}^N S_{t_i}\\right)^{1/N}\n\\qquad(14.3)\\]\nat date \\(T\\). The call option will pay \\(\\max(0,V_T-K)\\) at date \\(T\\). Let \\(k\\) denote the integer such that \\(t_{N-k-1} \\leq t &lt; t_{N-k}\\). This means that we have already observed the prices \\(S(t_1), \\ldots, S(t_{N-k-1})\\) and we have yet to observe the \\(k+1\\) prices \\(S(t_{N-k}), \\ldots ,S(t_N)\\). Define \\(\\varepsilon = (t_{N\\!-k}-t)/\\Delta t\\), which is fraction of the interval \\(\\Delta t\\) that must pass before we reach the next sampling date \\(t_{N\\!-k}\\). We will show at the end of this section that\n\\[\n\\begin{multline}\nV_t = \\mathrm{e}^{-r(T-t)}S_t^{\\frac{k+1}{N}}\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\\\\n\\times\\,\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}\\!+\\! \\frac{k(k+1)\\nu}{2N}\\! +\\! \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}\\!+\\!\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\;,\n\\end{multline}\n\\qquad(14.4)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\)\nAgain, two points are noteworthy. Assume the call was written at date \\(0\\) and the first observation date \\(t_1\\) is \\(\\Delta t\\) years away. Then, we have \\(k+1=N\\) and \\(\\varepsilon=1\\) so \\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left( \\frac{(N+1)\\nu\\Delta t}{2} + \\frac{(N+1)(2N+1)\\sigma^2\\Delta t}{12N} \\right)\\;.\n\\qquad(14.5)\\]\nSecond, the volatility of \\(V_t\\) comes from the factor \\(S_t^{(k+1)/N}\\), and \\[\n\\frac{ \\,\\mathrm{d}S^{\\frac{k+1}{N}}}{S^{\\frac{k+1}{N}}} = \\text{something}\\,\\mathrm{d}t + \\left(\\frac{k+1}{N}\\right)\\sigma\\,\\mathrm{d}B\\;.\n\\] This implies that the average volatility, in the sense of ?sec-s:timevaryingvolatility, is\n\\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{N}\\sum_{k=0}^{N-1} \\left(\\frac{k+1}{N}\\right)^2\\sigma^2\\,\\mathrm{d}t}\n\\] \\[\n=\\frac{\\sigma}{N^{3/2}}\\sqrt{\\frac{N(N+1)(2N+1)}{6}}\\;,\n\\qquad(14.6)\\]\nwhere we have used the fact that \\(\\sum_{i=1}^N i^2 = N(N+1)(2N+1)/6\\) to obtain the second equality. Thus, the Black-Scholes formula implies:\nThis formula will be used in Section 20.2 as a control variate for pricing discretely-sampled average-price calls (even average-price calls that were written before the date of valuation).\nThe following code computes the price of a geometric-average-price call.\nCode\n\"\"\"\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\nprint(\"Discrete Geometric Average Price Call:\", discrete_geom_average_price_call(S, K, r, sigma, q, T, N))\n\"\"\"\n\n\n'\\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\\n    dt = T / N\\n    nu = r - q - 0.5 * sigma ** 2\\n    a = N * (N + 1) * (2 * N + 1) / 6\\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\\n    return black_scholes_call(V, K, r, sigavg, q, T)\\n\\nprint(\"Discrete Geometric Average Price Call:\", discrete_geom_average_price_call(S, K, r, sigma, q, T, N))\\n'",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#asian-options",
    "href": "Chapter_Asians.html#asian-options",
    "title": "14  Asians, Baskets, and Spreads",
    "section": "",
    "text": "14.2\n\n\n\nThe value at date \\(0\\) of a continuously-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 14.2, and \\(\\sigma_{\\text{avg}}=\\sigma/\\sqrt{3}\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.3\n\n\n\nThe value at date \\(0\\) of a discretely-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\qquad(14.7)\\]\nwhere \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 14.5, and \\(\\sigma_{\\text{avg}}\\) is defined in Equation 14.6.\n\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will now derive Equation 14.1 and Equation 14.4. We will begin with Equation 14.1. The random variable \\(A_g_T\\) is normally distributed under the risk-neutral probability given information at time \\(t\\). To establish this, and to calculate the mean and variance of \\(A_g_T\\), the key is to change the order of integration in the integral in the second line below to obtain the third line: \\[\\begin{align*}\n\\int_t^T \\log S(u)\\,du &= \\int_t^T \\left\\{\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(u-t) + \\sigma [B(u)-B_t]\\right\\}\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_t^u \\,\\mathrm{d}B_s\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_s^T du\\,\\mathrm{d}B_s\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T (T-s)\\,\\mathrm{d}B_s\n\\end{align*}\\] and then to note that \\(\\int_t^T (T-s)\\,\\mathrm{d}B_s\\) is normally distributed with mean zero and variance equal to \\[\n\\int_t^T (T-s)^2\\,ds =\\frac{(T-t)^3}{3}\\;.\n\\] Therefore \\(\\\\E^R_t\\left[A_g_T\\right]\\) is the expectation of the exponential of a normally distributed random variable. Equation~Equation 14.1 now follows from the fact that if \\(x\\) is normally distributed with mean \\(\\mu\\) and variance \\(\\sigma^2\\) then \\(\\\\E\\left[\\mathrm{e}^x\\right] = \\mathrm{e}^{\\mu+\\sigma^2/2}\\).\nTo establish Equation 14.4, note that the discounted risk-neutral expectation of Equation 14.3, conditional on having observed \\(S(t_1), \\ldots, S(t_{N-k-1})\\), is\n\\[\nV_t = \\mathrm{e}^{-r(T-t)}\\\\E^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n= \\mathrm{e}^{-r(T-t)}\\exp\\left(\\frac{1}{N}\\sum_{i=1}^{N-k-1} \\log S_{t_i}\\right)\\times \\\\E^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n=\\left(\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\right)\\times \\mathrm{e}^{-r(T-t)}\\\\E^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\\;.\n\\qquad(14.8)\\]\nLet \\(\\Delta_0B = B(t_{N-k})-B_t\\) and \\(\\Delta_iB = B(t_{N\\!-k+i})-B(t_{N\\!-k+i-1})\\) for \\(i \\geq 1\\). We can write the sum of logarithms inside the expectation above as \\[\\begin{multline*}\n\\sum_{i=0}^{k}\\big\\{[\\log S_t + (t_{N-k+i}-t)\\nu + \\sigma [B(t_{N-k+i})-B_t]\\big\\}\\\\\n=(k+1)\\log S_t + \\sum_{i=0}^{k} (\\varepsilon + i)\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} [\\Delta_0B + \\Delta_1B + \\cdots + \\Delta_iB] \\\\\n=(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} (k+1-i)\\Delta_iB\\;,\n\\end{multline*}\\] where to obtain the last equality we used the fact that \\(\\sum_{i=0}^k i = k(k+1)/2\\). The random variables \\(\\Delta_iB\\) are normally distributed with mean zero and variance \\(\\Delta t\\) (the variance is \\(\\varepsilon \\Delta t\\) for \\(i=0\\)). Thus, the sum of logarithms is a normally distributed random variable with mean \\[\n(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t\n\\] and variance \\[\n(k+1)^2\\sigma^2\\varepsilon\\Delta t + \\sigma^2\\sum_{i=1}^{k} (k+1-i)^2\\Delta t = (k+1)^2\\sigma^2\\varepsilon\\Delta t +\\frac{k(k+1)(2k+1)\\sigma^2}{6}\\; ,\n\\] using the fact that \\(\\sum_{i=1}^k i^2 = k(k+1)(2k+1)/6\\). The expectation of the exponential of a normally distributed random variable equals the exponential of its mean plus one-half of its variance, and the exponential of \\((k+1)\\log S_t/N\\) is \\(S_t^{(k+1)/N}\\). Therefore the conditional expectation in Equation 14.8 is \\[S_t^{\\frac{k+1}{N}}\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}+ \\frac{k(k+1)\\nu}{2N} + \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}+\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\; ,\n\\] which implies Equation 14.4.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#basket-options",
    "href": "Chapter_Asians.html#basket-options",
    "title": "14  Asians, Baskets, and Spreads",
    "section": "14.4 Basket Options",
    "text": "14.4 Basket Options\nA basket option is an option written on a portfolio of assets. For example, someone may want to hedge the change in the value of the dollar relative to a basket of currencies. A basket option is an alternative to purchasing separate options on each currency. Generally, the basket option would have a lower premium than the separate options, because an option on a portfolio is cheaper (and pays less at maturity) than a portfolio of options.\nLetting \\(S_1\\), , \\(S_n\\) denote the asset prices and \\(w_1\\), , \\(w_n\\) the weights specified by the contract, a basket call would pay \\[\\max\\left(0,\\;\\sum_{i=1}^n w_iS_i_T - K\\right)\\] at maturity \\(T\\). A spread option is actually a special case of a basket option, with \\(n=2\\), \\(w_1=1\\), and \\(w_2=-1\\). The difficulty in valuing basket options is the same as that encountered in valuing spread options. The volatility of the basket price \\(\\sum_{i=1}^nw_iS_i_t\\) will vary over time, depending on the relative volatilities of the assets and the price changes in the assets. For example, consider the case \\(n=2\\) and write \\(S_t\\) for the basket price \\(w_1S_1_t+w_2S_2_t\\). Then \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}S}{S} &= \\frac{w_1\\,\\mathrm{d}S_1}{S} + \\frac{w_2\\,\\mathrm{d}S_2}{S}\\\\\n&=\\frac{w_1S_1}{S}\\times \\frac{\\,\\mathrm{d}S_1}{S_1} + \\frac{w_2S_2}{S}\\times \\frac{\\,\\mathrm{d}S_2}{S_2}\\;.\n\\end{align*}\\] Let \\(x_i_t=w_iS_i_t/S_t\\). This is the fraction of the portfolio value that the \\(i\\)–th asset contributes. It will vary randomly over time as the prices change. Letting \\(\\sigma_i\\) denote the volatilities of the individual assets and \\(\\rho\\) their correlation, the formula just given for \\(\\,\\mathrm{d}S/S\\) shows that the instantaneous volatility of the basket price at any date \\(t\\) is \\[\n\\sqrt{x_1^2_t\\sigma_1^2 + 2x_1_tx_2_t\\rho\\sigma_1\\sigma_2 + x_2^2_t\\sigma_2^2}\\; .\n\\]\nHence, the volatility will vary randomly over time as the \\(x_i\\) change. There is no simple closed-form solution for the value of a basket option.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#spread-options",
    "href": "Chapter_Asians.html#spread-options",
    "title": "14  Asians, Baskets, and Spreads",
    "section": "14.5 Spread Options",
    "text": "14.5 Spread Options\nA spread option is a call or a put written on the difference of two asset prices. For example, a spread call will pay at maturity \\(T\\) the larger of zero and \\(S_1_T-S_2_T-K\\), where the \\(S_i\\) are the asset prices and \\(K\\) is the strike price of the call. Spread options can be used by producers to hedge the difference between an input price and an output price. They are also useful for hedging basis risk. For example, someone may want to hedge an asset by selling a futures contract on a closely related but not identical asset. This exposes the hedger to basis risk: the difference in value between the asset and the underlying asset on the futures contract. A spread call can hedge the basis risk: take \\(S_1\\) to be the value of the asset underlying the futures contract and \\(S_2\\) the value of the asset being hedged.\nA spread option is actually an exchange option. Assuming constant dividend yields \\(q_1\\) and \\(q_2\\), we can take the assets underlying the exchange option to be as follows\n\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_1T}\\) units of the asset with price \\(S_1\\) and reinvest dividends, leading to a value of \\(S_1_T\\) at date \\(T\\),\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_2T}\\) units of the asset with price \\(S_2\\) and invest \\(\\mathrm{e}^{-rT}K\\) in the risk-free asset. Reinvesting dividends and accumulating interest means that we will have \\(S_2_T+K\\) dollars at date \\(T\\).\n\nHowever, we cannot apply Margrabe’s formula to price spread options, because the second portfolio described above will have a stochastic volatility. To see this, note that if the price \\(S_2_t\\) falls to a low level, then the portfolio will consist primarily of the risk-free asset, so the portfolio volatility will be near the volatility of the risk-free asset, which is zero. On the other hand, if \\(S_2_t\\) becomes very high, then the portfolio will be weighted very heavily on the stock investment, and its volatility will approach the volatility of \\(S_2\\).",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#section-2",
    "href": "Chapter_Asians.html#section-2",
    "title": "14  Asians, Baskets, and Spreads",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nIntuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T'\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Compute and plot the value of the option for \\(T=0.1T'\\), \\(T=0.2T'\\), , \\(T=0.9T'\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K'=S\\) (i.e., the call is at the money) and maturity \\(T'\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T'\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T'\\). Take the date of the dividend payment to be \\(T=0.5T'\\) and take the strike price to be \\(K=S\\). As discussed in Section 11.3, the value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 15.12. Verify that the function gives the same result as the function Chooser.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Take the time to maturity of the underlying call and put to be \\(T'\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T'\\). Compute the cost of the chooser and the cost of the straddle.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nA stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 15.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\n\n\nExercise 14.1 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 14.2 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 14.3 Modify Exercise 15.1 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 15.1 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 14.4 Modify Exercise 15.2 by including the hedge in Exercise 15.3. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 14.5 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 15.1.\n\n\nExercise 14.6 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive Equation 15.19 for the value of a call on a put.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nComplete the derivation of Equation 15.34 for the value of a chooser option.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_2_0 + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html",
    "href": "Chapter_Exotics.html",
    "title": "15  Other Exotics",
    "section": "",
    "text": "15.1 Barrier Options\nWe study six classes of exotic options:\nA down-and-out call pays the usual call value at maturity if and only if the stock price does not hit a specified lower bound during the lifetime of the option. If it does breach the lower barrier, then it is out. Conversely, a down-and-in call pays off only if the stock price does hit the lower bound. Up-and-out and up-and-in calls are defined similarly, and there are also put options of this sort. The out versions are called knock-outs and the in versions are called knock-ins.\nKnock-ins can be priced from knock-outs and vice-versa. For example, the combination of a down-and-out call and a down-and-in call creates a standard European call, so the value of a down-and-in can be obtained by subtracting the value of a down-and-out from the value of a standard European call. Likewise, up-and-in calls can be valued by subtracting the value of an up-and-out from the value of a standard European call. Both knock-outs and knock-ins are of course less expensive than comparable standard options.\nWe will describe the pricing of a down-and-out call. The pricing of up-and-out calls and knock-out puts is similar. Often there are rebates associated with the knocking-out of a barrier option, but we will not include that feature here (see Section 22.7 however).\nA down-and-out call provides a hedge against an increase in an asset price, just as does a standard call, for someone who is short the asset. The difference is that the down-and-out is knocked out when the asset price falls sufficiently. Presumably this is acceptable to the buyer because the need to hedge against high prices diminishes when the price falls. In fact, in this circumstance the buyer may want to establish a new hedge at a lower strike. However, absent re-hedging at a lower strike, the buyer of a knock-out call obviously faces the risk that the price may reverse course after falling to the knock-out boundary, leading to regret that the option was knocked out. The rationale for accepting this risk is that the knock-out is cheaper than a standard call. Thus, compared to a standard call, a down-and-out call provides cheaper but incomplete insurance.\nThe combination of a knock-out call and a knock-in call (or knock-out puts) with the same barrier and different strikes creates an option with a strike that is reset when the barrier is hit. This is a hedge that adjusts automatically to the market. An example is given in Probs.~\\(\\ref{e_standardknockout3}\\) and~\\(\\ref{e_standardknockout4}\\).",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:barriers",
    "href": "Chapter_Exotics.html#sec-s:barriers",
    "title": "15  Other Exotics",
    "section": "",
    "text": "Down-and-Out Call Payoff\nLet \\(L\\) denote the lower barrier for the down-and-out call and assume it has not yet been breached at the valuation date, which we are calling date \\(0\\). Denote the minimum stock price realized during the remaining life of the contract by \\(z = \\min_{0\\leq t\\leq T} S_t\\). In practice, this minimum is calculated at discrete dates (for example, based on daily closing prices), but we will assume here that the stock price is monitored continuously for the purpose of calculating the minimum.\nThe down-and-out call will pay \\(\\max(0,S_T-K)\\) if \\(z &gt; L\\) and 0 otherwise, at its maturity T.\nLet \\[\nx = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z &gt; L$\\;,}\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\n\\] Then the value of the down-and-out call at maturity is \\[\nxS_T - xK\\; .\n\\] ### Numeraires As in other cases, the value at date \\(0\\) can be written as \\[\n\\mathrm{e}^{-qT}S_0\\times\\text{prob}^{V}(x=1) - \\mathrm{e}^{-rT}K\\times\\text{prob}^{R}(x=1)\\; ,\n\\]\nwhere \\(V_t = \\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nTo calculate \\(\\text{prob}^{V}(x=1)\\) and \\(\\text{prob}^{R}(x=1)\\), we consider two cases.\n\nSuppose \\(K&gt;L\\). Define \\[\ny = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z \\leq L$}\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;K\\) is equal to the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!K) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!K) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\]\nAs in the derivation of the Black-Scholes formula, we have \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_2)\\;,\n\\qquad(15.1)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(15.2)\\]\nFurthermore , defining \\[\nd_1' = \\frac{\\log\\left(\\frac{L^2}{KS_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2' = d_1'-\\sigma\\sqrt{T}\\;,\n\\qquad(15.3)\\]\nit can be shown (see Appendix~\\(\\ref{a_minimum}\\)) that\n\\[\n\\text{prob}^{V}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1')\\;,\n\\qquad(15.4)\\]\n\\[\n\\text{prob}^{R}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2')\\;.\n\\qquad(15.5)\\]\n\nSuppose \\(K \\leq L\\). Then the condition \\(S_T&gt;K\\) in the definition of the event \\(x=1\\) is redundant: if \\(z &gt; L \\geq K\\), then it is necessarily true that \\(S_T&gt;K\\). Therefore, the probability (under either numeraire) of the event \\(x=1\\) is the probability that \\(z &gt; L\\). Define \\[y = \\begin{cases} 1 & \\text{if $S_T&gt;L$ and $z \\leq L$\\;,}\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;L\\) is the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, as in the previous case (but now with \\(K\\) replaced by \\(L\\)), \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!L) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!L) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\] Also as before, we know that \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_2)\\;,\n\\qquad(15.6)\\]\nwhere now\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{L}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(15.7)\\]\nMoreover, \\(\\text{prob}^{V}(y=1)\\) and \\(\\text{prob}^{R}(y=1)\\) are given by Equation 15.4 - Equation 15.5 but with \\(K\\) replaced by \\(L\\), which means that \\[\nd_1' = \\frac{\\log\\left(\\frac{L}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2'= d_1' - \\sigma\\sqrt{T}\\;.\n\\qquad(15.8)\\]\n\n\nDown-and-Out Call Pricing Formula\n\n\n\n\n\n\nCalculation Rule\n\n\n\nThe value of a continuously-sampled down-and-out call option with barrier \\(L\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\left[\\mathrm{N}(d_1)-\\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1')\\right]\\\\ - \\mathrm{e}^{-rT}K\\left[\\mathrm{N}(d_2) - \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2')\\right]\\;,\n\\end{multline}\n\\qquad(15.9)\\]\nwhere\n\nif \\(K&gt;L\\), \\(d_1\\), \\(d_2\\) , \\(d_1'\\) and \\(d_2'\\) are defined in Equation 15.2 - Equation 15.3,\nif \\(K\\leq L\\), \\(d_1\\), \\(d_2\\), \\(d_1'\\) and \\(d_2'\\) are defined in Equation 15.7 - Equation 15.8.\n\n\n\nThe following code computes the price of a down and out call option.\n\n\nCode\n\"\"\"\n\ndef down_and_out_call(S, K, r, sigma, q, T, Barrier):\n    if K &gt; Barrier:\n        a = S / K\n        b = Barrier * Barrier / (K * S)\n    else:\n        a = S / Barrier\n        b = Barrier / S\n\n    d1 = (np.log(a) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1prime = (np.log(b) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2prime = d1prime - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N1prime = norm.cdf(d1prime)\n    N2prime = norm.cdf(d2prime)\n    x = 1 + 2 * (r - q) / (sigma ** 2)\n    y = x - 2\n    q1 = N1 - (Barrier / S) ** x * N1prime\n    q2 = N2 - (Barrier / S) ** y * N2prime\n\n    return np.exp(-q * T) * S * q1 - np.exp(-r * T) * K * q2\nprint(\"Down and Out Call:\", down_and_out_call(S, K, r, sigma, q, T, 80))\n\"\"\"\n\n\n'\\n\\ndef down_and_out_call(S, K, r, sigma, q, T, Barrier):\\n    if K &gt; Barrier:\\n        a = S / K\\n        b = Barrier * Barrier / (K * S)\\n    else:\\n        a = S / Barrier\\n        b = Barrier / S\\n\\n    d1 = (np.log(a) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\\n    d2 = d1 - sigma * np.sqrt(T)\\n    d1prime = (np.log(b) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\\n    d2prime = d1prime - sigma * np.sqrt(T)\\n    N1 = norm.cdf(d1)\\n    N2 = norm.cdf(d2)\\n    N1prime = norm.cdf(d1prime)\\n    N2prime = norm.cdf(d2prime)\\n    x = 1 + 2 * (r - q) / (sigma ** 2)\\n    y = x - 2\\n    q1 = N1 - (Barrier / S) ** x * N1prime\\n    q2 = N2 - (Barrier / S) ** y * N2prime\\n\\n    return np.exp(-q * T) * S * q1 - np.exp(-r * T) * K * q2\\nprint(\"Down and Out Call:\", down_and_out_call(S, K, r, sigma, q, T, 80))\\n'",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:lookbacks",
    "href": "Chapter_Exotics.html#sec-s:lookbacks",
    "title": "15  Other Exotics",
    "section": "15.2 Lookbacks",
    "text": "15.2 Lookbacks\n A floating-strike lookback call pays the difference between the asset price at maturity and the minimum price realized during the life of the contract. A floating-strike lookback put pays the difference between the maximum price over the life of the contract and the price at maturity. Thus, the floating-strike lookback call allows one to buy the asset at its minimum price, and the floating-strike lookback put allows one to sell the asset at its maximum price. Of course, one pays upfront for this opportunity to time the market. These options were first discussed by Goldman, Sosin and Gatto (Goldman, Sosin, and Gatto 1979).\nA fixed-strike lookback put pays the difference between a fixed strike price and the minimum price during the lifetime of the contract. Thus, a fixed-strike lookback put and a floating-strike lookback call are similar in one respect: both enable one to buy the asset at its minimum price. However, the put allows one to sell the asset at a fixed price whereas the call allows one to sell it at the terminal asset price. A fixed-strike lookback call pays the difference between the maximum price and a fixed strike price and is similar to a floating-strike lookback put in the sense that both enable one to sell the asset at its maximum price. Fixed-strike lookback options were first discussed by Conze and Viswanathan (Conze and Viswanathan 1991). We will discuss the valuation of floating-strike lookback calls. As in the discussion of barrier options, we will assume that the price is continuously sampled for the purpose of computing the minimum.\n\nFloating-Strike Lookback Call Payoff\nAs in the previous section, let \\(z\\) denote the minimum stock price realized over the remaining lifetime of the contract. This is not necessarily the minimum stock price realized during the entire lifetime of the contract. Let \\(S_{\\min}\\) denote the minimum stock price realized during the lifetime of the contract up to and including date \\(0\\), which is the date at which we are valuing the contract. The minimum stock price during the entire lifetime of the contract will be the smaller of \\(z\\) and \\(S_{\\text{min}}\\). The payoff of the floating strike lookback call is \\(S_T - \\min\\left(z, S_{\\text{min}}\\right)\\).\n\n\nCalculations\nThe value at date \\(0\\) of the piece \\(S_T\\) is simply \\(\\mathrm{e}^{-qT}S_0\\). Using the result in Appendix~\\(\\ref{a_minimum}\\) on the distribution of \\(z\\), it can be shown (see, e.g., Musiela and Rutkowski (Musiela and Rutkowski 1997) for the details) that the value at date \\(0\\) of receiving \\[\n\\min(z, S_{\\text{min}})\n\\] at date \\(T\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) -\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2') \\\\\n+\\left(1+ \\frac{\\sigma^2}{2(r-q)}\\right)\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;.\n\\end{multline*}\\] where\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S_{\\text{min}}}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; , \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(15.10)\\]\n\\[\nd_1' = \\frac{\\log\\left(\\frac{S_{\\text{min}}}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2'=d_1' - \\sigma\\sqrt{T} \\;.\n\\qquad(15.11)\\]\nUsing the fact that \\([1-\\mathrm{N}(-d_1)]\\mathrm{e}^{-qT}S_0=\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)\\), this implies:\n\n\nFloating-Strike Lookback Call Pricing Formula\n\n\n\n\n\n\n15.3\n\n\n\nThe value at date \\(0\\) of a continuously-sampled floating-strike lookback call, given that the minimum price during the lifetime of the contract through date \\(0\\) is \\(S_{\\text{min}}\\) and the remaining time to maturity is \\(T\\), is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) \\\\+\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2') \\\\\n-\\frac{\\sigma^2}{2(r-q)}\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\end{multline}\n\\qquad(15.12)\\]\nwhere \\(d_1\\), \\(d_2\\), and \\(d_2'\\) are defined in Equation 15.10 - Equation 15.11.\n\n\nThe following program calculates the price of a floating strike lookback option.\n\n\nCode\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\n# Example usage\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\n\n# print(\"Floating Strike Call:\", floating_strike_call(S, r, sigma, q, T, 90))",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#compound-options",
    "href": "Chapter_Exotics.html#compound-options",
    "title": "15  Other Exotics",
    "section": "15.4 Compound Options",
    "text": "15.4 Compound Options\nA compound option is an option on an option, for example a call option on a call option or a call on a put. These options are useful for hedging when there is some uncertainty about the need for hedging which may be resolved by the exercise date of the compound option. As speculative trades, they have the benefit of higher leverage than ordinary options. These options were first discussed by Geske (Geske 1979).\n\nCall-on-a-Call Payoff\nLet the underlying call option have exercise price \\(K'\\) and maturity \\(T'\\). Consider an option maturing at \\(T&lt;T'\\) to purchase the underlying call at price \\(K\\).\nLet \\(C(t,S)\\) denote the value at date \\(t\\) of the underlying call when the stock price is \\(S\\) (i.e., \\(C\\) is the Black-Scholes formula). It is of course rational to exercise the compound call at date \\(T\\) if the value of the underlying call exceeds \\(K\\); i.e., if \\(C(T,S_T)&gt;K\\). Let \\(S^*\\) denote the critical price such that \\(C(T,S^*)=K\\). To calculate \\(S^*\\), we need to solve\nBlack_Scholes_Call(S*,Kprime,r,sigma,q,Tprime-T) = K\nfor \\(S^*\\). We can do this by bisection or one of the other methods mentioned in Section 10.8. It is rational to exercise the compound option when \\(S_T &gt; S^*\\).\nWhen \\(S_T &gt; S^*\\), exercise of the compound option generates a cash flow of \\(-K\\) at date \\(T\\). There is a cash flow (of \\(S_{T'}-K'\\)) at date \\(T'\\) only if the compound call is exercised and the underlying call finishes in the money. This is equivalent to: \\[\nS_T &gt; S^* \\quad\\text{and}\\quad S_{T'}&gt;K'\\;.\n\\qquad(15.13)\\]\nLet \\[\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$\\;,}\\\\\n                               0 & \\text{otherwise\\;,}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$ and $S_{T'}&gt;K'$\\;,}\\\\\n                               0 & \\text{otherwise\\;.}\n        \\end{cases}\n\\end{align*}\\] The cash flows of the compound option are \\(-xK\\) at date \\(T\\) and \\(yS_{T'}-yK'\\) at date \\(T'\\). We can value the compound option at date \\(0\\) by valuing these separate cash flows.\nThe cash flow \\(-xK\\) is the cash flow from being short \\(K\\) digital options on the underlying asset with strike price \\(S^*\\) and maturity \\(T\\). Therefore the value at date \\(0\\) of this cash flow is \\(-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\), where \\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},  \\qquad d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(15.14)\\]\n\n\nNumeraires\nThe payoffs \\(yS_T\\) and \\(yK'\\) are similar to share digitals and digitals, respectively, except that the event \\(y=1\\) is more complex than we have previously encountered. However, we know from the analysis of share digitals and digitals that the values at date \\(0\\) of these payoffs are \\[\n\\mathrm{e}^{-q T'}S_0\\times\\text{prob}^V\\!(y=1) \\quad \\text{and}\\quad \\mathrm{e}^{-rT'}K'\\times\\text{prob}^R(y=1)\\; ,\n\\] where \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nWe will calculate the two probabilities in terms of the bivariate normal distribution function.\n\nThe event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K'\\; ,\n\\] where \\(B^*\\) is a Brownian motion when the underlying asset (\\(V\\)) is used as the numeraire. These conditions can be rearranged as\n\n\\[-\\frac{B^*_T}{\\sqrt{T}}&lt;d_1 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}}&lt;d_1'\\;,\n\\qquad(15.15)\\]\nwhere \\(d_1\\) is defined in Equation 15.14, and \\[\nd_1' = \\frac{\\log\\left(\\frac{S_0}{K'}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'}{\\sigma\\sqrt{T'}}\\;,\n\\qquad d_2'=d_1'-\\sigma\\sqrt{T'}\\;.\n\\qquad(15.16)\\]\nThe two standard normal variables on the left-hand sides in Equation 15.15 have a covariance equal to \\[\n\\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_{T'}) = \\frac{1}{\\sqrt{TT'}}\\mathrm{cov}(B_T,B_T) = \\sqrt{\\frac{T}{T'}}\\; ,\n\\]\nthe first equality following from the fact that \\(B_T\\) is independent of \\(B_{T'}-B_T\\) and the second from the fact that the covariance of a random variable with itself is its variance. Hence, \\(\\text{prob}^V\\!(y=1)\\) is the probability that \\(a\\leq d_1\\) and \\(b\\leq d_1'\\), where \\(a\\) and \\(b\\) are standard normal random variables with covariance (= correlation coefficient) of \\(\\sqrt{T/T'}\\). We will write this probability as \\(\\mathrm{M}\\!\\left(d_1,d_1',\\sqrt{T/T'}\\right)\\). A program to approximate the bivariate normal distribution function \\(\\mathrm{M}\\) is provided later.\n\nThe calculation for \\(\\text{prob}^R(y=1)\\) is similar. The event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\\;,\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T'+\\sigma B^*_{T'} &gt; \\log K'\\; ,\n\\] where \\(B^*\\) now denotes a Brownian motion under the risk-neutral probability. These are equivalent to \\[\n-\\frac{B^*_T}{\\sqrt{T}}&lt;d_2 \\quad \\text{and} \\quad - \\frac{B^*_{T'}}{\\sqrt{T'}} &lt; d_2'\\;.\n\\qquad(15.17)\\]\n\nHence, \\(\\text{prob}^R(y=1)=\\mathrm{M}\\!\\left(d_2,d_2',\\sqrt{T/T'}\\right)\\).\n\n\nCall-on-a-Call Pricing Formula\nWe conclude:\n\n\n\n\n\n\n15.5\n\n\n\nThe value of a call on a call is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2) + \\mathrm{e}^{-q T'}S_0\\mathrm{M}\\!\\left(d_1,d_1',\\sqrt{T/T'}\\right)\n\\\\- \\mathrm{e}^{-rT'}K'\\mathrm{M}\\!\\left(d_2,d_2',\\sqrt{T/T'}\\right)\\;,\n\\end{multline}\n\\qquad(15.18)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 15.14 and \\(d_1'\\) and \\(d_2'\\) are defined in Equation 15.16.\n\n\n\n\nPut-Call Parity\nEuropean compound options with the same underlyings and strikes satisfy put-call parity in the usual way: \\[\n\\text{Cash} + \\text{Call} = \\text{Underlying} + \\text{Put}\\; .\n\\]\nThe portfolio on each side of this equation gives the owner the maximum of the strike and the value of the underlying at the option maturity. In the case of options on calls, put-call parity is specifically \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on call} \\\\= \\text{Value of underlying call} + \\text{Value of put on call}\\; ,\n\\end{multline*}\\] where \\(K\\) is the strike price of the compound options and \\(T\\) is their maturity date. Likewise, for options on puts, we have \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on put} \\\\= \\text{Value of underlying put} + \\text{Value of put on put}\\; .\n\\end{multline*}\\] Thus, the value of a put on a call can be derived from the value of a call on a call. The value of a put on a put can be derived from the value of a call on a put, which we will now consider.\n\n\nCall-on-a-Put Pricing Formula\nConsider a call option maturing at \\(T\\) with strike \\(K\\) with the underlying being a put option with strike \\(K'\\) and maturity \\(T'&gt;T\\). The underlying of the put is the asset with price \\(S\\) and constant volatility \\(\\sigma\\). The call on the put will never be in the money at \\(T\\) and hence is worthless if \\(K&gt; \\mathrm{e}^{-r(T'-T)}K'\\), because the maximum possible value of the put option at date \\(T\\) is \\(\\mathrm{e}^{-r(T'-T)}K'\\). So assume \\(K&lt; \\mathrm{e}^{-r(T'-T)}K'\\).\nLet \\(S^*\\) again denote the critical value of the stock price such that the call is at the money at date \\(T\\) when \\(S_T=S^*\\). This means that \\(S^*\\) solves\nBlack_Scholes_Put(S*,Kprime,r,sigma,q,Tprime-T) = K.\nWe leave it as an exercise to confirm the following.\n\n\n\n\n\n\n15.6\n\n\n\nThe value of a call on a put is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2) + \\mathrm{e}^{-rT'}K'\\mathrm{M}\\!\\left(-d_2,-d_2',\\sqrt{T/T'}\\right) \\\\- \\mathrm{e}^{-q T'}S_0\\mathrm{M}\\!\\left(-d_1,-d_1',\\sqrt{T/T'}\\right) \\;,\n\\end{multline}\n\\qquad(15.19)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 15.14 and \\(d_1'\\) and \\(d_2'\\) are defined in Equation 15.16.\n\n\nWe will use bisection to find the critical price \\(S^*\\). We can use \\(e^{q(T'-T)}(K+K')\\) as an upper bound for \\(S^*\\) and 0 as a lower bound.^[We set the value of the call to be zero when the stock price is zero. The upper bound works because (by put-call parity and the fact that the put value is nonnegative) \\(C(T,S) \\geq e^{-q(T'-T)}S-e^{-r(T'-T)}K'\\). Therefore, when \\(S = e^{q(T'-T)}(K+K')\\), we have \\(C(T,S) \\geq K + K' - e^{-r(T'-T)}K' &gt; K\\). }\nThe following uses \\(10^{-6}\\) as the error tolerance in the bisection.\n\n\nCode\nimport numpy as np\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\n\ndef call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * (Tu - Tc)) * (Kc + Ku)\n    guess = 0.5 * lower + 0.5 * upper\n    flower = -Kc\n    fupper = black_scholes_call(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(d2)\n    M1 = binormal_prob(d1, d1prime, rho)\n    M2 = binormal_prob(d2, d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-q * Tu) * S * M1 - np.exp(-r * Tu) * Ku * M2\n\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n\n# print(\"Call on Call:\", call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu))\n\n\nThe implementation of the call-on-a-put formula is of course very similar to that of a call-on-a-call. One difference is that there is no obvious upper bound for \\(S^*\\), so we start with \\(2K'\\) (= 2*K2) and double this until the value of the put is below \\(K\\). We can take 0 again to be the lower bound. Recall that we assume \\(K&lt;\\mathrm{e}^{-r(T'-T)}K'\\) and the right-hand side of this is the value of the put at date \\(T\\) when \\(S_T=0\\).\n\n\nCode\ndef black_scholes_put(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-r * T) * K - np.exp(-q * T) * S)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(-d1)\n        N2 = norm.cdf(-d2)\n        return np.exp(-r * T) * K * N2 - np.exp(-q * T) * S * N1\n\ndef call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    flower = np.exp(-r * (Tu - Tc)) * Ku - Kc\n    upper = 2 * Ku\n    fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    while fupper &gt; 0:\n        upper *= 2\n        fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n\n    guess = 0.5 * lower + 0.5 * upper\n    fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(-d2)\n    M1 = binormal_prob(-d1, -d1prime, rho)\n    M2 = binormal_prob(-d2, -d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-r * Tu) * Ku * M2 - np.exp(-q * Tu) * S * M1\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n# print(\"Call on Put:\", call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu))",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#options-on-the-max-or-min",
    "href": "Chapter_Exotics.html#options-on-the-max-or-min",
    "title": "15  Other Exotics",
    "section": "15.7 Options on the Max or Min",
    "text": "15.7 Options on the Max or Min\nWe will consider here an option written on the maximum or minimum of two asset prices; for example, a call on the maximum pays \\[\n\\max(0,\\max(S_1_T, S_2_T)-K) = \\max(0,S_1_T-K,S_2_T-K)\n\\] at maturity \\(T\\). There are also call options on \\(\\min(S_1_T, S_2_T)\\) and put options on the maximum and minimum of two (or more) asset prices. Pricing formulas for these options are due to Stulz (Stulz 1982), who also discusses applications. We will assume the two assets have constant dividend yields \\(q_i\\), constant volatilities \\(\\sigma_i\\), and a constant correlation \\(\\rho\\).\n\nCall-on-the-Max Payoff\nTo value the above option, define the random variables: \\[\\begin{align*}\nx&= \\begin{cases} 1 & \\text{if $S_1_T&gt;S_2_T$ and $S_1_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\ny&= \\begin{cases} 1 & \\text{if $S_2_T&gt; S_1_T$ and $S_2_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\nz&= \\begin{cases} 1 & \\text{if $S_1_T &gt; K$ or $S_2_T&gt; K$}\\; ,\\\\\n0 & \\text{otherwise}\\;. \\end{cases}\n\\end{align*}\\] Then the value of the option at maturity is \\[xS_1_T + yS_2_T - zK\\; .\\] ### Numeraires Consider numeraires \\(V_1_t = \\mathrm{e}^{q_1t}S_1_t\\), \\(V_2_t=\\mathrm{e}^{q_2t}S_2_t\\), and \\(R_t=\\mathrm{e}^{rt}\\). By familiar arguments, the value of the option at date \\(0\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-q_1T}S_1_0\\times\\text{prob}^{V_1}(x=1) + \\mathrm{e}^{-q_2T}S_2_0\\times\\text{prob}^{V_2}(y=1) \\\\- \\mathrm{e}^{-rT}K\\times\\text{prob}^R(z=1)\\; .\n\\end{multline*}\\]\n\n\nCalculating Probabilities\n\nWe will begin by calculating \\(\\text{prob}^{V_1}(x=1)\\). From the second and third examples in ?sec-s:girsanov, the asset prices satisfy \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}S_1}{S_1} &= (r-q_1+\\sigma^2_1)\\,\\mathrm{d}t + \\sigma_1\\,\\mathrm{d}B^*_{1}\\; ,\\\\\n\\frac{\\,\\mathrm{d}S_2}{S_2} &= (r-q_2+\\rho\\sigma_1\\sigma_2)\\,\\mathrm{d}t + \\sigma_2\\,\\mathrm{d}B^*_{2}\\;,\n\\end{align*}\\] where \\(B^*_{1}\\) and \\(B^*_{2}\\) are Brownian motions when we use \\(V_1\\) as the numeraire. Thus, \\[\\begin{align*}\n\\log S_1_T &= \\log S_1_0 + \\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}_T\\; ,\\\\\n\\log S_2_T &= \\log S_2_0 + \\left(r-q_2+\\rho\\sigma_1\\sigma_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}_T\\;.\n\\end{align*}\\] The condition \\(\\log S_1_T &gt; \\log K\\) is therefore equivalent to\n\n\\[\n  -\\frac{1}{\\sqrt{T}}B^*_{1}_T &lt; d_{11}\\;,\n\\qquad(15.20)\\]\nand the condition \\(\\log S_1_T&gt;\\log S_2_T\\) is equivalent to \\[\n\\frac{\\sigma_2B^*_{2}_T-\\sigma_1B^*_{1}_T}{\\sigma\\sqrt{T}} &lt; d_1\\;,\n\\qquad(15.21)\\]\nwhere \\[\n\\sigma =\\sqrt{\\sigma_1^2-2\\rho\\sigma_1\\sigma_2+\\sigma_2^2}\\;,\n\\qquad(15.22)\\]\nand\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_1_0}{S_2_0}\\right)+\\left(q_2-q_1+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(15.23)\\]\n\\[\nd_{11}=\\frac{\\log\\left(\\frac{S_1_0}{K}\\right)+\\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T}{\\sigma_1\\sqrt{T}}\\;, \\qquad d_{12} = d_{11} - \\sigma_1\\sqrt{T}\\;.\n\\qquad(15.24)\\]\nThe random variables on the left-hand sides of Equation 15.20 - Equation 15.21 have standard normal distributions and their correlation is \\[\n\\rho_1 = \\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\; .\n\\] Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_1}(x=1) = \\mathrm{M}(d_{11},d_1,\\rho_1)\\;,\n\\end{equation*}\\] where \\(\\mathrm{M}\\) again denotes the bivariate normal distribution function.\n\nThe probability \\(\\text{prob}^{V_2}(y=1)\\) is exactly symmetric to \\(\\text{prob}^{V_1}(x=1)\\), with the roles of \\(S_1\\) and \\(S_2\\) interchanged. Note that the mirror image of \\(d_1\\) defined in Equation 15.23 is \\[\n\\frac{\\log\\left(\\frac{S_2_0}{S_1_0}\\right)+\\left(q_1-q_2+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\n\\] which equals \\(-d_2\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_2}(y=1) = \\mathrm{M}(d_{21},-d_2,\\rho_2)\\;,\n\\end{equation*}\\] where \\[\nd_{21}=\\frac{\\log\\left(\\frac{S_2_0}{K}\\right)+\\left(r-q_2+\\frac{1}{2}\\sigma_2^2\\right)T}{\\sigma_2\\sqrt{T}},\\qquad d_{22} = d_{21}-\\sigma_2\\sqrt{T}\\;,\n\\qquad(15.25)\\]\n\nand \\[\n\\rho_2 = \\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\; .\n\\] 3. As usual, we have \\[\\begin{align*}\n\\log S_1_T &= \\log S_1_0 + \\left(r-q_1-\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}_T\\; ,\\\\\n\\log S_2_T &= \\log S_2_0 + \\left(r-q_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}_T\\;,\n\\end{align*}\\] where \\(B^*_{1}\\) and \\(B^*_{2}\\) now denote Brownian motions under the risk-neutral probability. The event \\(z=1\\) is the complement of the event \\[\nS_1_T\\leq K \\quad \\text{and} \\quad S_2_T\\leq K\\; ,\n\\] which is equivalent to\n\\[\n\\frac{1}{\\sqrt{T}}B^*_{1}_T &lt; -d_{12}\\;,\n\\qquad(15.26)\\]\nand \\[\n\\frac{1}{\\sqrt{T}}B^*_{2}_T &lt; -d_{22}\\;.\n\\qquad(15.27)\\]\nThe random variables on the left-hand sides of Equation 15.26 and Equation 15.27 are standard normals and have correlation \\(\\rho\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{R}(z=1) = 1- \\mathrm{M}(-d_{12},-d_{22},\\rho)\\;.\n\\end{equation*}\\]\n\n\nCall-on-the-Max Pricing Formula\n\n\n\n\n\n\n15.8\n\n\n\nThe value of a call option on the maximum of two risky asset prices with volatilities \\(\\sigma_1\\) and \\(\\sigma_2\\) and correlation \\(\\rho\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q_1T}S_1_0\\mathrm{M}\\!\\left(d_{11},d_1,\\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\right) + \\mathrm{e}^{-q_2T}S_2_0\\mathrm{M}\\!\\left(d_{21},-d_2,\\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\right)\\\\+ \\mathrm{e}^{-rT}K\\mathrm{M}(-d_{12},-d_{22},\\rho) - \\mathrm{e}^{-rT}K\\;,\n\\end{multline}\n\\qquad(15.28)\\]\nwhere \\(\\sigma\\) is defined in Equation 15.22 and \\(d_1\\), \\(d_2\\), \\(d_{11}\\), \\(d_{12}\\), \\(d_{21}\\) and \\(d_{22}\\) are defined in Equation 15.23 - Equation 15.24.\n\n\nThe following code shows how to compute the price of a Call on the Max.\n\n\nCode\ndef call_on_max(S1, S2, K, r, sig1, sig2, rho, q1, q2, T):\n    sigma = np.sqrt(sig2 ** 2 - 2 * rho * sig1 * sig2 + sig1 ** 2)\n    d1 = (np.log(S1 / S2) + (q2 - q1 + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d11 = (np.log(S1 / K) + (r - q1 + sig1 ** 2 / 2) * T) / (sig1 * np.sqrt(T))\n    d12 = d11 - sig1 * np.sqrt(T)\n    d21 = (np.log(S2 / K) + (r - q2 + sig2 ** 2 / 2) * T) / (sig2 * np.sqrt(T))\n    d22 = d21 - sig2 * np.sqrt(T)\n    rho1 = (sig1 - rho * sig2) / sigma\n    rho2 = (sig2 - rho * sig1) / sigma\n    M1 = binormal_prob(d11, d1, rho1)\n    M2 = binormal_prob(d21, -d2, rho2)\n    M3 = binormal_prob(-d12, -d22, rho)\n\n    return np.exp(-q1 * T) * S1 * M1 + np.exp(-q2 * T) * S2 * M2 + np.exp(-r * T) * K * M3 - np.exp(-r * T) * K\n# Example usage\n\nS1 = 100\nS2= 100\nK = 100\nr = 0.05\nsigma1 = 0.2\nsigma2 = 0.2\nq1 = 0.02\nq2= 0.01\nT=1\nrho= 0.1\n\n# print(\"Call on Max:\", call_on_max(S1, S2, K, r, sigma1, sigma2, rho, q1, q2, T))",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#forward-start-options",
    "href": "Chapter_Exotics.html#forward-start-options",
    "title": "15  Other Exotics",
    "section": "15.9 Forward-Start Options",
    "text": "15.9 Forward-Start Options\nA forward-start option is an option for which the strike price is set equal to the stock price at some later date. In essence, it is issued at the later date, with the strike price set at the money. For example, an executive may know that he is to be given an option grant at some later date with the strike price set equal to the stock price at that date.\n\nForward-Start Call Payoff\nA forward-start call is defined by its maturity date \\(T'\\) and the date \\(T&lt;T'\\) at which the strike price is set. The value of a forward-start call at maturity is \\[\\max(0,S_{T'}-S_T)\\; .\\] Let \\[x= \\begin{cases} 1 &\\text{if $S_{T'}&gt;S_T$\\;,}\\\\\n                               0 & \\text{otherwise\\;.}\n        \\end{cases}\n\\] Then, the value of the call at maturity can be written as \\[xS_{T'}-xS_T\\; .\\] ### Numeraires\n\nUse \\(V_t=\\mathrm{e}^{qt}S_t\\) as numeraire to price the payoff \\(xS_{T'}\\). From the fundamental pricing Equation 7.28, the value at date \\(0\\) is \\[\\mathrm{e}^{-qT'}S_0\\\\E^V[x] = \\mathrm{e}^{-qT'}S_0\\times \\text{prob}^V\\!(S_{T'}&gt;S_T)\\; .\\]\nTo price the payoff \\(xS_T\\), use the following portfolio as numeraire:1purchase \\(\\mathrm{e}^{-qT}\\) shares of the stock at date \\(0\\) and reinvest dividends until date \\(T\\). This will result in the ownership of one share at date \\(T\\), worth \\(S_T\\) dollars. At date \\(T\\), sell the share and invest the proceeds in the risk-free asset and hold this position until date \\(T'\\). At date \\(T'\\), the portfolio will be worth \\(\\mathrm{e}^{r(T'-T)}S_T\\). Let \\(Z_t\\) denote the value of this portfolio for each \\(0\\leq t\\leq T'\\). The fundamental pricing Equation 7.28 implies that the value of receiving \\(xS_T\\) at date \\(T'\\) is \\[\\begin{align*}\nZ_0\\\\E^Z\\left[ \\frac{xS_T}{Z_{T'}}\\right] &=\n\\mathrm{e}^{-qT}S_0\\\\E^Z\\left[ \\frac{xS_T}{\\mathrm{e}^{r(T'-T)}S_T}\\right]\\\\&= \\mathrm{e}^{-qT-r(T'-T)}S_0\\\\E^Z[x] \\\\&= \\mathrm{e}^{-qT-r(T'-T)}S_0 \\times\\text{prob}^Z(S_{T'}&gt;S_T)\\;.\n\\end{align*}\\]\n\n\n\nCalculating Probabilities\n\nAs in the case of a share digital, we know that \\[\n\\log S_t = \\log S_0 + \\left(r-q +\\frac{1}{2}\\sigma^2\\right)t + \\sigma B^*_t\n\\] for all \\(t&gt;0\\), where \\(B^*\\) is a Brownian motion when \\(V\\) is used as the numeraire. Taking \\(t=T'\\) and \\(t=T\\) and subtracting yields \\[\\log S_{T'}-\\log S_T = \\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T) + \\sigma \\left[B^*_{T'}-B^*_T\\right]\\; .\\] Hence, \\(S_{T'}&gt;S_T\\) if and only if \\[-\\frac{B^*_{T'}-B^*_T}{\\sqrt{T'-T}} &lt; \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}}\\; .\\] The random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^V\\!(S_{T'}&gt;S_T) = \\mathrm{N}(d_1)\\; ,\n\\] where\n\n\\[\nd_1 = \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}} =\\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)\\sqrt{T'-T}}{\\sigma}\\;.\n\\qquad(15.29)\\]\n\nTo calculate the probability \\(\\text{prob}^Z(S_{T'}&gt;S_T)\\), note that between \\(T\\) and \\(T'\\), the portfolio with price \\(Z\\) earns the risk-free rate \\(r\\). The same argument presented in ?sec-s:girsanov shows that between \\(T\\) and \\(T'\\) we have \\[\n\\frac{\\,\\mathrm{d}S}{S} = (r-q)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B^*\\; ,\n\\] where now \\(B^*\\) denotes a Brownian motion when \\(Z\\) is used as the numeraire. This implies as usual that \\[\n\\,\\mathrm{d}\\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B^*\\; ,\n\\] which means that \\[\n\\log S_{T'} - \\log S_T = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(T'-T) + \\sigma(B^*_{T'}-B^*_T)\\; .\n\\] Hence, \\(S_{T'}&gt;S_T\\) if and only if \\[\n-\\frac{B^*_{T'}-B^*_T}{\\sqrt{T'-T}} &lt; \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)(T'-T)}{\\sigma\\sqrt{T'-T}}\\; .\n\\] As before, the random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^Z(S_{T'}&gt;S_T) = \\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_2 = \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)\\sqrt{T'-T}}{\\sigma}=d_1-\\sigma\\sqrt{T'-T}\\;.\n\\qquad(15.30)\\]\n\n\n\nForward-Start Call Pricing Formula\nCombining these results, we have:\n\n\n\n\n\n\n15.10\n\n\n\nThe value of a forward-start call at date \\(0\\) is \\[\n\\mathrm{e}^{-qT'}S_0\\mathrm{N}(d_1) - \\mathrm{e}^{-qT-r(T'-T)}S_0\\mathrm{N}(d_2)\\;,\n\\qquad(15.31)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 15.29 - Equation 15.30.\n\n\n\n\nPut-Call Parity\nForward-strike calls and puts satisfy a somewhat unusual form of put-call parity. The usual put-call parity is of the form: \\[\n\\text{Call} \\;+\\; \\text{Cash} \\quad = \\quad \\text{Put} \\;+ \\;\\text{Underlying}\\; .\n\\]\nThe amount of cash is the amount that will accumulate to the exercise price at maturity; i.e., it is \\(\\mathrm{e}^{-rT'}K\\). For forward-start calls and puts, the effective exercise price is \\(S_T\\), which is not known at date \\(0\\). However, the portfolio used as numeraire to value the second part of the payoff will be worth \\(\\mathrm{e}^{r(T'-T)}S_T\\) at date \\(T'\\), and by following the same strategy but starting with \\(\\mathrm{e}^{-r(T'-T)-qT}\\) instead of \\(\\mathrm{e}^{-qT}\\) shares, we will have \\(S_T\\) dollars at date \\(T'\\). The date–0 value of this portfolio should replace Cash in the above. Thus:\n\n\n\n\n\n\n15.11\n\n\n\nPut-call parity for forward-start calls and puts is \\[\n\\text{Call Price} \\;+\\; \\mathrm{e}^{-r(T'-T)-qT}S_0 = \\text{Put Price} \\;+\\; \\mathrm{e}^{-qT'}S_0\\;.\n\\qquad(15.32)\\]\nThe new features in the option pricing formulas in this chapter are the use of the bivariate normal distribution function and sometimes the need to compute a critical (at-the-money) value of the underlying asset price. We will compute the critical values by bisection, in the same way that we computed implied volatilities for the Black-Scholes formula in Chapter 10.\nThe following is a fast approximation of the bivariate cumulative normal distribution function, accurate to six decimal places, due to Drezner (Drezner 1978)). For given numbers \\(a\\) and \\(b\\), this function gives the probability that \\(\\xi_1&lt;a\\) and \\(\\xi_2&lt;b\\) where \\(\\xi_1\\) and \\(\\xi_2\\) are standard normal random variables with a given correlation \\(\\rho\\), which we must input.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef binormal_prob(a, b, rho):\n    x = np.array([0.24840615, 0.39233107, 0.21141819, 0.03324666, 0.00082485334])\n    y = np.array([0.10024215, 0.48281397, 1.0609498, 1.7797294, 2.6697604])\n    a1 = a / np.sqrt(2 * (1 - rho ** 2))\n    b1 = b / np.sqrt(2 * (1 - rho ** 2))\n    if a &lt;= 0 and b &lt;= 0 and rho &lt;= 0:\n        total_sum = 0\n        for i in range(5):\n            for j in range(5):\n                z1 = a1 * (2 * y[i] - a1)\n                Z2 = b1 * (2 * y[j] - b1)\n                z3 = 2 * rho * (y[i] - a1) * (y[j] - b1)\n                total_sum += x[i] * x[j] * np.exp(z1 + Z2 + z3)\n        return total_sum * np.sqrt(1 - rho ** 2) / np.pi\n    elif a &lt;= 0 and b &gt;= 0 and rho &gt;= 0:\n        return norm.cdf(a) - binormal_prob(a, -b, -rho)\n    elif a &gt;= 0 and b &lt;= 0 and rho &gt;= 0:\n        return norm.cdf(b) - binormal_prob(-a, b, -rho)\n    elif a &gt;= 0 and b &gt;= 0 and rho &lt;= 0:\n        total_sum = norm.cdf(a) + norm.cdf(b)\n        return total_sum - 1 + binormal_prob(-a, -b, rho)\n    elif a * b * rho &gt; 0:\n        rho1 = (rho * a - b) * np.sign(a) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        rho2 = (rho * b - a) * np.sign(b) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        Delta = (1 - np.sign(a) * np.sign(b)) / 4\n        return binormal_prob(a, 0, rho1) + binormal_prob(b, 0, rho2) - Delta\n# print(\"BiNormalProb:\", binormal_prob(0.1, 0.2, 0.3))\n\n\nNotice that this function calls itself. This is an example of recursion.\nThe forward-start call pricing formula is of the same form as the Black-Scholes, Margrabe, Black, and Merton formulas. We can compute it with our Generic_Option pricing function.\n\n\nCode\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\ndef forward_start_call(S, r, sigma, q, Tset, TCall):\n    P1 = np.exp(-q * TCall) * S\n    P2 = np.exp(-q * Tset - r * (TCall - Tset)) * S\n    return generic_option(P1, P2, sigma, TCall - Tset)\n\n# Example usage\nS = 100\nK = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT = 1\nDiv = 5\nTDiv = 0.5\nTCall = 1\nN = 10\n\n# print(\"Forward Start Call:\", forward_start_call(S, r, sigma, q, 0.5, TCall))",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#sec-s:choosers",
    "href": "Chapter_Exotics.html#sec-s:choosers",
    "title": "15  Other Exotics",
    "section": "15.12 Choosers",
    "text": "15.12 Choosers\nA chooser option allows the holder to choose whether the option will be a put or call at some fixed date before the option maturity. Let \\(T\\) denote the date at which the choice is made, \\(T_c\\) the date at which the call expires, \\(T_p\\) the date at which the put expires, \\(K_c\\) the exercise price of the call, and \\(K_p\\) the exercise price of the put, where \\(0&lt;T&lt;T_c\\) and \\(0&lt;T&lt;T_p\\). A simple chooser has \\(T_c=T_p\\) and \\(K_c=K_p\\). A chooser is similar in spirit to a straddle: it is a bet on volatility without making a bet on direction. A simple chooser must be cheaper than a straddle with the same exercise price and maturity \\(T'=T_c=T_p\\), because a straddle is always in the money at maturity, whereas a simple chooser has the same value as the straddle if it is in the money but is only in the money at \\(T'\\) when the choice made at \\(T\\) turns out to have been the best one.\n\nChooser Payoff\nThe value of the chooser at date \\(T\\) will be the larger of the call and put prices. Let \\(S^*\\) denote the stock price at which the call and put have the same value. We can find \\(S^*\\) by solving\nBlack_Scholes_Call(S*,Kc,r,sigma,q,Tc-T) = Black_Scholes_Put(S*,Kp,r,sigma,q,Tp-T).\nFor a simple chooser with \\(K_c=K_p=K\\) and \\(T_c=T_p=T'\\), we can find \\(S^*\\) from the put-call parity relation at \\(T\\), leading to \\(S^*=\\mathrm{e}^{(q-r)(T'-T)}K.\\)\nThe call will be chosen when \\(S_T&gt;S^*\\) and it finishes in the money if \\(S(T_c)&gt;K_c\\) at date \\(T_c\\), so the payoff of the chooser is \\(S(T_c)-K_c\\) when \\[S_T&gt;S^* \\quad \\text{and}\\quad S(T_c)&gt;K_c\\;.\n\\] The payoff is \\(K_p-S(T_p)\\) at date \\(T_p\\) when \\[\nS_T&lt;S^* \\quad \\text{and}\\quad S(T_p)&lt;K_p\\;.\n\\] Let \\[\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^* $ and $S(T_c)&gt;K_c$\\;,}\\\\\n                               0 & \\text{otherwise\\;.}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&lt;S^*$ and $S(T_p)&lt;K_p$\\;,}\\\\\n                               0 & \\text{otherwise\\;.}\n        \\end{cases}\n\\end{align*}\\] Then the payoff of the chooser is \\(xS(T_c)-xK_c\\) at date \\(T_c\\) and \\(yK_p-yS(T_p)\\) at date \\(T_p\\).\n\n\nNumeraires\nAs in the analysis of compound options, the value of the chooser at date \\(0\\) must be\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\times\\text{prob}^V\\!(x=1) \\;- \\;\\mathrm{e}^{-rT_c}K_c\\times\\text{prob}^R(x=1)\n\\\\+\\; \\mathrm{e}^{-rT_p}K_p\\times\\text{prob}^R(y=1) \\;- \\;\\mathrm{e}^{-q T_p}S_0\\times\\text{prob}^V\\!(y=1)\\;,\n\\end{multline}\n\\qquad(15.33)\\]\nwhere we use \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\) as numeraires.\n\n\nChooser Pricing Formula\nEquation 15.33 and calculations similar to those of the previous two sections lead us to:\n\n\n\n\n\n\n15.13\n\n\n\nThe value of a chooser option is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\mathrm{M}\\!\\left(d_1,d_{1c},\\sqrt{T/T_c}\\right) - \\mathrm{e}^{-rT_c}K_c\\mathrm{M}\\!\\left(d_2,d_{2c},\\sqrt{T/T_c}\\right)\\\\ +\\mathrm{e}^{-rT_p}K_p\\mathrm{M}\\!\\left(-d_2,-d_{2p} , \\sqrt{T/T_p}\\right) \\\\- \\mathrm{e}^{-q T_p}S_0\\mathrm{M}\\!\\left(-d_1 ,-d_{1p} ,\\sqrt{T/T_p}\\right)\\;,\n\\end{multline}\n\\qquad(15.34)\\]\nwhere \\[\\begin{equation*}\n\\begin{array}{ll}\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n& \\qquad d_2=d_1-\\sigma\\sqrt{T}\\;,\\\\\n&\\\\\nd_{1c} = \\frac{\\log\\left(\\frac{S_0}{K_c}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_c}{\\sigma\\sqrt{T_c}}\\;,\n& \\qquad d_{2c}=d_{1c}-\\sigma\\sqrt{T_c}\\;,\\\\\n&\\\\d_{1p} = \\frac{\\log\\left(\\frac{S_0}{K_p}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_p}{\\sigma\\sqrt{T_p}}\\;,\n& \\qquad d_{2p}=d_{1p}-\\sigma\\sqrt{T_p}\\;.\n\\end{array}\n\\end{equation*}\\]\n\n\nTo implement the bisection to compute \\(S^*\\), we can take zero as a lower bound and \\(K_c+K_p\\) as an upper bound.^[We take the call value to be zero and the put value to be \\(\\mathrm{e}^{-r(T_p-T)}K_p\\) at date \\(T\\) when the stock price is zero. To see why the upper bound works, note that when the stock price is \\(S\\) at date \\(T\\), the call is worth at least \\(S^*-K_c\\) and the put is worth no more than \\(K_p\\); i.e, \\(C \\geq S-K_c\\) and \\(P \\leq K_p\\). Therefore, \\(C-P \\geq S-K_c-K_p\\). Hence when \\(S=K_c+K_p\\), we have \\(C-P\\geq 0\\). }\n\n\nCode\ndef chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * Tc) * (Kc + Kp)\n    guess = 0.5 * Kc + 0.5 * Kp\n    flower = -np.exp(-r * (Tp - T)) * Kp\n    fupper = black_scholes_call(upper, Kc, r, sigma, q, Tc - T) - black_scholes_put(upper, Kp, r, sigma, q, Tp - T)\n    fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1c = (np.log(S / Kc) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2c = d1c - sigma * np.sqrt(Tc)\n    d1p = (np.log(S / Kp) + (r - q + sigma ** 2 / 2) * Tp) / (sigma * np.sqrt(Tp))\n    d2p = d1p - sigma * np.sqrt(Tp)\n    rhoc = np.sqrt(T / Tc)\n    rhop = np.sqrt(T / Tp)\n    M1c = binormal_prob(d1, d1c, rhoc)\n    M2c = binormal_prob(d2, d2c, rhoc)\n    M1p = binormal_prob(-d1, -d1p, rhop)\n    M2p = binormal_prob(-d2, -d2p, rhop)\n\n    return np.exp(-q * Tc) * S * M1c - np.exp(-r * Tc) * Kc * M2c + np.exp(-r * Tp) * Kp * M2p - np.exp(-q * Tp) * S * M1p\n\n# Example usage\nS = 100\nKc = 80\nKp = 80\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 1.5\nTp = 1.5\nT=1\n\n# print(\"Chooser Option:\", chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp))",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#section-7",
    "href": "Chapter_Exotics.html#section-7",
    "title": "15  Other Exotics",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nIntuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T'\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Compute and plot the value of the option for \\(T=0.1T'\\), \\(T=0.2T'\\), , \\(T=0.9T'\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K'=S\\) (i.e., the call is at the money) and maturity \\(T'\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T'\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T'\\). Take the date of the dividend payment to be \\(T=0.5T'\\) and take the strike price to be \\(K=S\\). As discussed in Section 11.3, the value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 15.12. Verify that the function gives the same result as the function Chooser.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T'\\). Take the time to maturity of the underlying call and put to be \\(T'\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T'\\). Compute the cost of the chooser and the cost of the straddle.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nA stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 15.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\n\n\nExercise 15.1 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 15.2 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 15.3 Modify Exercise 15.1 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 15.1 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 15.4 Modify Exercise 15.2 by including the hedge in Exercise 15.3. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 15.5 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 15.1.\n\n\nExercise 15.6 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive Equation 15.19 for the value of a call on a put.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nComplete the derivation of Equation 15.34 for the value of a chooser option.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nDerive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nUsing the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_2_0 + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]\n\n\n\n\n\n\n\nConze, A., and Viswanathan. 1991. “Path Dependent Options: The Case of Lookback Options.” Journal of Finance 46: 1893–1907.\n\n\nDrezner, Z. 1978. “Computation of the Bivariate Normal Integral.” Mathematics of Computation 32: 277–79.\n\n\nGeske, R. 1979. “The Valuation of Compound Options.” Journal of Financial Economics 7: 63–81.\n\n\nGoldman, M., H. Sosin, and M. Gatto. 1979. “Path Dependent Options: ‘Buy at the Low, Sell at the High.” ’ Journal of Finance 34: 1111–27.\n\n\nMusiela, M., and M. Rutkowski. 1997. Martingale Methods in Financial Modeling. Springer, Berlin Heidelberg New York.\n\n\nStulz, R. 1982. “Options on the Minimum or Maximum of Two Risky Assets: Analysis and Applications.” Journal of Financial Economics 10: 161–85.",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_Exotics.html#footnotes",
    "href": "Chapter_Exotics.html#footnotes",
    "title": "15  Other Exotics",
    "section": "",
    "text": "We are going to use equation~Equation 7.23 at date \\(T'\\) to define the probabilities, because it will not be known until date \\(T'\\) whether the event \\(S_{T'}&gt;S_T\\) is true. Thus, we need the price of a numeraire asset at date \\(T'\\). We would like this price to be a constant times \\(S_T\\), which is what we will obtain. An equivalent numeraire is to make a smaller investment in the same portfolio: start with \\(\\mathrm{e}^{-r(T'-T)-qT}\\) shares. This results in a final value of \\(S_T\\) at date \\(T'\\). As will be seen, this is useful for deriving the put-call parity relation for forward-start options.↩︎",
    "crumbs": [
      "Part IV: Black-Scholes and Extensions",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html",
    "href": "Chapter_GARCH.html",
    "title": "16  GARCH Models",
    "section": "",
    "text": "16.1 Statistics Review\nThus far, we have assumed that the volatility of the underlying asset is constant or varying in a non-random way during the lifetime of the derivative. In this chapter we will look at models that relax this assumption and allow the volatility to change randomly. This is very important, because there is plenty of evidence that volatilities do change over time in a random way.\nIn the first three sections, we will consider the problem of estimating the volatility. The discussion of estimation methods leads naturally into the discussion of modeling a changing volatility.\nWe begin with a brief review of basic statistics. Given a random sample \\(\\{x_1,\\ldots,x_N\\}\\) of size \\(N\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\), the best estimate of \\(\\mu\\) is of course the sample mean \\[\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N}x_i\\; .\\] The variance is the expected value of \\((x-\\mu)^2\\), so an obvious estimate of the variance is the sample average of \\((x_i-\\mu)^2\\), replacing \\(\\mu\\) with its estimate \\(\\bar{x}\\). This would be \\[\\frac{1}{N}\\sum_{i=1}^{N} (x_i-\\bar{x})^2\\] However, because \\(\\bar{x}\\) is computed from the \\(x_i\\), the \\(x_i\\) will deviate less on average from \\(\\bar{x}\\) than they do from the true mean \\(\\mu\\). Hence the estimate proposed above will on average be less than \\(\\sigma^2\\). To eliminate this bias, it suffices just to scale the estimate up by a factor of \\(N/(N-1)\\). This leads to the estimate \\[s^2=\\frac{1}{N-1}\\sum_{i=1}^{N} (x_i-\\bar{x})^2\\; ,\\] and the best estimate of \\(\\sigma\\) is the square root \\[s=\\sqrt{\\frac{1}{N-1}\\sum_{i=1}^{N} (x_i-\\bar{x})^2}\\; .\\] To calculate \\(s^2\\), notice that \\[\\begin{align*}\n\\sum_{i=1}^{N} (x_i-\\bar{x})^2 &= \\sum_{i=1}^{N} (x_i^2-2x_i\\bar{x}+\\bar{x}^2)\\\\\n&=\\sum_{i=1}^{N} x_i^2 -2\\bar{x}\\sum_{i=1}^{N} x_i + \\sum_{i=1}^N \\bar{x}^2\\\\\n&=\\sum_{i=1}^{N} x_i^2 -2\\bar{x}(N\\bar{x})+N\\bar{x}^2\\\\\n&=\\sum_{i=1}^{N} x_i^2 -N\\bar{x}^2\\;.\n\\end{align*}\\] Therefore \\[s=\\sqrt{\\frac{1}{N-1}\\left(\\sum_{i=1}^{N} x_i^2-N\\bar{x}^2\\right)}\\; .\\]\nIt is important to know how much variation there would be in \\(\\bar{x}\\) if one had access to multiple random samples. More variation means that an \\(\\bar{x}\\) computed from a single sample will be a less reliable estimate of \\(\\mu\\). The variance of \\(\\bar{x}\\) in repeated samples is \\(\\sigma^2/N\\),1 and our best estimate of this variance is \\(s^2/N\\). The standard deviation of \\(\\bar{x}\\) in repeated samples, which is called the standard error of \\(\\bar{x}\\), is \\(\\sigma/\\sqrt{N}\\), and we estimate this by \\(s/\\sqrt{N}\\), which equals \\[\\sqrt{\\frac{1}{N(N-1)}\\left(\\sum_{i=1}^{N} x_i^2-N\\bar{x}^2\\right)}\\; .\\] If the population from which \\(x\\) is sampled has a normal distribution, then a 95% confidence interval for \\(\\mu\\) will be \\(\\bar{x}\\) plus or minus 1.96 standard errors. Even if \\(x\\) does not have a normal distribution, by the Central Limit Theorem, \\(\\bar{x}/\\sqrt{N}\\) will be approximately normally distributed if the sample size \\(N\\) is large enough, and plus or minus 1.96 standard errors will still be approximately a 95% confidence interval for \\(\\mu\\).",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#sec-s:estimatingvolatility",
    "href": "Chapter_GARCH.html#sec-s:estimatingvolatility",
    "title": "16  GARCH Models",
    "section": "16.2 Estimating a Constant Volatility and Mean",
    "text": "16.2 Estimating a Constant Volatility and Mean\nConsider an asset price that is a geometric Brownian motion under the actual probability measure: \\[\\frac{\\,\\mathrm{d}S}{S} = \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\; ,\\] where \\(\\mu\\) and \\(\\sigma\\) are unknown constants and \\(B\\) is a Brownian motion. We can as usual write this in log form as \\[\\,\\mathrm{d}\\log S = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\; .\\] Over a discrete time period of length \\(\\Delta t\\), this implies \\[\n\\Delta \\log S = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta B\\;.\n\\qquad(16.1)\\]\nSuppose we have observed the asset price \\(S\\) at dates \\(0=t_0&lt;t_1&lt;\\cdots&lt; t_N=T\\), where \\(t_i-t_{i-1}=\\Delta t\\). If the asset pays dividends, we will take \\(S\\) to be the value of the portfolio in which the dividends are reinvested in new shares. Thus, in general, \\(S_{t_i}/S_{t_{i-1}}\\) denotes the gross return (one plus the rate of return) between dates \\(t_{i-1}\\) and \\(t_i\\). This return is measured on a non-compounded and non-annualized basis. The annualized continuously-compounded rate of return is the rate \\(r_i\\) defined by \\[\\frac{S_{t_i}}{S_{t_{i-1}}} = \\mathrm{e}^{r_i\\Delta t}\\; .\\] This implies that \\[\nr_i = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}}{\\Delta t} = \\mu-\\frac{1}{2}\\sigma^2 + \\sigma \\frac{B_{t_i}-B_{t_{i-1}}}{\\Delta t}\\;.\n\\qquad(16.2)\\]\nBecause \\(B_{t_i}-B_{t_{i-1}}\\) is normally distributed with mean zero and variance \\(\\Delta t\\), the sample \\(\\{r_1,\\ldots,r_N\\}\\) is a sample of independent random variables each of which is normally distributed with mean \\(\\mu-\\sigma^2/2\\) and variance \\(\\sigma^2/\\Delta t\\). We are focused on estimating \\(\\sigma^2\\), so it will simplify things to define \\[\ny_i = r_i\\sqrt{\\Delta t} = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}}{\\sqrt{\\Delta t}}\\;.\n\\qquad(16.3)\\]\nThe sample \\(\\{y_1,\\ldots,y_N\\}\\) is a sample of independent random variables each of which is normally distributed with mean \\((\\mu-\\sigma^2/2)\\sqrt{\\Delta t}\\) and variance \\(\\sigma^2\\). As was discussed in the previous section, the best estimate of the mean of \\(y\\) is the sample mean \\[\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N}y_i\\; ,\\] and the best estimate of \\(\\sigma^2\\) is \\[\\hat{\\sigma}^2 = \\frac{1}{N-1}\\sum_{i=1}^{N} (y_i-\\bar{y})^2\\; .\\] This means that we estimate \\(\\mu\\) as \\[\\hat{\\mu} = \\frac{\\bar{y}}{\\sqrt{\\Delta t}} + \\frac{1}{2}\\hat{\\sigma}^2 = \\bar{r}+ \\frac{1}{2}\\hat{\\sigma}^2\\; .\\]\nLet us digress for a moment to discuss the reliability of \\(\\hat{\\mu}\\) as an estimate of \\(\\mu\\). Notice that\n\\[\n\\bar{r}\n= \\frac{\\sum_{i=1}^N \\log S_{t_i}-\\log S_{t_{i-1}}}{N\\Delta t}\n\\] \\[\n=   \\frac{\\log S_T-\\log S_0}{N\\Delta t}\n\\] \\[\n= \\frac{\\log S_T-\\log S_0}{T}\\;.\n\\qquad(16.4)\\]\nTherefore the first component \\(\\bar{r}\\) of the estimate of \\(\\mu\\) depends only on the total change in \\(S\\) over the time period. Hence, the reliability of this component cannot depend on how frequently we observe \\(S\\) within the time period \\([0,T]\\). The standard deviation of \\(\\bar{r}\\) in repeated samples is the standard deviation of \\([\\log S_T-\\log S_0]/T\\), which is \\(\\sigma/\\sqrt{T}\\). This is likely to be quite large. For example, with \\(\\sigma =0.3\\) and ten years of data (\\(T=10\\)), the standard deviation of \\(\\bar{r}\\) is 9.5%, which means that a 95% confidence interval will be a band of roughly 38%. Given that \\(\\mu\\) itself should be of the order of magnitude of 10%, such a wide confidence interval is useless for all practical purposes.\nFortunately, it is easier to estimate \\(\\sigma\\). We observed in the previous section that the \\(\\hat{\\sigma}^2\\) defined above can be calculated as \\[\n\\frac{1}{N-1}\\sum_{i=1}^N y_i^2 - \\frac{N\\bar{y}^2}{N-1}\\;.\n\\qquad(16.5)\\]\nFrom Equation 16.3 of \\(y_i\\) and Equation 16.4, we have \\[\\bar{y} =  \\frac{\\sqrt{\\Delta t}}{T}[\\log S_T-\\log S_0]\\; .\\] Hence, the second term in Equation 16.5 is \\[ \\frac{N}{N-1}\\left(\\frac{\\Delta t}{T^2}\\right)[\\log S_T-\\log S_0]^2\\; .\\] If we observe the stock price sufficiently frequently, so that \\(\\Delta t\\) is very small, this term will be negligible. In this circumstance, \\(\\hat{\\sigma}^2\\) is approximately\n\\[\n\\frac{1}{N-1}\\sum_{i=1}^N y_i^2 = \\frac{1}{N-1}\\sum_{i=1}^N \\frac{[\\log S_{t_i}-\\log S_{t_{i-1}}]^2}{\\Delta t}\n\\] \\[\n= \\frac{N}{N-1}\\times \\frac{1}{T}\\times \\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2 \\;.\n\\qquad(16.6)\\]\nIf we observe \\(S\\) more and more frequently, letting \\(\\Delta t \\rightarrow 0\\) and \\(N \\rightarrow \\infty\\), the sum \\[\\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2\\] will converge with probability one to \\(\\sigma^2T\\), as explained in Section 4.3. This implies that \\(\\hat{\\sigma}^2\\) will converge to \\(\\sigma^2\\). Thus, in theory, we can estimate \\(\\sigma^2\\) with any desired degree of precision by simply observing \\(S\\) sufficiently frequently. This is true no matter how short the overall time period \\([0,T]\\) may be.\nIn practice, this doesn’t work out quite so well. If we observe minute-by-minute data, or we observe each transaction, much of the variation in the price \\(S\\) will be due to bouncing back and forth between the bid price and the ask price. This is not really what we want to estimate, and this source of variation will be much less important if we look at weekly or even daily data. So, there are practical limits to how frequently we should observe \\(S\\). Nevertheless, it is still true that, if \\(\\sigma^2\\) were truly constant, we could estimate it with a very high degree of precision. In fact, we can estimate the volatility of a stock with enough precision to determine that it really isn’t constant! The real problem that we face is to estimate and model a changing volatility.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#estimating-a-changing-volatility",
    "href": "Chapter_GARCH.html#estimating-a-changing-volatility",
    "title": "16  GARCH Models",
    "section": "16.3 Estimating a Changing Volatility",
    "text": "16.3 Estimating a Changing Volatility\nWithout attempting yet to model how the volatility may change, we can say a few things about how we might estimate a changing volatility. In this and following sections, we will take the observation interval \\(\\Delta t\\) to be fixed. We assume it is small (say, a day or a week) and focus on the estimate Equation 16.6. Recall from Section 16.1 that the reason we are dividing by \\(N-1\\) rather than \\(N\\) is that the sample standard deviation usually underestimates the actual standard deviation, because it uses the sample mean, which will be closer to the points \\(x_i\\) than will be the true mean. However, Equation 16.6 does not employ the sample mean (it replaces it with zero), so there is no reason to make this correction. So, we take as our point of departure the estimate \\[\\frac{1}{T} \\sum_{i=1}^N [\\log S_{t_i}-\\log S_{t_{i-1}}]^2 = \\frac{1}{N}\\sum_{i=1}^N y_i^2 \\; .\\] An obvious response to the volatility changing over time is simply to avoid using data from the distant past. Such data is not likely to be informative about the current value of the volatility. What distant should mean in this context is not entirely clear, but, for example, we might want to use only the last 60 observations. If we are using daily data, this would mean that at the end of each day we would add that day’s observation and drop the observation from 61 days past. This leads to a somewhat abruptly varying estimate. For example, a very large movement in the price on a particular day increases the volatility estimate for the next 60 days. On the 61st day, this observation would drop from the sample, leading to an abrupt drop in the estimate (presuming that there is not an equally large change in \\(S\\) on the 61st day). This seems unreasonable. An estimate in which the impact of each observation decays smoothly over time is more attractive.\nWe can construct such an estimate as \\[\n\\hat{\\sigma}^2_{i+1} = (1-\\lambda) y_{i}^2 + \\lambda\\hat{\\sigma}^2_{i}\n\\qquad(16.7)\\]\nfor any constant \\(0&lt;\\lambda&lt;1\\). Here, \\(\\hat{\\sigma}^2_{i+1}\\) denotes the estimate of the volatility from date \\(t_{i}\\) to date \\(t_{i+1}\\). The estimate Equation 16.7 is a weighted average of the estimate \\(\\hat{\\sigma}^2_{i}\\) for the previous time period and the most recently observed squared change \\(y_{i}^2\\). Following the same procedure, the next estimate will be \\[\\begin{align*}\n\\hat{\\sigma}^2_{i+2}& = (1-\\lambda) y_{i+1}^2 + \\lambda\\hat{\\sigma}^2_{i+1}\\\\\n&= (1-\\lambda) y_{i+1}^2 + \\lambda(1-\\lambda)  y_{i}^2 + \\lambda^2\\hat{\\sigma}^2_{i}\\;.\n\\end{align*}\\] Likewise, the estimate at the following date will be \\[\\hat{\\sigma}^2_{i+3} = (1-\\lambda) y_{i+2}^2 +\\lambda(1-\\lambda) y_{i+1}^2 + \\lambda^2(1-\\lambda)^2  y_{i}^2 +\\lambda^{3}\\hat{\\sigma}^2_{i}\\; .\\] This demonstrates the declining importance of the squared deviation \\(y_{i}^2\\) for future estimates. At each date, \\(y_{i}^2\\) enters with a weight that is lower by a factor of \\(\\lambda\\), compared to the previous date. If \\(\\lambda\\) is small, the decay in the importance of each squared deviation will be fast. In fact, Equation 16.7 shows that, if \\(\\lambda\\) is close to zero, the estimate \\(\\hat{\\sigma}_{i+1}^2\\) is approximately equal to the squared deviation \\(y_i^2\\)—previous squared deviations are relatively unimportant. On the other hand, if \\(\\lambda\\) is close to one, the decay will be slow; i.e., the importance of \\(y_i^2\\) for the estimate \\(\\hat{\\sigma}^2_{i+2}\\) will be nearly the same as for \\(\\hat{\\sigma}^2_{i+1}\\), and nearly the same for \\(\\hat{\\sigma}^2_{i+3}\\) as for \\(\\hat{\\sigma}^2_{i+2}\\), etc. This will lead to a smooth (slowly varying) volatility estimate. The slowly varying nature of the estimate in this case is also clear from Equation 16.7, because it shows that if \\(\\lambda\\) is close to one, then \\(\\hat{\\sigma}^2_{i+1}\\) will be approximately the same as \\(\\hat{\\sigma}^2_{i}\\).\nThis method can also be used to estimate covariances, simply by replacing the squared deviations \\(y_i^2\\) by the product of deviations for two different assets. And, of course, given covariance and variance estimates, we can construct estimates of correlations. To ensure that an estimated correlation is between \\(-1\\) and \\(+1\\), we will need to use the same \\(\\lambda\\) to estimate each of the variances and the covariance. This is the method used by RiskMetrics.2.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#sec-s:garch",
    "href": "Chapter_GARCH.html#sec-s:garch",
    "title": "16  GARCH Models",
    "section": "16.4 GARCH Models",
    "text": "16.4 GARCH Models\nWe are going to adopt a subtle but important change of perspective now. Instead of considering Equation 16.7 as simply an estimation procedure, we are going to assume that the actual volatility evolves according to Equation 16.7, or a generalization thereof. We are also going to reintroduce the expected change in \\(\\log S\\), which we dropped in going from Equation 16.5 to Equation 16.6. Specifically, we return to Equation 16.1, but we operate under the risk-neutral probability, so \\(\\mu=r-q\\), and we have \\[\n\\log S(t_{i+1}) - \\log S_{t_i} = \\left(r-q-\\frac{1}{2}\\sigma_{i+1}^2\\right)\\Delta t + \\sigma_{i+1} \\Delta B\\;.\n\\qquad(16.8)\\]\nWe assume the volatility \\(\\sigma_{i+1}\\) between dates \\(t_i\\) and \\(t_{i+1}\\) is given by \\[\n\\sigma_{i+1}^2 = a + b y_{i}^2 + c \\sigma_i^2\\;,\n\\qquad(16.9)\\]\nfor some constants \\(a &gt; 0\\), \\(b\\geq 0\\) and \\(c\\geq 0\\), with \\(y_i\\) now defined by \\[y_i = \\frac{\\log S_{t_i}-\\log S_{t_{i-1}}-\\left(r-q-\\frac{1}{2}\\sigma_i^2\\right)\\Delta t}{\\sqrt{\\Delta t}}\\; .\\] From Equation 16.8, applied to the period from \\(t_{i-1}\\) to \\(t_i\\), this implies that \\(y_i\\) is normally distributed with mean zero and variance \\(\\sigma_i^2\\), and of course \\(y_{i+1}\\) has variance \\(\\sigma_{i+1}^2\\), etc.\nUnder these assumptions, the random process \\(\\log S\\) is called a GARCH(1,1) process.3 There are many varieties of GARCH processes that have been proposed in the literature, but we will only consider GARCH(1,1), which is the simplest.\nWe assume \\(b+c&lt;1\\), in which case we can write the variance equation as a generalization of Equation 16.7. Namely, %\\[\\sigma_{i+1}^2 = (1-\\phi)d + \\phi\\left[(1-\\lambda) y_{i}^2 + \\lambda \\sigma^2_{i}\\right]\\; ,\\] \\[\n\\sigma_{i+1}^2 = \\kappa\\theta + (1-\\kappa)\\left[  (1-\\lambda) y_{i}^2 + \\lambda\\sigma^2_{i}\\right]\\;,\n\\qquad(16.10)\\]\nwhere \\(\\lambda=c/(b+c)\\), %\\(\\phi=b+c\\), and \\(d=a/(1-b-c)\\).\n\\(\\kappa = 1-b-c\\), and \\(\\theta=a/(1-b-c)\\). Hence, \\(\\sigma_{i+1}^2\\) is a weighted average with weights \\(\\kappa\\) and \\(1-\\kappa\\), of two parts, one being the constant \\(\\theta\\) and the other being itself a weighted average of \\(y_{i}^2\\) and \\(\\sigma^2_{i}\\). Whatever the variance might be at time \\(t_i\\), the variance of \\(y_j\\) at any date \\(t_j\\) far into the future, computed without knowing the intervening \\(y_{i+1}, y_{i+2},\\ldots\\), will be approximately the constant \\(\\theta\\). The constant \\(\\theta\\) is called the unconditional variance, whereas \\(\\sigma_{i}^2\\) is the conditional variance of \\(y_i\\). \nTo understand the unconditional variance, it is useful to consider the variance forecasting equation. Specifically, we can calculate \\(\\\\E_{t_i} \\left[\\sigma_{i+n}^2\\right]\\), which is the estimate made at date \\(t_i\\) of the variance of \\(y_{i+n}\\); i.e, we estimate the variance without having observed \\(y_{i+1},\\ldots,y_{i+n-1}\\). Note that by definition \\(\\\\E_{t_{i}}[y_{i+1}^2]=\\sigma_{i+1}^2\\), so Equation 16.10 implies \\[\\begin{align*}\n\\\\E_{t_{i}}\\left[\\sigma_{i+2}^2\\right] &= \\kappa\\theta + (1-\\kappa)\\left[  (1-\\lambda) \\\\E_{t_{i}}[y_{i+1}^2] + \\lambda\\sigma^2_{i+1}\\right] \\\\\n&= \\kappa\\theta + (1-\\kappa)\\sigma^2_{i+1}\\; .\n\\end{align*}\\] Likewise, \\[\\\\E_{t_{i+1}}\\left[\\sigma_{i+3}^2\\right] = \\kappa\\theta + (1-\\kappa)\\sigma^2_{i+2}\\; ,\\] and taking the expectation at date \\(t_i\\) of both sides of this yields \\[\\begin{align*}\n\\\\E_{t_{i}}\\left[\\sigma_{i+3}^2\\right] = \\\\E_{t_{i}}\\left[\\\\E_{t_{i+1}}\\left[\\sigma_{i+3}^2\\right]\\right] &=\\kappa\\theta + (1-\\kappa)\\\\E_{t_{i}}\\left[\\sigma_{i+2}^2\\right]\\\\\n&=\\kappa\\theta + (1-\\kappa)\\left[\\kappa\\theta + (1-\\kappa)\\sigma^2_{i+1}\\right]\\\\\n&=\\kappa\\theta[1+(1-\\kappa)] + (1-\\kappa)^2\\sigma^2_{i+1}\\;.\n\\end{align*}\\] This generalizes to \\[\\\\E_{t_{i}}\\left[\\sigma_{i+n}^2\\right] = \\kappa\\theta\\left[1+(1-\\kappa)+ \\cdots (1-\\kappa)^{n-2}\\right] + (1-\\kappa)^{n-1}\\sigma^2_{i+1}\\; .\\] Thus, there is decay at rate \\(\\kappa\\) in the importance of the current volatility \\(\\sigma^2_{i+1}\\) for forecasting the future volatility. Furthermore, as \\(n\\rightarrow \\infty\\), the geometric series \\[1+(1-\\kappa)+ \\cdots (1-\\kappa)^{n-2}\\] converges to \\(1/\\kappa\\), so, as \\(n \\rightarrow \\infty\\) we obtain \\[\\\\E_{t_{i}}\\left[\\sigma_{i+n}^2\\right] \\rightarrow \\theta\\; .\\] This means that our best estimate of the conditional variance, at some date far in the future, is approximately the unconditional variance \\(\\theta\\).\nThe most interesting feature of the volatility equation is that large returns (in absolute value) lead to an increase in the variance and hence are likely to be followed by more large returns (whether positive or negative). This is the phenomenon of volatility clustering, which is quite observable in actual markets. This feature also implies that the distribution of returns will be fat tailed (more technically, leptokurtic). This means that the probability of extreme returns is higher than under a normal distribution with the same standard deviation.4 It is well documented that daily and weekly returns in most markets have this fat-tailed property.\nWe can simulate a path of an asset price that follows a GARCH process and the path of its volatility as follows. The following python code produces three columns of data (with headings), the first column being time, the second the asset price, and the third the volatility.\n\n\nCode\nimport numpy as np\nimport pandas as pd\n\ndef simulating_garch(S, sigma, r, q, dt, N, theta, kappa, lambd):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    sigma = initial volatility\n    r = risk-free rate\n    q = dividend yield\n    dt = length of each time period (Delta t)\n    N = number of time periods\n    theta = theta parameter for GARCH\n    kappa = kappa parameter for GARCH\n    lambd = lambda parameter for GARCH\n    \"\"\"\n    LogS = np.log(S)\n    Sqrdt = np.sqrt(dt)\n    a = kappa * theta\n    b = (1 - kappa) * (1 - lambd)\n    c = (1 - kappa) * lambd\n    \n    time = np.zeros(N + 1)\n    stock_price = np.zeros(N + 1)\n    volatility = np.zeros(N + 1)\n    \n    stock_price[0] = S\n    volatility[0] = sigma    \n    \n    for i in range(1, N + 1):\n        time[i] = i * dt\n        y = sigma * np.random.randn()\n        LogS = LogS + (r - q - 0.5 * sigma * sigma) * dt + Sqrdt * y\n        S = np.exp(LogS)\n        stock_price[i] = S\n        sigma = np.sqrt(a + b * y ** 2 + c * sigma ** 2)\n        volatility[i] = sigma\n\n    df_garch = pd.DataFrame({'Time': time, 'Stock Price': stock_price, 'Volatility': volatility})\n    df_garch.to_csv('garch_simulation.csv', index=False)\n    return df_garch\n\n# Example usage:\nS = 100       # Initial stock price\nsigma = 0.2   # Initial volatility\nr = 0.05      # Risk-free rate\nq = 0.02      # Dividend yield\ndt = 1/252    # Length of each time period (daily)\nN = 252       # Number of time periods (one year)\ntheta = 0.1   # Theta parameter for GARCH\nkappa = 0.1   # Kappa parameter for GARCH\nlambd = 0.9   # Lambda parameter for GARCH\n\ndf_garch = simulating_garch(S, sigma, r, q, dt, N, theta, kappa, lambd)\nprint(df_garch)\n\n\n         Time  Stock Price  Volatility\n0    0.000000   100.000000    0.200000\n1    0.003968   100.199762    0.206123\n2    0.007937    98.087022    0.233983\n3    0.011905    95.742260    0.260066\n4    0.015873    94.016594    0.268839\n..        ...          ...         ...\n248  0.984127   110.281290    0.293693\n249  0.988095   109.411780    0.285078\n250  0.992063   108.299371    0.279602\n251  0.996032   106.029937    0.288896\n252  1.000000   107.266285    0.284035\n\n[253 rows x 3 columns]\n\n\nTo price European options, we need to compute the usual probabilities \\(\\text{prob}^S(S_T&gt;K)\\) and \\(\\text{prob}^R(S_T &gt;K)\\). Heston and Nandi (Heston and Nandi 2000) provide a fast method for computing these probabilities in a GARCH (1,1) model.5 Rather than developing this approach, we will show in ?sec-c:introcomputation how to apply Monte-Carlo methods.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#hedging-and-market-completeness",
    "href": "Chapter_GARCH.html#hedging-and-market-completeness",
    "title": "16  GARCH Models",
    "section": "16.5 Hedging and Market Completeness",
    "text": "16.5 Hedging and Market Completeness\nThe GARCH model is inherently a discrete-time model. If returns have a GARCH structure at one frequency (e.g., monthly), they will not have a GARCH structure at a different frequency (e.g., weekly). Hence, the return period (monthly, weekly, ) is part of the specification of the model. One interpretation of the model is that the dates \\(t_i\\) at which the variance changes are the only dates at which investors can trade. Under this interpretation, it is impossible to perfectly hedge an option: the gross return \\(S_{t_i}/S_{t_{i-1}}\\) over the interval \\((t_{i-1},t_i)\\) is lognormally distributed, so no portfolio of the stock and riskless asset formed at \\(t_{i-1}\\) and held over the interval \\((t_{i-1},t_i)\\) can perfectly replicate the return of an option over the interval. As discussed in ?sec-s:incomplete, we call a market in which some derivatives cannot be perfectly hedged an incomplete market. Thus, the GARCH model is an example of an incomplete market, if investors can only trade at the frequency at which returns have a GARCH structure. However, it is unreasonable to assume that investors can only trade weekly or monthly or even daily.\nAnother interpretation of the GARCH model is that investors can trade continuously and the asset has a constant volatility within each period \\((t_{i-1},t_i)\\). Under this interpretation, the market is complete and options can be delta-hedged. The completeness is a result of the fact that the change \\(\\sigma_{i+1}-\\sigma_i\\) in the volatility at date \\(t_i\\) (recall that \\(\\sigma_i\\) is the volatility over the period \\((t_{i-1},t_i)\\) and \\(\\sigma_{i+1}\\) is the volatility over the period \\((t_{i},t_{i+1})\\)) depends only on \\(\\log S_{t_i}\\). Thus, the only random factor in the model that needs to be hedged is, as usual, the underlying asset price. However, this interpretation of the model is also a bit strange. Suppose for example that monthly returns are assumed to have a GARCH structure. Then the model states that the volatility in February will be higher if there is an unusually large return (in absolute value) in January. Suppose there is an unusually large return in the first half of January. Then, intuitively, one would expect the change in the volatility to occur in the second half of January rather than being delayed until February. However, the model specifies that the volatility is constant during each month, hence constant during January in this example.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#section",
    "href": "Chapter_GARCH.html#section",
    "title": "16  GARCH Models",
    "section": "",
    "text": "Exercise 16.1 The purpose of this exercise is to generate a fat-tailed distribution from a model that is simpler than the GARCH and stochastic volatility models but has somewhat the same flavor. The distribution will be a mixture of normals. Create a python program in which the user can input \\(S\\), \\(r\\), \\(q\\), \\(T\\), \\(\\sigma_1\\) and \\(\\sigma_2\\). Use these inputs to produce a column of 500 simulated \\(\\log S_T\\). In each simulation, define \\(\\log S_T\\) as \\[\\log S_T = \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma \\sqrt{T}z\\;,\\] where \\(z\\) is a standard normal, \\(\\sigma = x\\sigma_1 + (1-x)\\sigma_2\\), and \\(x\\) is a random variable that equals zero or one with equal probabilities.\nCalculate the mean and standard deviation of the \\(\\log S_T\\) and calculate the fraction that lie more than two standard deviations below the mean. If the \\(\\log S_T\\) all came from a normal distribution with the same variance, then this fraction should equal \\(\\mathrm{N}(-2) =\\) 2.275%. If the fraction is higher, then the distribution is fat tailed. (Of course, the actual fraction would differ from 2.275% in any particular case due to the randomness of the simulation, even if all of the \\(\\log S_T\\) came from a normal distribution with the same variance).\n\n\nExercise 16.2 Create a python program prompting the user to input the same inputs as in the simulating_garch function except for the initial volatility and \\(\\theta\\). Simulate 500 paths of a GARCH process and output \\(\\log S_T\\) for each simulation (you don’t need to output the entire paths as in the simulating_garch function). Take the initial volatility to be 0.3 and \\(\\theta = 0.09\\). Determine whether the distribution is fat-tailed by computing the fraction of the \\(\\log S_T\\) that lie two or more standard deviations below the mean, as in the previous exercise. For what values of \\(\\kappa\\) and \\(\\lambda\\) does the distribution appear to be especially fat-tailed?\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 18.2 for the Heston stochastic volatility model, describing the values of \\(\\kappa\\), \\(\\gamma\\) and \\(\\rho\\) that appear to generate especially fat-tailed distributions.\n\n\n\n\n\n\n\nBollerslev, T. 1986. “Generalized Autoregressive Conditional Heteroskedasticity.” Journal of Econometrics 31: 307–27.\n\n\nHeston, S., and S. Nandi. 2000. “A Closed-Form GARCH Option Valuation Model.” Review of Financial Studies 13: 585–625.\n\n\nMina, J., and J. Xiao. 2001. Return to RiskMetrics. The Evolution of a Standard.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_GARCH.html#footnotes",
    "href": "Chapter_GARCH.html#footnotes",
    "title": "16  GARCH Models",
    "section": "",
    "text": "The variance of \\(\\bar{x} = (1/N)(x_1 + \\cdots + x_N)\\) is, by independence of the \\(x_i\\), equal to \\((1/N)^2(\\mathrm{var}{x_1} + \\cdots + \\mathrm{var}{x_N})\\), and, because the \\(x_i\\) all have the same variance \\(\\sigma^2\\), this is equal to \\((1/N)^2 \\times N\\sigma^2 = \\sigma^2/N\\).↩︎\nSee Mina and Xiao (Mina and Xiao 2001), available online at www.riskmetrics.com↩︎\nGARCH is the acronym for Generalized Autoregressive Conditional Heteroskedastic. GARCH(1,1) means that there is only one past \\(y\\) (no \\(y_{i-1}\\), \\(y_{i-2}\\), etc.) and one past \\(\\sigma\\) (no \\(\\sigma_{i-1}\\), \\(\\sigma_{i-2}\\), etc.) in Equation 16.9. See Bollerslev (Bollerslev 1986).↩︎\nConversely, the probability of returns very near the mean must also be higher than under a normal distribution with the same standard deviation—a fat-tailed distribution must also have a relatively narrow peak.↩︎\nActually, a slightly more general model is considered in (Heston and Nandi 2000), in which large negative returns lead to a greater increase in volatility than do large positive returns. This accommodates the empirically observed negative correlation between stock returns and volatility.↩︎",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>GARCH Models</span>"
    ]
  },
  {
    "objectID": "Chapter_StochasticVol.html",
    "href": "Chapter_StochasticVol.html",
    "title": "17  Stochastic Volatility",
    "section": "",
    "text": "17.1 Hedging and Market Completeness\nThe volatility is stochastic (random) in a GARCH model, but it is determined by the changes in the stock price. In this section, in contrast, we will consider models in which the volatility depends on a second Brownian motion. The most popular model of this type is the model of Heston (Heston 1993). In this model, we have, as usual,\n\\[\n\\,\\mathrm{d}\\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B_s\\;,\n\\qquad(17.1)\\]\nwhere \\(B_s\\) is a Brownian motion under the risk-neutral probability but now \\(\\sigma\\) is not a constant but instead evolves as \\(\\sigma_t = \\sqrt{v_t}\\) where\n\\[\ndv_t = \\kappa \\big[\\theta-v_t\\big]\\,\\mathrm{d}t + \\gamma \\sqrt{v_t}\\,\\mathrm{d}B_v\\;,\n\\qquad(17.2)\\]\nwhere \\(B_v\\) is a Brownian motion under the risk-neutral probability having a constant correlation \\(\\rho\\) with the Brownian motion \\(B_s\\). In this equation, \\(\\kappa\\), \\(\\theta\\) and \\(\\gamma\\) are positive constants. Given the empirical fact that negative return shocks have a bigger impact on future volatility than do positive shocks, one would expect the correlation \\(\\rho\\) to be negative.\nThe term \\(\\kappa (\\theta-v)\\) will be positive when \\(v&lt;\\theta\\) and negative when \\(v&gt;\\theta\\) and hence \\(\\sigma^2=v\\) will tend to drift towards \\(\\theta\\), which, as in the GARCH model, is the long-run or unconditional mean of \\(\\sigma^2\\). Thus, the volatility is said to mean revert. The rate at which it drifts towards \\(\\theta\\) is obviously determined by the magnitude of \\(\\kappa\\), also as in the GARCH model.\nThe specification Equation 17.2 implies that the volatility of \\(v\\) approaches zero whenever \\(v\\) approaches zero. In this circumstance, one might expect the drift towards \\(\\theta\\) to dominate the volatility and keep \\(v\\) nonnegative, and this is indeed the case; thus, the definition \\(\\sigma_t = \\sqrt{v_t}\\) is possible. Moreover, the parameter \\(\\gamma\\) plays a role here that is similar to the role of \\(1-\\lambda\\) in the GARCH model—the variance of the variance in the GARCH model Equation 16.10 depends on the weight \\(1-\\lambda\\) placed on the scaled return \\(y_i\\), just as the variance of the variance in the stochastic volatility model Equation 17.2 depends on the weight \\(\\gamma\\) placed on \\(\\,\\mathrm{d}B_v\\).\nWe could discretize Equation 17.1 - Equation 17.2 as:\n\\[\n\\log S(t_{i+1}) = \\log S_{t_i} + \\left(r-q-\\frac{1}{2}\\sigma_{t_i}^2\\right)\\,\\Delta t + \\sqrt{v_{t_i}}\\,\\Delta B_s,\n\\qquad(17.3)\\]\n\\[\nv(t_{i+1}) = v_{t_i} + \\kappa \\big[\\theta-v_{t_i}\\big]\\,\\Delta t + \\gamma \\sqrt{v_{t_i}}\\,\\Delta B_v\\;.\n\\qquad(17.4)\\]\nHowever, even though in the continuous-time model Equation 17.1 - Equation 17.2 we always have \\(v_t \\geq 0\\) and hence can define \\(\\sigma_t=\\sqrt{v_t}\\), there is no guarantee that \\(v(t_{i+1})\\) defined by Equation 17.4 will be nonnegative. A simple remedy is to define \\(v(t_{i+1})\\) as the larger of zero and the right-hand side of Equation 17.4; thus, we will simulate the Heston model as Equation 17.3 and1 \\[\nv(t_{i+1}) = \\max\\left\\{0,v_{t_i} + \\kappa \\big[\\theta-v_{t_i}\\big]\\,\\Delta t + \\gamma \\sqrt{v_{t_i}}\\,\\Delta B_v\\right\\}\\;.\n\\qquad(17.5)\\]\nA simple way to simulate the changes \\(\\Delta B_s\\) and \\(\\Delta B_v\\) in the two correlated Brownian motions is to generate two independent standard normals \\(z_1\\) and \\(z_2\\) and take \\[\\Delta B_s = \\sqrt{\\Delta t}\\,z \\qquad \\text{and} \\qquad \\Delta B_v = \\sqrt{\\Delta t}\\,z^*\\; ,\\] where we define \\[z = z_1 \\qquad \\text{and} \\qquad z^* = \\rho z_1 + \\sqrt{1-\\rho^2}\\,z_2\\; .\\] The random variable \\(z^*\\) is also a standard normal, and the correlation between \\(z\\) and \\(z^*\\) is \\(\\rho\\).\nAs in the GARCH model, we can simulate a path of an asset price that follows a GARCH process and the path of its volatility as follows. The following python code produces three columns of data (with headings), the first column being time, the second the asset price, and the third the volatility in the Heston model.\nThe following code plots the simulated stock price and the variance paths.\nThe following code shows that the stock returns under the stochastic volatility model display fat-tails with positive kurtosis.\nTo price European options, we again need to compute \\[\\text{prob}^S(S_T&gt;K) \\qquad \\text{and} \\qquad \\text{prob}^R(S_T&gt;K)\\; .\\] The virtue of modelling volatility as in Equation 17.2 is that these probabilities can be computed quite efficiently, as shown by Heston (Heston 1993).2 There are many other ways in which one could model volatility, but the computations may be more difficult. For example, one could replace Equation 17.2 by \\[\n\\sigma_t = \\mathrm{e}^{v_t} \\quad \\text{and} \\quad dv_t = \\kappa (\\theta-v_t)\\,\\mathrm{d}t + \\lambda \\,\\mathrm{d}B^*\\;.\n\\qquad(17.6)\\]\nThis implies a lognormal volatility and is simpler to simulate than Equation 17.2—because \\(\\mathrm{e}^{v}\\) is well defined even when \\(v\\) is negative—but it is easier to calculate the probabilities \\(\\text{prob}^S(S_T&gt;K)\\) and \\(\\text{prob}^R(S_T&gt;K)\\) if we assume Equation 17.2.\nOne way to implement the GARCH or stochastic volatility model is to imply both the initial volatility \\(\\sigma_0\\) and the constants \\(\\kappa\\), \\(\\theta\\) and \\(\\lambda\\) or \\(\\kappa\\), \\(\\theta\\), \\(\\gamma\\) and \\(\\rho\\) from observed option prices. These four (or five) constants can be computed by forcing the model prices of four (or five) options to equal the observed market prices. Or, a larger set of prices can be used and the constants can be chosen to minimize the average squared error or some other measure of goodness-of-fit between the model and market prices.\nThe GARCH model is inherently a discrete-time model. If returns have a GARCH structure at one frequency (e.g., monthly), they will not have a GARCH structure at a different frequency (e.g., weekly). Hence, the return period (monthly, weekly, ) is part of the specification of the model. One interpretation of the model is that the dates \\(t_i\\) at which the variance changes are the only dates at which investors can trade. Under this interpretation, it is impossible to perfectly hedge an option: the gross return \\(S_{t_i}/S_{t_{i-1}}\\) over the interval \\((t_{i-1},t_i)\\) is lognormally distributed, so no portfolio of the stock and riskless asset formed at \\(t_{i-1}\\) and held over the interval \\((t_{i-1},t_i)\\) can perfectly replicate the return of an option over the interval. As discussed in ?sec-s:incomplete, we call a market in which some derivatives cannot be perfectly hedged an incomplete market. Thus, the GARCH model is an example of an incomplete market, if investors can only trade at the frequency at which returns have a GARCH structure. However, it is unreasonable to assume that investors can only trade weekly or monthly or even daily.\nAnother interpretation of the GARCH model is that investors can trade continuously and the asset has a constant volatility within each period \\((t_{i-1},t_i)\\). Under this interpretation, the market is complete and options can be delta-hedged. The completeness is a result of the fact that the change \\(\\sigma_{i+1}-\\sigma_i\\) in the volatility at date \\(t_i\\) (recall that \\(\\sigma_i\\) is the volatility over the period \\((t_{i-1},t_i)\\) and \\(\\sigma_{i+1}\\) is the volatility over the period \\((t_{i},t_{i+1})\\)) depends only on \\(\\log S_{t_i}\\). Thus, the only random factor in the model that needs to be hedged is, as usual, the underlying asset price. However, this interpretation of the model is also a bit strange. Suppose for example that monthly returns are assumed to have a GARCH structure. Then the model states that the volatility in February will be higher if there is an unusually large return (in absolute value) in January. Suppose there is an unusually large return in the first half of January. Then, intuitively, one would expect the change in the volatility to occur in the second half of January rather than being delayed until February. However, the model specifies that the volatility is constant during each month, hence constant during January in this example.\nThe stochastic volatility model is more straightforward. The market is definitely incomplete. The value of a call option at date \\(t&lt;T\\), where \\(T\\) is the maturity of the option, will depend on the underlying asset price \\(S_t\\) and the volatility \\(\\sigma_t\\). Denoting the value by \\(C(t,S_t,\\sigma_t)\\), we have from Ito’s formula that \\[\n\\,\\mathrm{d}C_t = \\text{something}\\;\\,\\mathrm{d}t + \\frac{\\partial C}{\\partial S}\\,\\mathrm{d}S_t + \\frac{\\partial C}{\\partial \\sigma}\\,\\mathrm{d}\\sigma_t\\; .\\] A replicating portfolio must have the same dollar change at each date \\(t\\). If we hold \\(\\partial C/\\partial S\\) shares of the underlying asset, then the change in the value of the shares will be \\((\\partial C/\\partial S)\\,\\mathrm{d}S\\). However, there is no way to match the\n\\((\\partial C/\\partial \\sigma)\\,\\mathrm{d}\\sigma\\) term using the underlying asset and the riskless asset.\nThe significance of the market being incomplete is that the value of a derivative asset that cannot be replicated using traded assets (e.g., the underlying and riskless assets) is not uniquely determined by arbitrage considerations. As discussed in ?sec-s:incomplete, one must use equilibrium pricing in this circumstance. That is what we have implicitly done in this chapter. By assuming particular dynamics for the volatility under the risk-neutral probability, we have implicitly selected a particular risk-neutral probability from the set of risk-neutral probabilitys that are consistent with the absence of arbitrage.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Stochastic Volatility</span>"
    ]
  },
  {
    "objectID": "Chapter_StochasticVol.html#variance-swaps",
    "href": "Chapter_StochasticVol.html#variance-swaps",
    "title": "17  Stochastic Volatility",
    "section": "17.2 Variance Swaps",
    "text": "17.2 Variance Swaps\nVariance swaps are a type of futures contracts that allows investors to trade future realized volatility against current option implied variance. Unlike traditional futures, which provide a payoff based on the difference between the underlying asset’s price and the futures price, variance swaps provide a payoff based on the difference between the realized variance of the underlying asset and the predetermined variance level (termed ``Strike’’ in practice), which is the futures price in variance unit.\nVariance swaps have gained popularity due to their ability to provide pure exposure to the volatility of an underlying asset, independent of its price movements. Unlike traditional options, variance swaps allow investors to speculate on or hedge against changes in volatility without the need for constant delta hedging. This makes them an effective tool for managing volatility risk and for executing volatility arbitrage strategies, as they simplify the trading of variance and offer a more straightforward payoff structure based on realized versus implied volatility.\n\nPayoff of a Variance Swap\nA variance swap is a future contract on future realized variance. Its main components include:\n\nNotional Amount: Specifies the amount of money to be paid for each unit of variance difference.\nStrike: The predetermined level of variance agreed upon at the inception of the swap.\nRealized Variance: Calculated from the returns of the underlying asset over the life of the swap.\n\nThe payoff of a variance swap is given by:\n\\[\n\\text{Payoff} = \\text{Notional} \\times (\\text{Realized Variance} - \\text{Strike})\n\\]\nWhere:\n\nRealized Variance is typically calculated using the formula:\n\n\\[\n\\text{Realized Variance} = \\frac{252}{N} \\sum_{i=1}^{N} \\left( \\log\\left(\\frac{S_i}{S_{i-1}}\\right) \\right)^2\n\\]\nHere, \\(S_i\\) represents the price of the underlying asset at time \\(i\\), and \\(N\\) is the number of trading days over the contract period.\nExample: Suppose an investor enters into a variance swap with a notional amount of $100,000 and a strike of 0.04 (implying a volatility strike of 20%). If the realized variance over the swap’s life is 0.06 (implying a realized volatility of 24.5%), the payoff would be:\n\\[\n\\text{Payoff} = 100,000 \\times (0.06 - 0.04) = 100,000 \\times 0.02 = 2,000\n\\]\nThis means the investor would receive $2,000 at the end of the swap period.\nAs all futures constracts, variance swaps are marked to market on each trading day.\nVariance swaps can be used to hedge against volatility risk. For example, a portfolio manager concerned about increasing market volatility can buy variance swaps to protect the portfolio’s value.\nTraders can also use variance swaps to speculate or arbitrage on future volatility. For example, If a trader believes that future volatility will be higher than the current implied volatility, they can enter a variance swap to profit from this view.\n\n\nPricing of a Variance Swap for Stocks with Geometric Brownian Motion Prices\nSimilor the pricing of a futures, we need find the fair swap strike such that the initial value of the swap is zero. For simplicity, consider a stock whose price \\(S_t\\) follows a geometric Brownian motion process:\n\\[ \\frac{dS_t}{S_t} = \\mu \\, dt + \\sigma \\, dZ_t\n\\]\nApplying Ito’s Lemma to \\(\\log(S_t)\\):\n\\[ d(\\log S_t) = \\left( \\mu - \\frac{\\sigma^2}{2} \\right) \\, dt + \\sigma \\, dZ_t\n\\]\nRearranging terms, we get:\n\\[ \\frac{dS_t}{S_t} - d(\\log S_t) = \\frac{\\sigma^2}{2} \\, dt\n\\]\nIntegrating over the life of the swap ( [0, T] ):\n\\[ \\text{Total Variance} = \\frac{1}{T} \\int_0^T \\sigma^2 \\, dt = \\frac{2}{T} \\left( \\int_0^T \\frac{dS_t}{S_t} - \\log \\left( \\frac{S_T}{S_0} \\right) \\right),  \n\\] which implies that the total variance can be replicated by continuously rebalancing the stock position with weight \\(1/S_t\\) and shorting one unit of the security which pays the \\(\\log\\) return of the stock. However, this \\(\\log\\) return secutiry is not traded in the market. Fortunately, we can synthesize this security with a forward and options, because\n\\[\n-ln (\\frac{S_T}{S^*})=-\\frac{S-S^*}{S^*}+\\int_0^{S^*}\\frac{(K-S)^+}{K^2}dK+\\int_{S^*}^\\infty\\frac{(S-K)^+}{K^2}dK,\n\\] where \\(S^*\\) is an arbitrary cut-off strike for calls and puts, the first term on the right hand side represents a short position in the forward contract on the stock, the second term represents a continuum of put options with strike prices from 0 to \\(S^*\\), and the third term represents a continuum of call options with strike prices above \\(S^*\\). Taking expectation under the risk-neutral probability, we have that the fair swap strike \\(K_{\\text{var}}\\) is equal to:\n\\[ K_{\\text{var}} = \\frac{2}{T} \\left( rT - \\left( \\frac{S_0}{S^*} e^{rT} - 1 \\right) - \\log \\left( \\frac{S^*}{S_0} \\right) + e^{rT} \\int_0^{S^*} \\frac{1}{K^2} P(K) \\, dK + e^{rT} \\int_{S^*}^\\infty \\frac{1}{K^2} C(K) \\, dK \\right)\n\\]\nChoosing \\(S^*\\) to be the current forward price \\(F_0=S_0 e^{rT}\\):\n\\[ K_{\\text{var}} = \\frac{2 e^{rT}}{T} \\left( \\int_0^{F_0} \\frac{P(K)}{K^2} \\, dK + \\int_{F_0}^\\infty \\frac{C(K)}{K^2} \\, dK \\right)\n\\]\nThis formula allows us to compute the fair strike price of a variance swap using the prices of European call and put options. The following code provides an example of this computation using data from Yahoo finance for Apple.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\nfrom scipy.stats import norm\nimport yfinance as yf\n\ndef indicator_function(condition):\n    return 1 if condition else 0\n\ndef calculate_variance_swap_strike(S, r, T, options_data):\n    # Extract call and put prices\n    call_data = options_data[options_data['Type'] == 'call'].copy()\n    put_data = options_data[options_data['Type'] == 'put'].copy()\n    \n    # Interpolate call and put prices\n    strikes = np.unique(options_data['Strike'])\n    call_interp = interp1d(call_data['Strike'], call_data['Price'], fill_value=\"extrapolate\")\n    put_interp = interp1d(put_data['Strike'], put_data['Price'], fill_value=\"extrapolate\")\n    \n    # Integrate using numerical methods (trapezoidal rule)\n    \n    K_min, K_max = strikes.min(), strikes.max()\n    K = np.linspace(K_min, S*np.exp(r*T), 500)\n    integral1 = np.trapezoid(put_interp(K) / K**2, K)\n    K = np.linspace(S*np.exp(r*T),K_max, 500)\n    integral2 = np.trapezoid(call_interp(K) / K**2, K)\n    \n    # Calculate the variance swap strike\n    variance_swap_strike = np.sqrt(2 * (integral1+integral2) / T)\n    return variance_swap_strike\n\n# Example usage\nticker = \"AAPL\"\nS = 150.0  # Current stock price\nr = 0.01  # Risk-free rate\nT = 0.5  # Time to maturity (6 months)\n\n# Fetch options data from Yahoo Finance\nstock = yf.Ticker(ticker)\nexpiry = stock.options[0]\nopt_chain = stock.option_chain(expiry)\ncalls = opt_chain.calls[['strike', 'lastPrice']].copy()\nputs = opt_chain.puts[['strike', 'lastPrice']].copy()\ncalls.columns = ['Strike', 'Price']\nputs.columns = ['Strike', 'Price']\ncalls['Type'] = 'call'\nputs['Type'] = 'put'\noptions_data = pd.concat([calls, puts])\n\n# Calculate the variance swap strike\nvariance_swap_strike = calculate_variance_swap_strike(S, r, T, options_data)\nprint(f\"Variance Swap Strike: {variance_swap_strike:.4f}\")\n\n\nVariance Swap Strike: 0.6075",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Stochastic Volatility</span>"
    ]
  },
  {
    "objectID": "Chapter_StochasticVol.html#section",
    "href": "Chapter_StochasticVol.html#section",
    "title": "17  Stochastic Volatility",
    "section": "",
    "text": "Exercise 17.1 The purpose of this exercise is to generate a fat-tailed distribution from a model that is simpler than the GARCH and stochastic volatility models but has somewhat the same flavor. The distribution will be a mixture of normals. Create a python program in which the user can input \\(S\\), \\(r\\), \\(q\\), \\(T\\), \\(\\sigma_1\\) and \\(\\sigma_2\\). Use these inputs to produce a column of 500 simulated \\(\\log S_T\\). In each simulation, define \\(\\log S_T\\) as \\[\\log S_T = \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma \\sqrt{T}z\\;,\\] where \\(z\\) is a standard normal, \\(\\sigma = x\\sigma_1 + (1-x)\\sigma_2\\), and \\(x\\) is a random variable that equals zero or one with equal probabilities.\nCalculate the mean and standard deviation of the \\(\\log S_T\\) and calculate the fraction that lie more than two standard deviations below the mean. If the \\(\\log S_T\\) all came from a normal distribution with the same variance, then this fraction should equal \\(\\mathrm{N}(-2) =\\) 2.275%. If the fraction is higher, then the distribution is fat tailed. (Of course, the actual fraction would differ from 2.275% in any particular case due to the randomness of the simulation, even if all of the \\(\\log S_T\\) came from a normal distribution with the same variance).\n\n\nExercise 17.2 Create a python program prompting the user to input the same inputs as in the simulating_garch function except for the initial volatility and \\(\\theta\\). Simulate 500 paths of a GARCH process and output \\(\\log S_T\\) for each simulation (you don’t need to output the entire paths as in the simulating_garch function). Take the initial volatility to be 0.3 and \\(\\theta = 0.09\\). Determine whether the distribution is fat-tailed by computing the fraction of the \\(\\log S_T\\) that lie two or more standard deviations below the mean, as in the previous exercise. For what values of \\(\\kappa\\) and \\(\\lambda\\) does the distribution appear to be especially fat-tailed?\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 18.2 for the Heston stochastic volatility model, describing the values of \\(\\kappa\\), \\(\\gamma\\) and \\(\\rho\\) that appear to generate especially fat-tailed distributions.\n\n\n\n\n\n\n\nBroadie, M., and O. Kaya. 2006. “Exact Simulation of Stochastic Volatility and Other Affine Jump Diffusion Processes.” Operations Research 52: 217–31.\n\n\nEpps, T. W. 2000. Pricing Derivative Securities. World Scientific Publishing, Singapore.\n\n\nGlasserman, P. 2004. Monte Carlo Methods in Financial Engineering. Springer, New York Berlin Heidelberg.\n\n\nHeston, S. 1993. “A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.” Review of Financial Studies 6: 327–44.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Stochastic Volatility</span>"
    ]
  },
  {
    "objectID": "Chapter_StochasticVol.html#footnotes",
    "href": "Chapter_StochasticVol.html#footnotes",
    "title": "17  Stochastic Volatility",
    "section": "",
    "text": "There are better (but more complicated) ways to simulate the Heston model. An excellent discussion of ways to simulate the volatility process can be found in Glasserman (Glasserman 2004). Broadie and Kaya (Broadie and Kaya 2006) present a method for simulating from the exact distribution of the asset price in the Heston model and related models.↩︎\nFurther discussion can be found in Epps (Epps 2000).↩︎",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Stochastic Volatility</span>"
    ]
  },
  {
    "objectID": "Chapter_Jumps.html",
    "href": "Chapter_Jumps.html",
    "title": "18  Jumps",
    "section": "",
    "text": "18.1 Smiles and Smirks Again\nIn the classical Black-Scholes model, stock prices are assumed to follow a geometric Brownian motion, which is characterized by continuous paths and normally distributed returns. While this model has been widely used due to its simplicity and analytical tractability, it fails to capture certain empirical phenomena observed in financial markets, such as sudden and significant price changes (jumps) and the heavy tails of return distributions.\nTo address these shortcomings, the jump diffusion model was introduced by Robert C. Merton in 1976. This model extends the Black-Scholes framework by incorporating jumps into the stock price dynamics, thereby allowing for discontinuous price paths. The jump diffusion model is better suited to describe the behavior of financial assets that exhibit sudden price changes due to news, earnings announcements, or other market events.\nIn a jump diffusion model, the stock price \\(S_t\\) is governed by the following stochastic differential equation (SD\\E):\n\\[\ndS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t + S_t \\, dJ_t\n\\]\nwhere \\(\\mu\\) is the drift rate, \\(\\sigma\\) is the volatility, \\(B_t\\) is a standard Brownian motion, \\(J_t\\) is a jump process.\nThe jump process \\(J_t\\) is typically modeled as a compound Poisson process:\n\\[\nJ_t = \\sum_{i=1}^{N_t} (Y_i - 1)\n\\]\nwhere \\(N_t\\) is a Poisson process with intensity \\(\\lambda\\), \\(Y_i\\) are i.i.d. random variables representing the relative jump sizes, with \\(Y_i - 1\\) being the actual jump size.\nThe jump diffusion model introduces several important implications for the behavior of stock prices and the pricing of derivative securities:\nThe following python code simulates the stock price that evolves as a jump diffusion.\nThe jump diffusion model offers a more realistic framework for modeling stock prices by incorporating the possibility of sudden jumps. This enhancement over the classical Black-Scholes model allows for better capturing the empirical characteristics of financial markets, thereby improving the accuracy of option pricing and risk management practices.\nAs mentioned before, the GARCH, stochastic volatility and jump diffusion models can generate fat-tailed distributions for the asset price \\(S_T\\). Thus, they can be more nearly consistent with the option smiles discussed in ?sec-s:smiles than is the Black-Scholes model (though it appears that one must include jumps in asset prices as well as stochastic volatility in order to duplicate market prices with an option pricing formula). To understand the relation, let \\(\\sigma_\\text{am}\\) denote the implied volatility from an at-the-money call option, i.e., a call option with strike \\(K=S_0\\). The characteristic of a smile is that implied volatilities from options of the same maturity with strike prices significantly above and below \\(S_0\\) are higher than \\(\\sigma_\\text{am}\\).\nA strike price higher than \\(S_0\\) corresponds to an out-of-the money call option. The high implied volatility means that the market is pricing the right to buy at \\(K&gt;S_0\\) above the Black-Scholes price computed from the volatility \\(\\sigma_\\text{am}\\); thus, the market must attach a higher probability to stock prices \\(S_T&gt;S_0\\) than the volatility \\(\\sigma_\\text{am}\\) would suggest.\nA strike price lower than \\(S_0\\) corresponds to an in-the-money call option. The put option with the same strike is out of the money. The high implied volatility means that the market is pricing call options above the Black-Scholes price computed from the volatility \\(\\sigma_\\text{am}\\). By put-call parity, the market must also be pricing put options above the Black-Scholes price computed from the volatility \\(\\sigma_\\text{am}\\). The high prices for the rights to buy and sell at \\(K&lt;S_0\\) means that the market must attach a higher probability to stock prices \\(S_T&lt;S_0\\) than the volatility \\(\\sigma_\\text{am}\\) would suggest. In particular, the high price for the right to sell at \\(K&lt;S_0\\) means a high insurance premium for owners of the asset who seek to insure their positions, which is consistent with a market view that there is a significant probability of a large loss. This can be interpreted as a crash premium. Indeed, the implied volatilities at strikes less than \\(S_0\\) are typically higher than the implied volatilities at strikes above \\(S_0\\) (giving the smile the appearance of a smirk, as discussed in ?sec-s:smiles), which is consistent with a larger probability of crashes than of booms (a fatter tail for low returns than for high).\nAs an example, the following code shows that the stochstic volatility model can generate implied volatility smiles.\nThis program involes (1) Simulating Heston Model: simulate_heston_paths function generates stock price paths using the Heston model parameters. (2) Calculating call price by discounting the averaged call payoffs across the stock price sample paths (3) Calculating Black Scholes call price : black_scholes_call_price function calculates the call option price using the Black-Scholes formula. (4) Calculating implied volatility: implied_volatility function computes the implied volatility by solving for the volatility that matches the Black-Scholes call price to the simulated call price. (5) Repeating Steps (2)-(4) for different strik prices. (6) Plotting the implied volatility against strike prices fixing the initial stock price at $100.\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom scipy.optimize import brentq\n\n# Heston model parameters\nS0 = 100      # Initial stock price\nV0 = 0.04     # Initial variance\nr = 0.05      # Risk-free rate\nq = 0.01      # Dividend yield\nT = 1         # Time to maturity (in years)\nkappa = 0.25   # Rate of mean reversion of variance\ntheta = 0.04  # Long-term variance\nsigma = 0.5   # Volatility of variance\nrho = -0.2    # Correlation between the two Wiener processes\ndt = 1/252    # Length of each time period (daily)\nN = 252       # Number of time periods (one year)\nn_simulations = 10000  # Number of simulations\n\ndef simulate_heston_paths(S0, V0, r, q, T, kappa, theta, sigma, rho, dt, N, n_simulations):\n    S = np.zeros((N + 1, n_simulations))\n    V = np.zeros((N + 1, n_simulations))\n    S[0] = S0\n    V[0] = V0\n    \n    for t in range(1, N + 1):\n        Z1 = np.random.normal(size=n_simulations)\n        Z2 = np.random.normal(size=n_simulations)\n        W1 = Z1\n        W2 = rho * Z1 + np.sqrt(1 - rho**2) * Z2\n        \n        V[t] = np.maximum(V[t-1] + kappa * (theta - V[t-1]) * dt + sigma * np.sqrt(V[t-1] * dt) * W2, 0)\n        S[t] = S[t-1] * np.exp((r - q - 0.5 * V[t-1]) * dt + np.sqrt(V[t-1] * dt) * W1)\n    \n    return S, V\n\ndef black_scholes_call_price(S, K, T, r, sigma):\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    call_price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return call_price\n\ndef implied_volatility(C, S, K, T, r):\n    def objective_function(sigma):\n        return black_scholes_call_price(S, K, T, r, sigma) - C\n    try:\n        return brentq(objective_function, 0.001, 5.0)\n    except ValueError:\n        return np.nan\n\n# Simulate paths using the Heston model\nS_paths, _ = simulate_heston_paths(S0, V0, r, q, T, kappa, theta, sigma, rho, dt, N, n_simulations)\n\n# Calculate option prices at different strike prices\nstrike_prices = np.linspace(90, 120, 20)\ncall_prices = np.zeros_like(strike_prices)\n\nfor i, K in enumerate(strike_prices):\n    call_payoffs = np.maximum(S_paths[-1] - K, 0)\n    call_prices[i] = np.mean(call_payoffs) * np.exp(-r * T)\n\n# Calculate implied volatilities\nimplied_vols = [implied_volatility(C, S0, K, T, r) for C, K in zip(call_prices, strike_prices)]\n\n# Filter out NaN values that may occur\nvalid_indices = ~np.isnan(implied_vols)\nstrike_prices = strike_prices[valid_indices]\nimplied_vols = np.array(implied_vols)[valid_indices]\n\n# Plot the implied volatility smile\nplt.figure(figsize=(10, 6))\nplt.plot(strike_prices, implied_vols, label='Implied Volatility', marker='o')\nplt.title('Implied Volatility Smile')\nplt.xlabel('Strike Price')\nplt.ylabel('Implied Volatility')\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Jumps</span>"
    ]
  },
  {
    "objectID": "Chapter_Jumps.html#section",
    "href": "Chapter_Jumps.html#section",
    "title": "18  Jumps",
    "section": "",
    "text": "Exercise 18.1 The purpose of this exercise is to generate a fat-tailed distribution from a model that is simpler than the GARCH and stochastic volatility models but has somewhat the same flavor. The distribution will be a mixture of normals. Create a python program in which the user can input \\(S\\), \\(r\\), \\(q\\), \\(T\\), \\(\\sigma_1\\) and \\(\\sigma_2\\). Use these inputs to produce a column of 500 simulated \\(\\log S_T\\). In each simulation, define \\(\\log S_T\\) as \\[\\log S_T = \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma \\sqrt{T}z\\;,\\] where \\(z\\) is a standard normal, \\(\\sigma = x\\sigma_1 + (1-x)\\sigma_2\\), and \\(x\\) is a random variable that equals zero or one with equal probabilities.\nCalculate the mean and standard deviation of the \\(\\log S_T\\) and calculate the fraction that lie more than two standard deviations below the mean. If the \\(\\log S_T\\) all came from a normal distribution with the same variance, then this fraction should equal \\(\\mathrm{N}(-2) =\\) 2.275%. If the fraction is higher, then the distribution is fat tailed. (Of course, the actual fraction would differ from 2.275% in any particular case due to the randomness of the simulation, even if all of the \\(\\log S_T\\) came from a normal distribution with the same variance).\n\n\nExercise 18.2 Create a python program prompting the user to input the same inputs as in the simulating_garch function except for the initial volatility and \\(\\theta\\). Simulate 500 paths of a GARCH process and output \\(\\log S_T\\) for each simulation (you don’t need to output the entire paths as in the simulating_garch function). Take the initial volatility to be 0.3 and \\(\\theta = 0.09\\). Determine whether the distribution is fat-tailed by computing the fraction of the \\(\\log S_T\\) that lie two or more standard deviations below the mean, as in the previous exercise. For what values of \\(\\kappa\\) and \\(\\lambda\\) does the distribution appear to be especially fat-tailed?\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 18.2 for the Heston stochastic volatility model, describing the values of \\(\\kappa\\), \\(\\gamma\\) and \\(\\rho\\) that appear to generate especially fat-tailed distributions.",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Jumps</span>"
    ]
  },
  {
    "objectID": "Chapter_VarianceSwaps.html",
    "href": "Chapter_VarianceSwaps.html",
    "title": "19  Variance Swaps",
    "section": "",
    "text": "Variance swaps are a type of futures contracts that allows investors to trade future realized volatility against current option implied variance. Unlike traditional futures, which provide a payoff based on the difference between the underlying asset’s price and the futures price, variance swaps provide a payoff based on the difference between the realized variance of the underlying asset and the predetermined variance level (termed ``Strike’’ in practice), which is the futures price in variance unit.\nVariance swaps have gained popularity due to their ability to provide pure exposure to the volatility of an underlying asset, independent of its price movements. Unlike traditional options, variance swaps allow investors to speculate on or hedge against changes in volatility without the need for constant delta hedging. This makes them an effective tool for managing volatility risk and for executing volatility arbitrage strategies, as they simplify the trading of variance and offer a more straightforward payoff structure based on realized versus implied volatility.\n\nPayoff of a Variance Swap\nA variance swap is a future contract on future realized variance. Its main components include:\n\nNotional Amount: Specifies the amount of money to be paid for each unit of variance difference.\nStrike: The predetermined level of variance agreed upon at the inception of the swap.\nRealized Variance: Calculated from the returns of the underlying asset over the life of the swap.\n\nThe payoff of a variance swap is given by:\n\\[\n\\text{Payoff} = \\text{Notional} \\times (\\text{Realized Variance} - \\text{Strike})\n\\]\nWhere:\n\nRealized Variance is typically calculated using the formula:\n\n\\[\n\\text{Realized Variance} = \\frac{252}{N} \\sum_{i=1}^{N} \\left( \\log\\left(\\frac{S_i}{S_{i-1}}\\right) \\right)^2\n\\]\nHere, \\(S_i\\) represents the price of the underlying asset at time \\(i\\), and \\(N\\) is the number of trading days over the contract period.\nExample: Suppose an investor enters into a variance swap with a notional amount of $100,000 and a strike of 0.04 (implying a volatility strike of 20%). If the realized variance over the swap’s life is 0.06 (implying a realized volatility of 24.5%), the payoff would be:\n\\[\n\\text{Payoff} = 100,000 \\times (0.06 - 0.04) = 100,000 \\times 0.02 = 2,000\n\\]\nThis means the investor would receive $2,000 at the end of the swap period.\nAs all futures constracts, variance swaps are marked to market on each trading day.\nVariance swaps can be used to hedge against volatility risk. For example, a portfolio manager concerned about increasing market volatility can buy variance swaps to protect the portfolio’s value.\nTraders can also use variance swaps to speculate or arbitrage on future volatility. For example, If a trader believes that future volatility will be higher than the current implied volatility, they can enter a variance swap to profit from this view.\n\n\nPricing of a Variance Swap for Stocks with Geometric Brownian Motion Prices\nSimilor the pricing of a futures, we need find the fair swap strike such that the initial value of the swap is zero. For simplicity, consider a stock whose price \\(S_t\\) follows a geometric Brownian motion process:\n\\[ \\frac{dS_t}{S_t} = \\mu \\, dt + \\sigma \\, dZ_t\n\\]\nApplying Ito’s Lemma to \\(\\log(S_t)\\):\n\\[ d(\\log S_t) = \\left( \\mu - \\frac{\\sigma^2}{2} \\right) \\, dt + \\sigma \\, dZ_t\n\\]\nRearranging terms, we get:\n\\[ \\frac{dS_t}{S_t} - d(\\log S_t) = \\frac{\\sigma^2}{2} \\, dt\n\\]\nIntegrating over the life of the swap ( [0, T] ):\n\\[ \\text{Total Variance} = \\frac{1}{T} \\int_0^T \\sigma^2 \\, dt = \\frac{2}{T} \\left( \\int_0^T \\frac{dS_t}{S_t} - \\log \\left( \\frac{S_T}{S_0} \\right) \\right),  \n\\] which implies that the total variance can be replicated by continuously rebalancing the stock position with weight \\(1/S_t\\) and shorting one unit of the security which pays the \\(\\log\\) return of the stock. However, this \\(\\log\\) return secutiry is not traded in the market. Fortunately, we can synthesize this security with a forward and options, because\n\\[\n-ln (\\frac{S_T}{S^*})=-\\frac{S-S^*}{S^*}+\\int_0^{S^*}\\frac{(K-S)^+}{K^2}dK+\\int_{S^*}^\\infty\\frac{(S-K)^+}{K^2}dK,\n\\] where \\(S^*\\) is an arbitrary cut-off strike for calls and puts, the first term on the right hand side represents a short position in the forward contract on the stock, the second term represents a continuum of put options with strike prices from 0 to \\(S^*\\), and the third term represents a continuum of call options with strike prices above \\(S^*\\). Taking expectation under the risk-neutral probability, we have that the fair swap strike \\(K_{\\text{var}}\\) is equal to:\n\\[ K_{\\text{var}} = \\frac{2}{T} \\left( rT - \\left( \\frac{S_0}{S^*} e^{rT} - 1 \\right) - \\log \\left( \\frac{S^*}{S_0} \\right) + e^{rT} \\int_0^{S^*} \\frac{1}{K^2} P(K) \\, dK + e^{rT} \\int_{S^*}^\\infty \\frac{1}{K^2} C(K) \\, dK \\right)\n\\]\nChoosing \\(S^*\\) to be the current forward price \\(F_0=S_0 e^{rT}\\):\n\\[ K_{\\text{var}} = \\frac{2 e^{rT}}{T} \\left( \\int_0^{F_0} \\frac{P(K)}{K^2} \\, dK + \\int_{F_0}^\\infty \\frac{C(K)}{K^2} \\, dK \\right)\n\\]\nThis formula allows us to compute the fair strike price of a variance swap using the prices of European call and put options. The following code provides an example of this computation using data from Yahoo finance for Apple.\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\nfrom scipy.stats import norm\nimport yfinance as yf\n\ndef indicator_function(condition):\n    return 1 if condition else 0\n\ndef calculate_variance_swap_strike(S, r, T, options_data):\n    # Extract call and put prices\n    call_data = options_data[options_data['Type'] == 'call'].copy()\n    put_data = options_data[options_data['Type'] == 'put'].copy()\n    \n    # Interpolate call and put prices\n    strikes = np.unique(options_data['Strike'])\n    call_interp = interp1d(call_data['Strike'], call_data['Price'], fill_value=\"extrapolate\")\n    put_interp = interp1d(put_data['Strike'], put_data['Price'], fill_value=\"extrapolate\")\n    \n    # Integrate using numerical methods (trapezoidal rule)\n    \n    K_min, K_max = strikes.min(), strikes.max()\n    K = np.linspace(K_min, S*np.exp(r*T), 500)\n    integral1 = np.trapezoid(put_interp(K) / K**2, K)\n    K = np.linspace(S*np.exp(r*T),K_max, 500)\n    integral2 = np.trapezoid(call_interp(K) / K**2, K)\n    \n    # Calculate the variance swap strike\n    variance_swap_strike = np.sqrt(2 * (integral1+integral2) / T)\n    return variance_swap_strike\n\n# Example usage\nticker = \"AAPL\"\nS = 150.0  # Current stock price\nr = 0.01  # Risk-free rate\nT = 0.5  # Time to maturity (6 months)\n\n# Fetch options data from Yahoo Finance\nstock = yf.Ticker(ticker)\nexpiry = stock.options[0]\nopt_chain = stock.option_chain(expiry)\ncalls = opt_chain.calls[['strike', 'lastPrice']].copy()\nputs = opt_chain.puts[['strike', 'lastPrice']].copy()\ncalls.columns = ['Strike', 'Price']\nputs.columns = ['Strike', 'Price']\ncalls['Type'] = 'call'\nputs['Type'] = 'put'\noptions_data = pd.concat([calls, puts])\n\n# Calculate the variance swap strike\nvariance_swap_strike = calculate_variance_swap_strike(S, r, T, options_data)\nprint(f\"Variance Swap Strike: {variance_swap_strike:.4f}\")\n\n\nVariance Swap Strike: 0.6075",
    "crumbs": [
      "Part V: Alternative Models",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Variance Swaps</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html",
    "href": "Chapter_MonteCarlo.html",
    "title": "20  Monte Carlo Methods",
    "section": "",
    "text": "20.1 Introduction to Monte Carlo\nIn this chapter, we will introduce two principal numerical methods for valuing derivative securities: Monte Carlo and binomial models. We will consider two applications: valuing European options in the presence of stochastic volatility with Monte Carlo and valuing American options via binomial models. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.\nAccording to our risk-neutral pricing Equation 7.29, the value of a security paying an amount \\(x\\) at date \\(T\\) is \\[\n\\mathrm{e}^{-rT}\\\\E^R[x]\\;.\n\\qquad(20.1)\\]\nTo estimate this by Monte-Carlo means to simulate a sample of values for the random variable \\(x\\) and to estimate the expectation by averaging the sample values.1. Of course, for this to work, the sample must be generated from a population having a distribution consistent with the risk-neutral probabilities.\nThe simplest example is valuing a European option under the Black-Scholes assumptions. Of course, for calls and puts, this is redundant, because we already have the Black-Scholes formulas. Nevertheless, we will describe how to do this for the sake of introducing the Monte Carlo method. In the case of a call option, the random variable \\(x\\) in Equation 20.1 is \\(\\max(0,S_T-K)\\). To simulate a sample of values for this random variable, we need to simulate the terminal stock price \\(S_T\\). This is easy to do, because, under the Black-Scholes assumptions, the logarithm of \\(S_T\\) is normally distributed under the risk-neutral probability with mean \\(\\log S_0+\\mathrm{n}u T\\) and variance \\(\\sigma^2T\\), where \\(\\mathrm{n}u=r-q-\\sigma^2/2\\). Thus, we can simulate values for \\(\\log S_T\\) as \\(\\log S_0+\\mathrm{n}u T + \\sigma\\sqrt{T}z\\), where \\(z\\) is a standard normal. We can average the simulated values of \\(\\max(0,S_T-K)\\), or whatever the payoff of the derivative is, and then discount at the risk-free rate to compute the date–0 value of the derivative. This means that we generate some number \\(M\\) of standard normals \\(z_i\\) and estimate the option value as \\(\\mathrm{e}^{-rT}\\bar{x}\\), where \\(\\bar{x}\\) is the mean of \\[x_i = \\max\\left(0,\\mathrm{e}^{\\log S_0+\\mathrm{n}u T + \\sigma\\sqrt{T}z_i}-K\\right)\\; .\\] To value options that are path-dependent we need to simulate the path of the underlying asset price. Path-dependent options are discussed in Chaps.~\\(\\ref{c_exotics}\\) and~\\(\\ref{c_montecarlo}\\).\nThere are two main drawbacks to Monte-Carlo methods. First, it is difficult (though not impossible) to value early-exercise features.2 To value early exercise, we need to know the value at each date if not exercised, to compare to the intrinsic value. One could consider performing a simulation at each date to calculate the value if not exercised, but this value depends on the option to exercise early at later dates, which cannot be calculated without knowing the value of being able to exercise early at even later dates, etc. In contrast, the binomial model (and finite difference models discussed in Chapter 22) can easily handle early exercise but cannot easily handle path dependencies.\nThe second drawback of Monte Carlo methods is that they can be quite inefficient in terms of computation time (though, as will be explained later, they may be faster than alternative methods for derivatives written on multiple assets). As in statistics, the standard error of the estimate depends on the sample size. Specifically, we observed in Section 16.1 that, given a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of size \\(M\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\), the best estimate of \\(\\mu\\) is the sample mean \\(\\bar{x}\\), and the standard error of \\(\\bar{x}\\) (which means the standard deviation of \\(\\bar{x}\\) in repeated samples) is best estimated by \\[\n\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^{M} x_i^2-M\\bar{x}^2\\right)}\\;.\n\\qquad(20.2)\\] Recall that \\(\\bar{x}\\) plus or minus 1.96 standard errors is a 95% confidence interval for \\(\\mu\\) when the \\(x_i\\) are normally distributed. In the context of European option valuation, the expression Equation 20.2 gives the standard error of the estimated option value at maturity, and multiplication of Equation 20.2 by \\(\\mathrm{e}^{-rT}\\) gives the standard error of the estimated date–0 option value.\nTo obtain an estimate with an acceptably small standard error may require a large sample size and hence a relatively large amount of computation time. The complexities of Monte Carlo methods arise from trying to reduce the required sample size. Later, we will describe two such methods (antithetic variates and control variates). For those who want to engage in a more detailed study of Monte Carlo methods, the book of Glasserman (Glasserman 2004) is highly recommended. J\"ackel (Jäckel 2002) is useful for more advanced readers, and Clewlow and Strickland (Clewlow and Strickland 1998) and Brandimarte (Brandimarte 2002) are useful references that include computer code.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "href": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "title": "20  Monte Carlo Methods",
    "section": "",
    "text": "Monte Carlo Valuation of a European Call\nWe will illustrate Monte Carlo by valuing a European call under the Black-Scholes assumptions. We will also estimate the delta by each of the methods described in Section 20.3 and~\\(\\ref{s_montecarlogreeks2}\\). Of course, we know the call value and its delta from the Black-Scholes formulas, and they can be used to evaluate the accuracy of the Monte Carlo estimates. We use the code in Chapter ?sec-c:continuoustime. In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process. Therefore we set \\(m=1\\). However, we use a large number of paths, \\(n=10000\\) to get a large sample of terminal stock prices.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 10000\n#number of divisions\nm = 1\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Dividend Yield\nq=0.0\n# Delta t\ndt = T/m\n# Drift\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2020\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before, this code generates two samples \\(St\\), which adds the simulated standard (zero mean) normal random variable, and \\(St1\\) which subtracts the simulated (zero mean) standard normal random variable. Each sample produces and estimate for the Black-Scholes European call option.\n\n\nCode\ncc=np.maximum(St[m,:]-K,0)\ncp = np.mean(cc) * np.exp(-r * T)\ncc1=np.maximum(St1[m,:]-K,0)*np.exp(-r * T)\ncp1= np.mean(np.maximum(St1[m,:]-K,0)) * np.exp(-r * T)\n\nprint('The first sample gives an estimated call price=',cp)\nprint('The second sample gives an estimated call price=',cp1)\nbsc = (cp+cp1)/2\nprint('The average of the two estimates=',bsc)\n\n\nThe first sample gives an estimated call price= 4.791646287615179\nThe second sample gives an estimated call price= 4.687624646438364\nThe average of the two estimates= 4.739635467026771\n\n\nThe true call price is given by\n\n\nCode\nfrom scipy.stats import norm\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n    \n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n        \n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n    if call:\n        return np.exp(- q *T) * S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1) \n    else:\n        return -np.exp(-q * T) * S0 * norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc=blackscholes(S0, K, r, q, sig, T, call = True)\nprint('The black scholes fromula=',truebsc)\n\n\nThe black scholes fromula= 4.759422392871532\n\n\nNotice that even with 10000 data points for each sample the individual estimates are not very accurate compared to the exact Black Scoles price. This is a well known problem that is difficult to estimate the mean, even with a lot of data and is a drawback to Monte Carlo as discussed earlier. However, the average of the two prices is sgnificantly more accurate. This is an example of an antithetic variable which is discussed later. One simple intution is the two samples yield negatively correlated errors; if the plus sample is two high, then the minus sample will be too low. Combined, the simulation error will cancel out. Another intution is that each individual sample has a wrong estimate of the mean. However, the combined sample has zero mean by construction. Therefore combining the samples give the right mean of the simulated standard normal random variable. Nevertheless, there is still sampling error since we are estimating the mean of the discounted call payoffs, not the mean of the standard normal. This method and other methods to reduce sampling error are discussed next.\n## Antithetic Variates in Monte Carlo\nIn this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method. These are two of the simplest methods. They are used extensively, but there are other important methods that are also widely used. J\"ackel (Jäckel 2002) and Glasserman (Glasserman 2004) provide a wealth of information on this topic.\nThe Monte Carlo method estimates the mean \\(\\mu\\) of a random variable \\(x\\) as the sample average of randomly generated values of \\(x\\). An antithetic variate is a random variable \\(y\\) with the same mean as \\(x\\) and a negative correlation with \\(x\\). It follows that the random variable \\(z=(x+y)/2\\) will have the same mean as \\(x\\) and a lower variance. Therefore the sample mean of \\(M\\) simulations of \\(z\\) will be an unbiased estimate of \\(\\mu\\) and will have a lower standard error than the sample mean of \\(M\\) simulations of \\(x\\). Thus, we should obtain a more efficient estimator of \\(\\mu\\) by simulating \\(z\\) instead of \\(x\\).3\nIn the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent). The terminal value of the derivative written on the first asset serves as \\(x\\) and the terminal value of the derivative written on the second serves as \\(y\\). Because both asset prices have the same distribution, the means of \\(x\\) and \\(y\\) will be the same, and the discounted mean is the date–0 value of the derivative.\nConsider for example a non-path-dependent option in a world with constant volatility. In each simulation \\(i\\) (\\(i=1,\\ldots,M\\)), we would generate a standard normal \\(Z_i\\) and compute \\[\\begin{align*}\n\\log S_i_T &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z_i\\; ,\\\\\n\\log S_i'_T &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T - \\sigma\\sqrt{T}Z_i\\;.\n\\end{align*}\\] Given the first terminal price, the value of the derivative will be some number \\(x_i\\) and given the second it will be some number \\(y_i\\). The date–0 value of the derivative is estimated as \\[\\mathrm{e}^{-rT}\\frac{1}{M}\\sum_{i=1}^M\\frac{x_i+y_i}{2}\\; .\\]",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "href": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "title": "20  Monte Carlo Methods",
    "section": "20.2 Control Variates in Monte Carlo",
    "text": "20.2 Control Variates in Monte Carlo\n Another approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable. We can explain this in terms of linear regression in statistics. Suppose we have a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of a variable \\(x\\) with unknown mean \\(\\mu\\), and suppose we have a corresponding sample \\(\\{y_1,\\ldots,y_M\\}\\) of another variable \\(y\\) with known mean \\(\\phi\\). Then an efficient estimate of \\(\\mu\\) is \\(\\hat{\\mu} = \\bar{x} + \\hat{\\beta} (\\phi-\\bar{y})\\), where \\(\\bar{x}\\) and \\(\\bar{y}\\) denote the sample means of \\(x\\) and \\(y\\), and where \\(\\hat{\\beta}\\) is the coefficient of \\(y\\) in the linear regression of \\(x\\) on \\(y\\) (i.e., the estimate of \\(\\beta\\) in the linear model \\(x = \\alpha +\\beta y + \\varepsilon\\)). The standard Monte Carlo method, which we have described thus far, simply estimates the mean of \\(x\\) as \\(\\bar{x}\\). The control variate method adjusts the estimate by adding \\(\\hat{\\beta} (\\phi-\\bar{y})\\). To understand this correction, assume for example that the true \\(\\beta\\) is positive. If the random sample is such that \\(\\bar{y}&lt;\\phi\\), then it must be that small values of \\(y\\) were over-represented in the sample. Since \\(x\\) and \\(y\\) tend to move up and down together (this is the meaning of a positive \\(\\beta\\)) it is likely that small values of \\(x\\) were also over-represented in the sample. Therefore, one should adjust the sample mean of \\(x\\) upwards in order to estimate \\(\\mu\\). The best adjustment will take into account the extent to which small values of \\(y\\) were over-represented (i.e., the difference between \\(\\bar{y}\\) and \\(\\phi\\)) and the strength of the relation between \\(x\\) and \\(y\\) (which the estimate \\(\\hat{\\beta}\\) represents). The efficient correction of this sort is also the simplest: just add \\(\\hat{\\beta}(\\phi-\\bar{y})\\) to \\(\\bar{x}\\). In practice, the estimation of \\(\\hat{\\beta}\\) may be omitted and one may simply take \\(\\hat{\\beta}=1\\), if the relationship between \\(x\\) and \\(y\\) can be assumed to be one-for-one. If \\(\\beta\\) is to be estimated, the estimate (by ordinary least squares) is \\[\\hat{\\beta} = \\frac{\\sum_{i=1}^M x_iy_i - M\\bar{x}\\bar{y}}{\\sum_{i=1}^M y_i^2 - M\\bar{y}^2}\\; .\\] In general, the correction term \\(\\hat{\\beta}(\\phi-\\bar{y})\\) will have a nonzero mean, which introduces a bias in the estimate of \\(\\mu\\). To eliminate the bias, one can compute \\(\\hat{\\beta}\\) from a pre-sample of \\(\\{x,y\\}\\) values.\nAs an example of a control variate, in our simulation code to estimate the Black Scholes price for a call option we can use the stock price itself. The known stock price is the inout price \\(S0\\). The simulation also produces an estimate for the stock price as the dicsounted expected value of the terminal stock price \\(\\hat{S}=\\sum_{i=1}^{n} e^{- r T } St(m,i)\\) where \\(St(m,i)\\) is the \\(i\\)th simulated stock price at time \\(T\\). Theoretically these should be the same umber, but due to error they typically wil not be the same.\n\n\nCode\nSS=np.mean(St[m,:])*np.exp(-r*T)\nprint('The Estimated Stock Price for the first sample is =', SS)\nprint('The actual stock price should be=', S0)\nprint('The error is =', S0-SS)\n\n\nThe Estimated Stock Price for the first sample is = 42.05899999577932\nThe actual stock price should be= 42\nThe error is = -0.058999995779316805\n\n\nThe error is \\(S0-\\hat{S}\\) which corresponds to \\(\\phi-y\\) above. We then compute \\(\\hat{\\beta}\\) and comute the improved estimate \\[ \\text{new estimate}= \\text{original estimate} +\\hat{\\beta}(S0-\\hat{S}) \\] In the code below we do this procedure for both samples and average the updates.\n\n\nCode\nhatbeta= np.cov(St[m,:],cc)[0,1]/np.cov(St[m,],cc)[1,1]\nhatbeta1=np.cov(St1[m,:],cc1)[0,1]/np.cov(St1[m,],cc1)[1,1]\ncorrection =hatbeta*(S0-SS)\nupdate=cp + correction\nprint('hatbeta=',hatbeta)\nprint('The original estimate for the call price from the first sample=',cp)\nprint('The original estimate for the call price from the second sample=',cp1)\nprint('The updated estimate from the first sample is=',update)\nSS1=np.mean(St1[m,:])*np.exp(-r*T)\nupdate1=cp1+hatbeta1*(S0-SS1)\nprint('The updated estimate from the second sample is=',update1)\nprint('The average of the updated estimates =',(update+update1)/2)\n\n\nhatbeta= 1.1541186403411716\nThe original estimate for the call price from the first sample= 4.791646287615179\nThe original estimate for the call price from the second sample= 4.687624646438364\nThe updated estimate from the first sample is= 4.723553292706219\nThe updated estimate from the second sample is= 4.780385012196883\nThe average of the updated estimates = 4.751969152451551\n\n\nWe can compare this to the exact Black Scholes formula from before.\n\n\nCode\nprint('The exact Black Scholes Price is=', truebsc)\n\n\nThe exact Black Scholes Price is= 4.759422392871532\n\n\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[A_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\; .\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[K^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\; .\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\\\E^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\; .\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[x = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\; .\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[y =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\; .\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 14.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "title": "20  Monte Carlo Methods",
    "section": "20.3 Monte Carlo Greeks I: Difference Ratios",
    "text": "20.3 Monte Carlo Greeks I: Difference Ratios\nGreeks can be calculated by Monte Carlo by running the valuation program twice and computing a difference ratio, for example \\((C_u-C_d)/(S_u-S_d)\\) to estimate a delta. However, to minimize the error, and minimize the number of computations required, one should use the same set of random draws to estimate the derivative value for different values of the parameter. For path-independent options (e.g., European puts and calls) under the Black-Scholes assumptions, we only need to generate \\(S_T\\) and then we can compute \\(S_u_T\\) as \\([S_u_0/S_0] \\times S_T\\) and \\(S_d_T\\) as \\([S_u_0/S_0] \\times S_T\\). We can estimate standard errors for the Greeks in the same way that we estimate the standard error of the derivative value.\nActually, there is often a better method available that is just as simple. This is called pathwise calculation. We will explain this in the next section. Here we will describe how to estimate the delta and gamma of a derivative as sample means of difference ratios.\nConsider initial prices for the underlying \\(S_u&gt;S&gt;S_d\\). Denote the underlying price at the option maturity in a given simulation by \\(S_u_T\\) when the initial underlying price is \\(S_u\\), by \\(S_T\\) when the initial underlying price is \\(S\\), and by \\(S_d_T\\) when the initial underlying price is \\(S_d\\). Under the Black-Scholes assumptions, the logarithm of the stock price at date \\(T\\) starting from the three initial prices \\(S_d\\), \\(S\\) and \\(S_u\\) is \\[\\begin{align*}\n\\log S_d_T &= \\log S_d + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_T &= \\log S + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_u _T &= \\log S_u + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\;,\n\\end{align*}\\] so \\[\\log S_d_T = \\log S_T + \\log S_d - \\log S\\Longrightarrow S_d_T = \\left(\\frac{S_d}{S}\\right) S_T\\; ,\\] and \\[\\log S_u_T = \\log S_T + \\log S_u - \\log S \\Longrightarrow S_u_T = \\left(\\frac{S_u}{S}\\right) S_T\\; .\\] Therefore, under the Black-Scholes assumptions, we only need to simulate \\(S_T\\) and then perform the multiplications indicated above to obtain \\(S_d_T\\) and \\(S_u_T\\).\nConsider a particular simulation and let \\(C_d_T\\) denote the value of the derivative at maturity when the initial asset price is \\(S_d\\), let \\(C_T\\) denote the value of the derivative at maturity when the initial asset price is \\(S\\), and let \\(C_u_T\\) denote the value of the derivative at maturity when the initial asset price is \\(S_u\\). For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of \\(S_T\\) as just described. However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).\nThe estimates \\(C_d\\), \\(C\\) and \\(C_u\\) of the date–0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the \\(C_d_T\\), \\(C_T\\) and \\(C_u_T\\). One way to estimate the delta is \\((C_u-C_d)/(S_u-S_d)\\). This is a difference of discounted sample means, multiplied by the reciprocal of \\(S_u-S_d\\). Equivalently, it is the sample mean of the differences \\(C_u_T-C_d_T\\), multiplied by \\(\\mathrm{e}^{-rT}/(S_u-S_d)\\). As a sample mean, its standard error can be estimated as described in Chapter 17. The standard error is \\[\\frac{\\mathrm{e}^{-rT}}{S_u-S_d}\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^M \\left[C_{ui}_T-C_{di}_T\\right]^2 - M\\left[\\overline{C_{u}_T}-\\overline{C_{d}_T}\\right]^2\\right)}\\; ,\\] where the overline denotes the sample mean and where \\(C_{ui}_T\\) [respectively, \\(C_{di}_T\\)] denotes the value of the derivative at maturity in simulation \\(i\\) when the initial asset price is \\(S_u\\) [respectively, \\(S_d\\)].\nThe corresponding Monte Carlo estimate of the gamma is also a sample mean. Simple algebra shows that Equation 21.15 is equivalent to \\[\n\\Gamma = \\frac{2}{(S_u-S)(S_u-S_d)}C_u - \\frac{2}{(S_u-S)(S-S_d)}C +\\frac{2}{(S-S_d)(S_u-S_d)}C_d\\;.\n\\qquad(20.3)\\]\nNormally one would take \\(S_u=(1+\\alpha)S\\) and \\(S_d = (1-\\alpha)S\\) for some \\(\\alpha\\) (e.g., \\(\\alpha=0.01\\)). In this case Equation 20.3 simplifies to \\[\n\\Gamma = \\frac{C_u - 2C + C_d}{\\alpha^2S^2}\\;,\n\\qquad(20.4)\\]\nand the standard error of the gamma is\n\\[\\begin{multline*}\\frac{\\mathrm{e}^{-rT}}{\\alpha^2S^2}\\sqrt{\\frac{1}{M(M-1)}}\\\\\n\\times \\sqrt{\\sum_{i=1}^M \\left[C_{ui}_T-2C_i_T+C_{di}_T\\right]^2 -M\\left[\\overline{C_{u}_T}-2\\overline{C_T}+\\overline{C_{d}_T}\\right]^2}\\; .\n\\end{multline*}\\]",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "title": "20  Monte Carlo Methods",
    "section": "20.4 Monte Carlo Greeks II: Pathwise Estimates",
    "text": "20.4 Monte Carlo Greeks II: Pathwise Estimates\nWe will examine the bias in the Monte Carlo delta estimate discussed in the preceding section and explain pathwise estimation of Greeks. By biased, we mean that the expected value of an estimate is different from the true value. It is important to recognize that if a Monte Carlo estimate is biased, then, even if a large number of simulations is used and the standard error is nearly zero, the answer provided by the Monte Carlo method will be incorrect. For simplicity, consider a European call under the Black-Scholes assumptions.\nThe delta estimate we have considered is the discounted sample mean of \\[\n\\frac{C_u_T - C_d_T}{S_u-S_d}\\;. \\qquad(20.5)\\]\nThis ratio takes on one of three values, depending on \\(S_T\\):\n\nIf \\(S_u_T \\leq K\\) then the option is out of the money in both the up and down cases; i.e., \\[C_u_T = C_d_T = 0\\; ,\\] so the ratio Equation 20.5 is zero.\nIf \\(S_d_T \\geq K\\) then the option is in the money in both the up and down cases; i.e., \\[\\begin{align*} C_u_T &= S_u_T - K =\\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d_T &= S_d_T - K = \\left(\\frac{S_d}{S}\\right)S_T - K\\;,\n\\end{align*}\\] so the ratio Equation 20.5 equals \\(S_T/S\\).\nIf \\(S_u_T &gt; K &gt; S_d_T\\), then the option is in the money in only the up case; i.e., \\[\\begin{align*}\nC_u_T &= S_u_T - K = \\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d_T &= 0\\;,\n\\end{align*}\\] so the ratio Equation 20.5 equals \\[\\frac{\\left(\\frac{S_u}{S}\\right)S_T - K}{S_u-S_d} &lt; \\frac{S_T}{S}\\; .\\]\n\nThe bias is induced by the third case above. We can see this as follows. We are trying to estimate \\[\n\\frac{\\partial }{\\partial S} \\mathrm{e}^{-rT}\\\\E^R \\big[\\max(0,S_T-K)\\big] = \\mathrm{e}^{-rT}\\\\E^R  \\left[ \\frac{\\partial }{\\partial S} \\max(0,S_T-K)\\right]\\;.\n\\qquad(20.6)\\]\nThe delta estimate \\((C_u-C_d)/(S_u-S_d)\\) replaces the mean \\(\\\\E^R\\) with the sample mean and replaces \\[\n\\frac{\\partial }{\\partial S} \\max(0,S_T-K)\n\\qquad(20.7)\\]\nwith the ratio Equation 20.5. The derivative Equation 20.7 takes on two possible values, depending on \\(S_T\\)—we can ignore the case \\(S_T=K\\) because it occurs with zero probability:\n\nIf \\(S_T &lt; K\\), then \\(\\max(0,S_T-K) = 0\\) and the derivative is zero.\nIf \\(S_T&gt;K\\), then \\(\\max(0,S_T-K) = S_T-K\\) and the derivative equals \\[\\frac{\\partial S_T}{\\partial S}=\\mathrm{e}^{(r-q-\\sigma^2/2)T + \\sigma B_T} = \\frac{S_T}{S}\\; .\\]\n\nTherefore, the true delta—the expectation Equation 20.6—equals4 \\[\n\\mathrm{e}^{-rT}\\\\E^R\\left[\\frac{S_T}{S} x\\right]\\;,\n\\qquad(20.8)\\]\nwhere \\(x\\) is the random variable defined as \\[\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] On the other hand, our analysis of the ratio Equation 20.5 shows that the expected value of the delta estimate \\((C_u-C_d)/(S_u-S_d)\\) is \\[\n\\mathrm{e}^{-rT}\\\\E^R\\left[\\frac{S_T}{S} y\\right] + \\mathrm{e}^{-rT}\\\\E^R\\left[\\frac{S_uS_T-SK}{S(S_u-S_d)}z\\right]\\;,\n\\qquad(20.9)\\]\nwhere \\[\\begin{align*}\ny &=  \\begin{cases} 1 & \\text{if} S_d_T&gt;K\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\\] and \\[\\begin{align*}\nz &=  \\begin{cases} 1 & \\text{if} S_u_T&gt;K&gt;S_d_T\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\\] To contrast Equation 20.8 and Equation 20.9, note that if \\(y=1\\) then \\(x=1\\), so the term \\(\\\\E^R\\left[\\frac{S_T}{S} y\\right]\\) in Equation 20.9 is part of Equation 20.8. However, there are two partially offsetting errors in Equation 20.9: \\(z\\) sometimes equals one when \\(x\\) is zero, and when both \\(z\\) and \\(x\\) are one, then the factor multiplying \\(z\\) is smaller than the factor multiplying \\(x\\). In any case, the expected value Equation 20.9 is not the same as the true delta Equation 20.8. As noted before, this implies that the delta estimate will be incorrect even if its standard error is zero. The bias can be made as small as one wishes by taking the magnitude \\(S_u-S_d\\) of the perturbation to be small, but taking the perturbation to be very small will introduce unacceptable roundoff error.\nThe obvious way to estimate the delta in this situation is simply to compute the discounted sample average of \\([S_T/S]x\\). This is called a pathwise estimate of the delta, because it only uses the sample paths of \\(S_t\\) rather than considering up and down perturbations. This method is due to Broadie and Glasserman (Broadie and Glasserman 1996). Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.\nTo compute pathwise estimates in other models and for other Greeks, we need the Greek to be an expectation as on the right-hand side of Equation 20.6. Additional examples can be found in Glasserman (Glasserman 2004) and J\"ackel (Jäckel 2002).",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "href": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "title": "20  Monte Carlo Methods",
    "section": "20.5 Monte Carlo Models for Path-Dependent Options",
    "text": "20.5 Monte Carlo Models for Path-Dependent Options\nA derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length \\(\\Delta t = T/N\\) for some integer \\(N\\). Under the risk-neutral probability, the logarithm of the stock price changes over such a time period by \\[\n\\Delta \\log S = \\nu\\,\\Delta t + \\sigma\\sqrt{\\Delta t}\\,z\\;,\n\\qquad(20.10)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\) and \\(z\\) is a standard normal. Given that there are \\(N\\) time periods of length \\(\\Delta t\\), we need to generate \\(N\\) standard normals to generate a stock price path. If we generate \\(M\\) paths to obtain a sample of \\(M\\) option values, then we will need to generate \\(MN\\) standard normals.\nConsider for example a floating-strike lookback call. The formula for this option given in Section 15.2 assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing \\(\\Delta t\\) to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting \\(N\\) to be the number of weeks before the option matures.\nFor most path dependent options, a possible starting point is to generate an array of \\(n\\) paths but since we want the entire path we choose the number of time steps that is appropriate for our application. We can use the same code as in Section @#sec-s:mc_europeans if we are working in a Black Scholes setting.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq=0.0\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Delta t\ndt = T/m\n# Drift\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before this code generates two samples the original and the antithetic. The output is an array of \\(n\\) sample paths with \\(m\\) time steps. The sample can also be used to find the value of a floating strike lookback call.\n\n\nCode\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\nStmin=St[m:]-np.minimum(np.min(St,axis=0),S0)\nSt1min=St1[m:]-np.minimum(np.min(St1,axis=0),S0)\nfloatlkbk=np.exp(-r*T)*np.mean(Stmin)\nfloatlkbk1=np.exp(-r*T)*np.mean(St1min)\n\nprint('The first estimate is=',floatlkbk)\nprint('The second estimate is=',floatlkbk1)\nprint('The average estimate is=',(floatlkbk+floatlkbk1)/2)\nprint('The exact formula is=',floating_strike_call(S0, r, sigma, 0, T, S0))\n\n\nThe first estimate is= 5.45244209168367\nThe second estimate is= 5.468030697490039\nThe average estimate is= 5.460236394586854\nThe exact formula is= 7.231056939691567\n\n\nTo value the fixed strike lookback call option with time \\(T\\) payoff \\(\\max(\\max_{0\\le t \\le T} S_t.0)\\), we simply add the following\n\n\nCode\nStmax=np.maximum(np.max(St,axis=0)-K,0)\nSt1max=np.maximum(np.max(St1,axis=0)-K,0)\nlookbck = np.exp(-r*T) *np.mean(Stmax)\nlookbck1=np.exp(-r * T)*np.mean(St1max)\nprint('The first estimate is=',lookbck)\nprint('The second estimate is=',lookbck1)\nprint('The average estimate is=', (lookbck + lookbck1)/2)\n\n\nThe first estimate is= 7.716467940991822\nThe second estimate is= 7.769558237964809\nThe average estimate is= 7.743013089478316\n\n\nAsian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks.\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[\nA_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\;.\n\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[\nK^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\;.\n\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\n\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\\\E^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\;.\n\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[\nx = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;.\n\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[\ny =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\;.\n\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 14.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.\nAgain we can get a sample of payoffs using our stock price samples.\n\n\nCode\naverage = np.mean(St,axis=0)\naverage1 = np.mean(St1,axis=0)\ndpayoff=np.exp(-r*T)*np.mean(np.maximum(average-K,0))\ndpayoff1=np.exp(-r*T)*np.mean(np.maximum(average1-K,0))\nprint('The first estimate is=',dpayoff)\nprint('The second estimate is=',dpayoff1)\nprint('The average of the estimates=',(dpayoff+dpayoff1)/2)\n\n\nThe first estimate is= 3.231154315344899\nThe second estimate is= 3.296876297130776\nThe average of the estimates= 3.2640153062378374\n\n\nWe now construct a control variate, the geometric asian option which has a known formula for its value.\n\n\nCode\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\ngeom=np.exp((np.mean(np.log(St),axis=0)))\ngeom1=np.exp((np.mean(np.log(St1),axis=0)))\ngeomavgpo=np.maximum(geom-K,0)\ngeomavg1po=np.maximum(geom1-K,0)\nvalue=np.mean(geomavgpo)*np.exp(-r*T)\nvalue1=np.mean(geomavg1po)*np.exp(-r*T)\ntga=discrete_geom_average_price_call(S0, K, r, sigma, q, T, m)\nerror =tga-value\nerror1=tga-value1\nprint('The estimate from the first sample=',value)\nprint('The estimate from the second sample=',value1)\nprint('The average of the two estimates is=',(value+value1)/2)\nprint('The value from the exact formula=',tga)\nprint('The error in the first estimate=',error)\nprint('The error in the second estimate=',error1)\n\n\nThe estimate from the first sample= 3.172076049997697\nThe estimate from the second sample= 3.236566795172543\nThe average of the two estimates is= 3.20432142258512\nThe value from the exact formula= 2.6835589764289125\nThe error in the first estimate= -0.4885170735687847\nThe error in the second estimate= -0.5530078187436307\n\n\nNext we estimate the beta. As discussed before, we could simply set beta=1. Alternatively, if we estimate beta from the simulated sample, then our update could be biased. Instead we compute an independent sample from which we estimate beta. We then estimate the updated estimate for both samples from the formula \\[\n\\text{new estimate} = \\text{original estimate} + \\beta * \\text{error}\n\\]\n\n\nCode\nincpre = np.zeros(shape = (m + 1, n))\nincpre[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nStpre = np.zeros(shape = (m + 1, n))\nSt1pre=np.zeros(shape = (m + 1, n))\nStpre = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1pre = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\namean=np.mean(Stpre,axis=0)\namean1=np.mean(St1pre,axis=0)\napo = np.maximum(amean-K,0)\na1po=np.maximum(amean1-K,0)\ngmean=np.exp(np.mean(np.log(St),axis=0))\ng1mean=np.exp(np.mean(np.log(St1),axis=0))\ngpo=np.maximum(gmean-K,0)\ng1po=np.maximum(g1mean-K,0)\nbeta=np.cov(gpo,apo)[0,1]/np.cov(gpo,apo)[1,1]\nbeta1=np.cov(g1po,a1po)[0,1]/np.cov(g1po,a1po)[1,1]\nupdate=dpayoff +beta*error\nupdate1=dpayoff1+beta1*error1\n\nprint('The updated estimate for the first sample=',update)\nprint('The updated value for the second sample=',update1)\nprint('The average of the updated values is=',(update +update1)/2)\n\n\nThe updated estimate for the first sample= 2.7518403446698483\nThe updated value for the second sample= 2.7538925235582683\nThe average of the updated values is= 2.7528664341140585",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "href": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "title": "20  Monte Carlo Methods",
    "section": "20.6 Monte Carlo Valuation of Basket and Spread Options",
    "text": "20.6 Monte Carlo Valuation of Basket and Spread Options\n In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. As noted in ?sec-s:baskets, there are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.\nThe difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral probability). In an \\(N\\)–period model, the binomial model produces \\(N+1\\) values for the terminal price of each underlying asset. Letting \\(k\\) denote the number of underlying assets, this produces \\((N+1)^k\\) combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces \\(M\\) combinations of terminal prices, where \\(M\\) is the number of simulations. Each combination is given the same weight (\\(1/M\\)) when estimating the expected value.\nWith a single underlying asset, the binomial model is more efficient, as discussed in Section 21.1, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the \\((N+1)^k\\) combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.\nTo implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. As observed in ?sec-s:stochasticvolatility, we can simulate the changes in two Brownian motions \\(B_1\\) and \\(B_2\\) that have correlation \\(\\rho\\) by generating two independent standard normals \\(Z_1\\) and \\(Z_2\\) and defining \\[\n\\Delta B_1 = \\sqrt{\\Delta t}\\,Z_1\\;, \\qquad \\text{and} \\qquad \\Delta B_2 = \\sqrt{\\Delta t}\\,Z\\; ,\n\\] where \\(Z\\) is defined as \\[\nZ = \\rho Z_1 + \\sqrt{1-\\rho^2}\\,Z_2\\;.\n\\] The random variable \\(Z\\) is also a standard normal, and the correlation between \\(Z_1\\) and \\(Z\\) is \\(\\rho\\).\n\n\nCode\n# Simulate 2 Geometric Brownian Motions\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq1=0.0\nq2=0\n# Volatility\nsig1 = 0.2\nsig2=.3\n# correlation\nrho=0.5\n# Initial Stock Price\nS0 = 42\nV0 = 50\n# Maturity\nT = 0.5\n\n# Delta t\ndt = T/m\n# Drift\ndrift1 = (r-q1-0.5*sig1**2)\ndrift2 = (r-q2-0.5*sig2**2)\n# Volatility\nvol = np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\ninc1 = np.zeros(shape = (m + 1, n))\ninc1[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nincr = np.zeros(shape = (m + 1, n))\nincr = rho*inc + np.sqrt(1-rho**2)*inc1\n\n\nThus, we can simulate the changes in the logarithms of two correlated asset prices as \\[\\begin{align*}\n\\Delta \\log S_1 &= \\nu_1\\Delta t + \\sigma_1\\sqrt{\\Delta t}Z_1 \\; ,\\\\\n\\Delta \\log S_2 &= \\nu_2\\Delta t + \\sigma_2\\rho\\sqrt{\\Delta t}Z_1 + \\sigma_2\\sqrt{1-\\rho^2}\\sqrt{\\Delta t}Z_2\\;,\n\\end{align*}\\] where \\(\\nu_i = r-q_1-\\sigma_i^2/2\\) and the \\(Z_i\\) are independent standard normals.\n\n\nCode\nSt1 = np.zeros(shape = (m + 1, n))\nSt2 = np.zeros(shape = (m + 1, n))\nSt1 = S0 * np.exp(sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2 = V0 * np.exp(sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nWe can also construct antithetic variables.\n\n\nCode\nSt1a = np.zeros(shape = (m + 1, n))\nSt2a = np.zeros(shape = (m + 1, n))\nSt1a = S0 * np.exp(-sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2a = V0 * np.exp(-sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nGiven this sample, we can estimate the value of a best of 2 option with payoff \\(\\max(S_{1T},S_{2T})\\).\n\n\nCode\npayoff = np.maximum(St1[m,:],St2[m,:])\npayoffa = np.maximum(St1a[m,:],St2a[m,:])\nvalue= np.exp(-r*T)*np.mean(payoff)\nvaluea= np.exp(-r*T)*np.mean(payoffa)\n\nprint('The first estmate is =',value)\nprint('The second estimate is =',valuea)\nprint('The avergae of the estimates is=',(value+valuea)/2)\n\n\nThe first estmate is = 50.11374784508302\nThe second estimate is = 51.46596027225067\nThe avergae of the estimates is= 50.78985405866685\n\n\nTo generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as\n\\[\n\\Delta \\log S_1 = \\nu_1\\Delta t + a_{11}\\sqrt{\\Delta t}Z_1 + a_{12}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(20.11)\\]\n\\[\n\\Delta \\log S_2 = \\nu_2\\Delta t + a_{21}\\sqrt{\\Delta t}Z_1 + a_{22}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(20.12)\\]\nwhere \\[\\begin{array}{rclcrcl}\na_{11}&=&\\sigma_1\\;, &\\qquad & a_{12}&=&0\\; ,\\\\\na_{21}&=&\\sigma_2\\rho\\;, &\\qquad & a_{22} &= &\\sigma_2\\sqrt{1-\\rho^2}\\;.\n\\end{array}\n\\]\nThese are not the only possible choices for the constants \\(a_{ij}\\). Given that \\(Z_1\\) and \\(Z_2\\) are independent standard normals, the conditions the \\(a_{ij}\\) must satisfy in order to match the variances \\(\\sigma_i^2\\Delta t\\) and correlation \\(\\rho\\) of the changes in the logarithms are\n\\[\na_{11}^2+a_{12}^2 =\\sigma_1^2\\;,\n\\qquad(20.13)\\]\n\\[\na_{21}^2+a_{22}^2 =\\sigma_2^2\\;,\n\\qquad(20.14)\\]\n\\[\na_{11}a_{21}+a_{12}a_{22} = \\sigma_1\\sigma_2\\rho\\;.\n\\qquad(20.15)\\]\nThese three equations in the four coefficients \\(a_{ij}\\) leave one degree of freedom. We choose to take \\(a_{12}=0\\) and then solve for the other three.\nIn matrix notation, the system Equation 20.13 - Equation 20.15 plus the condition \\(a_{12}=0\\) can be written as the equation \\[\n\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}^\\top = \\begin{pmatrix}\\sigma_1^2 & \\rho\\sigma_1\\sigma_2 \\\\\\rho\\sigma_1\\sigma_2 & \\sigma_2^2\\end{pmatrix}\\; ,\n\\] where \\(^\\top\\) denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the \\(a_{ij}\\) so that the lower triangular matrix \\[\nA \\equiv \\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\n\\] satisfies \\[\nAA^\\top = \\text{covariance matrix}\n\\] is called the the Cholesky decomposition of the covariance matrix. Given any number \\(L\\) of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the \\(L\\times L\\) covariance matrix always exists. An algorithm for computing the Cholesky decomposition in numpy is np.linalg.cholesky.\nWe can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.5 If there were some path dependency in the option value, we would simulate the paths of the asset prices as in Equation 20.11 - Equation 20.12. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date \\(T\\), as in Section 20.1. The value of a basket call option at its maturity \\(T\\) is \\[\n\\max\\left(0,\\;\\sum_{i=1}^L w_iS_i_T-K\\right)\\; ,\n\\] where \\(L\\) is the number of assets in the basket (portfolio) and \\(w_i\\) is the weight of the \\(i\\)–th asset in the basket. The logarithm of the \\(i\\)–th asset price at maturity is simulated as \\[\n\\log S_i_T = \\log S_i_0 +\\nu_iT + \\sqrt{T} \\sum_{j=1}^L a_{ij}Z_j\\; ,\n\\] where the \\(Z_j\\) are independent standard normals. Given the simulated values of the \\(\\log S_i_T\\), the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.\nFor our two asset example we compute the value of a call opttion on an equally weighted porfotlio.\n\n\nCode\nw=0.5\nK=45\nbasketpo=np.maximum(w*St1[m,:]+(1-w)*St2[m,:]-K,0)\nbasketpoa=np.maximum(w*St1a[m,:]+(1-w)*St2a[m,:]-K,0)\nestimate=np.exp(-r*T)*np.mean(basketpo)\nestimatea=np.exp(-r*T)*np.mean(basketpoa)\nprint('The first estimate is =',estimate)\nprint('The second estimate is =',estimatea)\nprint('The average of the estimates=',(estimate+estimatea)/2)\n\n\nThe first estimate is = 4.4030641748675095\nThe second estimate is = 4.945665333101932\nThe average of the estimates= 4.674364753984721\n\n\nBelow is a three asset basket option whihc uses the numpy cholesky decomposition. In contrast to the above routine, this routine is does not have the option to generate the entire path, although this can be easily modeified.\n\n\nCode\nimport numpy as np\n#risk free rate\nr=0.1\n# number of assets\nk=3\n\n# number of paths\nn=100000\n# Horizon\nT=0.5\n\n# Initial price\n\nS0=[42,50,45]\n\n# Basket Weights\nw=[.25,.5,.25]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n# drift of log returns\n\ndrift= r*np.ones(k) -0.5*np.dot(S@S,np.ones(k))\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n# covariance matrix\n\nV = S@rho@S\n\n# generate uniform n*k normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc1=np.transpose(np.random.normal(loc = 0, scale = np.sqrt(T),size = (n,k)))\n \n\n\n# create correlated random variables\nZ=np.linalg.cholesky(V)\nincr=np.dot(Z,inc1)\n\nprint('The sample correlation matrix =',np.corrcoef(incr))\nprint('The input correlation matrix =',rho)\n\n\n\n\nSt = S0 * np.exp(drift *T + np.transpose(incr))\n#antithetic sample\nSt1 = S0 * np.exp( drift * T - np.transpose(incr))\n\nestimate=np.mean(St,axis=0)*np.exp(-r*T)\nestimate1=np.mean(St1,axis=0)*np.exp(-r*T)\nprint('The average discounted stock price averaged over both samples=',(estimate+estimate1)/2)\nprint('The initial Srock Price input =',S0)\n\nbasketpo=np.maximum(w@np.transpose(St)-K,0)\nbasketpo1=np.maximum(w@np.transpose(St1)-K,0)\nvalue=np.mean(basketpo)*np.exp(-r*T)\nvalue1=np.mean(basketpo1)*np.exp(-r*T)\nprint('The first sample estimate of the basket option value=',value)\nprint('The second sample estimate of the basket option value=',value1)\nprint('The average estimate of the basket option value=',(value+value1)/2)\n\n\nThe sample correlation matrix = [[1.         0.50356746 0.30497838]\n [0.50356746 1.         0.20383175]\n [0.30497838 0.20383175 1.        ]]\nThe input correlation matrix = [[1.  0.5 0.3]\n [0.5 1.  0.2]\n [0.3 0.2 1. ]]\nThe average discounted stock price averaged over both samples= [42.00560021 50.00484037 45.01680115]\nThe initial Srock Price input = [42, 50, 45]\nThe first sample estimate of the basket option value= 5.335894164783821\nThe second sample estimate of the basket option value= 5.289353051200051\nThe average estimate of the basket option value= 5.312623607991936\n\n\nWe can generate the entire path of multiple assets to value, for example, lookback options on a basket. The code below values the same European basket option as above only it calculates \\(m=2\\) time steps; a lookback can be created by changing the payoffs and increasing \\(m\\).\n\n\nCode\nimport numpy as np\n#number of time steps\nm=2\n# number of assets\nk=3\n# number of sample paths\nn=100000\n\n#risk free rate\nr=0.1\n\n\n\n# Horizon\nT=0.5\n# delta t\ndt=T/m\n# Initial price\n\nS0=[42,50,45]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n\n# covariance matrix\n\nV = S@rho@S\n\n# drift of log returns\ndrift= np.array(r*np.ones(k) -0.5*np.dot(S@S,np.ones(k)))*dt\n\n# times vector\nt=np.array(range(1,m + 1,1))\n\n\ndriftv = np.transpose(np.kron(drift,t).reshape(3,m))\n\n# generate uniform n(paths)*k(assets)*m(time steps) normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc=np.random.normal(loc = 0, scale = np.sqrt(dt),size = (n,k,m))\n\n#create correlated random increments\nZ=np.linalg.cholesky(V)\n# numpy matmul assumes last two define matrix multiplication\nincr=np.matmul(Z,inc)\n\n\n\nSSt=S0*np.exp(driftv)\n\n# generate returns along path and antithetic path\n# first e^{cumsum(increments)} gives e^sigma B_t for different t\n\nStb = np.exp(np.cumsum(incr[:,:,],axis=2))\nStb1 = np.exp(-np.cumsum(incr[:,:,],axis=2))\n\n\n#Multiply by S0 e^drift for each t\nSt=np.multiply(Stb,np.transpose(SSt))\nSt1=np.multiply(Stb1,np.transpose(SSt))\n\n#Last date returns\nStm=St[:,:,m-1]\nStm1=St1[:,:,m-1]\n\n#define payoff\n# Basket Weights\nw=[.25,.5,.25]\n\n\npayoff= np.maximum(np.matmul(Stm,np.transpose(w))-K,0)\npayoff1= np.maximum(np.matmul(Stm1,np.transpose(w))-K,0)\n\n\nvalue= np.exp(-r*T)*np.mean(payoff)\nvalue1= np.exp(-r*T)*np.mean(payoff1)\nprint('The estimate for the first sample value=',value)\nprint('The estimate for the second sample value=',value1)\nprint('The average estimate for the value=',(value+value1)/2)\n\n\nThe estimate for the first sample value= 5.310173600480473\nThe estimate for the second sample value= 5.287928240443306\nThe average estimate for the value= 5.299050920461889",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#section",
    "href": "Chapter_MonteCarlo.html#section",
    "title": "20  Monte Carlo Methods",
    "section": "",
    "text": "Boyle, P. 1977. “Options: A Monte Carlo Approach.” Journal of Financial Economics 4: 323–38.\n\n\nBrandimarte, P. 2002. Numerical Methods in Finance: A MATLAB-Based Introduction. Wiley, New York.\n\n\nBroadie, M., and P. Glasserman. 1996. “Estimating Security Price Derivatives Using Simulation.” Management Science 42: 269–85.\n\n\n———. 1997. “Pricing American-Style Securities Using Simulation.” Journal of Economic Dynamics and Control 21: 1323–52.\n\n\nClewlow, L., and C. Strickland. 1998. Implementing Derivatives Models. Wiley, New York.\n\n\nGlasserman, P. 2004. Monte Carlo Methods in Financial Engineering. Springer, New York Berlin Heidelberg.\n\n\nJäckel, P. 2002. Monte Carlo Methods in Finance. Wiley, New York.\n\n\nLongstaff, F., and E. Schwartz. 2001. “Valuing American Options by Simulation: A Simple Least-Squares Approach.” Review of Financial Studies 14: 113–47.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#footnotes",
    "href": "Chapter_MonteCarlo.html#footnotes",
    "title": "20  Monte Carlo Methods",
    "section": "",
    "text": "Boyle~(Boyle 1977) introduced Monte-Carlo methods for derivative valuation, including the variance-reduction methods of control variates and antithetic variates to be discussed later↩︎\nMonte-Carlo methods for valuing early exercise include the stochastic mesh method of Broadie and Glasserman (Broadie and Glasserman 1997) and the regression method of Longstaff and Schwartz (Longstaff and Schwartz 2001). Glasserman (Glasserman 2004) provides a good discussion of these methods and the relation between them.↩︎\n The negative correlation between \\(x\\) and \\(y\\) is essential for this method to generate a real gain in efficiency. To generate \\(M\\) simulations of \\(z\\), one must generate \\(M\\) simulations of \\(x\\) and \\(M\\) of \\(y\\), which will generally require about as much computation time as generating \\(2M\\) simulations of \\(x\\). If \\(x\\) and \\(y\\) were independent, the standard error from \\(M\\) simulations of \\(z\\) would be the same as the standard error from \\(2M\\) simulations of \\(x\\), so using the antithetic variate would be no better than just doubling the sample size for \\(x\\).↩︎\nBy changing numeraires, we can show that Equation 20.8 equals \\(\\mathrm{e}^{-qT}\\\\E^V[x] = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)\\), as we know from Chapter 10 is the delta of a European call in the Black-Scholes model (here, as in Chapter 10, \\(V_t=\\mathrm{e}^{qt}S_t\\) denotes the value of the dividend-reinvested portfolio created from the stock).↩︎\nFor a spread option, take \\(L=2\\), \\(w_1=1\\) and \\(w_2=-1\\).↩︎",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html",
    "href": "Chapter_Binomial.html",
    "title": "21  Binomial and Trinomial Models",
    "section": "",
    "text": "21.1 Introduction to Binomial Models\nIn this chapter, we will introduce two principal numerical methods for valuing derivative securities: Monte Carlo and binomial models. We will consider two applications: valuing European options in the presence of stochastic volatility with Monte Carlo and valuing American options via binomial models. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.\nAs in the previous section, we will work with the dynamics of the logarithms of asset prices under the risk-neutral probability. Thus, our starting point is the equation \\[\n\\,\\mathrm{d}\\log S = \\left(r-q-\\frac{\\sigma^2}{2}\\right)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B\\;,\n\\qquad(21.1)\\]\nwhere \\(B\\) represents a Brownian motion under the risk-neutral probability.\nIn the binomial model, we assume that if the stock price is \\(S\\) at the beginning of the period, it will be either \\(uS\\) or \\(dS\\) at the end of the period, where the multiplicative factors \\(u\\) and \\(d\\) are constants to be determined. This means that the rate of return is \\(\\Delta S/S = u\\!-\\!1\\) in the up state and \\(\\Delta S/S = d\\!-\\!1\\) in the down state. There are three parameters to the model: \\(u\\), \\(d\\), and the probability \\(p\\) of the up state (the probability of the down state being necessarily \\(1\\!-\\!p\\)). The following illustrates a three-period model.\nA tree constructed like this is recombining in the sense that the stock price after an up-down sequence is the same as after a down-up sequence. This is very important for reducing the computation time. For example, the number of nodes at the final date is \\(N+1\\) in a recombining tree, where \\(N\\) is the number of periods, but it is \\(2^N\\) for a non-recombining (sometimes called bushy) tree. Hence, the computation time will increase linearly with \\(N\\) for a recombining tree but exponentially with \\(N\\) for a non-recombining tree. Unfortunately, this computational savings is generally not possible for path-dependent options, because the number of distinct paths through a tree (whether recombining or not) is again \\(2^N\\).\nThe value of a European derivative is of course the discounted expectation of its value at maturity, discounting at the risk-free rate and taking the expectation under the risk-neutral probability. The binomial tree allows us to approximate the expectation very easily. We simply sum over the nodes of the tree at the option maturity and weight each node by its binomial probability. In an \\(N\\)-period model, the probability of the top node is \\(p^N\\), since the stock must go up each time to reach the top node. There are \\(N\\) paths reaching the second node from the top (since the period of the single down move could be any one of the \\(N\\) periods) and each such path has probability \\(p^{N-1}(1-p)\\); therefore, the probability of reaching the second node from the top is \\(Np^{N-1}(1-p)\\). More generally, the probability of going up \\(i\\) times and down \\(N-i\\) times is \\[\\frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\\; ,\\] where as usual \\(x!\\) denotes \\(x\\) factorial. Therefore, the expectation, for a European call option, is the following sum over the \\(N+1\\) nodes at date \\(N\\) (starting with \\(i=0\\) up moves and ending with \\(i=N\\) up moves): \\[\n\\sum_{i=0}^N \\frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\\max(u^id^{N-i}S-K,0)\\;.\n\\qquad(21.2)\\]\nMultiplying the expectation by \\(\\mathrm{e}^{-rT}\\) yields the option value.\nIt is worthwhile to emphasize the close connection between this method and the Monte-Carlo method discussed in the previous section. In the Monte-Carlo method for valuing a European call option, we generate \\(M\\) random values for \\(S_T\\) and estimate the expectation \\(\\\\E^R[\\max(0,S_T-K)]\\) by averaging the \\(M\\) values. This amounts to approximating the distribution of \\(S_T\\) by an \\(M\\)–point distribution, each point being assigned equal probability. In the binomial method, we choose a particular set of points for \\(S_T\\) and assign the probabilities specified above in order to approximate the distribution of \\(S_T\\). Both the Monte-Carlo and the binomial approximations are known to converge to the continuous-time distribution of \\(S_T\\) as the number of points increases. However, by specifically choosing the points and their probabilities, the binomial method allows us to use a much smaller number of points to obtain the same accuracy; i.e., for a given desired accuracy, we can use many fewer periods \\(N\\) in the binomial model than we would need simulations \\(M\\) in the Monte-Carlo method. Thus, the binomial method will be much faster. Furthermore, as we will discuss in the next section, the binomial method is much better for pricing American options. On the other hand, as mentioned in the previous section, to value a path-dependent option in an \\(N\\)–period binomial tree would require the analysis of \\(2^N\\) separate paths, so Monte Carlo may be faster for path-dependent options. Finally, as we will discuss in Section 21.6, Monte Carlo may be faster for options on multiple assets.\nThere is an important alternative method for calculating the sum Equation 21.2, which is usually called backward induction. We will describe it here and implement it in the next section to value American options. We begin at the last date, where there are \\(N+1\\) nodes. We calculate the option value at each of these nodes, storing the value at the bottom node as \\(C_0\\), the value at the next node up as \\(C(1)\\), etc. This is illustrated in the diagram on the next page. Then we step back to the penultimate date. At each node at this date, we calculate the option value as the discounted expectation of its value at the last date. From each node, there are two nodes that can be reached at the next date, corresponding to a down move or an up move. So, the option value is calculated as \\[\nC = \\mathrm{e}^{-r\\Delta t}p\\,C_{\\text{up}} + \\mathrm{e}^{-r\\Delta t}(1-p)C_{\\text{down}}\\;.\n\\qquad(21.3)\\]\nIn terms of the vector notation shown in the figure below, the down move from node \\(i\\) is also node \\(i\\) and the up move is \\(i+1\\). So, we write over the elements of the \\(C\\) vector as \\[\nC(i) = \\mathrm{e}^{-r\\Delta t}p\\,C(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)C(i)\\;.\n\\qquad(21.4)\\]\nDiscounting back through the tree like this, we reach date \\(0\\) and return the option value as \\(C_0\\). The virtue of this procedure is that it calculates a value for the option at each node in the tree, the value being the discounted expectation of the subsequent values attained by the option. This approach is essential for assessing the value of early exercise.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:binomialparameters",
    "href": "Chapter_Binomial.html#sec-s:binomialparameters",
    "title": "21  Binomial and Trinomial Models",
    "section": "21.2 Binomial Parameters",
    "text": "21.2 Binomial Parameters\nSeveral different ways have been proposed for matching the binomial model to the continuous-time model. Consider an \\(N\\)–period binomial model for a time period of \\(T\\) years. This means that the length of each period is \\(\\Delta t = T/N\\). In the continuous-time model, over a discrete time period \\(\\Delta t\\), we have \\[\\Delta \\log S =\\mathrm{n}u\\,\\Delta t + \\sigma\\,\\Delta B\\; ,\\] where \\(\\mathrm{n}u = r-q-\\sigma^2/2\\) and \\(B\\) is a Brownian motion under the risk-neutral probability. The mean and variance, under the risk-neutral probability, of \\(\\Delta \\log S\\) in the continuous-time model are \\[\\begin{align*}\n\\\\E^R[\\Delta \\log S] &= \\mathrm{n}u\\,\\Delta t\\; ,\\\\\n\\mathrm{var}^R[\\Delta \\log S]&=\\sigma^2\\Delta t\\; ,\n\\end{align*}\\] so \\[\\begin{align*}\n\\frac{\\\\E^R[\\Delta \\log S]}{\\Delta t} &= \\mathrm{n}u\\; ,\\\\\n\\frac{\\mathrm{var}^R[\\Delta \\log S]}{\\Delta t}&=\\sigma^2\\;.\n\\end{align*}\\] In the binomial model, we have \\[\\begin{align*}\n\\frac{\\\\E^R\\big[\\Delta \\log S\\big]}{\\Delta t} &=\\frac{p\\,\\log u+(1-p)\\log d}{\\Delta t}\\; ,\\\\\n\\frac{\\mathrm{var}^R\\big[\\Delta \\log S\\big] }{\\Delta t}&=\\frac{p\\,(1-p)(\\log u-\\log d)^2}{\\Delta t}\\;.\n\\end{align*}\\] In order for the binomial model to converge in the appropriate sense to the continuous-time model as the number of periods \\(N \\rightarrow \\infty\\) keeping the total amount of time \\(T\\) fixed (equivalently, as \\(\\Delta t \\rightarrow 0\\)), it is sufficient that \\[\\begin{align*}\n\\frac{p\\log u+(1-p)\\log d}{\\Delta t} &\\rightarrow \\mathrm{n}u\\; ,\\\\\n\\frac{p\\,(1-p)(\\log u-\\log d)^2}{\\Delta t} &\\rightarrow \\sigma^2\\;.\n\\end{align*}\\]\nThe most popular model is probably that proposed by Cox, Ross and Rubinstein (Cox, Ross, and Rubinstein 1979), who set \\(d=1/u\\) and\n\\[\nu = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}\\;,\n\\qquad(21.5)\\]\n\\[\np = \\frac{\\mathrm{e}^{(r-q)\\Delta t}-d}{u-d}\\;.\n\\qquad(21.6)\\]\nAnother well-known model is that of Jarrow and Rudd (Jarrow and Rudd 1983), who take \\(p=1/2\\) and\n\\[\nu = \\exp\\left(\\left((r-q-\\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma\\sqrt{\\Delta t}\\right)\\;,\n\\qquad(21.7)\\]\n\\[\nd = \\exp\\left(\\left((r-q-\\frac{1}{2}\\sigma^2\\right)\\Delta t - \\sigma\\sqrt{\\Delta t}\\right)\\;.\n\\qquad(21.8)\\]\nYet another method is proposed by Leisen and Reimer (Leisen and Reimer 1996), and Jackson and Staunton (Jackson and Staunton 2001) show that it is more efficient for approximating the Black-Scholes value of a European option than are the Cox-Ross-Rubinstein and Jarrow-Rudd trees.\nFor illustration, the Cox-Ross-Rubinstein tree will be implemented below.\n\nBinomial Valuation of European Options\nThe binomial model for path-independent European options can be implemented as follows. We will use the Cox-Ross-Rubinstein parameters. We first define the binomial parameters and some useful constants, denoting the probability \\(p\\,\\) of an up move as \\(pu\\) and the probability \\(1-p\\) of a down move as \\(pd\\). The routine below uses the combinatoric function comb(N,i) to compute the term \\(\\frac{N !}{i! (N-i)!}\\).\n\n\nCode\nimport numpy as np\nfrom scipy.special import comb\n# Binomial Model for European Option\n\nr = .1 # interest rate\nsig = .2 # volatility\nT = .5 # Expiration\nq = div = 0.0 # Dividend\nS0 = 42 # initial stock price\nK = 40 # strike price\ntimes =100 # Number of steps\ndt = T/times\ndelt = np.exp(-div*dt)\na = np.exp(r*dt)*delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu  = (a-d)/(u-d)\npd = 1-pu\nvec = np.arange(times + 1)\nvec1 = np.array([1] * (times + 1))\nS = np.array([0] * (times + 1))\nS = S0*u**(2*vec-times*vec1)\nC =  np.maximum(S-K*vec1,0*vec1)\nCC =  comb((times)*vec1,(times)*vec1-vec)*pu**(vec)*pd**(times*vec1-vec)*C\nCall = sum(CC)*np.exp(-r*T)\nprint('The Value of the European Call is=',Call)\n\n\nThe Value of the European Call is= 4.761818357763364\n\n\nThe Black Scholes value is shown below.\n\n\nCode\nfrom scipy import stats\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n\n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n\n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n#     norm = sp.stats.norm\n    norm = stats.norm\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return -np.exp(-q*T)*S0 * norm.cdf(-d1,0,1) +K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc = blackscholes(S0,K,r, div, sig,T)\nprint('The exact Black Scholes Price is=', truebsc)\n\n\nThe exact Black Scholes Price is= 4.759422392871532\n\n\nAn alternative way to calculate te value of the call is to use a loop. This takes longer to run but is perhaps easier to understand.\n\n\nCode\nfor i in range(times+1):\n    S[i] = S0*u ** (2*i-times)\n    C[i] =  max(S[i]-K,0)\n\n    CC[i] =  comb((times),(i))*pu ** (i)*pd ** (times-i)*C[i]\n\n\n\nCall = sum(CC)*np.exp(-r*T)\nprint('The Value of the European Call is=',Call)\n\n\nThe Value of the European Call is= 4.761818357763364",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#binomial-models-for-american-options",
    "href": "Chapter_Binomial.html#binomial-models-for-american-options",
    "title": "21  Binomial and Trinomial Models",
    "section": "21.3 Binomial Models for American Options",
    "text": "21.3 Binomial Models for American Options\nEarly exercise features are very simple to handle in a binomial framework. One only has to use the backward induction approach and check the optimality of early exercise at each node. Exercise is optimal when the intrinsic value of the option exceeds the discounted expected value of the option contingent on not exercising. When we back up in the tree, we check whether exercise is optimal, and, when it is, we replace the discounted expected value with the intrinsic value.\nEarly exercise is more important for puts than for calls (as discussed in ?sec-s:fundamentalconcepts, an American call on a dividend-reinvested stock should not be exercised early) so we will change our symbol for the option value from \\(C\\) to \\(P\\). For a put option, we would calculate the value at each node at the end of the tree as described in the previous section: \\[\nP(i) = \\max\\left(0,K-u^{i}d^{N-i}S\\right)\\;,\n\\qquad(21.9)\\]\nfor \\(i=0,\\ldots,N\\). For a European put, we would also back up in the tree in accord with Equation 21.4: \\[\nP(i) = \\mathrm{e}^{-r\\Delta t}p\\,P(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)P(i)\\;.\n\\qquad(21.10)\\]\nTo accommodate early exercise, we simply need to assign to \\(P(i)\\) the larger of this value and the value of early exercise. At node \\(i\\) at date \\(n\\) the stock price is \\(u^{i}d^{n-i}S\\) and the intrinsic value of a put option is \\(\\max(0,K-u^{i}d^{n-i}S)\\). Therefore we replace Equation 21.10 with \\[\nP(i) = \\max\\big(K-u^{i}d^{n-i}S, \\;\\mathrm{e}^{-r\\Delta t}p\\,P(i+1) + \\mathrm{e}^{-r\\Delta t}(1-p)P(i)\\big)\\;.\n\\qquad(21.11)\\]\nThis will be explained in more detail later.\n\nBinomial Valuation of American Options\nWe will consider an American put. It may also be optimal to exercise an American call early, if there is a positive dividend yield, and the same procedure can be used for American calls. We begin as in the previous subsection by defining the binomial parameters, some useful constants, and the stock price at the last date. We also record the value of the lowest stock price where we exercise at the last date \\(ex[n]\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n# dividend yield\ny = 0\n\n# calculate parameters for binomial model\ndt = T/n\ndelt = np.exp(-y*dt)\na = np.exp(r*dt) * delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu = (a-d)/(u-d)\npd = 1-pu\n# Build vector of ending values\n# and prices for which put is exercised\nex = np.zeros(n+1)\nS = np.zeros(n+1)\nAP = np.zeros(n+1)\n\nfor j in range(n+1):\n    S[j] = S0*u**(2*j-n)\n    AP[j] = max(K-S[j],0)\n    if AP[j]&gt;0:\n        ex[n] = S[j]\n\n\nNow we do the backward induction. Note that a period is the time period between successive dates. In a one-period model, there are two dates (the beginning and end) and in general there are \\(N+1\\) dates in an \\(N\\)–period model. We index the dates as \\(i=0,\\ldots,N\\). At each date we start by defining the stock price at the bottom node. At date \\(i\\) there have been \\(i\\) past periods, so the bottom node corresponds to \\(i\\) down moves. The put value at each node is computed as the larger of the discounted expected value and the value of immediate exercise (the intrinsic value). Having already dealt with the bottom node (\\(j=0\\)) we loop over the nodes \\(j=1,\\ldots,i\\) at each date \\(i\\), increasing the stock price by a factor of \\(u^2\\) each time. When we have backed up to date \\(0\\), we return the put value \\(AP_0\\), the value at the bottom node, which is the only node at date \\(0\\).\n\n\nCode\nfor i in range(n):\n    S = np.zeros(n-i)\n    P = np.zeros(n-i)\n    PP = np.zeros(n-i)\n    for j in range(n-i):\n        S[j] = S0*u**(2*j-(n-i-1))\n        #\n        # P calculates the value of early exercise\n        P[j] = max(K-S[j],0)\n        #\n        # PP calculates value of waiting using payoffs\n        # from next period\n        PP[j] = (pu*AP[j+1] + pd*AP[j])/a\n        #\n        # AP is the max of ealry exercise and waiting\n        AP[j] = max(P[j],PP[j])\n        #\n        # ex is price where early exercise is optimal\n        if P[j] &gt; PP[j]:\n            ex[n-i] = S[j]\n        if ex[n-i]==0:\n           ex[n-i]=np.nan\n               \n\nprint('The value of the American Put is=',AP[0])\nplt.figure(figsize=(9,6))\nplt.plot(dt*np.arange(n+1),ex)\n\n\nThe value of the American Put is= 1.643396346909605\n\n\n\n\n\n\n\n\n\nThe above code runs slowly due to the loops and looping is inefficient in Python. Below we provide a code which generatee the same answer except one of the loops is replaced by vector calculations. The program creates the stock price for each time in a vector and uses vector comparisons to calcualte the maximum of the early exercise and waiting. To understand the code, it is probably a good idea to print out vec1 and vec to see how the exponents are calulated at each node. This procedure is necessary to speed up the execution since loops are inefficient in Python.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# true drift\nmu = .15\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n# dividend yield\ny = 0\n\ndt = T/n\ndelt = np.exp(-y*dt)\na = np.exp(r*dt) * delt\nu = np.exp(sig*np.sqrt(dt))\nd = 1/u\npu = (a-d)/(u-d)\npd = 1-pu\n# Build vector of ending values\n# and prices for which put is exercised\nvec = np.arange(n+1)\nvec1 = np.ones(n+1)\n\nS = S0 * u**(2*vec - n*vec1)\n\nAP = np.maximum(K-S,0)\n#print(AP)\nex = S[AP&gt;0]\neb = np.zeros(n+1)\neb[n] = ex.max()\n# Backward recursion in the loop\nfor i in range(n):\n    vec = np.arange(n-i)\n    vec1 = np.ones(n-i)\n    # Possible Stock prices at times-i period\n    S = S0 * u**(2*vec-(n-i)*vec1+1)\n#     S = S0 * u**(2*vec-(n-i))\n    # P calculates the value of early exercise\n    P = np.maximum(K*vec1 - S, 0)\n    # PP calculates value of waiting using payoffs from next period\n    PP = (pu*AP[1:(n-i+1)] + pd*AP[0:(n-i)])/a\n    # AP is the max of ealry exercise and waiting\n    AP = np.maximum(P,PP)\n    # ex is prices where early exercise is optimal\n    ex = S[AP-PP&gt;0]\n    # eb calculates the highest price\n    # where exercise is optimal to plot boundary\n    if ex.shape[0]&gt;0:\n        eb[n-i] = ex.max()\n    else:\n        eb[n-i] = np.nan\n\nprint('The value of the American Put is=',AP[0])        \n     # plot the exercise boundary\nplt.figure(figsize=(9,6))\nplt.plot(dt*np.arange(n+1),eb)\n\n\nThe value of the American Put is= 1.643396346909605\n\n\n\n\n\n\n\n\n\nHowever, when we consider binomial models for multiple assets later, we will use the tree proposed by Trigeorgis (Trigeorgis 1991), because it is the simplest to explain in that context. Trigeorgis proposes choosing \\(p\\), \\(u\\) and \\(d\\) so that the mean and variance of \\(\\Delta \\log S\\) in the binomial model match those in the continuous-time model exactly. This means that\n\\[\\begin{align*}\n\\frac{p\\log u+(1-p)\\log d}{\\Delta t} &= \\mathrm{n}u\\; ,\\\\\n\\frac{p(1-p)(\\log u-\\log d)^2}{\\Delta t} &= \\sigma^2\\;.\n\\end{align*}\\]\nThese are two equations in the three unknowns, leaving one degree of freedom, so Trigeorgis takes \\(d=1/u\\), as do Cox, Ross and Rubinstein. As we will show in the next section, taking \\(d=1/u\\) simplifies the calculations of deltas and gammas. Solving these two equations yields^[Notice that if we were to drop the \\((\\Delta t)^2\\) term in Equation 21.12 (which we could do because it becomes increasingly negligible as \\(\\Delta t \\rightarrow 0)\\), then Equation 21.12 would be the same as Equation 21.5. The different choices of \\(p\\) in Equation 21.6 and Equation 21.13 can be understood as follows. Equation 21.6 implies that the expected stock price \\(pS_u + (1-p)S_d\\) equals \\(\\mathrm{e}^{(r-q)\\Delta t}S\\), so we have average growth at the rate \\(r-q\\) as in the continuous-time model. On the other hand, Equation 21.13 implies that the expected log stock price \\(p \\,\\log S_u + (1-p) \\log S_d\\) equals \\(\\log S + \\mathrm{n}u \\Delta t\\), so the expected change in the logarithm is \\(\\mathrm{n}u\\Delta t\\), also as in the continuous-time model. Thus, both match the binomial model to the continuous-time model, the Cox-Ross-Rubinstein method focusing on the expected return (equivalently, the expected change in the price of the underlying) and the Trigeorgis method focusing on the expected continuously-compounded return (the expected change in the logarithm of the price).}\n\\[\n\\log u=\\sqrt{\\sigma^2\\Delta t + \\mathrm{n}u^2(\\Delta t)^2}\\;,\n\\qquad(21.12)\\]\n\\[\np = \\frac{1}{2}+\\frac{\\mathrm{n}u\\Delta t}{2\\log u}\\;.\n\\qquad(21.13)\\]",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:binomial_greeks",
    "href": "Chapter_Binomial.html#sec-s:binomial_greeks",
    "title": "21  Binomial and Trinomial Models",
    "section": "21.4 Binomial Greeks",
    "text": "21.4 Binomial Greeks\nTo estimate Greeks in any valuation model, one can run the valuation program twice, for two different parameter values, and then estimate the Greek as the difference in value divided by the difference in parameters. For example, to estimate vega when the volatility of the underlying is \\(\\sigma\\), we could estimate the derivative value for a volatility of \\(0.99\\sigma\\) and for a volatility of \\(1.01\\sigma\\). Denoting the former derivative value by \\(C_d\\) and the latter by \\(C_u\\), the vega can be estimated by \\[\\frac{C_u-C_d}{1.01\\sigma-0.99\\sigma} = \\frac{C_u-C_d}{0.02\\sigma}\\; .\\] We can in principle obtain a more precise estimate of the derivative by making a smaller change in the parameter (e.g., using \\(0.999\\sigma\\) and \\(1.001\\sigma\\)) but computer round-off errors limit how small a parameter change one should take in practice.\nTo estimate the gamma when the price of the underlying is \\(S\\), we need to estimate the derivative value at two other prices for the underlying, which we will call \\(S_u\\) and \\(S_d\\), with \\(S_u&gt;S&gt;S_d\\). As just explained, the estimate of the delta (which we continue to denote by \\(\\delta\\)) would be \\[\n\\delta = \\frac{C_u-C_d}{S_u-S_d}\\;,\n\\qquad(21.14)\\]\nwhere \\(C_u\\) denotes the derivative value when the underlying is equal to \\(S_u\\) and \\(C_d\\) denotes the derivative value when the underlying is equal to \\(S_d\\). Letting \\(C\\) denote the derivative value when the underlying is equal to \\(S\\), two other obvious estimates of the delta are \\[\\delta_u = \\frac{C_u-C}{S_u-S} \\qquad \\text{and} \\qquad \\delta_d = \\frac{C-C_d}{S-S_d}\\; .\\] The first of these should be understood as an estimate of the delta when the price of the underlying is at the midpoint of \\(S_u\\) and \\(S\\), and the second is an estimate of the delta when the price of the underlying is at the midpoint of \\(S_d\\) and \\(S\\). The distance between these midpoints is \\[\\frac{S_u+S}{2} - \\frac{S_d+S}{2} = \\frac{S_u-S_d}{2}\\; ,\\] so we obtain an estimate of \\(\\Gamma\\) (the derivative of \\(\\delta\\)) as \\[\n\\Gamma = \\frac{\\delta_u-\\delta_d}{(S_u-S_d)/2}\\;.\n\\qquad(21.15)\\]\nIn a binomial model, it is possible to compute the most important Greeks, delta and gamma, more efficiently than by simply running the valuation program several times. Assume we have taken \\(d=1/u\\), so after an up and a down move (or a down and an up move) the stock price returns to its initial value \\(S\\). After fixing the length \\(\\Delta t = T/N\\) of each time period, we redefine \\(N=N+2\\). This results in an \\(N+2\\) period tree covering a time period of length \\(T+2\\Delta t\\). Now consider the tree starting two periods from the initial date. At the middle node shown below, the stock price is \\(udS=S\\). Ignoring the top and bottom nodes and the branches that follow them, the result of adding two periods is that the tree starting from \\(udS\\) is an \\(N\\)–period tree for a time period of length \\(T\\).\n\nHence, the derivative price calculated at the middle node will be the price we are trying to estimate. The derivative price at the top node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(u^2S\\). Similarly, the derivative price at the bottom node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(d^2S\\). Thus, when we back up in the tree to this date, we will have all of the information we need to return an estimate of the derivative value and to return estimates of the delta and gamma, taking \\(S_u=u^2S\\) and \\(S_d = d^2S\\) in Equation 21.14 and Equation 21.15. We are not interested in the tree to the left of what is shown above.\n\nTrinomial Valuation of American Options\nThe trinomial model is a special case of an explicit finite difference method for solving partial differnetial equations studied in Chapter 22; however, it requires no knowledge of partial differential equations. It is similar to a binomial model in that it is a tree. As the name suggests, the trinomial model has three branches up, down, and middle. The middle branch eliminates the up down behavior and can lead to smoother exercise boundaries. We will use the following parameterization: at each node the stock price grows by a factor \\(u=e^{\\sigma \\sqrt{3 \\Delta t}}\\), stays the same, or declines by a factor of \\(d=1/u\\). In this sense, it inherits some of the tractabilty of the Cox, Ross, and Rubenstein model in the sense that the stock price at all nodes can be expressed as the initial stock price times \\(u\\) to a power. The probabilities are given by\n\\[\np_u = \\frac{1}{6} + \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)~~~p_m =2/3~~p_d= \\frac{1}{6} - \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)\n\\]\nWhile there are many choices for the parameterization they are not completely arbitrary. The probability \\(p_m =2/3\\) roughly corresponds to plus or minus one standard devation of a normal distribution and the up and down probabilities capture the tails. There are other parameterizations which can work ust as well.\nConceptually, although there are three states and only two assets and the market is incomplete, the model converges to the Black Scholes model but there is no direct replication strategy. Nevertheless, we are modelling the price in a risk-neutral probability. More importantly it does potentially give a better estimate of derivative prices.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nvec = np.arange(2*n+1)\nvec1 = np.ones(2*n+1)\nS = S0 * u**(vec-n*vec1)\nAP = np.maximum(K-S,0)\nex = S[AP&gt;0]\n# eb is an array to save the boundary price\neb = np.zeros(n+1)\neb[n] = ex.max()\n# Backward recursion in the loop\nfor i in range(n):\n    vec = np.arange(2*(n-i-1)+1)\n    vec1 = np.ones(2*(n-i-1)+1)\n    # Possible Stock prices at times-i period\n    S = S0 * u**(vec-(n-i-1)*vec1)\n    # P calculates the value of early exercise\n    P = np.maximum(K - S, 0)\n    # PP calculates value of waiting using payoffs from next period\n    PP = (pu*AP[2:(2*(n-i)+1)] + pm*AP[1:(2*(n-i))] + pd*AP[0:(2*(n-i)-1)])/a\n    # AP is the max of ealry exercise and waiting\n    AP = np.maximum(P,PP)\n    # ex is prices where early exercise is optimal\n    ex = S[(AP-PP)&gt;0]\n    # eb calculates the highest price\n    # where exercise is optimal to plot boundary\n    if ex.shape[0]&gt;0:\n        eb[n-i] = ex.max()\n    else:\n        eb[n-i] = np.nan\nprint('The American put price is=', AP[0])\n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),eb)\n\n\nThe American put price is= 1.6396310315369165\n\n\n\n\n\n\n\n\n\nWe again provide a program which does the same calculation using loops. It is much slower. We use the same parametrs and preamble as before and just outline the steps. As in the binomial model, we start at the last date and build \\(2n+1\\) terminal stock prices. We also keep track of the highest stock price which we exercise.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nex = np.zeros(n+1)\nS = np.zeros(2*n+1)\nAP = np.zeros(2*n+1)\n\nfor j in range(2*n+1):\n    S[j] = S0*u**(j-n)\n    AP[j] = max(K-S[j],0)\n    if AP[j]&gt;0:\n        ex[n] = S[j]\n\n\nWe then move backwards. There are two loops. The inner loop builds the stock price, the value, and exercise boundary at each time and the outer loop moves backwards in time.\n\n\nCode\nfor i in range(n):\n    S = np.zeros(2*(n-i-1)+1)\n    P = np.zeros(2*(n-i-1)+1)\n    PP = np.zeros(2*(n-i-1)+1)\n    for j in range(2*(n-i-1)+1):\n        S[j] = S0*u**(j-(n-i-1))\n        #\n        # P calculates the value of early exercise\n        P[j] = max(K-S[j],0)\n        #\n        # PP calculates value of waiting using payoffs\n        # from next period\n        PP[j] = (pu*AP[j+2] + pm*AP[j+1] + pd*AP[j])/a\n        #\n        # AP is the max of ealry exercise and waiting\n        AP[j] = max(P[j],PP[j])\n        #\n        # ex is price where early exercise is optimal\n        if P[j] &gt; PP[j]:\n            ex[n-i] = S[j]\n\nprint('The American put price is =', AP[0])            \n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),ex)            \n\n\nThe American put price is = 1.6396310315369165",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#accelerating-binomial-convergence",
    "href": "Chapter_Binomial.html#accelerating-binomial-convergence",
    "title": "21  Binomial and Trinomial Models",
    "section": "21.5 Accelerating Binomial Convergence",
    "text": "21.5 Accelerating Binomial Convergence\nBroadie and Detemple (Broadie and Detemple 1997) show that a modified binomial model is a quite efficient way to value American put options. They modify the binomial model as follows: (i) the Black-Scholes formula is used to value the option at the penultimate date, and (ii) Richardson extrapolation is used to estimate what the option value would be with an infinite number of periods.\nIf an option is not exercised at date \\(N-1\\) in an \\(N\\)–period binomial model (i.e., one date from the end), then, because in the binomial model there are no further opportunities for early exercise, the American option at date \\(N-1\\) is equivalent to a European option at that date. The value of a European option is given by the Black-Scholes formula. Therefore, the estimate of the option value can be improved by replacing\nwith\nat date \\(N-1\\) (of course this also means that we do not need to compute the intrinsic value at date \\(N\\)). This idea can be effectively used in binomial valuation of any option for which there is a closed-form solution (like the Black-Scholes formula) for the value of the corresponding European option in a continuous-time model.\nBroadie and Detemple combine the use of the Black-Scholes formula at date \\(N-1\\) with Richardson extrapolation. Richardson extrapolation is a method that may improve the efficiency of any algorithm by extrapolating to the limit. In the case of a binomial model, the idea is to extrapolate the values calculated for different numbers of periods (different \\(N\\)’s) to try to estimate the value for \\(N=\\infty\\).\nIt is easier to work with convergence to zero than convergence to infinity, so define \\(x=1/N\\). For any value of \\(N\\), the binomial model will return a value, which is an estimate of the option value and which we denote as \\(y=f(x)\\). We would like to know the value at \\(N=\\infty\\), which in this notation is \\(f_0\\). Of course, we cannot calculate \\(f_0\\), because we do not know the function \\(f\\), but we can approximate \\(f\\) by a known function \\(g\\) and then estimate \\(f_0\\) by \\(g_0\\).\nA linear approximation is the simplest and is shown by Broadie and Detemple to be quite effective. For a linear approximation, we would take \\[g(x) = a + bx\\] for parameters \\(a\\) and \\(b\\) to be determined. We can input values \\(N_1\\) and \\(N_2 = 2N_1\\) for the number of periods, run the binomial model for each, set \\(x_i=1/N_i\\), and define \\(y_i=f(x_i)\\) to be the value of the option returned by the binomial model when the number of periods is \\(N_i\\). Then we force \\(g(x_i)=f(x_i)\\) for \\(i=1,2\\) by solving the equations \\[y_i=a + bx_i\\] for \\(a\\) and \\(b\\). Of course, \\(g_0 = a\\), so we will return the constant \\(a\\) as our estimate of \\(f_0\\). This is simpler than it may appear—we put \\[\\begin{equation*}\\begin{array}{rclcl}\ny_1 &= &a + bx_1 &= &a+2bx_2\\;,\\\\\ny_2 &= & &  & a + bx_2 \\;,\n\\end{array}\\end{equation*}\\] and subtracting gives us \\(y_1-y_2 = bx_2\\), which implies from the bottom equation that \\(a = 2y_2-y_1\\). We can think of \\(N_2\\) as being the number of periods we want to use in the binomial model, in which case \\(y_2\\) would be our estimate of the option value. Richardson extrapolation here means also running the binomial model for half as many periods (\\(N_1 = N_2/2\\)) and adding the difference of the estimates \\(y_2-y_1\\) to the estimate \\(y_2\\).\nRichardson extrapolation can be viewed as cancelling the first-order term in the Taylor series expansion of \\(f\\). We have \\[\\begin{align*}\ny_1 = f(x_1) &= f_0 + f'_0x_1 + \\text{higher order terms} \\\\\n& = f_0 + 2f'_0x_2 + \\text{higher order terms}\\;,\\\\\ny_2 = f(x_2) &= f_0 + f'_0x_2 + \\text{higher order terms}\\;.\n\\end{align*}\\] This implies \\[2y_2-y_1 = f_0 + \\text{difference of higher order terms}\\;.\\] Having eliminated the first-order term, one can hope to obtain a closer approximation to \\(f_0\\).\nWe now show hot to implement this in Pyhton.\nFirst we create a binomial valuation program that replaces (i) calculation of the intrinsic value at maturity and (ii) calculation of the value at the penultimate date as the larger of intrinsic value and the discounted value at maturity with (iii) calculation of the value at the penultimate date as the larger of intrinsic value and the Black-Scholes value of a European option with one period to maturity.\n\n\nCode\n# uses blackscholes(S0, K, r, q, sig, T, call = False)\n\ndef binomialbd(n,r,sig,S0,y,K,T):\n\n    # parameters\n    # number of steps\n    #n \n    # interest rate\n    #r \n    # volatility\n    #sig \n    # Initial Stock Price\n    #S0\n    # Strike Price\n        #K \n    # Maturity\n    #T \n    # dividend yield\n    # y\n\n    # calculate parameters for binomial model\n    dt = T/n\n    delt = np.exp(-y*dt)\n    a = np.exp(r*dt) * delt\n    u = np.exp(sig*np.sqrt(dt))\n    d = 1/u\n    pu = (a-d)/(u-d)\n    pd = 1-pu\n    # Build vector of ending values\n    # \n    \n    S = np.zeros(n)\n    AP = np.zeros(n)\n    \n    # Build vector of ending values\n    # at the next to last date (penultimate date)\n    vec = np.arange(n)\n    vec1 = np.ones(n)\n\n    S = S0 * u**(2*vec - (n-1)*vec1)\n\n    AP = np.maximum(K-S,blackscholes(S, K, r, q, sig, dt, call = False))\n    \n    \n    # Backward recursion in the loop\n    for i in range(n-1):\n        vec = np.arange(n-i-1)\n        vec1 = np.ones(n-i-1)\n        # Possible Stock prices at times-i period\n        S = S0 * u**(2*vec-(n-i-1)*vec1+1)\n    \n    #     S = S0 * u**(2*vec-(n-i))\n        # P calculates the value of early exercise\n        P = np.maximum(K*vec1 - S, 0)\n        # PP calculates value of waiting using payoffs from next period\n        PP = (pu*AP[1:(n-i)] + pd*AP[0:(n-i-1)])/a\n        # AP is the max of ealry exercise and waiting\n        AP = np.maximum(P,PP)\n        \n\n    \n    \n    \n    return AP[0]          \n\n\nNow we create a program that uses Richardson extrapolation from a binomial model with N periods and a binomial model with N/2 periods to estimate the value from a binomial model with an infinite number of periods. We use the previous program as our binomial model. The number of time steps \\(n\\) must be even so \\(n/2\\) is an integer. In the following we initally use \\(n=20\\), which is smaller than the the number of steps in the previous binomial american option routines.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n\n\n#inputs\n#number of steps= n; must be an even number\nn=20\n# interest rate\nr=.1\n# volatility\nsig=.2\n# initial stock price\nS0=42\n# dividend yield\ny=0\n# Strike price \nK=42\n# expiration\nT=0.5\n\nif 2*int(n/2) == n:\n\n    y2=binomialbd(n,r,sig,S0,y,K,T)\n    y1=binomialbd(int(n/2),r,sig,S0,y,K,T)\n    \n    extrapolate= 2*y2-y1\n    print('The extrapolated value=',extrapolate)\n\nelse:\n    print('n must be even you big dummy!!')   \n\n\nThe extrapolated value= 1.6495917266169138",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#sec-s:curse",
    "href": "Chapter_Binomial.html#sec-s:curse",
    "title": "21  Binomial and Trinomial Models",
    "section": "21.6 Binomial Valuation of Basket and Spread Options",
    "text": "21.6 Binomial Valuation of Basket and Spread Options\n By combining binomial models, we can value options or other derivatives on multiple assets. We will illustrate for an option on two assets. This is the most important case, and the extension to more than two assets is straightforward.\nConsider two stocks with constant dividend yields \\(q_i\\) and constant volatilities \\(\\sigma_i\\). Suppose the two Brownian motions driving the two stocks have a constant correlation coefficient \\(\\rho\\). We will denote the price of stock \\(i\\) (\\(i=1,2\\)) in the up state in each period by \\(u_iS_i\\) and the price in the down state by \\(d_iS_i\\), where \\(S_i\\) is the price at the beginning of the period, and \\(u_i\\) and \\(d_i\\) are parameters to be specified. In each period, there are four possible combinations of returns on the two stocks: up for both stocks, up for stock 1 and down for stock~2, down for stock 1 and up for stock 2, and down for both stocks. Denote the probabilities of these four combinations by \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\) respectively. Thus, there are eight parameters in the binomial model: the number \\(N\\) of periods (which defines the length of each period as \\(\\Delta t=T/N\\) where \\(T\\) is the option maturity), the up and down parameters \\(u_i\\) and \\(d_i\\) for each stock, and three probabilities (the fourth probability being determined by the condition that the probabilities sum to one).\nGiven the period length \\(\\Delta t\\), we want to choose the up and down parameters and the probabilities to match (or approximately match in an appropriate sense) the means, variances and covariances of the returns \\(\\Delta S_i/S_i\\) or the continuously-compounded returns \\(\\Delta \\log S_i\\). There are two means, two variances and one covariance, so there are five restrictions to be satisfied and seven parameters. As in ?sec-c:introcomputation, it is convenient to take \\(d_i = 1/u_i\\), leaving five restrictions and five free parameters.\nAs discussed in Section 21.2, there are multiple ways to define the binomial model so that it converges to the continuous-time model as the number of periods is increased. As an example, we will describe here the suggestion of Trigeorgis (Trigeorgis 1991), which matches the means, variances and covariance of the continuously-compounded returns. Letting \\(p_i\\) denote the probability of the up state for stock \\(i\\), matching the means and variances implies, as in Section 21.2, \\[\\begin{align*}\n\\log u_i&=\\sqrt{\\sigma_i^2\\Delta t + \\nu_i^2(\\Delta t)^2}\\; ,\\\\\np_i &= \\frac{1}{2}+\\frac{\\nu_i\\Delta t}{2\\log u_i}\\;.\n\\end{align*}\\] where \\(\\nu_i=r-q_i-\\sigma_i^2/2\\). In terms of the notation \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\), the probability of the up state for stock 1 is \\(p_1=p_{uu}+p_{ud}\\) and the probability of the up state for stock 2 is \\(p_2=p_{uu}+p_{du}\\). Therefore,\n\\[\np_{uu}+p_{ud} = \\frac{1}{2}+\\frac{\\nu_1\\Delta t}{2\\log u_1}\\;,\n\\qquad(21.16)\\]\n\\[\np_{uu}+p_{du} = \\frac{1}{2}+\\frac{\\nu_2\\Delta t}{2\\log u_2}\\;.\n\\qquad(21.17)\\]\nIn the continuous time model, over a discrete time period \\(\\Delta t\\), the covariance of \\(\\Delta \\log S_1\\) and \\(\\Delta \\log S_2\\) is \\(\\rho\\sigma_1\\sigma_2\\Delta t\\). In the binomial model, with \\(d_i=1/u_i\\), we have \\[\n\\\\E \\big[\\Delta \\log S_1 \\times \\Delta \\log S_2\\big] = (p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2\\;.\n\\] Given that \\(\\\\E[\\Delta\\log S_i] =\\nu_i\\Delta t\\), this implies a covariance of \\[\n(p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2 - \\nu_1\\nu_2(\\Delta t)^2\\;.\n\\] Matching the covariance in the binomial model to the covariance in the continuous-time model therefore implies \\[\np_{uu}-p_{ud}-p_{du}+p_{dd} =\\frac{\\rho\\sigma_1\\sigma_2\\Delta t + \\nu_1\\nu_2(\\Delta t)^2}{\\log u_1\\log u_2}\\;.\n\\qquad(21.18)\\]\nWe can solve the system Equation 21.16 - Equation 21.18, together with the condition that the probabilities sum to one, to obtain the probabilities \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\). This solution and a Python function for valuing an American spread call option are given later. This function operates much like the binomial valuation of American options described in ?sec-c:introcomputation. The primary difference is that the value of the option at maturity depends on both stock prices, so we have to consider each possible combination of stock prices. In an \\(N\\)–period model, there are \\(N+1\\) nodes at the final date for each of the two stocks, and hence \\((N+1)^2\\) possible combinations of nodes. In fact, at each date \\(n\\) (\\(n=0,\\ldots,N\\)) there are \\((n+1)^2\\) combinations of nodes to be considered.\nThe computation time required for a spread call option is therefore roughly the square of the time required for a standard call.\nLikewise, in an \\(N\\)–period model for a basket option written on three assets, there are \\((n+1)^3\\) combinations of nodes to be considered at date \\(n\\); if there are five assets, there are \\((n+1)^5\\) combinations, etc. Thus, the computation time required increases exponentially with the number of assets. This can be a serious problem. For example, with five assets and \\(N=99\\), we would have \\(100^5\\) (10 billion) combinations. As this suggests, problems with multiple assets quickly become intractable in a binomial framework. This is called the curse of dimensionality.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Binomial.html#section",
    "href": "Chapter_Binomial.html#section",
    "title": "21  Binomial and Trinomial Models",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nConsider an at-the-money European call option on a dividend-reinvested stock with six months to maturity. Take the initial stock price to be $50, the interest rate to be 5% and $=$30%. Compute the value in a binomial model with \\(N=10, 11, \\ldots, 20\\) and plot the values against \\(N\\). Plot your results. Is convergence monotone?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider the same option as in the previous problem. Roughly what value of \\(N\\) is needed to get penny accuracy? (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the two previous problems only instead of the Cox, Ross Rubenstein model, use the Jarrow Rudd model.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nThe early exercise premium is the difference between the value of an American option and the value of a European option with the same parameters. Compute the early exercise premium for an American put and various values for the interest rate, exercise price, and stock parameters. Under what circumstances is the early exercise premium relatively large?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nA shout option is an option where the holder is entitled to shout at any time before the expiration of the option. Upon shouting, the holder receives the immediate exercise value paid at expiration, plus an at the money option with the same expiration as the original option. The payoff to this option if the holder shouts at time \\(\\tau\\) is thus given as \\(\\max(0, S(\\tau)-K, S_T-K )\\) where \\(K\\) is the original strike price.\n1) Show that it is better to shout at some time where \\(S(\\tau)&gt;K\\) than to never shout at all. 2) Modify the code for an American put to find the optimal exercise boundary for a shout option. Hint: The payoffs on the last nodes of the tree are simply \\((S_T - K)^+\\). Then work backwards. The `immediate exercise value’ which is the present value of \\(S_t-K\\), (\\(e^{-r(T-t)} (S_t -K)\\)) plus the Black Scholes value (use a python function) of an at the money option with expiration \\(T-t\\). Choose the maximum of these values at each node. For each time store the highest price at which you exersize. The first node (time 0) then gives the price. Plot the exercise boundary.\n\n\n\n\n\n\n\n\nBroadie, M., and J. Detemple. 1997. “American Option Valuation: New Bounds, Approximations, and a Comparison of Existing Methods.” Review of Financial Studies 9: 1211–50.\n\n\nCox, J., S. Ross, and M. Rubinstein. 1979. “Option Pricing: A Simplified Approach.” Journal of Financial Economics 7: 229–63.\n\n\nJackson, M., and M. Staunton. 2001. Advanced Modelling in Finance Using Excel and VBA. Wiley, New York.\n\n\nJarrow, R., and A. Rudd. 1983. Option Pricing. Dow Jones-Irwin, Homewood, Illinois.\n\n\nLeisen, D. P. J., and M. Reimer. 1996. “Binomial Models for Option Valuation—Examining and Improving Convergence” 3: 319–46.\n\n\nTrigeorgis, A. 1991. “A Log-Transformed Binomial Analysis Method for Valuing Complex Multi-Option Investments.” Journal of Financial and Quantitative Analysis 26: 309–26.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html",
    "href": "Chapter_PDEs.html",
    "title": "22  PDE Methods",
    "section": "",
    "text": "22.1 Fundamental PD\\E\nIn this chapter we will see how to estimate derivative values by numerically solving the partial differential equation (pde) that the derivative value satisfies, using finite difference methods. More advanced discussions of this topic can be found in Wilmott, DeWynne and Howison (Wilmott, Dewynne, and Howison 2000), Wilmott (Wilmott 2000), and Tavella (Tavella 2002), among other places. We will only consider derivatives written on a single underlying asset, but the ideas generalize to derivatives written on multiple underlying assets (e.g., basket and spread options) in much the same way that binomial models can be applied to derivatives on multiple underlying assets. The curse of dimensionality is the same for finite difference methods as for binomial models—the computation time increases exponentially with the number of underlying assets.\nConsider an asset with price \\(S\\) and constant dividend yield \\(q\\).\nSet \\(X=\\log S\\). Then we have \\[\\,\\mathrm{d}X = \\nu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B\\; ,\\] where \\(\\nu =r-q-\\sigma^2/2\\) and \\(B\\) is a Brownian motion under the risk-neutral probability.\nLet \\(T\\) denote the maturity date of a derivative security. At time \\(t\\) (when the remaining time to maturity is \\(T-t\\)), assume the price of the derivative can be represented as \\(C(t,X_t)\\).1\nSince \\(C\\) is a function of \\(t\\) and \\(X\\), Ito’s formula implies\n\\[\n\\,\\mathrm{d}C  = \\frac{\\partial C}{\\partial t}\\,\\mathrm{d}t + \\frac{\\partial C}{\\partial X}\\,\\mathrm{d}X +\\frac{1}{2}\\frac{\\partial^2 C}{\\partial X^2}(\\,\\mathrm{d}X)^2\n\\qquad(22.1)\\]\n\\[\n=\\frac{\\partial C}{\\partial t}\\,\\mathrm{d}t+ \\frac{\\partial C}{\\partial X}\\big(\\nu\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B\\big) + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial X^2}\\sigma^2\\,\\mathrm{d}t\\;.\n\\]\nOn the other hand, under the risk-neutral probability, the instantaneous expected rate of return on the derivative is the risk-free rate, so \\[\\frac{\\,\\mathrm{d}C}{C} =r\\,\\mathrm{d}t + \\text{something}\\,\\mathrm{d}B\\; .\\] where the something is the volatility of the derivative value. We can of course rearrange this as \\[\n\\,\\mathrm{d}C = rC\\,\\mathrm{d}t+\\text{something}\\,\\,C\\,\\mathrm{d}B\\;.\n\\qquad(22.2)\\]\nIn order for both Equation 22.1 and Equation 22.2 to hold, the drifts on both right-hand sides must be equal.2 This implies \\[\nrC = \\frac{\\partial C}{\\partial t}+ \\nu\\frac{\\partial C}{\\partial X}+ \\frac{1}{2}\\sigma^2\\frac{\\partial^2 C}{\\partial X^2}\\;.\n\\qquad(22.3)\\]\nThis equation is the fundamental pde. It is an equation that we want to solve for the function \\(C\\). Every derivative written on \\(S\\) satisfies this same equation. Different derivatives have different values because of boundary conditions. The boundary conditions are the intrinsic value at maturity, optimality conditions for early exercise, barriers and the like.\nTo translate the terms in Equation 22.3 into more familiar ones, notice that, because \\(S=\\mathrm{e}^X\\), we have \\[\n\\frac{\\partial S}{\\partial X}=\\mathrm{e}^X=S\\;.\n\\] Therefore, by the chain rule of calculus, \\[\n\\frac{\\partial C}{\\partial X} = \\frac{\\partial C}{\\partial S}\\frac{\\partial S}{\\partial X} = S\\frac{\\partial C}{\\partial S}\\;.\\] Thus the term \\(\\partial C/\\partial X\\) is the delta of the derivative multiplied by the price of the underlying. Similarly, by ordinary calculus, the term \\(\\partial^2 C/\\partial X^2\\) can be written in terms of the delta and the gamma of the derivative.\nSometimes one writes the derivative value as a function of time to maturity (\\(\\tau = T-t\\)) instead of \\(t\\). The partial derivative of \\(C\\) with respect to \\(\\tau\\) is the negative of the partial derivative with respect to \\(t\\), so the fundamental pde is the same except for a different sign on the first term of the right-hand side of Equation 22.3. Rearranging a little, we have \\[\n\\frac{\\partial C}{\\partial \\tau} = -rC + \\nu\\frac{\\partial C}{\\partial X}+ \\frac{1}{2}\\sigma^2\\frac{\\partial^2 C}{\\partial X^2}\\;.\n\\qquad(22.4)\\]\nIn this form, the pde is similar to important equations in physics, in particular the equation for how heat propagates through a rod over time. In fact, it can be transformed exactly into the heat equation, which is how Black and Scholes originally solved the option valuation problem. The terminal condition for a call option, \\(C = \\max(S-K,0)\\), can be viewed as defining \\(C\\) over the \\(X\\) dimension at \\(\\tau=0\\), just as the temperature along the length of the rod might be specified at an initial date, and as \\(\\tau\\) increases \\(C\\) changes at each point \\(X\\) according to Equation 22.4, which is similar, as noted, to the equation for the change in temperature at a point on the rod as time passes.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#discretizing-the-pde",
    "href": "Chapter_PDEs.html#discretizing-the-pde",
    "title": "22  PDE Methods",
    "section": "22.2 Discretizing the PD\\E",
    "text": "22.2 Discretizing the PD\\E\nTo numerically solve the fundamental pde, we consider a discrete grid on the \\((t,x)\\) space. We label the time points as \\(t_0, t_1, t_2, \\ldots, t_N\\), and the \\(x\\) points as \\(x_{-M}, x_{-M+1}, \\ldots, x_0, x_1, \\ldots, x_M\\), with \\(t_0=0\\), \\(t_N=T\\), and \\(x_0=\\log S_0\\). The equation should hold for \\(-\\infty&lt; x &lt; \\infty\\), but obviously we will have to bound this space, and we have denoted the upper and lower bounds by \\(x_M\\) and \\(x_{-M}\\) here. We take the points to be evenly spaced and set \\(\\Delta t= t_i-t_{i-1}\\) and \\(\\Delta x = x_j -x_{j-1}\\) for any \\(i\\) and \\(j\\).\nFor specificity, we will consider a call option, though the discussion in this section applies to any derivative. We will compute a value for the call at each of the points on the grid. Then we return the value of the call at the point \\((t_0,x_0)\\).\nConsider a point \\((t_i, x_j)\\). We could denote the estimated value of the call at this point by \\(C_{ij}\\) but for now we will just use the symbol \\(C\\). Think of \\(t\\) being on the horizontal axis and \\(x\\) on the vertical axis. There are four points that can be reached from \\((t_i,x_j)\\) by one step (an increase or decrease) in either \\(t\\) or \\(x\\). Let’s denote the estimated call value at \\((t_i, x_j+\\Delta x)\\) as \\(C_{\\text{up}}\\), the value at \\((t_i,x_j-\\Delta x)\\) as \\(C_{\\text{down}}\\), the value at \\((t_i+\\Delta t, x_j)\\) as \\(C_{\\text{right}}\\) and the value at \\((t_i-\\Delta t,x_j)\\) as \\(C_{\\text{left}}\\).\nWe want to force Equation 22.3 to hold on the grid. To estimate \\(\\partial C/\\partial X\\) and \\(\\partial^2 C/\\partial X^2\\), we make exactly the same calculations we made to estimate deltas and gammas in a binomial model. At the point \\((t_i,x_j)\\), we estimate\n\\[\n\\frac{\\partial C}{\\partial X} \\approx \\frac{C_{\\text{up}}-C_{\\text{down}}}{2\\Delta x}\\; .\n\\qquad(22.5)\\]\nThere are two other obvious estimates of this derivative: \\[\n\\frac{C_{\\text{up}}-C}{\\Delta x} \\qquad \\text{and} \\qquad \\frac{C-C_{\\text{down}}}{\\Delta x}\\;.\n\\] The first of these should be understood as an estimate at the midpoint of \\(x_j\\) and \\(x_j+\\Delta x\\) and the second as an estimate at the midpoint of \\(x_j\\) and \\(x_j-\\Delta x\\). The distance between these two midpoints is \\(\\Delta x\\), so the difference in these two estimates of \\(\\partial C/\\partial X\\) divided by \\(\\Delta x\\) is an estimate of the second derivative: \\[\n\\frac{\\partial^2 C}{\\partial X^2} \\approx \\frac{C_{\\text{up}}-2C+C_{\\text{down}}}{(\\Delta x)^2}\\;.\n\\qquad(22.6)\\]\nThe obvious estimate of \\(\\partial C/\\partial t\\), which is analogous to the estimate of \\(\\partial C/\\partial X\\), is \\[\n\\frac{C_{\\text{right}}-C_{\\text{left}}}{2\\Delta t}\\;.\n\\] This is not the estimate we are going to use. The reason is that we want to solve for the call values on the grid in much the same way that we solved the binomial model—starting at the end and working backwards. If we use the above estimate of the time derivative, then at each point \\((t_i,x_j)\\), Equation 22.3 will link the call values at times \\(t_{i-1}\\), \\(t_i\\) and \\(t_{i+1}\\). This would substantially complicate the backing up process. However, in a sense, it is the right estimate, and the Crank-Nicolson method to be discussed below uses a similar idea.\nThe other two choices for estimating \\(\\partial C/\\partial t\\) are analogous to the other two choices for estimating \\(\\partial C/\\partial X\\). We can use either\n\\[\n\\frac{\\partial C}{\\partial t} \\approx \\frac{C-C_{\\text{left}}}{\\Delta t}\\;,\n\\qquad(22.7)\\]\n\\[\n\\] or \\[\n\\frac{\\partial C}{\\partial t} \\approx \\frac{C_{\\text{right}}-C}{\\Delta t}\\;.\n\\qquad(22.8)\\]\nUsing the first is called the explicit method of solving the pde, and using the second is called the implicit method. The reason for these names should become clear below.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#explicit-and-implicit-methods",
    "href": "Chapter_PDEs.html#explicit-and-implicit-methods",
    "title": "22  PDE Methods",
    "section": "22.3 Explicit and Implicit Methods",
    "text": "22.3 Explicit and Implicit Methods\nWe first consider the explicit method. We set the value of the call at the final date \\(t_N\\) and each point \\(x_j\\) to be its intrinsic value, \\(\\max\\left(\\mathrm{e}^{x_j}-K,0\\right)\\). Now consider calculating the value at date \\(t_{N-1}\\) and any point \\(x_j\\). We do this by forcing the approximation to Equation 22.3 based on Equation 22.5–Equation 22.7 to hold at the point \\((t_N,x_j)\\). Using the same notation as before, for \\((t_i,x_j)=(t_N,x_j)\\), implies \\[\nrC = \\frac{C-C_{\\text{left}}}{\\Delta t}+ \\nu\\left(\\frac{C_{\\text{up}}-C_{\\text{down}}}{2\\Delta x}\\right)+ \\frac{1}{2}\\sigma^2\\left(\\frac{C_{\\text{up}}+C_{\\text{down}}-2C}{(\\Delta x)^2}\\right)\\;.\n\\qquad(22.9)\\]\nGiven that \\(t_i\\) is the final date \\(t_N\\), the values \\(C\\), \\(C_{\\text{up}}\\) and \\(C_{\\text{down}}\\) have already been calculated as the intrinsic value of the call at maturity. The only unknown is \\(C_{\\text{left}}\\), which is the value of the call at \\((t_{N-1},x_j)\\). We can solve this explicitly for \\(C_{\\text{left}}\\), whence the name of the algorithm. We do this at each point \\(x_j\\) at date \\(t_{N-1}\\) (except for the top and bottom points, which we will discuss below) and then we follow the same procedure to back up sequentially to the initial date, as in the binomial model.\nEquation 22.9 cannot be used to find \\(C_{\\text{left}}\\) at the bottom point \\(x_{-M}\\), because at this point there is no \\(C_{\\text{down}}\\) at date \\(t_N\\). Similarly, we cannot use it to find \\(C_{\\text{left}}\\) at the top point \\(x_M\\), because at that point there is no \\(C_{\\text{up}}\\). We have to define the values along the top and bottom of the grid in some other fashion. We do this using conditions the derivative is known to satisfy as the stock price approaches \\(+\\infty\\) or 0. For example, for a European call option, we use the conditions that \\(\\partial C/\\partial S \\rightarrow 1\\) as \\(S \\rightarrow \\infty\\) and \\(\\partial C/\\partial S \\rightarrow 0\\) as \\(S \\rightarrow 0\\). We will explain this in more detail in the following section.\nThe solution of Equation 22.9 for \\(C_{\\text{left}}\\) can be written as \\[\nC_{\\text{left}} = \\big(1-r\\Delta t\\big)\\big(p_uC_{\\text{up}}+pC + p_dC_{\\text{down}}\\big)\\;,\n\\qquad(22.10)\\]\nwhere \\[\\begin{align*}\np_u &= \\frac{\\sigma^2\\Delta t+\\nu\\Delta t\\Delta x}{2(1-r\\Delta t)(\\Delta x)^2}\\; ,\\\\\np_d &= \\frac{\\sigma^2\\Delta t-\\nu\\Delta t\\Delta x}{2(1-r\\Delta t)(\\Delta x)^2}\\; ,\\\\\np &= 1- p_u-p_d\\;.\n\\end{align*}\\] This can be interpreted as discounting the probability-weighted values of the call at the next date, where we consider that starting at the grid point \\((t_{i},x_j)\\), the logarithm of the stock price takes three possible values (\\(x_j-\\Delta x\\), \\(x_j\\), and \\(x_j+\\Delta x\\)) at the next date \\(t_{i+1}\\), and where we use \\(1-r\\Delta t\\) as the discount factor. Thus, it is essentially a trinomial model. This relationship was first noted by Brennan and Schwartz (Brennan and Schwartz 1978).\nActually, for this to be a sensible trinomial model, the probabilities \\(p_u\\), \\(p\\) and \\(p_d\\) should be nonnegative. Assuming \\(1-r\\Delta t&gt;0\\), this will be the case if and only if \\[\n\\Delta x \\leq  \\frac{\\sigma^2}{|\\nu|} \\qquad \\text{and} \\qquad \\Delta t \\leq \\frac{(\\Delta x)^2}{\\sigma^2 + r(\\Delta x)^2}\\;.\n\\] The first of these conditions characterizes \\(p_u\\) and \\(p_d\\) being nonnegative. The second is derived from \\(p_u+p_d \\leq 1\\). It is interesting to examine these conditions in terms of the number \\(N\\) of time periods and the number of steps in the \\(x\\) dimension, which is \\(2M\\). To simplify the notation in the following somewhat, denote the distance of the upper \\(x\\) boundary from \\(x_0\\) by \\(D\\) (i.e., \\(D=x_M-x_0\\)). Then \\(\\Delta t=T/N\\) and \\(\\Delta x = D/M\\). The probabilities are nonnegative if and only if \\[\nM \\geq \\frac{|\\nu| D}{\\sigma^2} \\qquad \\text{and} \\qquad N \\geq rT + \\left(\\frac{\\sigma^2T}{D^2}\\right)M^2\\;.\n\\] Consider fixing \\(D\\) and increasing the number of time periods and space steps (i.e., steps along the \\(x\\) dimension). To maintain positive probabilities, the above shows that the number of time periods must increase as the square of the number of space steps: increasing \\(M\\) by a factor of 10 requires increasing \\(N\\) by a factor of 100. The upshot is it can be computationally expensive to use a large number of space steps, if we want to maintain nonnegative probabilities.\nOne can reasonably ask whether this is important, because we can certainly solve Equation 22.9 to estimate the call values even when the probabilities are negative. The answer is that it is important, but for a reason we have not yet discussed. In a numerical algorithm for solving a partial differential equation (or for solving many other types of problems) there are two types of errors: discretization error and roundoff error. If we increase \\(N\\) and \\(M\\) sufficiently, we should reduce the discretization error. However, each calculation on the computer introduces roundoff error. An algorithm is said to be stable if the roundoff errors stay small and bounded as the discretization error is reduced. An unfortunate fact about the explicit method is that it is stable only if the number of time steps increases with the square of the number of space steps. In the absence of this condition, the roundoff errors can accumulate and prevent one from reaching a solution of the desired accuracy.\nThe implicit method is known to be fully stable, so it is to be preferred to the explicit method. We will discuss briefly how to implement this method, before moving in the next section to the Crank-Nicolson method, which is also fully stable and known to be more efficient than the implicit method.\nThe implicit method uses the approximation Equation 22.8 for \\(\\partial C/\\partial t\\). As before, the call values are defined at the final date as the intrinsic value. Backing up a period, consider a grid point \\((t_{N-1},x_j)\\). We will try to estimate the call value at this date by forcing Equation 22.3 to hold at this point. This means \\[\nrC = \\frac{C_{\\text{right}}-C}{\\Delta t}+ \\nu\\left(\\frac{C_{\\text{up}}-C_{\\text{down}}}{2\\Delta x}\\right)+ \\frac{1}{2}\\sigma^2\\left(\\frac{C_{\\text{up}}+C_{\\text{down}}-2C}{(\\Delta x)^2}\\right)\\;.\n\\qquad(22.11)\\]\nWe know \\(C_{\\text{right}}\\), because it is the intrinsic value at \\((t_N,x_j)\\). This equation links three unknowns (\\(C\\), \\(C_{\\text{up}}\\), and \\(C_{\\text{down}}\\)) to the known value \\(C_{\\text{right}}\\). We cannot solve it explicitly for these three unknowns. Instead, we need to solve a system of linear equations to simultaneously solve for all the call values at date \\(t_{N-1}\\). There are \\(2M-1\\) equations of the form Equation 22.11 plus conditions that we will impose at the upper and lower boundaries, and we need to solve these for the \\(2M+1\\) call values. This system of equations has the same form, and is solved in the same way, as the system of equations in the Crank-Nicolson method.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#crank-nicolson",
    "href": "Chapter_PDEs.html#crank-nicolson",
    "title": "22  PDE Methods",
    "section": "22.4 Crank-Nicolson",
    "text": "22.4 Crank-Nicolson\n The estimate Equation 22.8 of \\(\\partial C/\\partial t\\) used in the implicit method is best understood as an estimate of \\(\\partial C/\\partial t\\) at the midpoint of \\((t_i,x_j)\\) and \\((t_{i+1},x_j)\\), i.e., at \\((t_i+\\Delta t/2,x_j)\\). This is the basic idea of the Crank-Nicolson method. With this method, we continue to estimate the call values at the grid points, but we do so by forcing Equation 22.3 to hold at midpoints of this type. To do this, we also need estimates of \\(C\\), \\(\\partial C/\\partial X\\) and \\(\\partial^2 C/\\partial X^2\\) at the midpoints, but these are easy to obtain.\nLet’s modify the previous notation somewhat, writing \\(C'\\) for \\(C_{\\text{right}}\\) and \\(C'_{\\text{up}}\\) and \\(C'_{\\text{down}}\\) for the values to the right and one step up and down, i.e., at the grid points \\((t_i+\\Delta t,x_i+\\Delta x)\\) and \\((t_i+\\Delta t,x_i-\\Delta x)\\) respectively. The obvious estimate of the call value at the midpoint \\((t_i+\\Delta t/2,x_j)\\) is the average of \\(C\\) and \\(C'\\), so set \\[\nC^{\\text{mid}} = \\frac{C+C'}{2}\\;.\n\\] Analogously, define \\[\nC^{\\text{mid}}_{\\text{up}} = \\frac{C_{\\text{up}}+C'_{\\text{up}}}{2}\\;, \\qquad \\text{and} \\qquad\nC^{\\text{mid}}_{\\text{down}} = \\frac{C_{\\text{down}}+C'_{\\text{down}}}{2}\\;.\n\\qquad(22.12)\\]\nThe formulas Equation 22.12 give us estimates of the call value at the midpoints one space step up and one space step down from \\(x_j\\)—i.e., at \\((t_i+\\Delta t/2,x_{j+1})\\) and \\((t_i+\\Delta t/2,x_{j-1})\\). We can now estimate \\(\\partial C/\\partial X\\) and \\(\\partial^2 C/\\partial X^2\\) at the midpoint \\((t_i+\\Delta t/2,x_j)\\) exactly as before: \\[\n\\frac{\\partial C}{\\partial X} \\approx \\frac{C^{\\text{mid}}_{\\text{up}}-C^{\\text{mid}}_{\\text{down}}}{2\\Delta x}\\;,\n\\] and \\[\n\\frac{\\partial^2 C}{\\partial X^2} \\approx \\frac{C^{\\text{mid}}_{\\text{up}}+C^{\\text{mid}}_{\\text{down}}-2C^{\\text{mid}}}{(\\Delta x)^2}\\;.\n\\] Now, Equation 22.3 becomes \\[\nrC^{\\text{mid}} = \\frac{C'-C}{\\Delta t}+ \\nu\\left(\\frac{C^{\\text{mid}}_{\\text{up}}-C^{\\text{mid}}_{\\text{down}}}{2\\Delta x}\\right)+ \\frac{1}{2}\\sigma^2\\left(\\frac{C^{\\text{mid}}_{\\text{up}}+C^{\\text{mid}}_{\\text{down}}-2C^{\\text{mid}}}{(\\Delta x)^2}\\right)\\;.\n\\qquad(22.13)\\]\nSubstituting from the formulas for \\(C^{\\text{mid}}\\), \\(C^{\\text{mid}}_{\\text{up}}\\), and \\(C^{\\text{mid}}_{\\text{down}}\\), we can re-write Equation 22.13 as\n\\[\n\\begin{multline}\n\\left(\\frac{r}{2}+\\frac{1}{\\Delta t}+\\frac{\\sigma^2}{2(\\Delta x)^2}\\right)C - \\left(\\frac{\\sigma^2}{4(\\Delta x)^2}+\\frac{\\nu}{4\\Delta x}\\right)C_{\\text{up}}\\\\ - \\left(\\frac{\\sigma^2}{4(\\Delta x)^2}-\\frac{\\nu}{4\\Delta x}\\right)C_{\\text{down}}\n\\quad = \\quad \\left(\\frac{1}{\\Delta t}- \\frac{r}{2}-\\frac{\\sigma^2}{2(\\Delta x)^2}\\right)C' \\\\+ \\left(\\frac{\\sigma^2}{4(\\Delta x)^2}+\\frac{\\nu}{4\\Delta x}\\right)C'_{\\text{up}} + \\left(\\frac{\\sigma^2}{4(\\Delta x)^2}-\\frac{\\nu}{4\\Delta x}\\right)C'_{\\text{down}}\n\\end{multline}\n\\qquad(22.14)\\]\nWe can also write this as \\[\na_1C - a_2C_{\\text{up}} - a_3C_{\\text{down}}\n= a_4C' + a_2C'_{\\text{up}} + a_3C'_{\\text{down}}\\;, \\qquad(22.15)\\]\nwhere the constants \\(a_i\\) are the factors in parentheses in Equation 22.14.\nAs before, we start at the final date \\(t_N\\) and define the call value at that date by its intrinsic value. Consider a grid point \\((t_{N-1},x_j)\\). Forcing Equation 22.3 to hold at the midpoint \\((t_{N-1}+\\Delta t/2,x_j)\\) leads us to Equation 22.15. In this equation, \\(C'\\), \\(C'_{\\text{up}}\\) and \\(C'_{\\text{down}}\\) are known from the intrinsic value at maturity, and we need to solve for \\(C\\), \\(C_{\\text{up}}\\) and \\(C_{\\text{down}}\\). There are \\(2M-1\\) linear equations of this type and we will add linear equations at the upper and lower boundaries of the grid and solve the resulting system of \\(2M+1\\) linear equations for the \\(2M+1\\) call values. After finding the call values at date \\(t_{N-1}\\), we then repeat the calculation at \\(t_{N-2}\\) and continue backing up in this way until we reach the initial date.\nNotice that Equation 22.14 is similar to Equation 22.11 in the implicit method, but more information is used in each step of the Crank-Nicolson method than is used in each step of the implicit method. Equation 22.14 links the call values \\(C\\), \\(C_{\\text{up}}\\) and \\(C_{\\text{down}}\\) to the previously calculated \\(C'\\), \\(C'_{\\text{up}}\\) and \\(C'_{\\text{down}}\\), whereas in the implicit method they were linked only to \\(C'\\) (which we called \\(C_{\\text{right}}\\)).",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#european-options",
    "href": "Chapter_PDEs.html#european-options",
    "title": "22  PDE Methods",
    "section": "22.5 European Options",
    "text": "22.5 European Options\nTo value a European option, one simply defines the values at the final date as the intrinsic value and then backs up to the initial date, using any of the methods described (explicit, implicit, or Crank-Nicolson). The value that should be returned is the value at the middle node at the initial date, which corresponds to the initial price of the underlying.\nThe boundary conditions normally used at the bottom and top of the grid are conditions that the first derivative \\(\\partial C/\\partial S\\) of the option value are known to satisfy as \\(S \\rightarrow 0\\) and \\(S \\rightarrow \\infty\\). These are conditions of the form \\[\n\\lim_{S \\rightarrow \\infty} \\frac{\\partial C}{\\partial S} =  \\lambda_0\\;,\\qquad \\text{and} \\qquad\n\\lim_{S \\rightarrow 0} \\frac{\\partial C}{\\partial S} = \\lambda_{\\infty}\\;,\n\\qquad(22.16)\\]\nfor constants \\(\\lambda_0\\) and \\(\\lambda_{\\infty}\\). In the case of a call option, we have \\(\\lambda_0=0\\) and \\(\\lambda_{\\infty}=1\\). For a put option, we have \\(\\lambda_0=-1\\) and \\(\\lambda_\\infty = 0.\\)\nThese conditions are implemented on the grid by forcing each value \\(C\\) at a point \\((t_i,x_{-M})\\) on the bottom of the grid to satisfy\n\\[\nC - C_{\\text{up}} = \\lambda_0 (S - S_{\\text{up}})\n\\qquad(22.17)\\]\nand by forcing each value \\(C\\) at a point \\((t_i,x_{M})\\) on the top of the grid to satisfy\n\\[\nC-C_{\\text{down}} = \\lambda_\\infty(S-S_{\\text{down}})\\;.\n\\qquad(22.18)\\]\nThese two linear equations in the values at time \\(t_i\\) augment the \\(2M-1\\) equations already described to form a system of \\(2M+1\\) linear equations to be solved for the derivative values at the \\(2M+1\\) grid points at time \\(t_i\\).\nWe will create a program that solves a system of equations of the form Equation 22.15, Equation 22.17 and Equation 22.18. We input the vector \\(a\\) of coefficients, a vector \\(y\\) of dimension \\(2M+1\\) containing the estimated values of the derivative at any date \\(t_{i+1}\\), an integer \\(L\\) from which \\(M\\) is defined as \\(M=(L-1)/2\\) (i.e., \\(L=2M+1\\)). The function will return the vector of values at date \\(t_i\\).\nWe will write the boundary conditions Equation 22.17 and Equation 22.18, respectively, in the more general forms\n\\[\nC = z_1 + b_1C_{\\text{up}}\\;,\n\\qquad(22.19)\\]\nand \\[\nC = z_L + b_LC_{\\text{down}}\\;,\n\\qquad(22.20)\\]\nwhere \\(z_1\\), \\(b_1\\), \\(z_L\\) and \\(b_L\\) are numbers to be calculated or input by the user. Equation 22.17 and Equation 22.18 are the special cases in which \\(z_1 = \\lambda_0(S-S_{\\text{up}})\\), \\(b_1 = 1\\), \\(z_L = \\lambda_\\infty(S-S_{\\text{down}})\\), and \\(b_L=1\\). The additional generality in allowing \\(b_1\\) and \\(b_L\\) to be different from one is important for many purposes, and we will see an example of it in the valuation of barrier options.\nThe system of equations that we want to solve is therefore \n\\[\\begin{pmatrix}\n1 & -b_1 & 0 & 0 & 0  & \\cdots  & 0 & 0 & 0 & 0 & 0\\\\\n-a_3 & a_1 & - a_2 & 0 & 0 & \\cdots & 0 & 0 & 0 & 0 & 0\\\\\n0 & - a_3 & a_1 & -a_2 & 0 & \\cdots & 0 & 0 & 0 & 0 & 0\\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots &\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & 0 & 0 & \\cdots & 0 & -a_3 & a_1 & - a_2 & 0\\\\\n0 & 0 & 0 & 0 & 0 & \\cdots  & 0 & 0 & -a_3 & a_1 & - a_2 \\\\\n0 & 0 & 0 & 0 & 0 & \\cdots  & 0 & 0 & 0 & -b_L & 1\n\\end{pmatrix}\\]\n\\[\\begin{pmatrix}\nC_1 \\\\\nC_2\\\\\nC_3\\\\\n\\vdots\\\\\nC_{L-2}\\\\\nC_{L-1}\\\\\nC_L\n\\end{pmatrix}\n\\begin{matrix}\n\\phantom\\\\\n\\phantom\\\\\n\\phantom\\\\\n=\n\\phantom\\\\\n\\phantom\\\\\n\\phantom\\\\\n\\end{matrix}\n\\begin{pmatrix}\nz_1 \\\\\nz_2\\\\\nz_3\\\\\n\\vdots\\\\\nz_{L-2}\\\\\nz_{L-1}\\\\\nz_L\n\\end{pmatrix}\\]\nwhere we are denoting the derivative values to be determined at date \\(t_i\\) across the \\(L\\) (\\(=2M+1\\)) space nodes as \\(C_1, \\ldots, C_L\\). The coefficients \\(a_i\\) are defined in Equation 22.15. The numbers \\(z_2, \\ldots, z_{L-1}\\) are the right-hand sides of Equation 22.15 and are determined by the coefficients \\(a_i\\) and the derivative values \\(y_1, \\ldots, y_{L}\\) at date \\(t_{i+1}\\). The system of equations that must be solved to implement the implicit method is of this same form.\nThe first equation in this array (Equation 22.19) can be written as\n\\[\nC_1 = u_1 + b_1C_2\\;,\n\\] where \\(u_1 = z_1\\).\nBy induction, we will see that we can write, for each \\(j = 2, \\ldots, L\\), \\[\nC_{j-1} = u_{j-1} + b_{j-1}C_{j}\n\\qquad(22.21)\\]\nfor some coefficients \\(u_{j-1}\\) and \\(b_{j-1}\\) to be determined.\nThe \\(j\\)–th equation (\\(j = 2, \\ldots, L-1\\)) in the array (Equation 22.15) is \\[-a_3C_{j-1}+a_1C_j-a_2C_{j+1} = z_j\\; .\\] Supposing Equation 22.21 holds and using it to substitute for \\(C_{j-1}\\), we have \\[-a_3\\left(u_{j-1} + b_{j-1}C_{j}\\right) +a_1C_j-a_2C_{j+1} = z_j \\quad\\Longleftrightarrow\\quad C_{j} = u_{j} + b_{j}C_{j+1}\\; ,\\] where \\[\\begin{align*}\nu_j &= \\frac{z_j + a_3u_{j-1}}{a_1-a_3b_{j-1}} \\;,\\\\\nb_j &= \\frac{a_2}{a_1-a_3b_{j-1}}\\;.\n\\end{align*}\\] This establishes that Equation 22.21 holds for each \\(j = 2, \\ldots, L\\).\nThe last equation in the array (Equation 22.20) is \\[\nC_L = z_L + b_LC_{L-1}\\; . \\qquad(22.22)\\] Our induction argument gives us \\[\nC_{L-1} = u_{L-1} + b_{L-1}C_{L}\\; ,\n\\] and when we combine these we have two equations in two unknowns and can solve for \\(C_L\\) as \\[\nC_L = \\frac{z_L+ b_Lu_{L-1}}{1-b_Lb_{L-1}}\\;.\n\\] We then successively obtain \\(C_{L-1}, C_{L-2}, \\ldots, C_1\\) from Equation 22.21.\nWe will demonstrate the Crank-Nicolson method by valuing a European call. Any other path-independent European derivative is valued in the same way, by appropriately redefining the value of the derivative at the final date and redefining the constants \\(z_1\\) and \\(z_L\\) in the boundary conditions Equation 22.19 - Equation 22.20 at the bottom and top of the grid.\nAs elsewhere in this chapter, \\(N\\) denotes the number of time periods, and \\(2M+1\\) will be the number of \\(x\\) values on the grid. We use the symbol \\(D\\) to denote the distance of the top (or bottom) of the grid from \\(\\log S_0\\). In other words, \\(D = x_M-x_0\\). A reasonable value for \\(D\\) would be three standard deviations for \\(\\log S\\), which would mean \\(D = |\\nu|T +3 \\sigma\\sqrt{T}\\). For example, for a one-year option on a stock with a volatility of 30%, it should suffice to input \\(D=1\\).\nAs should be clear, the program is conceptually very similar to a binomial model. The difference is that the backing up procedure, which involves node-by-node discounting in a binomial model, here is accomplished via the Crank-Nicolson algorithm.3\nThe following code illustrates how to use the Crank_Nicolson method to vale a European call option.\n\n\nCode\nimport numpy as np\n\ndef crank_nicolson(a, y, L, z1, b1, zL, bL):\n    u = np.zeros(L)\n    b = np.zeros(L)\n    c = np.zeros(L)\n    z = np.zeros(L)\n\n    u[0] = z1\n    b[0] = b1\n    for j in range(1, L - 1):\n        z[j] = a[3] * y[j] + a[1] * y[j + 1] + a[2] * y[j - 1]\n        u[j] = (a[2] * u[j - 1] + z[j]) / (a[0] - a[2] * b[j - 1])\n        b[j] = a[1] / (a[0] - a[2] * b[j - 1])\n    c[-1] = (zL + bL * u[-2]) / (1 - bL * b[-2])\n    for j in range(L - 2, -1, -1):\n        c[j] = u[j] + b[j] * c[j + 1]\n    return c\n\ndef european_call_crank_nicolson(S0, K, r, sigma, q, T, N, M, Dist):\n    dt = T / N\n    dx = Dist / M\n    dx2 = dx ** 2\n    u = np.exp(dx)\n    sig2 = sigma ** 2\n    nu = r - q - sig2 / 2\n    St = S0 * np.exp(Dist)\n    Sb = S0 * np.exp(-Dist)\n    a = np.zeros(4)\n    a[0] = r / 2 + 1 / dt + sig2 / (2 * dx2)\n    a[1] = sig2 / (4 * dx2) + nu / (4 * dx)\n    a[2] = a[1] - nu / (2 * dx)\n    a[3] = -a[0] + 2 / dt\n\n    L = 2 * M + 1\n    y = np.zeros(L)\n    S = Sb\n    y[0] = max(S - K, 0)\n    for j in range(1, L):\n        S *= u\n        y[j] = max(S - K, 0)\n\n    z1 = 0\n    b1 = 1\n    zL = St - St / u\n    bL = 1\n    CallV = crank_nicolson(a, y, L, z1, b1, zL, bL)\n\n    for _ in range(N - 2, -1, -1):\n        CallV = crank_nicolson(a, CallV, L, z1, b1, zL, bL)\n    return CallV[M]\n\n# Example usage\nS0 = 100\nK = 90\nr = 0.05\nsigma = 0.2\nq = 0.02\nT = 1\nN = 100\nM = 50\nDist = 3\nBar = 85\n\nprint(\"European Call Crank-Nicolson:\", european_call_crank_nicolson(S0, K, r, sigma, q, T, N, M, Dist))\n\n\nEuropean Call Crank-Nicolson: 15.113207926084973",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#american-options",
    "href": "Chapter_PDEs.html#american-options",
    "title": "22  PDE Methods",
    "section": "22.6 American Options",
    "text": "22.6 American Options\nThe explicit method is easily adapted to American options. As in a binomial model, we compute the option value at each node as the larger of its discounted expected value and its intrinsic value. To be somewhat more precise, we replace the trinomial value Equation 22.10 with \\[\nC_{\\text{left}} = \\max\\left(\\big(1-r\\Delta t\\big)\\big(p_uC_{\\text{up}}+pC + p_dC_{\\text{down}}\\big), \\text{intrinsic value}\\right)\\;.\n\\]\nIn the Crank-Nicolson method, one can in similar fashion compute the value of the derivative at each space node at any date by solving the system of equations Equation 22.15 and then replace the computed values by the intrinsic value when that is higher. However, because the values at the different space nodes are linked (i.e., the method is an implicit-type method), this one-at-a-time replacement of values by intrinsic values is not the most efficient method. See Wilmott (Wilmott 2000) for more details (and for VBA code implementing the projected successive over-relaxation method).",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#sec-s:finitedifferencebarriers",
    "href": "Chapter_PDEs.html#sec-s:finitedifferencebarriers",
    "title": "22  PDE Methods",
    "section": "22.7 Barrier Options",
    "text": "22.7 Barrier Options\nFinite-difference methods work well for valuing discretely-sampled barrier options. For a down-and-out option, one should place the bottom of the grid at the knock-out boundary. For an up-and-out option, one should place the top of the grid at the knock-out boundary. As discussed in Chapter 15, knock-in options can be valued as standard options minus knock-out options.\nFor barrier options, the boundary information Equation 22.16 can be replaced by assigning a value of zero at the knock-out boundary. For example, for a down-and-out option, the condition Equation 22.17 can be replaced by \\(C=0\\). If the contract specifies that a rebate is to be paid to the buyer when the option is knocked out, then condition Equation 22.17 should be replaced by \\(C=\\) Rebate.\nTo price a down-and-out (or up-and-out option), we put the bottom (or top) of the grid at the boundary. The boundary condition that we use is that the value at the boundary is zero. We will consider the example of a down-and-out call option. In this case, the boundary condition at the bottom of the grid is Equation 22.19 with \\(z_1=0\\) and \\(b_1 = 0\\). The boundary condition at the top is the same as for an ordinary call. We can easily handle a rebate paid when the option is knocked out by inputting the value of the rebate as \\(z_1\\).\nThe main new issue that we encounter in valuing barriers is locating the boundary of the grid at the barrier. For the down-and-out, we will input the value of the stock price at which the option is knocked out as Bar. We want the bottom of the grid to lie at the natural logarithm of this number. This will influence our choice of the space step \\(\\Delta x\\), because we want to have an integer number of steps between the bottom of the grid and \\(\\log S_0\\). We assume that the value \\(M\\) input by the user represents the desired number of space steps above \\(\\log S_0\\). We start with \\(\\Delta x=D/M\\) as an initial estimate of the size of the space step. We then decrease it, if necessary, to ensure that the distance between Bar and \\(\\log S_0\\) is an integer multiple of \\(\\Delta x\\). We then increase \\(M\\), if necessary, to ensure that the top of the grid will still be at or above \\(D+\\log S_0\\). Finally, we define the top of the grid to be at \\(\\log S_0 +M \\cdot \\Delta x\\).\n\n\nCode\ndef down_and_out_call_cn(S0, K, r, sigma, q, T, N, M, Dist, Bar):\n    dx = Dist / M\n    DistBot = np.log(S0) - np.log(Bar)\n    NumBotSteps = int(np.ceil(DistBot / dx))\n    dx = DistBot / NumBotSteps\n    NumTopSteps = int(np.ceil(Dist / dx))\n    DistTop = NumTopSteps * dx\n    L = NumBotSteps + NumTopSteps + 1\n    dt = T / N\n    dx2 = dx ** 2\n    u = np.exp(dx)\n    sig2 = sigma ** 2\n    nu = r - q - sig2 / 2\n    St = S0 * np.exp(DistTop)\n    a = np.zeros(4)\n    a[0] = r / 2 + 1 / dt + sig2 / (2 * dx2)\n    a[1] = sig2 / (4 * dx2) + nu / (4 * dx)\n    a[2] = a[1] - nu / (2 * dx)\n    a[3] = -a[0] + 2 / dt\n\n    y = np.zeros(L)\n    S = Bar\n    y[0] = max(S - K, 0)\n    for j in range(1, L):\n        S *= u\n        y[j] = max(S - K, 0)\n\n    z1 = 0\n    b1 = 0\n    zL = St - St / u\n    bL = 1\n    CallV = crank_nicolson(a, y, L, z1, b1, zL, bL)\n\n    for _ in range(N - 2, -1, -1):\n        CallV = crank_nicolson(a, CallV, L, z1, b1, zL, bL)\n    return CallV[NumBotSteps]\n\nprint(\"Down and Out Call CN:\", down_and_out_call_cn(S0, K, r, sigma, q, T, N, M, Dist, Bar))\n\n\nDown and Out Call CN: 13.780367670052469",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#section",
    "href": "Chapter_PDEs.html#section",
    "title": "22  PDE Methods",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nCreate a python program to compare the estimates of the value of a discretely sampled barrier option given by the functions Down_And_Out_Call_MC created before and the function Down_And_Out_Call_CN. Allow the user to input \\(S\\), \\(K\\), \\(r\\), \\(\\sigma\\), \\(q\\), the knock-out barrier, the number of Monte Carlo simulations, and the number of space steps above \\(\\log S_0\\) in the Crank-Nicolson algorithm.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a python function Up_And_Out_Put_CN to value an up-and-out put option by the Crank-Nicolson method.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a python function European_Call_Explicit that uses the explicit method Equation 22.10 to value a European call option.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nWrite Equation 22.11 for the implicit method, together with boundary conditions of the form Equation 22.19 - Equation 22.20 as a matrix system and solve for \\(u_j\\) and \\(b_j\\) in Equation 22.21 - Equation 22.22, as in the subsection that defines the function CrankNicolson.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a python function Implicit that solves the system of equations in the preceding exercise.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a python function European_Call_Implicit that uses the implicit method to value a European call option.\n\n\n\n\n\n\n\nBrennan, M., and E. Schwartz. 1978. Finite Difference Methods and Jump Processes Arising in the Pricing of Contingent Claims: A Synthesis. Journal of Financial and Quantitative Analysis 13. 461–474.\n\n\nTavella, D. A. 2002. Quantitative Methods in Derivatives Pricing. Wiley, New York.\n\n\nWilmott, P. 2000. Paul Wilmott on Quantitative Finance. Vol. 2, Wiley, New York.\n\n\nWilmott, P., J. Dewynne, and S. Howison. 2000. Option Pricing: Mathematical Models and Computation. Oxford Financial Press, Oxford.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_PDEs.html#footnotes",
    "href": "Chapter_PDEs.html#footnotes",
    "title": "22  PDE Methods",
    "section": "",
    "text": "If the price of the derivative is a function of the asset price \\(S\\) and time, then we can always write it in this form as a function of the natural logarithm of \\(S\\) and time.↩︎\nSuppose a process \\(X\\) satisfies \\(\\,\\mathrm{d}X=\\alpha_1\\,\\mathrm{d}t+\\sigma_1\\,\\mathrm{d}B = \\alpha_2\\,\\mathrm{d}t+\\sigma_2\\,\\mathrm{d}B\\) for coefficients \\(\\alpha_i\\) and \\(\\sigma_i\\). This implies \\((\\alpha_1-\\alpha_2)\\,\\mathrm{d}t=(\\sigma_2-\\sigma_2)\\,\\mathrm{d}B\\). The right-hand side defines a (local) martingale and the left-hand side defines a continuous finite-variation process. As discussed in Section 4.3, the only continuous finite-variation martingales are constants, so the changes must be zero; i.e., \\(\\alpha_1=\\alpha_2\\) and \\(\\sigma_1=\\sigma_2\\).↩︎\nWe use a different variable (\\(y\\)) for the call values at the final date—and consequently need to separate the first step of backing up (to the penultimate date) and the other steps of backing up (to date zero). See Appendix~A for more discussion.↩︎",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>PDE Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html",
    "href": "Chapter_Fourier.html",
    "title": "23  Fourier Transforms",
    "section": "",
    "text": "23.1 Introduction\nThe Fourier Transform has become an essential tool in option pricing, particularly for complex models like those with stochastic volatility and Lévy processes including variance gamma and jump diffusion processes. In this chapter, we will explore how the Fourier Transform simplifies the pricing of derivative securities, examine its advantages, and provide analytical examples and Python code for practical illustration.\nThe key reason for using Fourier Transforms in option pricing is that they allow us to solve pricing problems more efficiently in the frequency domain rather than the time domain. Specifically, Fourier methods:\nIn this chapter, we’ll focus on the first three and demonstrate these advantages through theory, examples, and Python code.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#introduction",
    "href": "Chapter_Fourier.html#introduction",
    "title": "23  Fourier Transforms",
    "section": "",
    "text": "Handle Non-Gaussian Processes: Many real-world asset price models involve jumps or stochastic volatility, which may lead to non-Gaussian distributions of returns. Fourier Transforms allow us to handle these models efficiently.\nUse Characteristic Functions: The Fourier Transform is closely related to the characteristic function of the underlying asset price. Many stochastic processes have closed-form characteristic functions without explicit distribution functions. Using the closed-form characteristic functions simplifies the integration required in risk-neutral valuation.\nConduct Fast Numerical Computation: By leveraging Fast Fourier Transform (FFT) algorithms, we can calculate option prices for a wide range of strikes and maturities quickly.\nSimplify Complex Problems: Many option pricing models lead to complex partial differential equations (PDEs). The Fourier Transform helps transform these PDEs into simpler algebraic equations.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#section-1-theoretical-foundation",
    "href": "Chapter_Fourier.html#section-1-theoretical-foundation",
    "title": "23  Fourier Transforms",
    "section": "23.2 Section 1: Theoretical Foundation",
    "text": "23.2 Section 1: Theoretical Foundation\nThe Fourier transform of a function \\(f(x)\\), denoted as \\(\\hat{f}(u)\\), is given by:\n\\[\n\\hat{f}(u) = \\int_{-\\infty}^{\\infty} e^{-iux} f(x) \\, dx,\n\\] where \\(i=\\sqrt{-1}\\) and \\(u\\) is termed ``frequency.’’\nIn the context of option pricing using the Fourier Transform, our goal is to transform option payoff into the frequency domain (via the Fourier transform), which allows for efficient option pricing using techniques like the Fast Fourier Transform (FFT).\nTo apply the Fourier transform, we often work with the logarithm of the asset price, \\(X_T = \\ln(S_T)\\), instead of the asset price \\(S_T\\) directly. This is done because log-prices simplify the structure of the characteristic function (which is essential in the Fourier method). The payoff of a European call with strike price \\(K\\) at maturity \\(T\\) becomes:\n\\[\nC(X_T) = \\max(e^{X_T} - K, 0)\n\\]\nWe now take the Fourier transform of this function with respect to \\(x = X_T\\) (the log-price), leading to the formula for \\(\\hat{C}(u)\\), which is:\n\\[\n\\hat{C}(u) = \\int_{-\\infty}^{\\infty} e^{-iux} \\max(e^x - K, 0) \\, dx\n\\]\nTo compute this transform explicitly, we split the payoff function into two regions: - When \\(x &lt; \\ln(K)\\), the payoff is zero because \\(S_T &lt; K\\). - When \\(x \\geq \\ln(K)\\), the payoff is \\(e^x - K\\) because \\(S_T \\geq K\\).\nThus, the integral for \\(\\hat{C}(u)\\) becomes:\n\\[\n\\hat{C}(u) = \\int_{\\ln(K)}^{\\infty} e^{-iux} (e^x - K) \\, dx\n\\]\nThis integral can be computed analytically and results in a closed-form expression for \\(\\hat{C}(u)\\). The final result is:\n\\[\n\\hat{C}(u) = \\frac{K^{1 - iu}}{iu(1 + iu)}\n\\]\nIn essence, \\(\\hat{C}(u)\\) is the representation of the call option’s payoff in the frequency domain. It captures how different frequencies (or Fourier modes) contribute to the option price. Once the Fourier transform is applied to the payoff function, this \\(\\hat{C}(u)\\) can be combined with the characteristic function of the underlying asset’s price process to calculate the option price.\nThe characteristic function \\(\\phi_{X}(u)\\) of a random variable \\(X\\) is defined as:\n\\[\n\\phi_{X}(u) = \\mathbb{\\\\E}[e^{i u X}].\n\\] The characteristic function uniquely defines the probability distribution of \\(X\\) and can be used to recover the density function via the inverse Fourier Transform.\nThe final step in the pricing process involves integrating the product of \\(\\hat{C}(u)\\) and the characteristic function of the log-returns of the asset (under the risk-neutral probability) to recover the option price in the original domain (time or price space).\nOnce \\(\\hat{C}(u)\\) is computed, the price of the option can be calculated using the Fourier inversion formula. The general formula for the call option price \\(C(K)\\) at time \\(0\\) is:\n\\[\nC(K) = \\frac{e^{-rT}}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-iuk} \\hat{C}(u) \\phi_X(u) \\, du,\n\\qquad(23.1)\\] where \\(\\phi_X(u)\\) is the characteristic function of the log-price process at time \\(T\\), \\(k = \\ln(K)\\) is the log-strike, and \\(\\hat{C}(u)\\) is the Fourier transform of the payoff function.\nBy evaluating this integral (typically done numerically), we recover the option price. This illustrate the main idea behind the appilcation of Fourier transform in pricing options.\nUnfortunately, the Fast Fourier Transform (FFT) cannot be used to evaluate the pricing integral Equation 23.1, since the integrand is singular at the required evaluation point \\(u = 0\\). Given the considerable speed advantages of the FFT, we introduce the Carr-Madan method (Carr and Madan 1999) that can leverage the efficiency of the FFT.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#the-carr-madan-method",
    "href": "Chapter_Fourier.html#the-carr-madan-method",
    "title": "23  Fourier Transforms",
    "section": "23.3 The Carr-Madan Method",
    "text": "23.3 The Carr-Madan Method\nThe key idea behind the Carr-Madan Method is to express the option price as an integral in Fourier space and then discretize it for the FFT numerical evaluation.\n\nStep 1: Modify the Payoff Function\nLet \\(k\\) denote the log of the strike price \\(K\\), and let \\(C(k)\\) be the desired value of a \\(T\\)-maturity call option with strike exp(k). Let the risk-neutral density of the \\(s=\\ln(S)\\) be \\(q_s\\). The initial call value \\(C(k)\\) is related to the risk-neutral density \\(q_s\\) by\n\\[\nC(k) = \\int_{k}^\\infty e^{-r T} (e^s-e^k) q_s\\, ds.\n\\]\nBecause \\(C(k)\\) approaches \\(S_0\\) as \\(k\\) tends to \\(-\\infty\\), the call pricing function of \\(k\\) is not square integrable. To ensure the square integrability of the Fourier Transform, we first modify the option’s payoff function by introducing a dampening factor \\(\\alpha &gt; 0\\):\n\\[\n\\tilde{C}(k) = e^{\\alpha k} C(k).\n\\] This modification ensures that the transformed function decays sufficiently fast at infinity.\n\n\nStep 2: Express the Modified Price as an Integral\nBy the fourier inversion theorem, the modified call price can be written as:\n\\[\nC(k) = \\frac{e^{-\\alpha k}}{2\\pi} \\int_{-\\infty}^\\infty e^{-i u k} \\phi_{C}(u)\\, du = \\frac{e^{-\\alpha k}}{\\pi} \\int_{0}^\\infty e^{-i u k} \\phi_{C}(u)\\, du,\n\\qquad(23.2)\\] where \\(\\phi_{C}(u)\\) is the Fourier Transform of the option \\(C(k)\\) and the second equality follows because \\(\\phi_{C}(u)\\) is odd in its imaginary part and even in its real part.\n\n\nStep 3: Derive the Fourier Transform of the Payoff\nThe Fourier Transform \\(\\phi_{C}(u)\\) is given by:\n\\[\n\\phi_{C}(u) = \\int_{-\\infty}^\\infty e^{i u k} e^{\\alpha k}e^{-r T} (e^{s} - e^{k})^+q_s \\, ds.\n\\]\nBy simplifying and rearranging terms, we obtain:\n\\[\n\\phi_{C}(u) = \\frac{e^{-rT}\\phi_{S}(u - i (\\alpha + 1))}{(\\alpha + i u)(\\alpha + i u + 1)},\n\\] where \\(\\phi_{S}(u)\\) is the characteristic function of \\(\\ln S\\).\n\n\nStep 4: Discretize the Integral for FFT\nThe FFT is an efficient algorithm for computing the sum \\[\ng(m)=\\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N}(j-1) (m-1)\\right)y(j), m=1,...,N,\n\\] where \\(N\\) is typically a power of 2 and \\(y(\\cdot)\\) is some given function. The algorithm reduces the number of multiplications in the required \\(N\\) summations from an order of \\(N^2\\) to that of \\(N \\log_2(N)\\), a very significant reduction. We present in this section the details for writing the integration (5) as an application of the summation (16). To improve the accuracy of the approximation, we can combine it with the Simpson’s rule.\nSimpson’s Rule: We divide the integration interval \\([a, b]\\) into \\(N\\) subintervals, where \\(N\\) is an even number. Let \\(h = \\frac{b - a}{N}\\) be the width of each subinterval. The function \\(f(x)\\) is evaluated at equally spaced points \\(x_1, x_2, x_3, \\dots, x_{N+1}\\), where \\(x_j = a+(j-1) h\\).\nThe Simpson’s Rule formula is: \\[\n\\int_a^b f(x) \\, dx \\approx \\frac{h}{3} \\left[ f(x_1) + 4 \\sum_{j=2,4,6,\\dots}^{N-1} f(x_j) + 2 \\sum_{j=1,3,5,\\dots}^{N-2} f(x_j) + f(x_{N+1}) \\right].\n\\] Combinig the FFT with the Simpson’s rule, we have \\[\ng(m)=\\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N}(j-1) (m-1)\\right)y(j)w(j), m=1,...,N,\n\\qquad(23.3)\\] where \\(w(j)=4\\) if \\(j\\) is even, \\(w(j)=2\\) if \\(j\\) is odd, and \\(w(1)=w(N+1)=1\\).1\nTo apply the FFT Equation 23.3, we discretize the integral Equation 23.2 over \\(u\\):\n\nDefine \\(u_j = \\eta (j-1)\\), where \\(\\eta\\) is the spacing between points and $j = 1, 2, , N $.\nSimilarly, define \\(k_m = -b + \\lambda \\, (m-1)\\), where \\[\n\\lambda = \\frac{2\\pi}{N \\eta}\n\\] is the spacing in log-strike space, \\[\nb=\\frac{N \\lambda}{2}\n\\] is the integration upper limit of \\(k\\), and \\(m = 1, 2,  \\dots, N\\).\n\nThe integral Equation 23.2 becomes a sum:\n\\[\n\\tilde{C}(k_m) \\approx \\frac{e^{-\\alpha k_m}}{\\pi} \\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N} (j-1)\\, (m-1) \\right) e^{i u_j b} \\phi_{C}(u_j)  \\eta.\n\\] To further improve the efficiency, we use Simpson’s rule to choose the weights of each term to arrive at \\[\n\\tilde{C}(k_m) \\approx \\frac{e^{-\\alpha k_m}}{\\pi} \\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N} (j-1)\\, (m-1) \\right) e^{i u_j b} \\phi_{C}(u_j) \\frac{\\eta}{3}(3+(-1)^{j}-\\delta_{j-1}),\n\\qquad(23.4)\\] where \\(\\delta_n=1\\) is equal to 1 if and only if \\(n=0\\). Equation 23.4 can be efficiently computed using the FFT method.2\n\n\nImplementation Steps\n\n1. Set the Parameters\n\nChoose \\(N\\), the number of FFT points (preferably a power of 2 for computational efficiency).\nSet the dampening factor \\(\\alpha\\) to ensure convergence.\nDetermine \\(\\eta\\) and \\(\\lambda\\) based on \\(N\\) and the desired range of strikes.\n\n\n\n2. Compute the Characteristic Function\nFor a given model (e.g., Black-Scholes, Heston), compute the characteristic function \\(\\phi_{S_T}(u)\\) of \\(\\ln S_T\\).\n\n\n3. Calculate the Fourier Transform of the Call Payoff\nCompute \\(\\phi_{C}(u_j)\\) using:\n\\[\n\\phi_{C}(u_j) = \\frac{e^{-r T}\\phi_{S_T}(u_j - i (\\alpha + 1))}{(\\alpha + i u_j)(\\alpha + i u_j + 1)}.\n\\]\n\n\n4. Apply the FFT Equation 23.4 to get the option price.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#applications-of-the-carr-madan-method",
    "href": "Chapter_Fourier.html#applications-of-the-carr-madan-method",
    "title": "23  Fourier Transforms",
    "section": "23.4 Applications of the Carr-Madan Method",
    "text": "23.4 Applications of the Carr-Madan Method\n\nPricing a European Call Option under the Black-Scholes Model\nIn the Black-Scholes model, the asset price follows a geometric Brownian motion, and the log-price \\(X_T = \\ln(S_T)\\) is normally distributed with mean \\((r - \\frac{\\sigma^2}{2})T\\) and variance \\(\\sigma^2 T\\). The characteristic function for the log-price \\(X_T\\) is:\n\\[\n\\phi_T(u) = \\exp\\left(iu \\left(\\ln(S_0) + \\left(r -q-\\frac{\\sigma^2}{2}\\right)T\\right) - \\frac{1}{2} \\sigma^2 T u^2 \\right),\n\\] where \\(S_0\\) is the initial asset price, \\(r\\) is the risk-free rate, \\(\\sigma\\) is the volatility of the asset, \\(T\\) is the time to maturity, and \\(u\\) is the complex Fourier variable.\nThe following code implements the Carr-Madan method, which uses the FFT to price European call options by transforming the characteristic function of the Black-Scholes model into the frequency domain. The option prices are then obtained by applying Simpson’s Rule for integration and FFT for efficient computation. These prices are compared to those obtained using the Black-Scholes formula. The code also visualizes the comparison and the differences between the two methods. The results suggest that the Carr-Madan method yields an accurate call price.\n\n\nCode\nimport numpy as np\nfrom numpy.fft import fft\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Market and option parameters\nS0 = 100       # Initial stock price\nK = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\nT = 0.1        # Time to maturity\nr = 0.05       # Risk-free rate\nq = 0.02       # Dividend yield\nsigma = 0.2    # Volatility\n\n# Carr-Madan method parameters\nalpha = 1.5    # Damping factor (&gt; 0)\nN = 2**16      # Number of FFT points (must be even for Simpson's Rule)\neta = 0.05     # Spacing in the frequency domain (smaller for higher accuracy)\n\n# Ensure N is even for Simpson's Rule\nif N % 2 != 0:\n    N += 1\n\n# Compute the grid in the frequency domain (v)\nv = np.arange(N) * eta  # v_j = j * eta\n\n# Compute the grid in the log-strike domain (k)\nlambda_ = (2 * np.pi) / (N * eta)\nb = N * lambda_ / 2     # Upper limit for k\nk = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n\ndef phi(u):\n    \"\"\"Characteristic function of log(S_T) under the Black-Scholes model.\"\"\"\n    mu = np.log(S0) + (r -q- 0.5 * sigma**2) * T\n    variance = sigma**2 * T\n    return np.exp(1j * u * mu - 0.5 * variance * u**2)\n\n# Adjustment to the characteristic function for damping\nu = v - (alpha + 1) * 1j\npsi = np.exp(-r * T) * phi(u) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n\n#   Simpson's Rule weights\nw = np.ones(N)\nw[0] = w[-1] = 1\nw[1:-1:2] = 4  # Weights for odd indices\nw[2:-1:2] = 2  # Weights for even indices\nw = w * (eta / 3)\n\n# Function to be transformed with   weights\nfft_input = psi * np.exp(1j * v * b) * w\n\n# Apply the FFT\nfft_output = fft(fft_input)\n\n# Compute the option prices\nC_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n\n# Convert strikes to log-strikes\nlog_K = np.log(K)\n\n# Interpolate the option prices at desired strikes\ncall_prices_fft = np.interp(log_K, k, C_k)\n\n# Black-Scholes formula for European call options\ndef black_scholes_call(S0, K, T, r, sigma, q):\n    \"\"\"Black-Scholes formula for European call options.\"\"\"\n    d1 = (np.log(S0 / K) + (r -q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return np.exp(-q * T)*S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n\n# Compute Black-Scholes prices\ncall_prices_bs = black_scholes_call(S0, K, T, r, sigma, q)\n\n# Plot comparison\nplt.figure(figsize=(10, 6))\nplt.plot(K, call_prices_fft, label='Carr-Madan FFT Price', linestyle='--')\nplt.plot(K, call_prices_bs, label='Black-Scholes Price', alpha=0.7)\nplt.xlabel('Strike Price K')\nplt.ylabel('Option Price')\nplt.title('Comparison of Carr-Madan FFT and Black-Scholes Prices')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Optionally, plot the absolute difference\nplt.figure(figsize=(10, 6))\nplt.plot(K, np.abs(call_prices_fft - call_prices_bs), label='Absolute Difference')\nplt.xlabel('Strike Price K')\nplt.ylabel('Price Difference')\nplt.title('Absolute Difference between Carr-Madan FFT and Black-Scholes Prices')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPricing a European Call Option under the Heston (1993) Model\nIn the Heston stochastic volatility model (Heston 1993), the dynamics of the asset price \\(S_t\\) and its variance \\(v_t\\) are given by the following stochastic differential equations (SDEs):\n\\[\ndS_t = \\mu S_t dt + \\sqrt{v_t} S_t dW_t^S\n\\] \\[\ndv_t = \\kappa(\\theta - v_t)dt + \\sigma \\sqrt{v_t} dW_t^v\n\\]\nWhere \\(v_t\\) is the stochastic variance, \\(\\kappa\\) is the rate at which \\(v_t\\) reverts to the long-term mean \\(\\theta\\), \\(\\sigma\\) is the volatility of volatility, \\(W_t^S\\) and \\(W_t^v\\) are two Wiener processes with correlation coefficient \\(\\rho\\).\nThe characteristic function is more complex and involves solving a system of differential equations. The characteristic function of \\(\\ln(S_t)\\) for the Heston model is given by (for derivation details, see Heston (1993)):\n\\[\n\\begin{multline}\n\\phi(u) = \\exp\\left\\{ i u \\left( \\ln(S_0) + (r-q) T \\right) + \\frac{\\kappa \\theta}{\\sigma^2} \\left[ (b - d) T - 2 \\ln\\left( \\frac{1 - g e^{-d T}}{1 - g} \\right) \\right]\\\\ + \\frac{b - d}{\\sigma^2} \\left( \\frac{1 - e^{-d T}}{1 - g e^{-d T}} \\right) v_0 \\right\\},\n\\end{multline}\n\\] where \\[\n\\begin{aligned}\nb &= \\kappa +\\lambda- \\rho \\sigma i u, \\\\\nd &= \\sqrt{( \\rho \\sigma i u - b )^2 + \\sigma^2 (i u + u^2)}, \\\\\ng &= \\frac{b - d}{b + d}, \\\\\n\\end{aligned}\n\\] \\(v_0\\) is the initial variance (volatility squared), \\(q\\) is the dividend yield, \\(\\theta\\) is the long-term mean of the variance, \\(\\kappa\\) is the rate at which the variance reverts to \\(\\theta\\), \\(\\rho\\) is the correlation between the asset price and its volatility, \\(\\sigma\\) is the volatility of volatility, and \\(\\lambda\\) is the volatility risk premium.\nThe following Python code implements the Carr-Madan method to price a European call option under the Heston Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n\n# -----------------------------\n# 1. Define Heston Model Parameters\n# -----------------------------\n\n# Market parameters\nS0 = 100        # Initial stock price\nr = 0.05        # Risk-free interest rate\nq = 0.02        # Dividend yield\nT = 1.0         # Time to maturity (in years)\n\n# Heston model parameters\nkappa = 1.5     # Speed of mean reversion of variance\ntheta = 0.04    # Long-term variance\nsigma_v = 0.3   # Volatility of variance (vol of vol)\nrho = -0.7      # Correlation between asset and variance\nv0 = 0.04       # Initial variance\n\n# Carr-Madan parameters (Enhanced)\nalpha = 1.5             # Dampening factor (&gt; 0)\nN = 2**16             # Number of FFT points (power of 2)\neta = 0.25              # Spacing of the grid in Fourier space\nlambda_ = (2 * np.pi) / (N * eta)  # Spacing in log-strike space\nb = N * lambda_ / 2  # Upper bound of log-strike\n\n# Monte Carlo simulation parameters (Enhanced)\nnum_paths = 100000     # Number of simulated paths\nnum_steps = 500        # Number of time steps\n\n# -----------------------------\n# 2. Define the Heston Characteristic Function\n# -----------------------------\n\ndef heston_char_func(u, T, kappa, theta, sigma_v, rho, v0, r, q, S0):\n    \"\"\"\n    Characteristic function of log(S_T) under the Heston model.\n    \"\"\"\n    i = 1j\n    sigma = sigma_v\n\n    d = np.sqrt((rho * sigma * i * u - kappa) ** 2 + sigma ** 2 * (i * u + u ** 2))\n    g = (kappa - rho * sigma * i * u - d) / (kappa - rho * sigma * i * u + d)\n\n    exp_dT = np.exp(-d * T)\n\n    C = (np.log(S0)+(r-q)*T) * i * u  + (kappa * theta / sigma ** 2) * ((kappa - rho * sigma * i * u - d) * T - 2 * np.log((1 - g * exp_dT) / (1 - g)))\n\n    D = ((kappa - rho * sigma * i * u - d) / sigma ** 2) * (\n        (1 - exp_dT) / (1 - g * exp_dT)\n    )\n\n    phi = np.exp(C + D * v0)\n    return phi\n\n# -----------------------------\n# 3. Carr-Madan Option Pricing Function (Enhanced)\n# -----------------------------\n\ndef carr_madan_call_price(S0, r, q, T, kappa, theta, sigma_v, rho, v0, alpha, N, eta):\n    \"\"\"\n    Calculate the European call option prices using Carr-Madan method under Heston model.\n    \"\"\"\n    i = 1j\n    # Step 1: Compute the modified characteristic function\n    u = np.arange(N) * eta  # u values\n\n    # Avoid division by zero\n    u[0] = 1e-22\n\n    # Characteristic function with dampening factor\n    phi = np.exp(-r * T) * heston_char_func(u - (alpha + 1) * i, T, kappa, theta, sigma_v, rho, v0, r, q, S0) \\\n        / (alpha ** 2 + alpha - u ** 2 + i * (2 * alpha + 1) * u)\n\n    # Step 2: Apply Simpson's Rule weights\n    SimpsonW = np.ones(N)\n    SimpsonW[0] = 1\n    SimpsonW[1:N-1:2] = 4\n    SimpsonW[2:N-2:2] = 2\n    SimpsonW[-1] = 1\n    SimpsonW = SimpsonW * (eta / 3)\n\n    # Step 3: Compute the FFT\n    x = phi * np.exp(i * b * u) * SimpsonW\n    fft_x = np.fft.fft(x)\n    fft_x = np.real(fft_x)\n\n    # Step 4: Recover the call prices\n    k = -b + np.arange(N) * lambda_\n    K = np.exp(k)\n    call_prices = np.exp(-alpha * k) / np.pi * fft_x\n\n    return K, call_prices\n\n# -----------------------------\n# 4. Monte Carlo Simulation Function (Enhanced)\n# -----------------------------\n\ndef heston_simulation(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps):\n    \"\"\"\n    Simulate asset price paths under the Heston model using antithetic variates.\n    \"\"\"\n    dt = T / num_steps\n    sqrt_dt = np.sqrt(dt)\n    np.random.seed(0)  # For reproducibility\n\n    num_paths_half = num_paths // 2\n\n    # Initialize arrays\n    S = np.zeros((num_paths, num_steps + 1))\n    v = np.zeros((num_paths, num_steps + 1))\n\n    # Set initial values\n    S[:, 0] = S0\n    v[:, 0] = v0\n\n    # Cholesky decomposition for correlated Brownian motions\n    cov_matrix = np.array([[1.0, rho], [rho, 1.0]])\n    L = np.linalg.cholesky(cov_matrix)\n\n    for t in range(1, num_steps + 1):\n        # Generate standard normal random variables\n        Z = np.random.randn(num_paths_half, 2)\n        Z_antithetic = -Z  # Antithetic variates\n        Z_full = np.vstack((Z, Z_antithetic))\n\n        # Correlated random variables\n        dW = np.dot(Z_full, L.T) * sqrt_dt\n\n        # Update variance process using full truncation Euler scheme\n        v_prev = v[:, t - 1]\n        sqrt_v_prev = np.sqrt(np.maximum(v_prev, 0))\n        dv = kappa * (theta - np.maximum(v_prev, 0)) * dt + sigma_v * sqrt_v_prev * dW[:, 1]\n        v[:, t] = np.maximum(v_prev + dv, 0)  # Ensure variance is non-negative\n\n        # Update asset price\n        S_prev = S[:, t - 1]\n        S[:, t] = S_prev * np.exp((r - q - 0.5 * np.maximum(v_prev, 0)) * dt + sqrt_v_prev * dW[:, 0])\n\n    # Return asset prices at maturity\n    return S[:, -1]\n\ndef heston_option_pricing(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps, K_values):\n    \"\"\"\n    Price European call options using Monte Carlo simulation under the Heston model.\n    \"\"\"\n    # Simulate asset prices at maturity\n    S_T = heston_simulation(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps)\n\n    # Initialize array for call prices\n    call_prices = np.zeros_like(K_values)\n\n    # Discount factor\n    discount_factor = np.exp(-r * T)\n\n    # Calculate option prices for each strike price\n    payoffs_matrix = np.maximum(S_T[:, np.newaxis] - K_values, 0)\n    call_prices = discount_factor * np.mean(payoffs_matrix, axis=0)\n\n    return call_prices\n\n# -----------------------------\n# 5. Calculate Option Prices Using Both Methods\n# -----------------------------\n\n# Carr-Madan method\nstart_time_cm = time.time()\nK_cm, call_prices_cm = carr_madan_call_price(\n    S0, r, q, T, kappa, theta, sigma_v, rho, v0, alpha, N, eta\n)\nend_time_cm = time.time()\ntime_cm = end_time_cm - start_time_cm\n\n# Select strike prices between 60 and 140\nK_indices = np.where((K_cm &gt;= 60) & (K_cm &lt;= 140))\nK_cm = K_cm[K_indices]\ncall_prices_cm = call_prices_cm[K_indices]\n\n# Monte Carlo simulation\nK_mc = np.linspace(60, 140, 81)\nstart_time_mc = time.time()\ncall_prices_mc = heston_option_pricing(\n    S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps, K_mc\n)\nend_time_mc = time.time()\ntime_mc = end_time_mc - start_time_mc\n\n# -----------------------------\n# 6. Compute Price Differences\n# -----------------------------\n\n# Interpolate Carr-Madan prices to match K_mc\ncall_prices_cm_interp = np.interp(K_mc, K_cm, call_prices_cm)\n\n# Compute price differences\nprice_differences = np.abs(call_prices_cm_interp - call_prices_mc)\nmax_diff = np.max(price_differences)\n\n# -----------------------------\n# 7. Plot the Option Prices\n# -----------------------------\n\nplt.figure(figsize=(10, 6))\nplt.plot(K_mc, call_prices_cm_interp, label='Carr-Madan Method', color='blue', linewidth=2)\nplt.plot(K_mc, call_prices_mc, label='Monte Carlo Simulation', color='red', linestyle='--', linewidth=2)\nplt.xlabel('Strike Price K', fontsize=14)\nplt.ylabel('Option Price', fontsize=14)\nplt.title('European Call Option Prices under Heston Model', fontsize=16)\nplt.grid(True)\nplt.legend(fontsize=12)\nplt.show()\n\n\n# -----------------------------\n# 8. Plot Price Differences\n# -----------------------------\n\nplt.figure(figsize=(10, 6))\nplt.plot(K_mc, price_differences, label='Price Difference (Carr-Madan - MC)', color='green', linewidth=2)\nplt.xlabel('Strike Price K', fontsize=14)\nplt.ylabel('Price Difference', fontsize=14)\nplt.title('Price Differences between Carr-Madan and Monte Carlo Methods', fontsize=16)\nplt.grid(True)\nplt.legend(fontsize=12)\nplt.show()\n\n# -----------------------------\n# 9. Report Computation Times and Maximum Price Difference\n# -----------------------------\n\nprint(f\"Computation Time (Carr-Madan Method): {time_cm:.2f} seconds\")\nprint(f\"Computation Time (Monte Carlo Simulation): {time_mc:.2f} seconds\")\nprint(f\"Maximum Price Difference: {max_diff:.6f}\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputation Time (Carr-Madan Method): 0.06 seconds\nComputation Time (Monte Carlo Simulation): 5.76 seconds\nMaximum Price Difference: 0.024669\n\n\n\n\nPricing Options When Stock Price Follows a Lévy Process\nA Lévy process is a type of stochastic process with stationary, independent increments, generalizing Brownian motion and Poisson processes. It is widely used in various fields like finance, physics, and stochastic modeling due to its ability to model random jumps and continuous changes over time.\nKey Properties of a Lévy Process:\n\nIndependent Increments: The changes (increments) in the process over non-overlapping time intervals are independent. For example, the change in the process from time \\(t_1\\) to \\(t_2\\) is independent of the change from time \\(t_3\\) to \\(t_4\\) if \\(t_1 \\leq t_2 \\leq t_3 \\leq t_4\\).\nStationary Increments: The distribution of the increment of the process depends only on the length of the time interval, not the specific time at which the interval starts. That is, the increment between times \\(t\\) and \\(t+s\\) has the same distribution as the increment between times 0 and \\(s\\).\nStochastic Continuity: For every \\(\\epsilon &gt; 0\\) and \\(t \\geq 0\\), the probability that the change in the process over a small interval \\(h\\) becomes large tends to zero as \\(h \\to 0\\). Formally, \\[ \\lim_{h \\to 0} P(|X(t+h) - X_t| \\geq \\epsilon) = 0.\n\\]\nInitial Condition: Typically, a Lévy process starts at zero, \\(X_0 = 0\\).\n\nExamples of Lévy Processes:\n\nBrownian Motion (Wiener Process): A Lévy process with continuous paths and normally distributed increments.\nPoisson Process: A Lévy process where the increments represent the number of jumps (events) in a given time period, with the number of jumps following a Poisson distribution.\nJump Diffusion Process: A Lévy process where jumps occur at random times, with the size of each jump following a specified distribution.\nVariance Gamma: A Lévy process characterized by heavy-tailed distributions, often used to model extreme events or large movements (jumps).\n\nThe characteristic function of any Lévy process \\(X_t\\) can be expressed using the Lévy-Khintchine formula: \\[\n\\mathbb{\\\\E}[e^{itX_t}] = e^{t\\psi_t},\n\\] where \\(\\psi_t\\) is called the Lévy exponent and has the form: \\[\n\\psi_t = i\\gamma t - \\frac{1}{2} \\sigma^2 t^2 + \\int_{\\mathbb{R}} \\left( e^{itx} - 1 - itx \\mathbf{1}_{|x| &lt; 1} \\right) \\nu(dx).\n\\]\nIn this formula, \\(\\gamma\\) is the drift term (linear component), \\(\\sigma^2\\) is the variance of the continuous Gaussian component, \\(\\nu\\) is the Lévy measure, which controls the intensity and size of jumps.\nLévy processes can thus combine continuous movements, such as Brownian motion, with jumps, providing a powerful framework for modeling both smooth and abrupt changes in time series.\nPricing Options in the Variance Gamma Model\nLet \\(S_t\\) represent the stock price at time \\(t\\). Under the risk-neutral probability \\(\\mathbb{Q}\\), the stock price evolves as:\n\\[\nS_t = S_0 \\exp(X_t),\n\\] where \\(X_t\\) is a variance gamma process: \\[\nX_t = \\left( (r - q) - \\frac{1}{2} \\sigma^2 - \\frac{1}{\\nu} \\log\\left(1 - \\theta \\nu - \\frac{1}{2} \\sigma^2 \\nu \\right) \\right)t + \\sigma W(G_t)\n\\] where \\(r\\) is the risk-free rate, \\(q\\) is the dividend yield, \\(\\sigma\\) is the volatility parameter, \\(G_t\\) is a Gamma process with mean rate \\(t\\) and variance rate \\(\\nu\\), \\(\\theta\\) controls the drift of the VG process, \\(\\nu\\) is the variance rate of the Gamma process, and \\(W_t\\) is a standard Brownian motion under the risk-neutral probability \\(\\mathbb{Q}\\).\nThe characteristic function of \\(\\log(S_t)\\) under the risk-neutral probability is:\n\\[\n\\phi_{\\log(S_t)}^{\\mathbb{Q}}(u) = e^{iu \\log(S_0)} \\left( \\frac{1}{1 - iu \\theta_{\\mathbb{Q}} \\nu + \\frac{1}{2} \\sigma^2 u^2 \\nu} \\right)^{t/\\nu},\n\\] where \\[\n\\theta_{\\mathbb{Q}} = (r - q) - \\frac{1}{2} \\sigma^2 - \\frac{1}{\\nu} \\log\\left(1 - \\theta \\nu - \\frac{1}{2} \\sigma^2 \\nu \\right).\n\\]\nThe following Python code implements the Carr-Madan method to price a European call option under the Variance Gamma Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation.\n\n\nCode\nimport numpy as np\nfrom numpy.fft import fft\nimport matplotlib.pyplot as plt\nimport time\n\n# Market and option parameters\nS0 = 100        # Initial stock price\nr = 0.05        # Risk-free rate\nq = 0.0         # Dividend yield\nT = 1.0         # Time to maturity\n\n# Variance Gamma parameters\nsigma = 0.12    # Volatility parameter\nnu = 0.2        # Variance rate of the Gamma process\ntheta = -0.14   # Drift parameter\n\n# Strike prices\nK = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\n\n# Carr-Madan method parameters\nalpha = 5.0     # Damping factor (&gt; 0), increased for better convergence\nN = 2**14       # Number of FFT points (must be even for Simpson's Rule)\neta = 0.05      # Spacing in the frequency domain, decreased for better accuracy\n\n# Ensure N is even for Simpson's Rule\nif N % 2 != 0:\n    N += 1\n\n# Start timing the Carr-Madan method\nstart_time_fft = time.time()\n\n# Compute the grid in the frequency domain (v)\nv = np.arange(N) * eta  # v_j = j * eta\n\n# Compute the grid in the log-strike domain (k)\nlambda_ = (2 * np.pi) / (N * eta)\nb = N * lambda_ / 2     # Upper limit for k\nk = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n\ndef phi(u):\n    \"\"\"\n    characteristic function of log(S_T) under the Variance Gamma model.\n    \"\"\"\n    i = 1j\n    omega = (1 / nu) * np.log(1 - theta * nu - 0.5 * sigma**2 * nu)\n    drift = r - q - omega  \n    phi_u = np.exp(i * u * (np.log(S0) + drift * T)) * \\\n            (1 - i * theta * nu * u + 0.5 * sigma**2 * nu * u**2) ** (-T / nu)\n    return phi_u\n\n# Adjusted characteristic function\nu = v - (alpha + 1) * 1j\npsi = (np.exp(-r * T) * phi(u)) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n\n#   Simpson's Rule weights\nw = np.ones(N)\nw[0] = w[-1] = 1\nw[1:-1:2] = 4  # Weights for odd indices\nw[2:-1:2] = 2  # Weights for even indices\nw = w * (eta / 3)\n\n# Function to be transformed\nfft_input = psi * np.exp(-1j * v * b) * w  #   sign in exponential term\n\n# Apply the FFT\nfft_output = fft(fft_input)\n\n# Compute the option prices\nC_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n\n# Convert log-strike grid to strike prices\nK_fft = np.exp(k)\n\n# Interpolate the option prices at desired strikes\ncall_prices_fft = np.interp(K, K_fft, C_k)\n\n# End timing the Carr-Madan method\nend_time_fft = time.time()\ntime_fft = end_time_fft - start_time_fft\n\n# Monte Carlo simulation with variance reduction\ndef vg_process_mc(S0, T, r, q, sigma, theta, nu, M):\n    \"\"\"\n    Monte Carlo simulation for the Variance Gamma process with antithetic variates.\n    \"\"\"\n    np.random.seed(0)  # For reproducibility\n\n    # Simulate Gamma process\n    N_sim = T / nu\n    G = np.random.gamma(N_sim, nu, M)\n\n    # Antithetic variates for Z\n    Z = np.random.randn(M)\n    Z_antithetic = -Z\n\n    # VG process for original Z\n    X = theta * G + sigma * np.sqrt(G) * Z\n    # VG process for antithetic Z\n    X_antithetic = theta * G + sigma * np.sqrt(G) * Z_antithetic\n\n    # Adjusted drift to ensure martingale\n    omega = (1 / nu) * np.log(1 - theta * nu - 0.5 * sigma**2 * nu)\n    drift = (r - q - omega) * T  #   drift\n\n    # Simulate stock prices at maturity\n    ST = S0 * np.exp(drift + X)\n    ST_antithetic = S0 * np.exp(drift + X_antithetic)\n\n    # Combine the two sets of simulated prices\n    ST_combined = np.concatenate((ST, ST_antithetic))\n\n    return ST_combined\n\nM = 500000  # Number of simulations (total simulations will be 1,000,000 with antithetic variates)\n\n# Start timing the Monte Carlo method\nstart_time_mc = time.time()\n\n# Simulate stock prices\nST_combined = vg_process_mc(S0, T, r, q, sigma, theta, nu, M)\n\n# Compute payoffs\npayoffs = np.maximum(ST_combined[:, np.newaxis] - K, 0)\n\n# Discounted option prices\ncall_prices_mc = np.exp(-r * T) * np.mean(payoffs, axis=0)\n\n# End timing the Monte Carlo method\nend_time_mc = time.time()\ntime_mc = end_time_mc - start_time_mc\n\n# Compute the price differences\nprice_differences = call_prices_fft - call_prices_mc\n\n\n# Plot comparison\nplt.figure(figsize=(10, 6))\nplt.plot(K, call_prices_fft, label='Carr-Madan FFT Price (VG)', linestyle='--')\nplt.plot(K, call_prices_mc, label='Monte Carlo Price (VG)', alpha=0.7)\nplt.xlabel('Strike Price K')\nplt.ylabel('Option Price')\nplt.title('Comparison of Carr-Madan FFT and Monte Carlo Prices (VG)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Plot the differences in prices\nplt.figure(figsize=(10, 6))\nplt.plot(K, price_differences, label='Price Difference (FFT - MC)')\nplt.xlabel('Strike Price K')\nplt.ylabel('Price Difference')\nplt.title('Difference in Option Prices between Carr-Madan FFT and Monte Carlo (VG)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Calculate the maximum absolute difference\nmax_difference = np.max(np.abs(price_differences))\nprint(f\"Maximum Absolute Price Difference: {max_difference:.6f}\")\n\n# Print computational times\nprint(f\"Computational Time (Carr-Madan FFT): {time_fft:.6f} seconds\")\nprint(f\"Computational Time (Monte Carlo): {time_mc:.6f} seconds\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMaximum Absolute Price Difference: 0.010150\nComputational Time (Carr-Madan FFT): 0.022629 seconds\nComputational Time (Monte Carlo): 0.493940 seconds\n\n\nPricing Options in a Jump Diffusion Model\nA jump diffusion process is a type of stochastic process that extends a standard diffusion process, such as Brownian motion, by including random jumps. This model (e.g., Merton 1976) is widely used in financial mathematics to capture sudden, discontinuous changes in asset prices, interest rates, or other time series that are not explained by continuous diffusive processes alone.\nLet \\(S_t\\) represent the stock price at time \\(t\\), and under the risk-neutral probability \\(\\mathbb{Q}\\), the stock price follows a jump diffusion process. The stock price dynamics can be described by:\n\\[\ndS_t = (r - q) S_t dt + \\sigma S_t dW_t + S_t dJ_t\n\\]\nwhere \\(r\\) is the risk-free rate, \\(q\\) is the continuous dividend yield, \\(\\sigma\\) is the volatility of the Brownian motion component, \\(W_t\\) is a standard Brownian motion under the risk-neutral probability, and the jump process \\(J_t\\) follows: \\[\nJ_t = \\sum_{i=1}^{N_t} (Y_i - 1),\n\\] where \\(N_t\\) is a Poisson process with intensity \\(\\lambda\\), representing the number of jumps up to time \\(t\\), and \\(Y_i\\) is the jump size, often modeled as a random variable from a log-normal distribution such that \\(\\log(Y_i) \\sim \\mathcal{N}(\\mu_J, \\sigma_J^2)\\).\nThus, the stock price is driven by both the diffusion term (due to the Brownian motion) and the jump term (due to the Poisson process).\nThe solution to the stochastic differential equation (SD\\E) for \\(S_t\\) can be expressed as:\n\\[\nS_t = S_0 \\exp\\left( (r - q - \\frac{1}{2}\\sigma^2)t + \\sigma W_t + \\sum_{i=1}^{N_t} \\log(Y_i) \\right)\n\\]\nThis shows that the stock price incorporates both continuous changes (via the \\(W_t\\) term) and discrete jumps (via the \\(\\sum_{i=1}^{N_t} \\log(Y_i)\\) term).\nThe characteristic function of \\(\\log(S_t)\\) under the risk-neutral probability is:\n\\[\n\\phi_{\\log(S_t)}^{\\mathbb{Q}}(u) = e^{iu \\log(S_0)} \\exp\\left( iu (r - q - \\frac{1}{2} \\sigma^2) t - \\frac{1}{2} u^2 \\sigma^2 t \\right)\n\\cdot \\exp\\left( \\lambda t \\left( \\exp\\left( iu \\mu_J - \\frac{1}{2} u^2 \\sigma_J^2 \\right) - 1 \\right) \\right)\n\\]\nThis formula captures both the diffusion (Brownian motion) and jump components, making it applicable for more accurate modeling of stock prices that experience sudden jumps in addition to continuous fluctuations.\nThe following Python code implements the Carr-Madan method to price a European call option under the Jump Diffusion Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation.\n\n\nCode\nimport numpy as np\nfrom numpy.fft import fft\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt\nimport time\n\n# Market and option parameters\nS0 = 100       # Initial stock price\nr = 0.05       # Risk-free rate\nq = 0.0        # Dividend yield\nT = 0.1        # Time to maturity\n\n# Volatility\nsigma = 0.2    # Volatility of diffusion component\n\n# Jump parameters\nlam = 0.1      # Jump intensity (lambda)\nmu_j = -0.1    # Mean of jump size (mu_J)\nsigma_j = 0.3  # Standard deviation of jump size (sigma_J)\n\n# Calculated parameter kappa\nkappa = np.exp(mu_j + 0.5 * sigma_j**2) - 1\n\n# Strike prices\nK = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\n\n# Carr-Madan method parameters\nalpha = 1.5    # Damping factor (&gt; 0)\nN = 2**16      # Number of FFT points (must be even for Simpson's Rule)\neta = 0.05     # Spacing in the frequency domain (smaller for higher accuracy)\n\n# Ensure N is even for Simpson's Rule\nif N % 2 != 0:\n    N += 1\n\n# Start timing the Carr-Madan method\nstart_time_fft = time.time()\n\n# Compute the grid in the frequency domain (v)\nv = np.arange(N) * eta  # v_j = j * eta\n\n# Compute the grid in the log-strike domain (k)\nlambda_ = (2 * np.pi) / (N * eta)\nb = N * lambda_ / 2     # Upper limit for k\nk = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n\ndef phi(u):\n    \"\"\"\n    Characteristic function of log(S_T) under the Merton Jump-Diffusion model.\n    \"\"\"\n    i = 1j\n    mu = np.log(S0) + (r - q - lam * kappa - 0.5 * sigma**2) * T\n    variance = sigma**2 * T\n    phi_jump = lam * T * (np.exp(i * u * mu_j - 0.5 * sigma_j**2 * u**2) - 1)\n    cf = np.exp(i * u * mu - 0.5 * variance * u**2 + phi_jump)\n    return cf\n\n# Adjusted characteristic function\nu = v - (alpha + 1) * 1j\npsi = np.exp(-r * T) * phi(u) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n\n#   Simpson's Rule weights\nw = np.ones(N)\nw[0] = w[-1] = 1\nw[1:-1:2] = 4  # Weights for odd indices\nw[2:-1:2] = 2  # Weights for even indices\nw = w * (eta / 3)\n\n# Function to be transformed\nfft_input = psi * np.exp(-1j * v * b) * w\n\n# Apply the FFT\nfft_output = fft(fft_input)\n\n# Compute the option prices\nC_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n\n# Convert log-strike grid to strike prices\nK_fft = np.exp(k)\n\n# Interpolate the option prices at desired strikes\ncall_prices_fft = np.interp(K, K_fft, C_k)\n\n# End timing the Carr-Madan method\nend_time_fft = time.time()\ntime_fft = end_time_fft - start_time_fft\n\n# Monte Carlo simulation\ndef merton_jump_diffusion_mc(S0, K, T, r, q, sigma, lam, mu_j, sigma_j, M):\n    \"\"\"\n    Monte Carlo simulation for European call option under Merton jump-diffusion model.\n    \"\"\"\n    np.random.seed(0)  # For reproducibility\n    drift = (r - q - lam * kappa - 0.5 * sigma**2) * T\n    diffusion = sigma * np.sqrt(T) * np.random.randn(M)\n\n    # Simulate number of jumps for each path\n    N_jumps = np.random.poisson(lam * T, M)\n\n    # Simulate jump sizes\n    sum_Y = np.zeros(M)\n    idx = np.where(N_jumps &gt; 0)[0]\n    for i in idx:\n        Y_i = np.random.normal(mu_j, sigma_j, N_jumps[i])\n        sum_Y[i] = np.sum(Y_i)\n\n    # Compute log stock price at maturity\n    ln_ST = np.log(S0) + drift + diffusion + sum_Y\n\n    ST = np.exp(ln_ST)\n\n    # Compute payoff for each simulation\n    payoffs = np.maximum(ST[:, np.newaxis] - K, 0)\n\n    # Discount back\n    C_MC = np.exp(-r * T) * np.mean(payoffs, axis=0)\n\n    return C_MC\n\nM = 100000  # Number of simulations\n\n# Start timing the Monte Carlo method\nstart_time_mc = time.time()\ncall_prices_mc = merton_jump_diffusion_mc(S0, K, T, r, q, sigma, lam, mu_j, sigma_j, M)\nend_time_mc = time.time()\ntime_mc = end_time_mc - start_time_mc\n\n# Compute the price differences\nprice_differences = call_prices_fft - call_prices_mc\n\n\n# Plot comparison\nplt.figure(figsize=(10, 6))\nplt.plot(K, call_prices_fft, label='Carr-Madan FFT Price ', linestyle='--')\nplt.plot(K, call_prices_mc, label='Monte Carlo Price (JD)', alpha=0.7)\nplt.xlabel('Strike Price K')\nplt.ylabel('Option Price')\nplt.title('Comparison of Carr-Madan FFT and Monte Carlo Prices (JD)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Plot the differences in prices\nplt.figure(figsize=(10, 6))\nplt.plot(K, price_differences, label='Price Difference (FFT - MC)')\nplt.xlabel('Strike Price K')\nplt.ylabel('Price Difference')\nplt.title('Difference in Option Prices between Carr-Madan FFT and Monte Carlo (JD)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Print computational times\nprint(f\"Computational Time (Carr-Madan FFT): {time_fft:.6f} seconds\")\nprint(f\"Computational Time (Monte Carlo): {time_mc:.6f} seconds\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputational Time (Carr-Madan FFT): 0.021696 seconds\nComputational Time (Monte Carlo): 0.063854 seconds",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#section",
    "href": "Chapter_Fourier.html#section",
    "title": "23  Fourier Transforms",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nCreate a Python code to compare the Carr-Madan method with the direct Fourier Transform method using Equation 23.1 for pricing in-the-money, at-the-money, and out-of-the-money European call options in terms of speed and accuracy in the Black-Scholes model.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code to let users input all the parameter values in the jump diffusion model and use the Carr-Madan method to price European put options in this model.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code to let users input all the parameter values in the Heston model and use the Carr-Madan method to price European put options in this model.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code to show how the speed and accuracy change as one varies the damping factor \\(\\alpha\\) and the strike price spacing \\(\\eta\\) in the jump diffusion model.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#references",
    "href": "Chapter_Fourier.html#references",
    "title": "23  Fourier Transforms",
    "section": "23.5 References",
    "text": "23.5 References\n\nCarr, P., & Madan, D. B. (1999). Option valuation using the fast Fourier transform. Journal of Computational Finance, 2(4), 61-73.\nBlack, F., & Scholes, M. (1973). The pricing of options and corporate liabilities. Journal of Political Economy, 81(3), 637-654.\n\n\n\n\n\nCarr, P., and D. B. Madan. 1999. “Option Valuation Using the Fast Fourier Transform.” Journal of Computational Finance 2: 61–73.\n\n\nHeston, S. 1993. “A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.” Review of Financial Studies 6: 327–44.\n\n\nMerton, R. 1976. “Option Pricing When Underlying Stock Returns Are Discontinuous.” Journal of Financial Economics 3: 125–44.",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_Fourier.html#footnotes",
    "href": "Chapter_Fourier.html#footnotes",
    "title": "23  Fourier Transforms",
    "section": "",
    "text": "NOte that because for FFT to work efficiently, we need \\(N\\) to be even, but for the Simpson’s rule, we need even number of subintervals, i.e., \\(N\\) to be odd. In practice, we choose \\(N\\) to be even and ignore the last point evaluation for the Simpson’s weight \\(w(N+1)\\). When the spacing interval is small, the error from this omission is small.↩︎\nFor options with very short maturities, the pricing errors for close-to-money options because the value approaches the non-analytic intrinsic value. Adjusting the Fourier transform parameter values (e.g., \\(N\\) and \\(\\eta\\)) may be necessary.\nAn alternative method proposed by Carr and Madan (1999) may also be used. See Carr and Madan (1999) for details. ↩︎",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Fourier Transforms</span>"
    ]
  },
  {
    "objectID": "Chapter_MachineLearning.html",
    "href": "Chapter_MachineLearning.html",
    "title": "24  Machine Learning",
    "section": "",
    "text": "24.1 Latex\nTrying to get latex to work. Still works test commit 2/25 ~Austin\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nsigma = 1\nt = 1\n\n# Brownian path\nn = 1000   \ndt = t/n\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\nB = np.zeros(n+1)\nB[1:] = np.cumsum(dB)\n\n# Brownian path with discrete steps\nn_discrete = 10\nDelta_t = t/n_discrete\nB_discrete = B[::int(n/n_discrete)]\nDeltaB = np.diff(B_discrete)\n\n# X in discrete-time \nX1 = np.ones(n_discrete+1)\nfor i in range(1, n_discrete+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Delta_t + sigma * X1[i-1] * DeltaB[i-1]\n\n# Continuous-time\nX2 = np.exp((mu - 0.5 * sigma**2) * np.arange(0, t+dt, dt) + sigma * B)\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Delta_t, Delta_t), \n        y=X1, \n        mode='lines+markers', \n        line={'shape': 'spline', 'smoothing': 0},\n        name=r'$X_{ti}-X_{ti-1}$',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+dt, dt), \n        y=X2, \n        mode='lines', \n        name=r'$dX_t$',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    width=450,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()",
    "crumbs": [
      "Part VI: Numerical Methods",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Machine Learning</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html",
    "href": "Chapter_FixedIncome.html",
    "title": "25  Fixed-Income Concepts",
    "section": "",
    "text": "25.1 The Yield Curve\nIn this part of the book, we will study the pricing and hedging of fixed-income derivatives, that is, derivatives that can be viewed as written on bonds or on interest rates. The complexities of this subject stem from the fact that the underlying bonds or rates will have time-varying and generally random volatilities and have volatilities that must be linked in some way to each other. We are not free to arbitrarily specify the volatilities and correlations, as we can, for example, with basket equity options, because such a specification may imply there is an arbitrage opportunity available from trading the underlying assets, and, of course, one could not trust a derivative value or a hedging strategy derived from such a model. There are many books that provide a more comprehensive and advanced treatment than we will be able to give here, among which Rebonato (Rebonato 1998, Rebonato02), James and Webber (James and Webber 200AD) and Brigo and Mercurio (Brigo and Mercurio 2001) seem particularly useful.\nWe will focus on derivatives and underlyings that have very little default risk and ignore the pricing of default (credit) risk. Credit risk and credit derivatives are booming areas in both theory and practice. For this topic, one can consult the recent books of Bielecki and Rutkowski (Bielecki and Rutkowski 2002), Duffie and Singleton (Duffie and Singleton 2003), Sch{\"o}nbucher (Schönbucher 2003), and Tavakoli (Tavakoli 2001). Another important topic that will not be covered is mortgages.\nIn the first section, we introduce a fundamental construct: the yield curve, by which we mean the yields of (possibly theoretical) zero-coupon bonds of various maturities. The last two sections of the chapter (on principal components) are optional—nothing else in the book builds upon them.\nGiven prices of discount (zero-coupon) bonds of all maturities, any coupon paying bond can be priced as a portfolio of discount bonds. The relationship between time to maturity and the price of the corresponding discount bond with $1 face value is sometimes called the discount function. An equivalent concept is the yield curve, which is the relationship between time to maturity and the yield of the corresponding discount bond. Yields can be quoted according to different compounding conventions (semi-annual being the most common), but we will continue to use continuous compounding.^[The relationship between the annually compounded rate \\(y_a\\), the semi-annually compounded rate \\(y_s\\) and the continuously compounded rate \\(y_c\\) is \\(\\mathrm{e}^{y_c} = 1+y_a = (1+y_s/2)^2\\).} With this convention, the yield of a zero-coupon bond with $1 face value having \\(\\tau\\) years to maturity and price \\(P\\) is defined to be the rate \\(y\\) such that \\(P = \\mathrm{e}^{-y\\tau}\\). Denoting this yield \\(y\\) at maturity \\(\\tau\\) by \\(y(\\tau)\\), the yield curve is the collection of yields \\(\\{y(\\tau)| \\tau&gt;0\\}\\), conventionally plotted with maturity \\(\\tau\\) on the horizontal axis and the yields \\(y(\\tau)\\) on the vertical. Usually (but certainly not always) this is an upward sloping curve, meaning that rates at longer maturities are higher than rates at shorter maturities.\nSome amount of estimation is necessary to compute the yield curve. We would like to know yields at arbitrary maturities, but there are not enough actively traded zero-coupon bonds to provide this information. Thus, we have to fill in the missing maturities. We may also use coupon-paying bonds (or swap rates, as we will discuss later) to estimate the yields.\nThe most popular method of estimating the yield curve from bond prices is to fit a cubic spline, using the prices of a finite set of actively traded bonds. Given the set of bonds, let \\(P_i\\) denote the price of bond \\(i\\), \\(N_i\\) the number of dates at which bond \\(i\\) pays a coupon or its face value, and \\(\\{\\tau_{ij}| j=1, \\ldots, N_i\\}\\) the dates at which bond \\(i\\) pays a coupon or its face value. Finally, let \\(C_{ij}\\) denote the cash flow paid by bond \\(i\\) at date \\(\\tau_{ij}\\) for \\(j=1,\\ldots,N_i\\). Then for each \\(i\\) it should be the case that \\[\nP_i = \\sum_{j=1}^{N_i} \\mathrm{e}^{-y(\\tau_{ij})\\tau_{ij}}C_{ij}\\;.\n\\qquad(25.1)\\]\nThis simply says that the price should be the present value of the cash flows.\nHowever, in practice, we will typically be unable to find yields \\(y(\\tau_{ij})\\) such that Equation 25.1 holds exactly for each bond \\(i\\). This is due to measurement errors in the form of bid-ask spreads and nonsynchronous pricing. Furthermore, even if we can find such yields, we still face the issue of estimating the yields at other maturities \\(\\tau \\notin \\{\\tau_{ij}\\}\\). The cubic spline is one way to address these issues.\nA cubic spline consists of several cubic polynomials spliced together at a set of knot points. Specifically, it consists of maturities \\(\\tau_1,\\ldots, \\tau_n\\) (the knot points) and coefficients \\((a_i, b_i, c_i, d_i)\\) for \\(i= 0,\\ldots,n\\), and the yield curve is modeled as \\[y(\\tau) = \\begin{cases} a_0 \\tau^3 + b_0 \\tau^2 + c_0 \\tau + d_0 & \\text{for $0 &lt; \\tau \\leq \\tau_1\\;,$}\\\\\na_1 \\tau^3 + b_1 \\tau^2 + c_1 \\tau + d_1 & \\text{for $\\tau_1 &lt; \\tau \\leq \\tau_2\\;,$}\\\\\n\\cdots & \\cdots \\\\\na_{n} \\tau^3 + b_{n} \\tau^2 + c_{n} \\tau + d_{n} & \\text{for $\\tau_n &lt; \\tau \\leq T$,}\\end{cases}\n\\] where \\(T\\) is the maximum maturity considered. By changing the constants \\(d_1,\\ldots,d_n\\), we can write this in an equivalent and more convenient form: \\[\ny(\\tau) = \\begin{cases} a_0 \\tau^3 + b_0 \\tau^2 + c_0 \\tau + d_0 & \\text{for $0 &lt; \\tau \\leq \\tau_1\\;,$}\\\\\na_1 (\\tau-\\tau_1)^3 + b_1 (\\tau-\\tau_1)^2 + c_1 (\\tau-\\tau_1)+ d_1 & \\text{for $\\tau_1 &lt; \\tau \\leq \\tau_2\\;,$}\\\\\n\\cdots & \\cdots \\\\\na_{n} (\\tau-\\tau_n)^3 + b_{n} (\\tau-\\tau_n)^2 + c_{n} (\\tau-\\tau_n) + d_{n} & \\text{for $\\tau_n &lt; \\tau \\leq T\\;.$}\\end{cases}\n\\qquad(25.2)\\]\nTo splice these polynomials together at the knot points means to choose the coefficients so that the two polynomials that meet at a knot point have the same value and the same first and second derivatives at the knot point. For example, at the first knot point \\(\\tau_1\\), we want the adjacent polynomials to satisfy \\[\n\\begin{array}{llrcl}\n\\text{Equality of yields:} &\\quad &a_0 \\tau_1^3 + b_0 \\tau_1^2 + c_0 \\tau_1 + d_0 &= &d_1\\; ,\\\\\n\\text{Equality of first derivatives:} & \\quad &3a_0 \\tau_1^2 + 2b_0 \\tau_1 + c_0  &= &c_1\\; ,\\\\\n\\text{Equality of second derivatives:} & \\quad &6a_0 \\tau_1 + 2b_0  &= &2b_1\\;.\n\\end{array}\\] Thus, given the coefficients \\(a_0, b_0, c_0, d_0\\), the only free coefficient for the second polynomial is \\(a_1\\). Likewise, at the second knot point \\(\\tau_2\\), we want the adjacent polynomials to agree with regard to: \\[\n\\begin{array}{llrcl}\n\\text{Yields:} &\\quad &a_1 (\\tau_2-\\tau_1)^3 + b_1(\\tau_2- \\tau_1)^2 + c_1 (\\tau_2-\\tau_1) + d_1 &= &d_2\\; ,\\\\\n\\text{First derivatives:} & \\quad &3a_1 (\\tau_2-\\tau_1)^2 + 2b_1(\\tau_2- \\tau_1) + c_1  &= &c_2\\; ,\\\\\n\\text{Second derivatives:} & \\quad &6a_1 (\\tau_2-\\tau_1) + 2b_1  &= &2b_2\\;.\n\\end{array}\\] Thus, the only free coefficient for the third polynomial is \\(a_2\\). Continuing in this way, we see that the cubic spline is defined by the knot points and the coefficients \\(a_0\\), \\(b_0\\), \\(c_0\\), \\(d_0\\), \\(a_1\\), \\(a_2\\), , \\(a_n\\). One wants to choose the knot points (hopefully, not too many) and these coefficients so that the relations Equation 25.1 hold as closely as possible in some sense. For more on this subject, a good reference is James and Webber (James and Webber 200AD).",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#libor",
    "href": "Chapter_FixedIncome.html#libor",
    "title": "25  Fixed-Income Concepts",
    "section": "25.2 LIBOR",
    "text": "25.2 LIBOR\nMany fixed-income instruments have cash flows tied to interest rate indices that are quoted as simple (i.e., noncompounded) interest rates. If you deposit $1 at an annualized simple interest rate of \\(\\mathcal{R}\\) for a period of time \\(\\Delta t\\), then at the end of the period you will have \\(1+\\mathcal{R}\\,\\Delta t\\) dollars.^[The calligraphic symbol \\(\\mathcal{R}\\) will be used only for simple interest rates and hopefully will not be confused with the symbol \\(R\\) used for the accumulation factor \\(R_t=\\mathrm{e}^{\\int_0^t r_s\\,ds}\\) and the corresponding risk-neutral expectation \\(\\\\E^R\\).} The most common interest rate index is LIBOR (London Inter-Bank Offered Rate) which is an average rate offered by large London banks on large deposits for a specific term. For example, if \\(\\mathcal{R}\\) denotes six-month LIBOR, a $1 million deposit at this rate will grow in six months to $1 million times \\(1+\\mathcal{R}\\,\\Delta t\\), where \\(\\Delta t=1/2\\). We will use LIBOR as a generic term for such indices.\nWe will frequently find it convenient to express LIBOR rates in terms of equivalent bond prices. As before, let \\(P(t,u)\\) denote the price at date \\(t\\) of a zero-coupon bond with a face value of $1 maturing at date \\(u\\), having \\(\\Delta t = u-t\\) years to maturity. Previously, we used this notation only for default-free bonds such as Treasuries. However, there is a small amount of credit risk in LIBOR rates because of the possibility of a bank failure. In discussing derivatives linked to LIBOR rates, such as swaps, caps, and floors, we will use the notation \\(P(t,u)\\) for the price of a bond having the same default risk as a LIBOR deposit, but our models will ignore the possibility of default. An investment of $1 at date \\(t\\) in the bond will purchase \\(1/P(t,u)\\) units of the bond, which, in the absence of default, will be worth \\(1/P(t,u)\\) dollars at maturity. We will assume \\[\n\\frac{1}{P(t,u)} = 1+\\mathcal{R}\\,\\Delta t\\;.\n\\qquad(25.3)\\]\nWhen necessary for clarity, we call the rate \\(\\mathcal{R}\\) a spot rate (at date \\(t\\) for the time period \\(\\Delta t\\)), to distinguish it from forward rates to be defined later. The spot rate is also called a floating rate, because it changes with market conditions.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#sec-s:swaps",
    "href": "Chapter_FixedIncome.html#sec-s:swaps",
    "title": "25  Fixed-Income Concepts",
    "section": "25.3 Swaps",
    "text": "25.3 Swaps\nA plain vanilla interest rate swap involves the swap of a fixed interest rate for a floating interest rate on a given notional principal. Let \\(\\bar{\\mathcal{R}}\\) denote the fixed rate on a swap. The floating rate will be LIBOR (or some other interest rate index). In addition to \\(\\bar{\\mathcal{R}}\\) and the floating rate index, the swap is defined by payment dates, which we will denote by \\(t_1,\\dots,t_N\\), with \\(t_{i+1}-t_i=\\Delta t\\). In the most common form, the reset dates are \\(t_0,\\ldots,t_{N-1}\\), with \\(t_1-t_0=\\Delta t\\) also.\nAt each reset date \\(t_i\\), the simple interest rate \\(\\mathcal{R}_i\\) for period \\(\\Delta t\\) is observed. This rate determines a payment at the following date \\(t_{i+1}\\). In terms of bond prices, \\(\\mathcal{R}_i\\) is defined in accord with Equation 25.3, substituting date \\(t_i\\) for date \\(t\\) and date \\(t_{i+1}\\) for date \\(u\\); i.e., \\[\n\\frac{1}{P(t_i,t_{i+1})} = 1+\\mathcal{R}_i\\,\\Delta t\\;.\n\\qquad(25.4)\\]\nOne can enter a swap as the fixed-rate payer, normally called simply the payer or as the fixed-rate receiver, normally called the receiver. The payer pays the fixed rate \\(\\bar{\\mathcal{R}}\\) and receives the spot rate \\(\\mathcal{R}_i\\) at each payment date \\(t_{i+1}\\). Only the net payment is exchanged. If \\(\\bar{\\mathcal{R}} &gt; \\mathcal{R}_i\\) then the amount \\((\\bar{\\mathcal{R}}-\\mathcal{R}_i)\\,\\Delta t\\) is paid at date \\(t_{i+1}\\) by the payer to the receiver for each $1 of notional principal. If \\(\\bar{\\mathcal{R}} &lt;  \\mathcal{R}_i\\), then the payer receives \\((\\mathcal{R}_i - \\bar{\\mathcal{R}})\\,\\Delta t\\) from the receiver for each $1 of notional principal at date \\(t_{i+1}\\). To state this more simply, the cash flow to the payer is \\((\\mathcal{R}_i - \\bar{\\mathcal{R}})\\,\\Delta t\\) and the cash flow to the receiver is \\((\\bar{\\mathcal{R}}-\\mathcal{R}_i)\\,\\Delta t\\), with the usual understanding that a negative cash flow is an outflow. Note that there is no exchange of principal at initiation, and there is no return of principal at the end of the swap. The principal is notional because it is used only to define the interest payments.\nThe value of a swap to the fixed-rate payer at any date \\(t \\leq t_0\\) is \\[\nP(t,t_0) - P(t,t_N) - \\bar{\\mathcal{R}}\\,\\Delta t\\sum_{i=1}^N P(t,t_i)\\;.\n\\qquad(25.5)\\]\nTo see this, note that \\(P(t,t_0)\\) is the cost at date \\(t\\) of receiving $1 at \\(t_0\\). This $1 can be invested at \\(t_0\\) at the rate \\(\\mathcal{R}_0\\) and the amount \\(\\mathcal{R}_0 \\,\\Delta t\\) withdrawn at \\(t_1\\) with the $1 principal rolled over at the new rate \\(\\mathcal{R}_1\\). Continuing in this way, one obtains the cash flow \\(\\mathcal{R}_i\\,\\Delta t\\) at each payment date \\(t_{i+1}\\) and the recovery of the $1 principal at date \\(t_N\\). The value of the $1 principal at date \\(t_N\\) is negated in expression Equation 25.5 by the term \\(-P(t,t_N)\\). Thus, \\(P(t,t_0)-P(t,t_N)\\) is the value of the floating rate payments on the notional principal. On the other hand, \\(\\bar{\\mathcal{R}}\\,\\Delta t\\sum_{i=1}^N P(t,t_i)\\) is the value of the fixed-rate payments. Therefore, expression Equation 25.5 is the difference in the values of the floating and fixed-rate legs. \nAs with a forward price, the swap rate is usually set so that the value of the swap is zero at initiation. A swap initiated at date \\(t \\leq t_0\\) has zero value at initiation if the fixed rate \\(\\bar{\\mathcal{R}}\\) equates the expression Equation 25.5 to zero. This means that \\(\\bar{\\mathcal{R}}=\\mathcal{R}_t\\), where \\(\\mathcal{R}_t\\) is defined by \\[\nP(t,t_0) = P(t,t_N) + \\mathcal{R}_t\\,\\Delta t\\sum_{i=1}^N P(t,t_i)\\;.\n\\qquad(25.6)\\]\nIf \\(t=t_0\\) the rate \\(\\mathcal{R}_t\\) is a spot swap rate, and if \\(t&lt;t_0\\) the rate \\(\\mathcal{R}_t\\) is a forward swap rate. The concept of forward swap rates will be important in the discussion of swaptions in Section 26.6. Of course, there are many spot and forward swap rates at any date, corresponding to swaps with different maturities and different payment (and reset) dates.\nThe swap yield curve or simply swap curve is the relation between time-to-maturity and the yields of discount bonds, where the discount bond prices and yields are inferred from market swap rates. To explain this in a manner consistent with Section 25.1, consider date \\(t=0\\) and consider swaps with \\(t_0=0\\) (i.e., spot swaps). In the notation of Section 25.1, and noting that \\(P(0,0)=1\\), Equation 25.6 can be written in terms of yields as \\[\n1 = \\mathrm{e}^{-y(t_N)t_N}  + \\sum_{i=1}^N \\mathrm{e}^{-y_{t_i}t_i}\\mathcal{R}_0\\,\\Delta t\\; .\n\\qquad(25.7)\\]\nConsider for example a collection of nineteen swaps at date \\(0\\) with semi-annual payments and maturity dates \\(t_N=1.0\\), \\(t_N=1.5\\), , \\(t_N=10.0\\). Each market swap rate (a different rate \\(\\mathcal{R}_0\\) for each maturity) can be considered to satisfy Equation 25.7. In these equations we have the twenty yields \\(y(0.5)\\), \\(y(1.0)\\), \\(y(10.0)\\). The yield \\(y(0.5)\\) will be given by six-month LIBOR according to Equation 25.3. The other nineteen yields can be obtained by simultaneously solving the system of nineteen equations of the form Equation 25.7, given the nineteen market swap rates. In practice, there are missing maturities and the swap curve is estimated using a cubic spline or some other technique, as discussed in Section 25.1.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#sec-s:duration",
    "href": "Chapter_FixedIncome.html#sec-s:duration",
    "title": "25  Fixed-Income Concepts",
    "section": "25.4 Yield to Maturity, Duration, and Convexity",
    "text": "25.4 Yield to Maturity, Duration, and Convexity\nConsider a bond with cash flows \\(C_1, \\ldots, C_N\\) at dates \\(u_1 &lt; \\cdots &lt; u_N\\) and price \\(P\\) at date \\(t\\), where \\(t&lt; u_1\\). Write \\(\\tau_j = u_j-t\\) as the time remaining until the \\(j\\)–th cash flow is paid. The (continuously compounded) yield to maturity of the bond at date \\(t\\) is defined to be the rate \\(\\mathbf{y}\\) such that \\[\nP = \\sum_{j=1}^N \\mathrm{e}^{-\\mathbf{y}\\tau_j}C_j\\;.\n\\qquad(25.8)\\]\nThe bold character \\(\\mathbf{y}\\) is meant to distinguish this from the yield \\(y\\) of a discount bond. Viewing the right-hand side of Equation 25.8 as a function of \\(\\mathbf{y}\\), we can express the first derivative in differential form as \\[\\,\\mathrm{d}P = -\\sum_{j=1}^N \\tau_j\\mathrm{e}^{-\\mathbf{y}\\tau_j}C_j\\,\\mathrm{d}\\mathbf{y}\\; ,\\] or, equivalently, \\[\\frac{\\,\\mathrm{d}P}{P} = -\\sum_{j=1}^N \\frac{\\mathrm{e}^{-\\mathbf{y}\\tau_j}C_j}{P}\\tau_j\\,\\mathrm{d}\\mathbf{y}\\; .\\] The factor \\[\\sum_{j=1}^N \\frac{\\mathrm{e}^{-\\mathbf{y}\\tau_j}C_j}{P}\\tau_j\\] is called the Macaulay duration of the bond, and we will simplify this to duration. It is a weighted average of the times to maturity \\(\\tau_j\\) of the cash flows, the weight on each time \\(\\tau_j\\) being the fraction of the bond value that the cash flow constitutes (using the same rate \\(\\mathbf{y}\\) to discount all of the cash flows). Thus, we have \\[\n\\frac{\\,\\mathrm{d}P}{P} = - \\text{Duration} \\times \\,\\mathrm{d}\\mathbf{y}\\;.\n\\qquad(25.9)\\]\nGiven the initial yield \\(\\mathbf{y}\\) and a change in the yield to \\(\\mathbf{y}'\\), this equation suggests the following approximation for the return \\(\\Delta P/P\\): \\[\n\\frac{\\Delta P}{P} \\approx  -  \\text{Duration}  \\times \\,\\Delta \\mathbf{y}\\;,\n\\qquad(25.10)\\]\nwhere \\(\\Delta \\mathbf{y} = \\mathbf{y}'-\\mathbf{y}\\).\nThe relationship Equation 25.10 is the foundation for duration hedging. For example, to duration hedge a liability with a present value of \\(x_L\\) dollars and a duration of \\(D_L\\) years, one needs an asset with a value of \\(x_A\\) dollars and a duration of \\(D_A\\) satisfying \\(x_AD_A = x_LD_L\\). If the change in the yields to maturity of the asset and liability are the same number \\(\\Delta \\mathbf{y}\\), then by Equation 25.10 the change in the value of the liability will be approximately \\(-D_L\\,\\Delta \\mathbf{y}\\) per dollar of initial value, for a total change in value of \\(-x_LD_L\\,\\Delta \\mathbf{y}\\) dollars. The change in the value of the asset will approximately offset the change in the value of the liability.\nActually, because of the convexity of the bond price Equation 25.8 as a function of the yield \\(\\mathbf{y}\\), the approximation Equation 25.10 will overstate the loss on an asset when the yield rises and understate the gain when the yield falls. Given a change in yield \\(\\Delta \\mathbf{y}\\), the change in price \\(\\Delta P = P'-P\\) would actually satisfy \\[\\Delta P &gt; -  \\text{Duration} \\times P \\times \\Delta \\mathbf{y}\\; .\\] Thus, if a liability is duration hedged, and the asset value is a more convex function of its yield than is the liability value, then an equal change \\(\\Delta \\mathbf{y}\\) in their yields will lead to a net gain, the asset value falling less than the liability if \\(\\Delta \\mathbf{y} &gt;0\\) and gaining more than the liability if \\(\\Delta \\mathbf{y}&lt;0\\). The value of convexity (as a function of the yield to maturity) in a bond portfolio is the same as the value of convexity (as a function of the price of the underlying) in option hedging—cf.~Section 10.5.\nIn general, the changes in the yields of an asset and a liability (or two different coupon bonds) will not be equal. To understand how the changes will be related, note that Equation 25.8 of the yield to maturity and Equation 25.1 relating a bond price to the yields of discount bonds imply \\[\\sum_{j=1}^N \\mathrm{e}^{-\\mathbf{y}\\tau_j}C_j =  \\sum_{j=1}^{N} \\mathrm{e}^{-y(\\tau_{j})\\tau_{j}}C_{j}\\; .\\] Taking differentials of both sides, we have \\[\\,\\mathrm{d}P = -P \\times \\text{Duration} \\times \\,\\mathrm{d}\\mathbf{y} = -\\sum_{j=1}^{N} \\tau_j \\mathrm{e}^{-y(\\tau_{j})\\tau_{j}}C_{j}\\,\\mathrm{d}y(\\tau_j)\\; .\\] If we suppose that the changes \\(\\,\\mathrm{d}y(\\tau_j)\\) in the yields of the discount bonds are equal, to, say, \\(\\,\\mathrm{d}y\\), then we have \\[\\,\\mathrm{d}P = -P \\times \\text{Duration} \\times \\,\\mathrm{d}\\mathbf{y} = -P \\times \\text{Duration}' \\times \\,\\mathrm{d}y,\\] where we define \\[\n\\text{Duration}' = \\sum_{j=1}^N \\frac{\\mathrm{e}^{-y(\\tau_j)\\tau_j}C_j}{P}\\tau_j.\n\\qquad(25.11)\\]\nThis new definition of duration differs from the previous by using the yields of discount bonds to define the fraction of the bond value that each cash flow contributes, rather than the yield to maturity. If the changes in the yields of discount bonds are equal, then we say that there has been a parallel shift in the yield curve—it has moved up or down with the new curve being at each point the same distance from the old. Our previous discussion shows that duration hedging works if we use the new Equation 25.11 of duration and if the yield curve shifts in a parallel fashion. Of course, parallel shifts in the yield curve are not the only, or even most common, types of shifts. In the next two sections, we discuss hedging against more general types of shifts in the yield curve.\nSomething very similar to duration hedging works if we can continuously rebalance the hedge and there is only a single factor determining the yield curve (meaning a single Brownian motion driving all yields). To understand this, we must first note that the expressions given in this section for \\(\\,\\mathrm{d}P\\) are not the Ito differential, which explains how the bond price evolves over time and would include a second-derivative term. For example, in Equation 25.9 we are simply asking how different the price would be if the yield to maturity had been different at a given point in time. To define the Ito differential, let now \\(\\mathbf{y}_t\\) denote the yield to maturity of the bond at date \\(t\\). Equation 25.8 can be restated as \\[\nP_t = f(t,\\mathbf{y}_t) = \\sum_{j=1}^N \\mathrm{e}^{\\mathbf{y}_t(u_j-t)}C_j\\;.\n\\qquad(25.12)\\]\nNote that even if the yield to maturity were constant over time, the bond price would change with \\(t\\) as a result of the changes in the times to maturity \\(u_j-t\\) of the cash flows. This creates the dependence on \\(t\\) in the function \\(f(t,\\mathbf{y})\\).\nFrom Ito’s formula, we have \\[\\,\\mathrm{d}P = \\frac{\\partial f}{\\partial t} \\,\\mathrm{d}t + \\frac{\\partial f}{\\partial \\mathbf{y}} \\,\\mathrm{d}\\mathbf{y} + \\frac{1}{2} \\frac{\\partial ^2 f}{\\partial \\mathbf{y}^2} (\\,\\mathrm{d}\\mathbf{y})^2\\; .\\]\nAs explained above, the factor \\(\\partial f/\\partial \\mathbf{y}\\) equals $ - P$. The value of convexity appears here in the last term, the derivative \\(\\partial ^2 f/\\partial \\mathbf{y}^2\\) being positive as a result of convexity and analogous to the gamma of an option. Assuming \\(\\,\\mathrm{d}\\mathbf{y}_t = \\alpha_t\\,\\mathrm{d}t+\\sigma_t\\,\\mathrm{d}B_t\\) for a Brownian motion \\(B\\) and some \\(\\alpha\\) and \\(\\sigma\\), we have \\[\\frac{\\,\\mathrm{d}P}{P} = \\frac{1}{P}\\left(\\frac{\\partial f}{\\partial t}  + \\frac{\\partial f}{\\partial \\mathbf{y}}\\alpha + \\frac{1}{2} \\frac{\\partial ^2 f}{\\partial \\mathbf{y}^2} \\sigma^2\\right)\\,\\mathrm{d}t-  \\text{Duration}\\times\\sigma \\,\\mathrm{d}B\\; .\\] If the yields of an asset and liability are driven by the same Brownian motion and the duration hedge is adjusted for the relative volatilities of the asset and liability (holding more of the asset if its yield volatility is lower), then a duration hedge will hedge the risky part of the change in the liability value. If adjusted continuously, it will provide a perfect hedge, exactly analogous to a delta hedge of an option position. The Vasicek model we will discuss in Chapter 27 and the Cox-Ingersoll-Ross model we will discuss in Chapter 28 are examples of continuous-time models that assume a single Brownian motion driving all yields (i.e., they are single-factor models).The Ho-Lee, Black-Derman-Toy, and Black-Karasinski binomial models that will be discussed in Chapter 28 are also single-factor models and have the same implication for hedging. In the following section, we will discuss the fact that, empirically, there appears to be more than one factor determining the yield curve.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#sec-s:principalcomponents",
    "href": "Chapter_FixedIncome.html#sec-s:principalcomponents",
    "title": "25  Fixed-Income Concepts",
    "section": "25.5 Principal Components",
    "text": "25.5 Principal Components\nThis section will describe a popular statistical method for determining the factors that have the most impact on the yield curve. We consider yields at fixed maturities \\(\\tau_1, \\ldots, \\tau_N\\), the yield for maturity \\(\\tau_j\\) at date \\(t\\) being denoted \\(y(t,\\tau_j)\\). We assume that we have a sample of past yields at dates \\(t_0, \\ldots, t_M\\) at equally spaced dates. Thus, \\(t_i-t_{i-1} = \\Delta t\\) for some \\(\\Delta t\\) and each \\(i\\). We compute the changes in yields: \\[\\Delta_{ij} = y(t_i, \\tau_j) - y(t_{i-1}, \\tau_j)\\; .\\] Thus we are looking at the changes in the yield curve over time periods of length \\(\\Delta t\\), focusing on \\(N\\) points on the yield curve defined by the maturities \\(\\tau_j\\). Let \\(V\\) denote the sample covariance matrix of the changes in yields: the element in row \\(j\\) and column \\(k\\) of \\(V\\) is the sample covariance of the changes in yields at maturities \\(\\tau_j\\) and \\(\\tau_k\\); thus, the diagonal elements are the sample variances.1 to estimate the covariance matrix. The following applies equally well to other estimates \\(V\\) of the covariance matrix.\nThe method of principal components is to compute the eigenvectors and eigenvalues of the estimated covariance matrix \\(V\\). An eigenvector is a vector \\(x\\) for which there corresponds a number \\(\\lambda\\) such that \\(Vx = \\lambda x\\). The number \\(\\lambda\\) is called the eigenvalue corresponding to the eigenvector \\(x\\). Given the \\(N \\times N\\) symmetric matrix \\(V\\), we can construct an \\(N\\times N\\) matrix \\(C\\) whose columns are eigenvectors of \\(V\\) and an \\(N \\times N\\) diagonal matrix \\(D\\) containing the eigenvalues of \\(V\\) on the diagonal. The eigenvectors can be normalized to have unit length and to be mutually orthogonal, which means that the matrix \\(C\\) of eigenvectors has the property that \\(C^{-1} = C^\\top\\), where \\(C^{-1}\\) denotes the inverse of \\(C\\) and \\(C^\\top\\) its transpose. The property \\(Vx = \\lambda x\\) for the columns \\(x\\) of \\(C\\) implies that \\(VC= CD\\). Hence \\(C^\\top VC = C^\\top CD = D\\).\nThis can be understood as a factor model for the changes in yields, where there are as many factors as maturities. At date \\(t_i\\), the vector of factor realizations \\(z_{ij}\\) is computed as \\[\n\\begin{pmatrix} z_{i1} \\\\ \\vdots \\\\ z_{iN} \\end{pmatrix} = C^\\top \\begin{pmatrix} \\Delta_{i1} \\\\ \\vdots \\\\ \\Delta_{iN} \\end{pmatrix}\\;.\n\\qquad(25.13)\\]\nThus, \\[\n\\begin{pmatrix} \\Delta_{i1} \\\\ \\vdots \\\\ \\Delta_{iN} \\end{pmatrix}  \n= C \\begin{pmatrix} z_{i1} \\\\ \\vdots \\\\ z_{iN} \\end{pmatrix}\\;. \\qquad(25.14)\\]\nGiven any random vector \\(\\xi\\) with covariance matrix \\(\\Sigma\\) and a linear transformation \\(\\xi' = L \\xi\\), the covariance matrix of \\(\\xi'\\) is \\(L\\Sigma L^\\top\\). Therefore, Equation 25.13 implies that the covariance matrix of the factors is \\(C^\\top VC\\), and we observed in the previous paragraph that \\(C^\\top VC=D\\). Therefore, the factors are uncorrelated, and the factor variances are the eigenvalues of \\(V\\).\nLet \\(\\beta_{k\\ell}\\) denote the \\((k,\\ell)\\)–th element of \\(C\\). Then we can write Equation 25.14 as \\[\\begin{matrix} \\Delta_{i1} \\\\ \\vdots \\\\ \\Delta_{iN} \\end{matrix}\n\\;\\begin{matrix}= \\\\ \\vdots \\\\ = \\end{matrix}\\;\n\\begin{matrix} \\beta_{11}z_{i1} + \\cdots + \\beta_{1N}z_{iN}, \\\\ \\vdots \\\\ \\beta_{N1}z_{i1} + \\cdots + \\beta_{NN}z_{iN} \\;.\\end{matrix} \\qquad(25.15)\\]\nAs in any factor model, the factors are common to all of the maturities. Each factor is random, taking a different value at each date \\(t_i\\). The \\(\\beta\\)’s represent the loadings of the yield changes on the factors, \\(\\beta_{k\\ell}\\) being the loading of the change in the yield at maturity \\(\\tau_k\\) on the \\(\\ell\\)-th factor.\nIn a normal factor model, there are fewer factors than variables being explained. It serves no point to have a factor model with as many factors as there are variables to be explained (in our case, as many factors as maturities). We can improve the usefulness of the above by omitting some factors. We will omit the factors that are least important in explaining the changes in yields. For example, if we omit all but the first three factors, we will have \\[\\begin{matrix} \\Delta_{i1} \\\\ \\vdots \\\\ \\Delta_{iN} \\end{matrix}\n\\;\\begin{matrix}= \\\\ \\vdots \\\\ = \\end{matrix}\\;\n\\begin{matrix} \\beta_{11}z_{i1} + \\beta_{12}z_{i2}+ \\beta_{13}z_{i3} +\\varepsilon_{i1}, \\\\ \\vdots \\\\ \\beta_{N1}z_{i1} + \\beta_{N2}z_{i2}+ \\beta_{N3}z_{i3} +\\varepsilon_{iN}\\; ,\\end{matrix} \\qquad(25.16)\\]\nwhere \\[\n\\varepsilon_{ij} = \\beta_{j4}z_{i4} + \\cdots + \\beta_{jN}z_{iN}\n\\qquad(25.17)\\]\nis interpreted as the residual part^[Frequently, the definition of factor model requires the residuals to be uncorrelated, in which case they are called idiosyncratic risks. of \\(\\Delta_{ij}\\).\nThe importance of a factor depends on the factor loadings and the variance of the factor. The loadings on the \\(j\\)–th factor are the elements in the \\(j\\)–th column of \\(C\\), which is the \\(j\\)–th eigenvector of \\(V\\). Because the eigenvectors all have unit length and are mutually orthogonal, each vector of loadings has the same importance as any other for explaining the changes in yields. Thus, the importance of a factor in this model depends on the variance of the factor. The variance of the \\(j\\)–th factor is the \\(j\\)–th element on the diagonal of \\(D\\), which is the eigenvalue corresponding to the \\(j\\)–th eigenvector. The factors that we should omit are clearly those with small eigenvalues.\nAs an example, an analysis of monthly changes in (continuously compounded) U.S. Treasury yields from 1992 through 2002 at maturities of 1 month, 3 months, 1 year, 2 years, 3 years, 4 years, and 5 years2 produces seven eigenvalues (corresponding to the seven maturities) that sum to \\(5.526 \\times 10^{-5}\\). This sum is the total variance of the seven factors. The largest eigenvalue is 74% of the total, the two largest eigenvalues constitute 94% of the total, and the three largest constitute 98% of the total. Thus, three factors contribute 98% of the total factor variance for this data set, so a factor model with three (or even two) factors explains a very high percentage of the changes in yields for this data set.\nThe factors can be interpreted by examining the corresponding eigenvectors. The eigenvectors corresponding to the three largest eigenvalues in this data set are the columns below (the first column corresponding to the largest eigenvalue, etc.):\nWe can interpret these as follows. A positive value in a given month for the factor with the highest variance will lead to an increase in all of the yields, because all of the elements in the first column are positive (it will also lead to a slight increase in the slope due to the loadings at longer maturities being generally slightly larger than the loadings at smaller maturities). A positive value for the next factor will decrease yields at short maturities and increase the yields at longer maturities, thus leading to an increase in the slope of the yield curve. A positive value for the third factor will lead to an increase in yields at short and long maturities and a decrease in yields at intermediate maturities, thus affecting the curvature of the yield curve. Results of this sort are common for data sets containing longer maturities also, leading to the conclusion that the most important factor is the level of the yield curve, the second most important factor is the slope of the yield curve, and the third most important factor is the curvature of the yield curve, with three factors explaining nearly all of the variations in yields.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#sec-s:hedgingprincipalcomponents",
    "href": "Chapter_FixedIncome.html#sec-s:hedgingprincipalcomponents",
    "title": "25  Fixed-Income Concepts",
    "section": "25.6 Hedging Principal Components",
    "text": "25.6 Hedging Principal Components\nConsider again a bond with cash flows \\(C_1, \\ldots, C_N\\) at dates \\(\\tau_1 &lt; \\cdots &lt; \\tau_N\\) and price \\(P\\) and recall that the price at date \\(0 &lt; \\tau_1\\) should be \\[P = \\sum_{j=1}^{N} \\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\; ,\\] where for convenience we are writing \\(y_j\\) for the yield \\(y(0,\\tau_j)\\) of the discount bond maturing at \\(\\tau_j\\). Viewing the price as a function of \\(y_1, \\ldots, y_N\\), we can write the differential as \\[\\,\\mathrm{d}P = -\\sum_{j=1}^{N} \\tau_j\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\,\\mathrm{d}y_j\\; .\\] Equivalently, \\[\\frac{\\,\\mathrm{d}P}{P} = -\\sum_{j=1}^{N} \\frac{\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\tau_j}{P}\\,\\mathrm{d}y_j\\; .\\] Given discrete changes \\(\\Delta y_j\\) in the yields, this implies the following approximation for the return: \\[\n\\frac{\\Delta P}{P} \\approx -\\sum_{j=1}^{N} \\frac{\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\tau_j}{P}\\, \\Delta y_j\\;.\n\\qquad(25.18)\\]\nAs in Section 25.4, because of convexity, the approximation understates the new price \\(P' = P + \\Delta P\\). In Section 25.4 we considered this equation assuming equal changes in the yields (a parallel shift in the yield curve). Here, we will discuss the more general case.\nThe approximation Equation 25.18 suggests how we can hedge against the factors identified in the previous section. For example, let \\(\\beta_{1\\ell}, \\ldots, \\beta_{N\\ell}\\) denote the loadings of the yields at maturities \\(\\tau_1, \\ldots, \\tau_N\\) on the factor with the \\(\\ell\\)–th greatest variance, for \\(\\ell=1, 2, 3\\).3 Then the factor model suggests \\[\\Delta y_j \\approx \\beta_{j1} z_1 + \\beta_{j2} z_2 + \\beta_{j3} z_3\\; ,\\] where the \\(z_k\\) denote the realizations of the factors. Combining this with Equation 25.18 results in \\[\\begin{align*}\n\\frac{\\Delta P}{P} &\\approx -\\sum_{j=1}^{N} \\left(\\frac{\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\tau_j}{P}\\sum_{k=1}^3 \\beta_{jk}z_k \\right)\\\\\n&= -\\sum_{k=1}^3 \\left(\\sum_{j=1}^{N} \\frac{\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\tau_j\\beta_{jk}}{P}\\right)z_k.\n\\end{align*}\\] This means that the bond return is approximately a linear combination of the factors, with the coefficient (loading) on the \\(k\\)–th factor being \\[\n-\\sum_{j=1}^{N} \\frac{\\mathrm{e}^{-y_j\\tau_{j}}C_{j}\\tau_j\\beta_{jk}}{P}\\;.\n\\qquad(25.19)\\]\nTo hedge a liability against the factor, we want this coefficient for the asset multiplied by the dollar value of the asset to equal the corresponding coefficient for the liability multiplied by its dollar value. There are three conditions of this type in a three-factor model, which means that a portfolio of three distinct assets is necessary to hedge a liability. A similar application is in bond portfolio management. If we want to avoid exposing ourselves to factor risk relative to a benchmark portfolio, then we should match the loadings Equation 25.19 for our portfolio with the corresponding loadings of the benchmark.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#section",
    "href": "Chapter_FixedIncome.html#section",
    "title": "25  Fixed-Income Concepts",
    "section": "",
    "text": "Assume the following discount bond prices for each of the following exercises: \\[\\begin{align*}\nP(0,0.5) & = 0.995\\\\\nP(0,1.0) & = 0.988\\\\\nP(0,1.5) & = 0.978\\\\\nP(0,2.0) & = 0.966\\\\\nP(0,2.5) & = 0.951\\\\\nP(0,3.0) & = 0.935\\\\\nP(0,3.5) & = 0.916\\\\\nP(0,4.0) & = 0.896\\\\\nP(0,4.5) & = 0.874\\\\\nP(0,5.0) & = 0.850\n\\end{align*}\\]\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCompute the six-month and one-year LIBOR rates.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCompute the swap rate for a two-year swap with semi-annual payments.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCompute the forward swap rate for a two-year swap with semi-annual payments beginning in\n\none year,\ntwo years,\nthree years.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCompute and plot the continuously-compounded discount-bond yields at maturities 0.5, 1.0, 1.5, , 5.0.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider a cubic spline as defined in Equation 25.2 with knot points at two and four years and the following coefficients: \\[\\begin{align*}\na_0 & =  -0.00163  \\\\\nb_0 & =   0.00812\\\\\nc_0 & =   -0.00676 \\\\\nd_0 & =    0.01184\\\\\na_1 & =    0.00052\\\\\nb_1 & =    -0.00169\\\\\nc_1 & =    0.00609\\\\\nd_1 & =    0.01770\\\\\na_2 & =    -0.00175\\\\\nb_2 & =    0.00141\\\\\nc_2 & =    0.00552\\\\\nd_2 & =    0.02725\n\\end{align*}\\]\n\nPlot the cubic spline and compare it to the plot from the previous exercise.\nConfirm that the adjacent polynomials have the same values, first derivatives, and second derivatives at each of the two knot points.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function DiscountBondPrice that takes the time \\(\\tau\\) to maturity as an input and returns an estimated price for a discount bond maturing at \\(\\tau\\), using the cubic spline Equation 25.2, knot points at 2 and 4 years, and the coefficients in the previous exercise. Confirm that it gives approximately the same discount bond prices as those at the beginning of this set of exercises. A Warning about Extrapolating to Longer Maturities: What price does the function give for a discount bond maturing in ten years?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nConsider a two-year coupon bond with $1 face value and a semi-annual coupon of $0.03, with the first coupon being six months away.\n\nCompute the price of the bond.\nCompute the yield to maturity of the bond.\n\nCompute the duration of the bond.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous exercise for a one-year coupon bond with $1 face value and a semi-annual coupon of $0.04.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat the previous exercise for a five-year coupon bond with $1 face value and a semi-annual coupon of $0.02.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nSuppose you have shorted $100 million of the two-year bond with the semi-annual coupon of $0.03. How much of the five-year bond with the semi-annual coupon of $0.02 should you hold to duration hedge the short position?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nSuppose you have shorted $100 million of the two-year bond with the semi-annual coupon of $0.03. Using the data from the principal components example in Section 25.6, find a portfolio of the one-year bond with a coupon of $0.04 and the five-year bond with a coupon of $0.02 that will hedge the first two principal components of the short position. Assume the loadings of the six-month yield on the two factors are the averages of the loadings of the one-month and one-year yields, the loadings of the 1.5 year yield on the two factors are the averages of the loadings of the 1.0 and 2.0 years, the loadings of the 2.5 year yield are the averages of the loadings of the 2.0 and 3.0 year yields, etc.\n\n\n\n\n\n\n\nBielecki, T., and M. Rutkowski. 2002. Credit Risk: Modeling, Valuation and Hedging. Berlin Heidelberg New York: Springer.\n\n\nBrigo, D., and F. Mercurio. 2001. Interest Rate Models. Theory; Practice, Springer, Berlin Heidelberg New York.\n\n\nDuffie, D., and K. Singleton. 2003. Credit Risk: Pricing. Measurement; Management, Princeton University Press, Princeton, New Jersey.\n\n\nJames, J., and N. Webber. 200AD. Interest Rate Modelling. New York: Wiley.\n\n\nRebonato, R. 1998. Interest-Rate Option Models. 2nd ed., Wiley, New York,.\n\n\nSchönbucher, P. 2003. Credit Derivatives Pricing Models: Models. Pricing; Implementation, Wiley, New York.\n\n\nTavakoli, J. 2001. Credit Derivatives and Synthetic Structures. Wiley, New York.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncome.html#footnotes",
    "href": "Chapter_FixedIncome.html#footnotes",
    "title": "25  Fixed-Income Concepts",
    "section": "",
    "text": "The sample covariance matrix \\(V\\) is an estimate of the unconditional covariances. It is a common finding that variances and covariances change over time. Thus, we could (and probably should) use methods such as those described in Chapter 17↩︎\nThese were computed from discount bond price and yield data from the Center for Research in Security Prices (CRSP) at the University of Chicago.↩︎\nIt is unlikely that these specific maturities would have been used in the principal components algorithm, so the loadings would have to be estimated by interpolating or fitting some type of curve to the loadings of the maturities that were used.↩︎",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Fixed-Income Concepts</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html",
    "href": "Chapter_FixedIncomeDerivatives.html",
    "title": "26  Fixed-Income Derivatives",
    "section": "",
    "text": "26.1 Caps and Floors\nIn this chapter, we will introduce some fundamental fixed-income derivatives (caps, floors and swaptions) and explain the market model approach to valuation. We will also explain the relation between caps, floors and swaptions on the one hand and discount and coupon bond options on the other. This leads to other approaches for valuing caps, floors and swaptions, which will be developed in the following chapters.\nCaps and floors have a structure very similar to that of swaps, as described in Section 25.3. At each reset date \\(t_i\\), the simple interest rate \\(\\mathcal{R}_i\\) for period \\(\\Delta t\\) is observed. This rate determines a payment at the following date \\(t_{i+1}\\). As discussed in the preceding chapter, the cash flow to the payer in a swap is \\((\\mathcal{R}_i - \\bar{\\mathcal{R}})\\,\\Delta t\\) and the cash flow to the receiver is \\((\\bar{\\mathcal{R}}-\\mathcal{R}_i)\\,\\Delta t\\), for each $1 of notional principal. A swap is really a series of forward contracts, in which both parties have obligations. On the other hand, caps and floors are series of options. A premium is paid up-front by the buyer of a cap or floor to the seller and all future cash flows are paid by the seller to the buyer. The owner of a cap with cap rate \\(\\bar{\\mathcal{R}}\\) receives \\(\\max(0,\\mathcal{R}_i-\\bar{\\mathcal{R}})\\Delta t\\) at date \\(t_{i+1}\\) for each $1 of notional principal, and the owner of a floor receives \\(\\max(0,\\bar{\\mathcal{R}}-\\mathcal{R}_i)\\Delta t\\) at date \\(t_{i+1}\\) for each $1 of notional principal.\nCaps and floors are used in conjunction with hedging floating rate obligations or for speculative purposes. Portfolios of caps and floors have properties analogous to option portfolios. For example, the combination of a long cap and a short floor at the same rate \\(\\bar{\\mathcal{R}}\\) creates the payer side of a swap, in the same way that a long call and short put create a synthetic long forward (and a short cap and a long floor at the same rate \\(\\bar{\\mathcal{R}}\\) creates the receiver side of a swap just as a short call and long put create a synthetic short forward contract). A long cap at rate \\(\\bar{\\mathcal{R}}_c\\) and a short floor at rate \\(\\bar{\\mathcal{R}}_f &lt; \\bar{\\mathcal{R}}_c\\) creates a collar (for an underlying floating rate obligation), etc.\nThe individual payments on a cap are called caplets, and a cap is simply a portfolio of caplets. Similarly, the individual payments on a floor are called floorlets, and the values of caplets and floorlets are linked by put-call parity, as we will see below.\nA caplet can be viewed as a call option on the spot rate with strike equal to the fixed rate. Thus, it is a bet on higher interest rates. Because interest rates and bond prices are inversely related, it can also be viewed as a bet on lower bond prices. In this regard, it is similar to a put option on bond prices. In fact, we will see in Section 26.9 that a caplet is exactly equivalent to a put option on a discount bond. Likewise, a floorlet can be viewed either as a put option on the spot rate or a call option on a discount bond.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:forwardrates",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:forwardrates",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.2 Forward Rates",
    "text": "26.2 Forward Rates\nSuppose we wish to borrow money at date \\(u\\) for a period of \\(\\Delta t\\) years, and we want to lock in the rate on the loan at date \\(t&lt;u\\). To do this, we can buy the discount bond maturing at \\(u\\) and finance the purchase by shorting \\(P(t,u)/P(t,u+\\Delta t)\\) units of the bond maturing at \\(u+\\Delta t\\). This generates a cash flow of $1 at date \\(u\\) and \\(-P(t,u)/P(t,u+\\Delta t)\\) dollars at date \\(u+\\Delta t\\). This implies a simple interest rate of \\(\\mathcal{R}\\) defined as \\[\n\\frac{P(t,u)}{P(t,u+\\Delta t)} = 1+\\mathcal{R}\\,\\Delta t\\;.\n\\qquad(26.1)\\]\nThis rate is called a forward rate. \nForward rates will be important for loans at the reset dates maturing at the subsequent payment dates. We will denote the forward rate at date \\(t \\leq t_i\\) for a loan between \\(t_i\\) and \\(t_{i+1}\\) as \\(\\mathcal{R}_i_t\\). This rate is defined in accord with Equation 26.1, substituting the date \\(t_i\\) for date \\(u\\); i.e., \\[\n\\frac{P(t,t_i)}{P(t,t_{i+1})}=1+\\mathcal{R}_i_t\\,\\Delta t\\;.\n\\qquad(26.2)\\]\nNote that when \\(t=t_i\\), \\(P(t,t_i)=1\\), so \\(\\mathcal{R}_i_{t_i}=\\mathcal{R}_i\\) defined in Equation 25.4—i.e., the forward rate equals the spot rate at \\(t_i\\).",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:portfoliosspotrates",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:portfoliosspotrates",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.3 Portfolios that Pay Spot Rates",
    "text": "26.3 Portfolios that Pay Spot Rates\nOne way to value caps and floors is to view them as portfolios of options on rates, as we will see later. In order to apply the option pricing formulas derived earlier, we need to know that each rate is the value of some asset, so the option can be viewed as an option on an asset. This is very straightforward.\nTo obtain the spot rate \\(\\mathcal{R}_i\\) at date \\(t_{i+1}\\), one needs $1 to invest at date \\(t_i\\). This can be arranged at date \\(t&lt;t_i\\) by buying one unit of the bond maturing at \\(t_i\\). Investing the dollar paid by the bond at the spot rate at \\(t_i\\) will generate \\(1+\\mathcal{R}_i\\,\\Delta t\\) dollars at date \\(t_{i+1}\\). The extra dollar can be eliminated by being short one unit of the bond maturing at \\(t_{i+1}\\), leaving \\(\\mathcal{R}_i\\,\\Delta t\\) dollars. Thus, the portfolio that pays the spot rate multiplied by the period length \\(\\Delta t\\) consists of being long one unit of the bond maturing at \\(t_i\\) and short one unit of the bond maturing at \\(t_{i+1}\\).\nThis implies that the value at date \\(t&lt;t_i\\) of receiving \\(\\mathcal{R}_i\\,\\Delta t\\) dollars at date \\(t_{i+1}\\) is \\(P(t,t_i)-P(t,t_{i+1})\\).\nAt date \\(t_i\\) the spot rate \\(\\mathcal{R}_i\\) becomes known. Between \\(t_i\\) and \\(t_{i+1}\\), the value of receiving \\(\\mathcal{R}_i\\,\\Delta t\\) dollars at date \\(t_{i+1}\\) is the present value of this known cash flow, which is \\(\\mathcal{R}_i\\,\\Delta t\\,P(t, t_{i+1})\\). To summarize, the value of receiving \\(\\mathcal{R}_i\\,\\Delta t\\) dollars at date \\(t_{i+1}\\) is \\[\nS_i_t = \\begin{cases} P(t,t_i)-P(t,t_{i+1}) & \\text{if } t &lt; t_{i}\\; ,\\\\\n\\mathcal{R}_i\\,\\Delta t\\, P(t,t_{i+1}) & \\text{if }  t_{i} \\leq t \\leq t_{i+1}\\;. \\end{cases}\n\\qquad(26.3)\\]\nActually, we will view a caplet as an option on a forward contract and apply Black’s formula. To do this, we need to know the forward price of the asset with price \\(S_i_t\\) for a contract maturing at \\(t_{i+1}\\). We denote this forward price by \\(F_i_t\\). The synthetic forward argument presented in Section 13.5 shows that for any dividend-reinvested asset with price \\(S\\), the forward price for a contract maturing at \\(T\\) is \\(S_t/P(t,T)\\). So, \\(F_i\\) is given by\n\\[\nF_i_t = \\begin{cases} \\frac{P(t,t_i)}{P(t,t_{i+1})}-1 & \\text{if } t &lt; t_{i}\\; ,\\\\\n\\mathcal{R}_i\\,\\varDelta t & \\text{if }  t_{i} \\leq t \\leq t_{i+1}\\;. \\end{cases}\n\\]\n\\[\n= \\begin{cases}\\mathcal{R}_i_t\\,\\Delta t & \\text{if } t &lt; t_{i}\\; ,\\\\\n\\mathcal{R}_i\\,\\Delta t & \\text{if }  t_{i} \\leq t \\leq t_{i+1}\\;, \\end{cases}\n\\qquad(26.4)\\]\nwhere \\(\\mathcal{R}_i_t\\) is the forward rate defined in Equation 26.2. Thus, the asset with price \\(S_i_t\\) pays the spot rate at date \\(t_i\\) times the period length at date \\(t_{i+1}\\), and the forward price of this asset is the forward rate times the period length.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:valuingcaps",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:valuingcaps",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.4 The Market Model for Caps and Floors",
    "text": "26.4 The Market Model for Caps and Floors\nThe valuation we will describe here is standard market practice for valuing caps and floors or at least for quoting the prices of caps and floors. Specifically, it is standard to quote prices in terms of implied volatilities, where the volatility is to be input into Black’s formula for options on forwards. This model is sometimes called the market model. \nWe can apply Black’s formula to the forward contract with price \\(F_i\\) described in the previous section. We view the caplet as a call option maturing at \\(t_i\\) on this forward contract that matures at \\(t_{i+1}\\). As explained in Chapter~\\(\\ref{c_forwardexchange}\\), the value at the maturity date \\(T\\) of a call option with strike \\(K\\) on a forward contract with price \\(F\\) maturing at \\(T' \\geq T\\) is \\(\\max(0,F_T-K)P(T,T')\\). Therefore, the value at maturity of a call option maturing at \\(t_i\\) with strike \\(\\bar{\\mathcal{R}}\\,\\Delta t\\) on the forward contract with price \\(F_i\\) is \\[\\max(0,F_i_{t_i}-\\bar{\\mathcal{R}}\\,\\Delta t)P(t_i,t_{i+1})\\; .\\] Since \\(F_i_{t_i}=\\mathcal{R}_i\\,\\Delta t\\), this equals \\[\n\\max(0,\\mathcal{R}_i-\\bar{\\mathcal{R}})\\,\\Delta t\\,P(t_i,t_{i+1})\\;.\n\\qquad(26.5)\\]\nThis is also the value of the caplet at date \\(t_i\\).\nIt follows that the value of the caplet at any date \\(t\\leq t_i\\) is the value of the call option on the forward contract. To apply Black’s formula, we need the forward price to have a constant (or at least non-randomly varying) volatility. As noted earlier, at dates \\(t\\leq t_i\\), \\(F_i_t=\\mathcal{R}_i_t\\,\\Delta t\\), where \\(\\mathcal{R}_i_t\\) is the forward rate, so the volatility of the forward price is the volatility of the forward rate. Black’s formula yields:\n\n\n\n\n\n\n26.5\n\n\n\nAssuming the forward rate \\(\\mathcal{R}_i_t\\) has a constant volatility \\(\\sigma\\), the value at date \\(0&lt;t_i\\) of a caplet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\) is\n\\[\nP(0,t_{i+1})\\mathcal{R}_i_0\\,\\Delta t\\,N(d_1) - P(0,t_{i+1})\\bar{\\mathcal{R}}\\,\\Delta t\\,N(d_2)\\;,\n\\qquad(26.6)\\]\nand the value at date \\(0&lt;t_i\\) of a floorlet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\) is \\[\nP(0,t_{i+1})\\bar{\\mathcal{R}}\\,\\Delta t\\,N(-d_2)- P(0,t_{i+1})\\mathcal{R}_i_0\\,\\Delta t\\,N(-d_1)\\;,\n\\qquad(26.7)\\]\nwhere\n\\[\nd_1 = \\frac{\\log \\left(\\mathcal{R}_i_0/\\bar{\\mathcal{R}}\\right)+\\frac{1}{2}\\sigma^2 t_i}{\\sigma\\sqrt{t_i}}\\; ,\n\\] \\[\nd_2 = d_1 - \\sigma\\sqrt{t_i}\\;.\n\\]\n\n\nThe put-call parity relationship for caplets and floorlets can be seen as follows. If we add \\(\\bar{\\mathcal{R}}\\Delta t\\) to the caplet payment, we obtain \\[\\bar{\\mathcal{R}}\\,\\Delta t +  \\max(0,\\mathcal{R}_i-\\bar{\\mathcal{R}})\\,\\Delta t = \\max( \\bar{\\mathcal{R}}, \\mathcal{R}_i)\\,\\Delta t\\; .\\] On the other hand, if we add \\(\\mathcal{R}_i\\,\\Delta t\\) to the floorlet payment, we obtain the same thing: \\[\\mathcal{R}_i\\,\\Delta t + \\max(0,\\bar{\\mathcal{R}}-\\mathcal{R}_i)\\,\\Delta t = \\max( \\mathcal{R}_i,\\bar{\\mathcal{R}} )\\,\\Delta t\\; .\\] Hence, the value of a caplet plus the value of receiving \\(\\bar{\\mathcal{R}}\\,\\Delta t\\) at date \\(t_{i+1}\\) must equal the value of a floorlet plus the value of receiving \\(\\mathcal{R}_i\\,\\Delta t\\) at date \\(t_{i+1}\\). The value at any date \\(t\\leq t_i\\) of receiving \\(\\bar{\\mathcal{R}}\\,\\Delta t\\) at date \\(t_{i+1}\\) is the value of \\(\\bar{\\mathcal{R}}\\,\\Delta t\\) discount bonds maturing at date \\(t_{i+1}\\), which we are denoting by \\(\\bar{\\mathcal{R}}\\,\\Delta t P(t,t_{i+1})\\). The value at at any date \\(t\\leq t_i\\) of obtaining \\(\\mathcal{R}_i\\,\\Delta t\\) dollars at date \\(t_{i+1}\\) is\n\\(S_i_t =P(t,t_i)-P(t,t_{i+1})\\). We conclude that \\[\\text{ Value of Caplet} \\;+ \\;\\bar{\\mathcal{R}}\\,\\Delta t P(t,t_{i+1}) = \\text{Value of Floorlet} \\;+\\; P(t,t_i)-P(t,t_{i+1})\\; .\\]\nWe will compute the value of each caplet with the Black_Call function. In the Black_Call function, we input the forward price for the caplet with reset date \\(t_i\\) as \\[\nF_i_0 = \\mathcal{R}_i_0\\,\\Delta t = \\frac{P(0,t_i)}{P(0,t_{i+1})} - 1\\;,\n\\qquad(26.8)\\]\nas given in Equation 26.2 and Equation 26.4. The exercise price of each caplet is \\(K=\\bar{\\mathcal{R}}\\,\\Delta t\\). We also need to input the discounting factor \\(P(0,t_{i+1})\\). The discount bond prices \\(P(0,t_1)\\), , \\(P(0, t_N)\\) are input as a vector P. The discount bond price \\(P(0,t_0)\\) is input as P0. We will assume the same volatility for each forward rate.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_call(F, K, P, sigma, T):\n    d1 = (np.log(F / K) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return P * (F * norm.cdf(d1) - K * norm.cdf(d2))\n\ndef market_model_cap(P0, P, rbar, sigma, N, t0, dt):\n    K = rbar * dt\n    if t0 == 0:\n        return P[0] * max(0, 1 / P[0] - 1 - rbar * dt)\n    else:\n        F = P0 / P[0] - 1\n        cap_value = black_call(F, K, P[0], sigma, t0)\n    \n    for i in range(1, N):\n        F = P[i - 1] / P[i] - 1\n        cap_value += black_call(F, K, P[i], sigma, t0 + i * dt)\n    \n    return cap_value\n\n# Example usage\nP0 = 0.95\nP = [0.92, 0.89, 0.85, 0.80]\nrbar = 0.03\nsigma = 0.2\nN = 4\nt0 = 0.5\ndt = 0.5\nT = 2\n\nprint(\"Market Model Cap:\", market_model_cap(P0, P, rbar, sigma, N, t0, dt))\n\n\nMarket Model Cap: 0.09810002490023066",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:swaptions",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:swaptions",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.6 The Market Model for European Swaptions",
    "text": "26.6 The Market Model for European Swaptions\nThe owner of a European swaption has an option to enter into a swap at the maturity date of the swaption. A payer swaption gives the owner of the option the right to enter into a swap as a fixed-rate payer, for a given swap rate (not necessarily a rate that makes the swap have zero value at any date). The owner of a receiver swaption has the right to enter into the swap as a fixed-rate receiver. The values of payer swaptions and receiver swaptions are linked by put-call parity.\nA payer swaption has similarities to a cap. The owner of a cap has the right to receive the floating rate and pay the fixed rate and will do so in each period in which the floating rate is higher. Similarly, the owner of a payer swaption has the right to receive floating and pay fixed. However, the owner of a cap chooses each period whether to exercise his option, whereas the owner of a swaption makes a once-and-for-all decision whether to exercise, at the maturity of the swaption. A cap is therefore a portfolio of options, whereas a swaption is an option on a portfolio. In general of course, other things being equal, a portfolio of options is worth more than an option on a portfolio.\nConsider a payer swaption with maturity date \\(T\\) and swap rate \\(\\bar{\\mathcal{R}}\\), where the underlying swap has payment dates \\(t_1,\\ldots,t_N\\) with the first reset date of the swap being \\(t_0 = t_1-\\Delta t \\geq T\\). We assume the notional principal of the swap is $1. Expression Equation 25.5 in Section 25.3 gives the value at date \\(T\\) to the payer in the swap as \\[S_T-Z_T\\; ,\\] where we define\n\\[\nS_t=P(t,t_0)- P(t,t_N)\\; ,\n\\] \\[\nZ_t =  \\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(t,t_i)\\;.\n\\qquad(26.9)\\]\nAs explained in Section 25.3, \\(S_t\\) is the value of the floating-rate payments in the swap and \\(Z_t\\) is the value of the fixed-rate payments. The value of a payer swaption at its maturity \\(T\\) is therefore \\[\\max(0,S_T-Z_T)\\; .\\] We can value the swaption using Margrabe’s formula for exchange options provided the ratio of prices \\(S/Z\\) has a constant (or non-randomly varying) volatility. The volatility of the ratio is the same as the volatility of the forward swap rate. To see this, recall that in Section 25.3 the forward swap rate \\(\\mathcal{R}_t\\) was defined to be the rate such that \\[P(t,t_0)- P(t,t_N) = \\mathcal{R}_t\\,\\Delta t \\sum_{i=1}^N P(t,t_i)\\; ,\\] which means that the swap would have zero value if initiated at date \\(t\\) at the rate \\(\\mathcal{R}_t\\)—cf. equation~Equation 25.6. Thus, \\[\\begin{equation*}\n\\frac{S_t}{Z_t} = \\frac{P(t,t_0)- P(t,t_N)}{\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(t,t_i)} = \\frac{\\mathcal{R}_t\\,\\Delta t \\sum_{i=1}^N P(t,t_i)}{\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(t,t_i)} = \\frac{\\mathcal{R}_t}{\\bar{\\mathcal{R}}}\\;,\n\\end{equation*}\\] where \\(\\mathcal{R}_t\\) is the forward swap rate.\nMargrabe’s formula implies:1\n\n\n\n\n\n\n26.7\n\n\n\nAssuming the forward swap rate \\(\\mathcal{R}_t\\) has a constant volatility \\(\\sigma\\), the date–0 value of a European payer swaption is\n\\[\n\\big[P(0,t_0)-P(0,t_N)\\big]N(d_1) - \\left[\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(0,t_i)\\right]N(d_2)\\;,\n\\qquad(26.10)\\]\nand the date–0 value of a European receiver swaption is \\[\n\\left[\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(0,t_i)\\right]N(-d_2) - \\big[P(0,t_0)-P(0,t_N)\\big]N(-d_1)\\;,\n\\qquad(26.11)\\]\nwhere\n\\[\nd_1 = \\frac{\\log\\big(P(0,t_0)-P(0,t_N)\\big) - \\log\\left(\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(0,t_i)\\right) + \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(26.12)\\]\n\\[\nd_2 = d_1-\\sigma\\sqrt{T}.\n\\]\n\n\nPut-call parity for swaptions is as follows: fixed-rate cash flows plus the option to exchange for floating is equivalent to floating-rate cash flows plus the option to exchange for fixed. In each side of this equivalence, one obtains, at the option maturity, the larger of the values of the fixed and floating-rate legs. More formally, \\[\\begin{multline*} \\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(T,t_i) + \\max\\left(0, \\,P(T,t_0)- P(T,t_N)-  \\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(T,t_i)\\right) \\\\= P(T,t_0)- P(T,t_N) + \\max\\left(0,\\,  \\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(T,t_i)-P(T,t_0)+ P(T,t_N)\\right).\n\\end{multline*}\\] Therefore, at any date \\(t \\leq T\\),\n\\[\\begin{multline}\n\\bar{\\mathcal{R}}\\,\\Delta t \\sum_{i=1}^N P(t,t_i)\\; + \\;\\text{Value of Payer Swaption}\\\\ =\nP(t,t_0)- P(t,t_N) \\;+ \\;\\text{Value of Receiver Swaption}.\n\\end{multline}\\] {#eq-swaptionparity}\nThe following code uses the Margrabe formula to price a European swaption.\n\n\nCode\ndef margrabe(S1, S2, sigma, q1, q2, T):\n    sigma2 = sigma ** 2 * T\n    d1 = (np.log(S1 / S2) + 0.5 * sigma2) / np.sqrt(sigma2)\n    d2 = d1 - np.sqrt(sigma2)\n    return S1 * norm.cdf(d1) - S2 * norm.cdf(d2)\n\ndef market_model_payer_swaption(P0, P, rbar, sigma, N, T, dt):\n    floating_leg_value = P0 - P[N - 1]\n    fixed_leg_value = P[0]\n    for i in range(1, N):\n        fixed_leg_value += P[i]\n    fixed_leg_value *= rbar * dt\n    \n    return margrabe(floating_leg_value, fixed_leg_value, sigma, 0, 0, T)\n\n\n# Example usage\nP0 = 0.95\nP = [0.92, 0.89, 0.85, 0.80]\nrbar = 0.03\nsigma = 0.2\nN = 4\nt0 = 0.5\ndt = 0.5\nT = 2\n\nprint(\"Market Model Payer Swaption:\", market_model_payer_swaption(P0, P, rbar, sigma, N, T, dt))\n\n\nMarket Model Payer Swaption: 0.09810051508638021",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:consistency",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:consistency",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.8 A Comment on Consistency",
    "text": "26.8 A Comment on Consistency\nIt is well known that it is inconsistent to assume both that the forward rates \\(\\mathcal{R}_i_t\\) and the forward swap rate \\(\\mathcal{R}_t\\) have constant volatilities. We can obtain some intuition for this as follows. Recall that \\[\\mathcal{R}_i_t\\,\\Delta t = \\frac{P(t,t_i)-P(t,t_{i+1})}{P(t,t_{i+1})}\\; ,\\] and \\[\\mathcal{R}_t\\,\\Delta t = \\frac{P(t,t_0)-P(t,t_N)}{\\sum_{i=0}^{N-1} P(t,t_{i+1})}\\; .\\] The numerator in the last equation is the sum (over \\(i=0,\\dots,N\\!-\\!1\\)) of the numerators in the previous equation; hence, it is the sum of the \\(\\mathcal{R}_i_t\\,\\Delta t\\,P(t,t_{i+1})\\). This implies that \\[\\mathcal{R}_t = \\frac{\\sum_{i=0}^{N-1} P(t,t_{i+1})\\mathcal{R}_i_t}{\\sum_{i=1}^{N-1}P(t,t_{i+1})}\\; ,\\] which we can write as \\[\\mathcal{R}_t = \\sum_{i=0}^{N-1} w_i_t \\mathcal{R}_i_t\\; ,\\] where the weights \\(w_i_t\\) are defined as \\[w_i_t = \\frac{P(t,t_{i+1})}{\\sum_{i=0}^{N-1}P(t,t_{i+1})}\\; .\\] Therefore, the forward swap rate is a weighted average of the forward rates. A sum (or average) of lognormal variables is not lognormal, so if the forward rate has a constant volatility, then the forward swap rate will not (and vice versa), absent very peculiar assumptions about the weights \\(w_i_t\\). This means that one should not really simultaneously use Black’s formula for valuing caps (or floors) and Margrabe’s formula for valuing swaptions (though there is evidence that the error introduced by doing so may be small). In the following chapters, we will consider other models that do not suffer from this type of inconsistency.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:caps2",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:caps2",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.9 Caplets as Puts on Discount Bonds",
    "text": "26.9 Caplets as Puts on Discount Bonds\nPreviously, we considered a caplet as a call option on the forward rate and thus a bet on higher interest rates. This is equivalent to a bet on lower bond prices, and we will now show that a caplet with payment date \\(t_{i+1}\\) is equivalent to \\(1+\\bar{\\mathcal{R}}\\,\\Delta t\\) put options on the \\(t_{i+1}\\)–maturity discount bond. The put options mature at the reset date \\(t_i\\) of the caplet and have strike equal to \\(1/(1+ \\bar{\\mathcal{R}}\\,\\Delta t)\\). To see this equivalence, note that the value of \\(1+\\bar{\\mathcal{R}}\\,\\Delta t\\) such options at their maturity date \\(t_i\\)~is \\[\\begin{multline*}\n\\big[1+\\bar{\\mathcal{R}}\\,\\Delta t\\big] \\max\\left(0,\\frac{1}{1+ \\bar{\\mathcal{R}}\\,\\Delta t}-P(t_i,t_{i+1})\\right) \\\\ \\begin{array}{l}\n= \\max\\big(0,\\,1-\\big[1+\\bar{\\mathcal{R}}\\,\\Delta t\\big]P(t_i,t_{i+1})\\big)\\\\\n=P(t_i,t_{i+1})\\max\\left(0,\\frac{1}{P(t_i,t_{i+1})}-1-\\bar{\\mathcal{R}}\\,\\Delta t\\right)\\;. \\end{array}\n\\end{multline*}\\] Given that \\(1/P(t_i,t_{i+1}) = 1+\\mathcal{R}_i\\,\\Delta t\\), this equals \\[P(t_i,t_{i+1}) \\max(0,\\mathcal{R}_i-\\bar{\\mathcal{R}})\\,\\Delta t\\; .\\] This is the value at date \\(t_i\\) of the caplet with payment date \\(t_{i+1}\\) shown in expression Equation 26.5. It follows that the caplet and the \\(1+\\bar{\\mathcal{R}}\\,\\Delta t\\) put options must have the same value at any date prior to \\(t_i\\).\nSimilarly, a floorlet with payment date \\(t_{i+1}\\) is equivalent to \\(1+\\bar{\\mathcal{R}}\\,\\Delta t\\) call options on the \\(t_{i+1}\\)–maturity discount bond, with the call options maturing at date \\(t_i\\) and having strike equal to \\(1/(1+ \\bar{\\mathcal{R}}\\,\\Delta t)\\).\nIn the following chapters, we will describe models for valuing bond options. These models will also be applied to price caps, as portfolios of put options on discount bonds, and to price floors, as portfolios of calls.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#sec-s:swaptionscouponbondoptions",
    "href": "Chapter_FixedIncomeDerivatives.html#sec-s:swaptionscouponbondoptions",
    "title": "26  Fixed-Income Derivatives",
    "section": "26.10 Swaptions as Options on Coupon Bonds",
    "text": "26.10 Swaptions as Options on Coupon Bonds\nAs noted previously, the value at date \\(T\\) of the payer swaption, if exercised, is \\[P(T,t_0)-P(T,t_N) - \\bar{\\mathcal{R}}\\,\\Delta t\\sum_{i=1}^N P(T,t_i)\\; .\\] In Section 26.6, we considered this as the difference of two pieces, the first piece being \\(S_T = P(T,t_0)-P(T,t_N)\\), which is the value of the floating-rate leg, and the second being \\(Z_T = \\bar{\\mathcal{R}}\\,\\Delta t\\sum_{i=1}^N P(T,t_i)\\), the value of the fixed-rate leg. We can also separate it differently—the first part being \\(P(T,t_0)\\), which is the value at the swaption maturity of the discount bond maturing at \\(t_0\\), and the second part being \\(P(T,t_N)+\\bar{\\mathcal{R}}\\,\\Delta t\\sum_{i=1}^N P(T,t_i)\\), which is the value of a fixed-rate bond including the face value at maturity. Thus, a payer swaption is equivalent to an option to exchange a fixed-rate coupon bond for a discount bond. A receiver swaption is an option to engage in the reverse exchange. \nTypically, \\(t_0=T\\) (the swap starts at the swaption maturity), in which case \\(P(T,t_0)=1\\) and the payer (receiver) swaption is a standard put (call) option on the coupon bond, with exercise price equal to 1. The models developed in later chapters for valuing options on coupon bonds can therefore also be applied to value swaptions.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#section-2",
    "href": "Chapter_FixedIncomeDerivatives.html#section-2",
    "title": "26  Fixed-Income Derivatives",
    "section": "",
    "text": "Exercise 26.1  \nModify the function MarketModel_Cap so that rather than taking P0 and the vector P of discount bond prices as inputs, it looks up discount bond prices from a function DiscountBondPrice that returns a discount bond price for any maturity. For example, DiscountBondPrice might be based on a cubic spline fit to the yield curve as discussed in Section 25.1. To test the new function MarketModel_Cap, you will need to create a test function DiscountBondPrice. For example, you could use the following, which corresponds to a rather steeply increasing yield curve, especially at the short end.\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a function MarketModel_Cap_ImpliedVol that uses bisection to find the forward rate volatility (assume the same volatility for each forward rate) that equates the cap price given by MarketModel_Cap to a market cap price. The function should take the same inputs as MarketModel_Cap except that the forward rate volatility should be replaced by the market cap price.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 26.1 for the function MarketModel_Payer_Swaption.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a function MarketModel_Payer_Swaption_ImpliedVol that uses bisection to find the forward swap rate volatility that equates the swaption price given by MarketModel_Payer_Swaption to a market swaption price. The function should take the same inputs as MarketModel_Payer_Swaption except that the forward swap rate volatility should be replaced by the market swaption price.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function MarketModel_Floor to value a floor, assuming the forward rates have constant and equal volatilities. Write the function so that it looks up discount bond prices from the DiscountBondPrice function.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function MarketModel_Receiver_Swaption to value a receiver swaption, assuming the forward swap rate has a constant volatility. Write the function so that it looks up discount bond prices from the DiscountBondPrice function.\n\n\n\n\nExercise 26.2 The following exercise is motivated by an example presented in one of my classes by David Eichhorn of NISA Investment Advisors.\n\nUsing the DiscountBondPrice function above, calculate what the swap rate should be today for a 10-year swap with semiannual cash flows.\nCalculate the value of a $ 3 $ European receiver swaption (an option maturing in 3 years to enter into a 10-year swap as the receiver) with the underlying swap having semiannual cash flows and the fixed rate being equal to the spot swap rate calculated in part (a). Assume the forward swap rate has a constant volatility equal to 0.1.\nConsider a $ 3 $ European payer swaption with the underlying swap having semiannual cash flows. Calculate the fixed rate of the swap that makes the payer swaption have the same value as the receiver swaption calculated in part (b). Assume the forward swap rate has a constant volatility equal to 0.1.\nCalculate the forward swap rate for a 10-year swap with semiannual cash flows beginning in 3 years.\n\nCommentary\nA collar is an alternative to a forward contract. With standard options, as mentioned in ?sec-s:fundamentalconcepts, a collar consists of a long call and short put (or the reverse). If the strike of each equals the forward price, then the collar is equivalent to a forward and will have zero cost—by put-call parity, both options have the same price, so the purchase of the call can be financed by selling the put. One can also construct a zero-cost collar with the call and put having different strikes.\nA swaption collar is an alternative to a forward swap contract. For example, consider a long receiver swaption with the underlying swap rate being \\(\\bar{\\mathcal{R}}_r\\) and a short payer swaption with the underlying swap rate being \\(\\bar{\\mathcal{R}}_p &gt; \\bar{\\mathcal{R}}_r\\), with the swaptions having the same time to maturity \\(T\\). If the market swap rate \\(\\mathcal{R}_T\\) at date \\(T\\) is below \\(\\bar{\\mathcal{R}}_r\\) then the receiver swaption will be in the money and will be exercised—one would rather receive \\(\\bar{\\mathcal{R}}_r\\) than \\(\\mathcal{R}_T\\) in this circumstance. Likewise, if \\(\\mathcal{R}_T &gt; \\bar{\\mathcal{R}}_p\\) then the payer swaption will be exercised—one would rather pay \\(\\bar{\\mathcal{R}}_p\\) than \\(\\mathcal{R}_T\\) in this circumstance. When \\(\\bar{\\mathcal{R}}_p &gt;\\mathcal{R}_T&gt; \\bar{\\mathcal{R}}_r\\), neither swaption is in the money. Thus, we have the following for the investor who is long the receiver swaption and short the payer swaption:\n\n\\(\\mathcal{R}_T&lt; \\bar{\\mathcal{R}}_r \\Longrightarrow\\) receive \\(\\bar{\\mathcal{R}}_r\\) and pay floating for the maturity of the swap contract,\n\\(\\bar{\\mathcal{R}}_r&lt; \\mathcal{R}_T&lt; \\bar{\\mathcal{R}}_p \\Longrightarrow\\) neither swaption exercised,\n\\(\\mathcal{R}_T &gt; \\bar{\\mathcal{R}}_p \\Longrightarrow\\) receive \\(\\bar{\\mathcal{R}}_p\\) and pay floating for the maturity of the swap contract.\n\nNote that one can always pay floating just by borrowing short term; it is receiving fixed that is important here. In the second case above, the investor can engage in a swap at date \\(T\\) and receive the market swap rate \\(\\mathcal{R}_T\\). Thus, the collar guarantees that he will receive at least \\(\\bar{\\mathcal{R}}_r\\) and will receive no more than \\(\\bar{\\mathcal{R}}_p\\), whatever might be the market swap rate at date \\(T\\).\nAn institution such as a pension fund can use a receiver swap to help hedge its fixed-rate liabilities. As an alternative, it can use a collar as just described. The difference is that a forward receiver swap would guarantee a fixed rate to be received, whereas the collar leaves some residual risk—it guarantees only that the fixed rate will be between \\(\\bar{\\mathcal{R}}_r\\) and \\(\\bar{\\mathcal{R}}_p\\). This risk may appear attractive. In Exercise 26.2, the lower rate \\(\\bar{\\mathcal{R}}_r\\) is the market swap rate, and the higher rate \\(\\bar{\\mathcal{R}}_p\\) is significantly higher; thus, it may appear that the worst-case scenario is the same as what one can get in the market with a swap and the best case is significantly better. However, this is an illusion, because the appropriate comparison is with a forward swap (starting at the maturity of the swaptions) and the forward swap rate is substantially higher than the spot swap rate (due to the yield curve being steeply upward sloping). This illusion may create a good marketing opportunity for sellers of collars.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_FixedIncomeDerivatives.html#footnotes",
    "href": "Chapter_FixedIncomeDerivatives.html#footnotes",
    "title": "26  Fixed-Income Derivatives",
    "section": "",
    "text": "To improve the clarity of the typesetting, we have written \\(\\log(S)-\\log(Z)\\) in Equation 26.12 instead of our customary \\(\\log(S/Z)\\).↩︎",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Fixed-Income Derivatives</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html",
    "href": "Chapter_Vasicek.html",
    "title": "27  Vasicek and Extensions",
    "section": "",
    "text": "27.1 The Short Rate and Discount Bond Prices\nIn the preceding chapter, we presented models for valuing swaptions, caps, and floors based on assumptions that certain forward rates have constant volatilities. As noted, the assumptions used to value swaptions on the one hand and caps and floors on the other are inconsistent. Because the values of fixed-income derivatives are derived from the yield curve, one can obtain a consistent model by developing a model of how the yield curve will evolve over time. In this chapter, we will give a fairly full account of one popular and relatively simple model. The next chapter contains much briefer descriptions of other models.\nWe will begin by describing the basic Vasicek model. The extended Vasicek model (of which there are several versions) includes time-dependent parameters, so that it can be fit to the yield curve at the time it is used and possibly also to other market variables, such as cap prices or yield volatilities.\nAn assumption of the Vasicek model and related models discussed in the next chapter is that there is an instantaneously risk-free rate. Letting \\(r_s\\) denote this rate at date \\(s\\), the meaning of this assumption, as discussed in Chapter 7, is that there is an asset with price process \\[\nR_t = \\exp\\left(\\int_0^t r_s\\,\\mathrm{d}s\\right)\\;.\n\\] The instantaneous rate of return on this asset is \\[\n\\frac{\\,\\mathrm{d}R_t}{R_t} = r_t\\,\\mathrm{d}t\\;.\n\\]\nThere is no random term (of the form \\(\\sigma\\,\\mathrm{d}B\\)) in this rate of return; thus, we view the return as known at date \\(t\\), whence the name instantaneously risk-free. If there were another instantaneously risk-free asset with rate of return \\(\\hat{r}_t\\) which differed from \\(r_t\\) on a non-negligible set of dates and states of the world, there would be an arbitrage opportunity. Hence, we will assume there is a unique instantaneously risk-free rate. We will call this rate the short rate. The interpretation of the price \\(R_t\\) is that it is the amount that would be accumulated by date \\(t\\), beginning with $1 at date \\(0\\) and continuously rolling over the investment in the instantaneously risk-free asset. It is conceptually similar to the net asset value of a money market fund, so \\(R\\) is sometimes called the price of a money market account. We will also call it an accumulation factor.\nThe probability measure associated with \\(R\\) being the numeraire is called the risk-neutral probability, just as when the short rate is constant. Under the risk-neutral probability, the price \\(P(t,u)\\) at date \\(t\\) of a discount bond maturing at \\(u\\) must be \\[\nP(t,u) = R_t \\\\E^R_t \\left[\\frac{1}{R(u)}\\right] = \\\\E^R_t \\left[ \\exp\\left(-\\int_t^u r_s\\,\\mathrm{d}s\\right)\\right]\\;,\n\\qquad(27.1)\\]\nthe first equality being a result of our fundamental pricing Equation 7.28 and the fact that the discount bond pays $1 at maturity and the second equality following from the definition of \\(R\\). Thus, a model for the evolution of the short rate under the risk-neutral probability implies a model for discount bond prices and hence the yield curve.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:vasicek",
    "href": "Chapter_Vasicek.html#sec-s:vasicek",
    "title": "27  Vasicek and Extensions",
    "section": "27.2 The Vasicek Model",
    "text": "27.2 The Vasicek Model\nIn the basic Vasicek (Vasicek 1977) model, it is assumed that \\[\n\\,\\mathrm{d}r_t = \\kappa\\big[\\theta-r_t\\big]\\,\\mathrm{d}t+\\sigma\\,\\mathrm{d}B_t\n\\qquad(27.2)\\]\nfor constants \\(\\kappa\\geq 0\\), \\(\\theta\\), and \\(\\sigma\\), where \\(B\\) is a Brownian motion under the risk-neutral probability. In this model, \\(\\theta\\) is the long-run mean of the short rate process and \\(\\kappa\\) is interpreted as the rate of mean reversion. When \\(r_t &gt;\\theta\\), the drift term will be negative and push \\(r\\) down towards \\(\\theta\\). Likewise, when \\(r_t &lt;\\theta\\), the drift term will be positive and push \\(r\\) up towards \\(\\theta\\). The rate at which \\(r\\) drifts towards \\(\\theta\\) is obviously determined by \\(\\kappa\\). We are going to depart from our convention and call \\(\\sigma\\) the volatility of the short rate even though \\(\\sigma^2\\,\\mathrm{d}t\\) is the instantaneous variance of \\(\\,\\mathrm{d}r\\) rather than \\(\\,\\mathrm{d}r/r\\).\nThe short rate is normally distributed in the Vasicek model. Given information at date \\(t\\)—i.e., knowledge of \\(r_t\\)—then, if \\(\\kappa&gt;0\\), the rate \\(r_s\\) for \\(s&gt;t\\) is normally distributed with mean1 \\[\n\\theta + \\mathrm{e}^{-\\!\\kappa (s-t)}\\big[r_t-\\theta\\big]\n\\qquad(27.3)\\]\nand variance \\[\n\\frac{\\sigma^2\\left(1-\\mathrm{e}^{-2\\kappa(s-t)}\\right)}{2\\kappa}\\;.\n\\qquad(27.4)\\]\nFor any \\(r_t\\), the mean converges to \\(\\theta\\) at long horizons (i.e., as \\(s \\rightarrow \\infty\\)), justifying the interpretation of \\(\\theta\\) as the long run mean. In fact, the mean converges exponentially to \\(\\theta\\) at rate \\(\\kappa\\). The variance at long horizons is \\(\\sigma^2/2\\kappa\\). On the other hand, if \\(\\kappa=0\\), then the short rate is a Brownian motion with volatility \\(\\sigma\\). The mean of \\(r_s\\) is \\(r_t\\) for \\(s&gt;t\\), and the variance of \\(r_s\\) is \\((s-t)\\sigma^2\\). Thus, the uncertainty at long horizons, as measured by the variance, is unbounded when \\(\\kappa=0\\). Whether \\(\\kappa\\) is positive or not, an implication of the normal distribution is that there is a positive probability of the short rate \\(r_s\\) being negative at any date \\(s&gt;t\\), which should not be the case for (nominal) interest rates. However, the probability of negative rates over any given horizon will be small if the variance is sufficiently small. From Equation 27.4, we see that, when \\(\\kappa&gt;0\\), the variance will be small if either the volatility \\(\\sigma\\) is small or the rate of mean reversion \\(\\kappa\\) is large.\nThese facts about the distribution of the short rate demonstrate the importance of assuming mean reversion (\\(\\kappa&gt;0\\)). If \\(\\kappa=0\\), the short rate (because it is a Brownian motion) has the property that for any real number \\(K\\), with probability one there will be some date \\(s&gt;t\\) such that \\(r_s&gt;K\\), irrespective of the starting position \\(r_t\\). Likewise, there will be some date \\(s'&gt;t\\) such that \\(r(s')&lt;-K\\). Thus, the short rate wanders off in both directions in an unbounded way. This property may be reasonable for the logarithm of a stock price, because a stock price may become arbitrarily high or arbitrarily close to zero (implying that the logarithm is unbounded both above and below). However, it is not reasonable for an interest rate, which should exhibit more stability. The assumption of mean reversion (\\(\\kappa&gt;0\\)) provides this stability, guaranteeing that the uncertainty at long horizons is bounded and that on average the short rate will converge back to a finite long-run mean. Nevertheless, we will give results in this chapter for the case \\(\\kappa=0\\), because this is a particularly simple model and because it is the basic building block for what is called the continuous-time Ho-Lee model. The actual Ho-Lee model, which is a binomial model, will be discussed in the following chapter.\nThe relative simplicity of the Vasicek model stems from the fact that under assumption Equation 27.2 the accumulation factor \\(R\\) is lognormally distributed. Specifically, at any date \\(t\\) and given any date \\(u&gt;t\\), the random variable \\[\n\\int_t^u r_s\\,\\mathrm{d}s\n\\] is normally distributed. Its mean and variance depend on the parameters \\(\\kappa\\), \\(\\theta\\), and \\(\\sigma\\) and the length of the time interval \\(u-t\\). The mean also depends on the short rate \\(r_t\\) at date \\(t\\). Therefore, the discount bond price depends on the same things.\nWe will now present an explicit formula for discount bond prices, based on the fundamental Equation 27.1. By taking the Ito differential of \\(r_s\\) in the following, one can verify that it is the solution of the Vasicek model Equation 27.2:^[Equation 27.5 implies the distributional properties of \\(r_s\\) stated earlier. The integral \\(\\int_t^s \\mathrm{e}^{-\\!\\kappa (s-y)} \\,\\mathrm{d}B(y)\\) is normally distributed with mean zero; therefore equation~Equation 27.5 shows that the mean of \\(r_s\\) in the case \\(\\kappa&gt;0\\) is as given in Equation 27.3. The variance is computed, following the rules in ?sec-c:continuoustime, as \\(\\int_t^s \\mathrm{e}^{-2\\kappa (s-y)}\\,\\mathrm{d}y\\), which simplifies to the formula given in Equation 27.4.} \\[\nr_s =  \\theta - \\mathrm{e}^{-\\!\\kappa (s-t)}\\big[\\theta-r_t\\big]+ \\sigma\n\\int_t^s \\mathrm{e}^{-\\!\\kappa (s-y)} \\,\\mathrm{d}B(y).\n\\qquad(27.5)\\]\nIf \\(\\kappa=0\\), this simplifies to \\[\nr_s = r_t + \\sigma\\int_t^s\\,\\mathrm{d}B(y)= r_t + \\sigma[B_s-B_t]\\;.\n\\qquad(27.6)\\]\nThese equations imply the following.\n\n\n\n\n\n\n27.3\n\n\n\nIn the Vasicek model, consider dates \\(t&lt;u\\) and define \\(\\tau=u-t\\). Given the short rate \\(r_t\\) at date \\(t\\), the discount bond price has the form\n\\[\nP(t,u) = \\exp\\left(-a(\\tau)-b(\\tau)r_t\\right)\\;,\n\\qquad(27.7)\\]\nwhere, if \\(\\kappa=0\\),\n\\[\na(\\tau)=-\\sigma^2\\tau^3/6\\;,\n\\qquad(27.8)\\]\n\\[\nb(\\tau) = \\tau\\;,\n\\qquad(27.9)\\]\nand, if \\(\\kappa&gt;0\\), \\[\na(\\tau)= \\theta\\tau-\\frac{\\theta}{\\kappa}\\left(1-\\mathrm{e}^{-\\kappa\\tau}\\right)-\\frac{\\sigma^2}{4\\kappa^3}\\left(2\\kappa\\tau -\\mathrm{e}^{-2\\kappa\\tau}+4\\mathrm{e}^{-\\kappa\\tau}-3\\right)\\;,\n\\qquad(27.10)\\]\n\\[\nb(\\tau)= \\frac{1}{\\kappa}\\left(1-\\mathrm{e}^{-\\kappa\\tau}\\right)\\;.\n\\qquad(27.11)\\]\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will end this section with a proof of Equation 27.7 - Equation 27.11 in the case \\(\\kappa=0\\). The formula for \\(\\kappa&gt;0\\) can be established by the same reasoning, the calculations being only slightly more complicated. From Equation 27.6, we have \\[\\begin{align*}\n\\int_t^u r_s\\,\\mathrm{d}s & = \\int_t^u \\left[r_t+\\sigma \\int_t^s \\,\\mathrm{d}B(y)\\right]\\,\\mathrm{d}s\\\\\n&=\\tau\\, r_t+\\sigma \\int_t^u \\left\\{\\int_t^s \\,\\mathrm{d}B(y) \\right\\} \\,\\mathrm{d}s\\; .\n\\end{align*}\\] We can change the order of integration in the double integral above to obtain \\[\\begin{align*}\n\\int_t^u \\left\\{\\int_t^s \\,\\mathrm{d}B(y) \\right\\} \\,\\mathrm{d}s &=\\int_t^u \\left\\{\\int_y^u \\,\\mathrm{d}s\\,\\right\\} \\,\\mathrm{d}B(y)\\\\\n&=\\int_t^u (u-y)\\,\\mathrm{d}B(y)\\;.\n\\end{align*}\\] Given the information at date \\(t\\), this is a normally distributed random variable with mean zero and variance equal to \\[\n\\int_t^u (u-y)^2\\,\\mathrm{d}y = \\frac{\\tau^3}{3}\\;.\n\\] Therefore, \\(\\int_t^u r_s\\,\\mathrm{d}s\\) is normally distributed with mean \\(\\tau\\, r_t\\) and variance \\(\\sigma^2\\tau^3/3\\). We now use the fact that if \\(x\\) is normally distributed with mean \\(\\mu\\) and variance \\(\\sigma^2\\), then the mean of \\(\\mathrm{e}^x\\) is \\(\\mathrm{e}^{\\mu+\\sigma/2}\\). Substituting this into Equation 27.1 gives the result.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#estimating-the-vasicek-model",
    "href": "Chapter_Vasicek.html#estimating-the-vasicek-model",
    "title": "27  Vasicek and Extensions",
    "section": "27.4 Estimating the Vasicek Model",
    "text": "27.4 Estimating the Vasicek Model\nOne way to choose the parameters \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\) of the Vasicek model is to imply them from market bond prices and Equation 27.7 - Equation 27.11. This is analogous to implying the volatility of a stock from market option prices and the Black-Scholes formula. This can also be viewed as an alternative to fitting a cubic spline, as discussed in Chapter 25. Rather than selecting the parameters of the cubic spline to provide the best approximation to market bond prices, one can choose the Vasicek parameters \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\). The Equation 27.1 will then give prices of discount bonds of all maturities.2\nAn alternative procedure is to estimate the parameters from historical data on the short rate. The short rate is a theoretical construct and one must choose some proxy to use for empirical work, for example, the Federal Funds rate, or the yield of a short-term (typically one-month or three-month) Treasury bill. One also needs to use a proxy for the short rate when implying the parameters from market bond prices as described in the previous paragraph (or one could view the short rate as one of the parameters to be implied).\nAn issue that arises when estimating the model from historical data is that the Vasicek Equation 27.2 characterizes the evolution of the short rate relative to a Brownian motion under the risk-neutral probability, whereas the historical data is governed by the actual measure. Vasicek (Vasicek 1977) actually assumed that Equation 27.2 holds relative to a Brownian motion under the actual probability measure. We will write his assumption as \\[\n\\,\\mathrm{d}r_t = \\kappa^*[\\theta^*-r_t]\\,\\mathrm{d}t + \\sigma^*\\,\\mathrm{d}B^*_t\\;,\n\\qquad(27.12)\\]\nwhere \\(\\kappa^*\\), \\(\\theta^*\\), \\(\\sigma^*\\) are constants and \\(B^*\\) is a Brownian motion under the actual probability measure.3 Vasicek then assumed a constant market price of risk \\(\\lambda\\) and deduced that^[The price of risk is the new drift of \\(B^*\\) when we change from the actual measure to the risk-neutral probability. See Appendix~\\(\\ref{a_girsanov].}\\) \\[\n\\,\\mathrm{d}r_t = \\kappa^*[\\theta^*-r_t]\\,\\mathrm{d}t + \\sigma^*\\lambda\\,\\mathrm{d}t + \\sigma^*\\,\\mathrm{d}B_t\\;,\n\\qquad(27.13)\\]\nwhere \\(B\\) is a Brownian motion under the risk-neutral probability. This is the same as Equation 27.2 when we define \\(\\kappa=\\kappa^*\\), \\(\\sigma=\\sigma^*\\), and \\(\\theta = \\theta^*+\\sigma^*\\lambda/\\kappa^*\\). This means that the mean-reversion and volatility parameters are the same under the actual and risk-neutral probabilitys, whereas the long-run mean parameters \\(\\theta\\) and \\(\\theta^*\\) are related via the market price of risk. Thus, to estimate \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\) in Equation 27.2, we could estimate \\(\\kappa^*=\\kappa\\), \\(\\sigma^*=\\sigma\\), and \\(\\theta^*\\) from Equation 27.12 and historical data and then choose \\(\\theta\\) to best fit market bond prices.\nWe can estimate the parameters of Equation 27.12 by linear regression. Suppose we have data on a proxy for the short rate at dates \\(t_0, t_1, \\ldots, t_N\\), with \\(t_{i}-t_{i-1}=\\Delta t\\) for each \\(i\\). The solution Equation 27.5 of the Vasicek Equation 27.2 for the short rate, adapted to Equation 27.12, implies the following equation for the changes in the short rate: \\[\\begin{multline*}\nr_{t_i} - r_{t_{i-1}} = \\left(1- \\mathrm{e}^{-\\!\\kappa^* \\Delta t}\\right)\\theta^* -\\left(1- \\mathrm{e}^{-\\!\\kappa^* \\Delta t}\\right)r_{t_{i-1}} \\\\+ \\sigma^*\n\\int_{t_{i-1}}^{t_i} \\mathrm{e}^{-\\!\\kappa^* (t_i-a)} \\,\\mathrm{d}B^*(a)\\; .\n\\end{multline*}\\] We can write this as \\[\nr_{t_i} - r_{t_{i-1}} = a + b\\,r_{t_{i-1}} + \\varepsilon\n\\] where \\(\\varepsilon\\) is a normally distributed random variable, independent of \\(r_{t_{i-1}}\\), with mean zero and variance \\[\n\\sigma^{*2}\n\\int_{t_{i-1}}^{t_i} \\mathrm{e}^{-2\\kappa^* (t_i-a)}\\,\\mathrm{d}a = \\frac{\\sigma^{*2}\\left(1-\\mathrm{e}^{-2\\kappa^*\\Delta t}\\right)}{2\\kappa^*}\\;.\n\\] We can estimate \\(a\\), \\(b\\) and the variance of \\(\\varepsilon\\) by linear regression and then obtain \\(\\kappa^*\\), \\(\\theta^*\\) and \\(\\sigma^*\\) from the equations \\[\\begin{align*}\na& = \\left(1- \\mathrm{e}^{-\\!\\kappa^* \\Delta t}\\right)\\theta^*\\; ,\\\\\nb&= -\\left(1- \\mathrm{e}^{-\\!\\kappa^* \\Delta t}\\right)\\; ,\\\\\n\\text{var}(\\varepsilon) &= \\frac{\\sigma^{*2}\\left(1-\\mathrm{e}^{-2\\kappa^*\\Delta t}\\right)}{2\\kappa^*}\\;.\n\\end{align*}\\]",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:vasicekhedging",
    "href": "Chapter_Vasicek.html#sec-s:vasicekhedging",
    "title": "27  Vasicek and Extensions",
    "section": "27.5 Hedging in the Vasicek Model",
    "text": "27.5 Hedging in the Vasicek Model\nBecause the Brownian motion driving the short rate also drives all the discount bond prices, the bond prices are (instantaneously) perfectly correlated in the Vasicek model (and also in the extensions we will consider next). This is true in any model in which there is a single factor, such as the short rate, that determines all bond prices. The volatilities of the bond returns determine the hedge ratios for hedging one bond with another.\nEquation 27.7 and Ito’s formula (the rule that, if \\(P=\\mathrm{e}^X\\), then \\(\\,\\mathrm{d}P/P = dX + (dX)^2/2\\)) imply that for any date \\(t\\) and any fixed maturity date \\(u&gt;t\\), we have \\[\n\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} = r_t\\,\\mathrm{d}t - \\sigma b(u\\!-\\!t)\\,\\mathrm{d}B_t\\;.\n\\qquad(27.14)\\]\nBecause \\(B\\) is a Brownian motion under the risk-neutral probability, this equation implies that the expected rate of return on a discount bond under the risk-neutral probability is the short rate. This is not a surprise, because it is true for every asset under the risk-neutral probability. What is important in this equation is that the volatility is a non-random function of the date \\(t\\), given the maturity \\(u\\).\nAs an example, consider hedging a short two-year bond with a long position in a one-year bond at some date \\(t\\).\nAccording to Equation 27.14, the change in the value of the short position in the two-year bond will be \\[\n-P(t,t+2)r_t\\,\\mathrm{d}t-P(t,t+2)\\sigma b(2)\\,\\mathrm{d}B_t\n\\]\nSuppose we hold \\(x\\) units of the one-year bond as a hedge and borrow \\[\nxP(t,t+1)-P(t,t+2)\n\\]\ndollars at the instantaneously risk-free rate to finance the hedge. Then the change in the value of the portfolio will be \\[\\begin{multline*}\nxP(t,t+1)r_t\\,\\mathrm{d}t+xP(t,t+1)\\sigma b(1)\\,\\mathrm{d}B_t \\\\- P(t,t+2)r_t\\,\\mathrm{d}t-P(t,t+2)\\sigma b(2)\\,\\mathrm{d}B_t \\\\- [xP(t,t+1)-P(t,t+2)]\\,r\\,\\mathrm{d}t \\\\= xP(t,t+1)\\sigma b(1) \\,\\mathrm{d}B_t -P(t,t+2)\\sigma b(2)\\,\\mathrm{d}B_t\\;,\n\\end{multline*}\\] so a perfect hedge is obtained by setting \\[\nx = \\frac{b(2)P(t,t+2)}{b(1)P(t,t+1)}\\;.\n\\] In the case \\(\\kappa=0\\), this simplifies to \\(x=2P(t,t+2)/P(t,t+1)\\), which means that the dollar value \\(xP(t,t+1)\\) of the holding in the one-year bond is twice the dollar value of the short position in the two-year bond. One holds twice as much of the one-year bond, because it is half as volatile as the two-year bond in this model.\nBy this same reasoning, one can compute a perfect hedge for any discount bond by using another discount bond of any maturity. In fact, one can hedge any term structure derivative in this model by investing the right amount in a bond of any maturity. This is clearly overly simplistic, and such arbitrary hedges would not be used in practice.\nThere is a close connection between hedging in this model and duration hedging, as discussed in Section 25.4. To see this, consider a coupon bond that at date \\(t\\) has remaining cash flows \\(C_1, \\ldots, C_n\\) at dates \\(t+\\tau_1 &lt; \\cdots &lt; t+\\tau_n\\) and price \\(P_t\\). Its price should satisfy \\[\nP_t = \\sum_{j=1}^n C_jP(t,t+\\tau_j)\\;.\n\\] In the Vasicek model, the random part of the change in the price of the coupon bond is \\[\n-\\sigma\\left(\\sum_{j=1}^n b(\\tau_j)C_jP(t,t+\\tau_j)\\right)\\,\\mathrm{d}B_t \\; ,\n\\] and the random part of the return is \\[\n-\\sigma\\left(\\sum_{j=1}^n \\frac{b(\\tau_j)C_jP(t,t+\\tau_j)}{P_t}\\right)\\,\\mathrm{d}B_t\\;.\n\\qquad(27.15)\\]\nConsider the case \\(\\kappa=0\\). Then \\(b(\\tau_j)=\\tau_j\\), so the random part of the return of the coupon bond is \\[\n-\\sigma\\left(\\sum_{j=1}^n \\frac{\\tau_jC_jP(t,t+\\tau_j)}{P_t}\\right)\\,\\mathrm{d}B_t\\;.\n\\] The factor in parentheses is Duration\\('\\) defined in Equation 25.11. Denoting it now as \\(D_t\\) and recognizing that the expected rate of return of the bond must be the short rate, we have, in the Vasicek model with \\(\\kappa=0\\), \\[\n\\frac{\\,\\mathrm{d}P_t}{P_t} = r_t\\,\\mathrm{d}t - \\sigma D_t\\,\\mathrm{d}B_t\\;.\n\\] It follows that in this model one can hedge any fixed-income liability by holding enough of any coupon bond such that the dollar value multiplied by its duration equals the dollar value of the liability multiplied by its duration. In Section 25.4, we noted that duration matching works for parallel shifts in the yield curve. Later, we will see that in the Vasicek model with \\(\\kappa=0\\) only parallel shifts in the yield curve are possible. Therefore, it should not be surprising that duration matching works in this model.\nIn the case \\(\\kappa&gt;0\\), one can interpret the volatility of the coupon bond similarly. The analogue to duration for this model is the weighted average of the function \\(b(\\tau_j)\\) of the times to maturity, as Equation 27.15 shows. The weights again are the fractions of the bond value that each cash flow contributes.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#extensions-of-the-vasicek-model",
    "href": "Chapter_Vasicek.html#extensions-of-the-vasicek-model",
    "title": "27  Vasicek and Extensions",
    "section": "27.6 Extensions of the Vasicek Model",
    "text": "27.6 Extensions of the Vasicek Model\nTo fit the model to current market conditions at the time the model is being used, the parameters \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\) can be taken to be time-dependent. The model with time-dependent parameters is studied in Hull and White (Hull and White 1990) and is usually called the Hull-White model. It is convenient to denote by \\(\\theta_t\\) the time-dependent function replacing the constant \\(\\kappa\\theta\\) in the definition of the Vasicek model Equation 27.2; that is, we redefine as \\(\\theta\\) what was previously \\(\\kappa\\theta\\).4 As usual, we will let date \\(0\\) be the date at which we are using the model. The model is then, for \\(t&gt;0\\), \\[\n\\,\\mathrm{d}r_t = \\theta_t\\,\\mathrm{d}t - \\kappa_tr_t\\,\\mathrm{d}t + \\sigma_t\\,\\mathrm{d}B_t\\;.\n\\qquad(27.16)\\]\nWe will focus on the simplest case, in which \\(\\kappa\\) and \\(\\sigma\\) are constants, deferring discussion of the general case to the last section of this chapter. The general case is quite similar, with the formulas being only slightly more complicated. So, we assume now that \\[\n\\,\\mathrm{d}r_t = \\theta_t\\,\\mathrm{d}t - \\kappa r_t\\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}B_t\\;.\n\\qquad(27.17)\\]\nfor a non-random function \\(\\theta\\).\nWe will call this model with \\(\\kappa&gt;0\\) the Hull-White model. The model with \\(\\kappa=0\\) (i.e., in the absence of mean reversion) is called the continuous-time Ho-Lee model. We will refer to the general case Equation 27.16 as the general Hull-White model, and we will discuss it in Section 27.16. In the Hull-White model, we can interpret \\(\\theta_t/\\kappa\\) as a time-varying long-run mean of the short rate process, because we have \\[\\,\\mathrm{d}r_t = \\kappa\\left[ \\frac{\\theta_t}{\\kappa} - r_t\\right]\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B_t\\; .\\] One can show by the following by directly differentiating.\n\n\n\n\n\n\n27.7\n\n\n\nIn the Hull-White model,\n\\[\nr_s = \\phi_s + \\hat{r}_s\\;,\n\\qquad(27.18)\\]\nwhere\n\\[\n\\phi_s =  \\int_0^s\\mathrm{e}^{-\\kappa(s-y)}\\theta(y)\\,\\mathrm{d}y\\;,\n\\qquad(27.19)\\]\nand \\[\n\\hat{r}_s = \\mathrm{e}^{-\\kappa s}r_0+\\sigma\\int_0^s\\mathrm{e}^{-\\kappa(s-y)}\\,\\mathrm{d}B(y)\\;.\n\\qquad(27.20)\\]\nWhen \\(\\kappa=0\\) (the continuous-time Ho-Lee model), these formulas simplify to \\[\n\\phi_s =  \\int_0^s\\theta(y)\\,\\mathrm{d}y\\;.\n\\qquad(27.21)\\]\nand \\[\n\\hat{r}_s = r_0+\\sigma B_s\\;.\n\\qquad(27.22)\\]\n\n\nNote that Equation 27.20 and Equation 27.22 imply \\[\n\\,\\mathrm{d}\\hat{r}_t = -\\kappa \\hat{r}_t\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}B_t\\; ,\n\\qquad(27.23)\\]\nwhere \\(\\kappa=0\\) for Equation 27.22. Thus, \\(\\hat{r}\\) is a Vasicek short-rate process having a long-run mean of zero.\nThe virtue of the expression for \\(r\\) given in Equation 27.18 - Equation 27.22 is that the basic bond pricing Equation 27.1 now gives us\n\\[\nP(t,u) = \\\\E^R_t \\left[ \\exp\\left(-\\int_t^u r_s\\,\\mathrm{d}s\\right)\\right]\n\\] \\[\n= \\\\E^R_t \\left[ \\exp\\left(-\\int_t^u \\phi_s + \\hat{r}_s\\,\\mathrm{d}s\\right)\\right]\n\\] \\[\n= \\\\E^R_t \\left[ \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s\\right)\\exp\\left(-\\int_t^u  \\hat{r}_s\\,\\mathrm{d}s\\right)\\right]\n\\] \\[\n= \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s\\right)\\\\E^R_t \\left[ \\exp\\left(-\\int_t^u \\hat{r}_s\\,\\mathrm{d}s\\right)\\right]\\;.\n\\qquad(27.24)\\]\nThus, the non-random part \\(\\phi_s\\) of the short-rate process pulls out of the expectation in the pricing formula. Furthermore, we have already calculated the expectation in Equation 27.24 because it is the discount bond price in the Vasicek model with a long-run mean of zero. This yields the following.\n\n\n\n\n\n\n27.8\n\n\n\nConsider dates \\(t&lt;u\\) and define \\(\\tau=u-t\\). The price at date \\(t\\) of a discount bond maturing at date \\(u\\) in the extended Vasicek model is\n\\[\nP(t,u) = \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s-a(\\tau)-b(\\tau)\\hat{r}_t\\right)\\;,\n\\qquad(27.25)\\]\nwhere, in the continuous-time Ho-Lee model,\n\\[\na(\\tau)=-\\sigma^2\\tau^3/6\\;,\n\\qquad(27.26)\\]\n\\[\nb(\\tau) = \\tau\\;,\n\\qquad(27.27)\\]\nand, in the Hull-White model, \\[\na(\\tau)= -\\frac{\\sigma^2}{4\\kappa^3}\\left(2\\kappa\\tau -\\mathrm{e}^{-2\\kappa\\tau}+4\\mathrm{e}^{-\\kappa\\tau}-3\\right)\\;,\n\\qquad(27.28)\\]\n\\[\nb(\\tau)= \\frac{1}{\\kappa}\\left(1-\\mathrm{e}^{-\\kappa\\tau}\\right)\\;.\n\\qquad(27.29)\\]\n\n\nUsing the fact that the expected rate of return on a discount bond must be the short rate under the risk-neutral probability, we obtain from Equation 27.25 and Equation 27.23 that, for each fixed maturity date \\(u\\), \\[\n\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} = r_t\\,\\mathrm{d}t - \\sigma b(\\tau)\\,\\mathrm{d}B_t\\;.\n\\qquad(27.30)\\]\nThus, the volatilities are determined by the function \\(b\\), just as in the basic Vasicek model. The computation of hedge ratios is therefore analogous to the computations presented in Section 27.5 for the basic Vasicek model. In fact, the volatilities of discount bond returns in the Hull-White model are the same as in the Vasicek model with \\(\\kappa&gt;0\\), and the volatilities in the continuous-time Ho-Lee model are the same as in the Vasicek model with \\(\\kappa=0\\).",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:vasicek_fitting",
    "href": "Chapter_Vasicek.html#sec-s:vasicek_fitting",
    "title": "27  Vasicek and Extensions",
    "section": "27.9 Fitting Discount Bond Prices and Forward Rates",
    "text": "27.9 Fitting Discount Bond Prices and Forward Rates\nIt is simple to fit the Hull-White model and continuous-time Ho-Lee model to market discount bond prices by choosing the function \\(\\phi\\). We will use the superscript mkt to denote market prices. Letting date \\(0\\) denote the date at which we are fitting the model, we want to have \\[\nP^{\\text{mkt}}(0,u) = P(0,u)\n\\] for all maturities \\(u\\), where \\(P(0,u)\\) denotes the model prices given in Equation 27.25 as \\[\nP(0,u) = \\exp\\left(-\\int_0^u \\phi_s\\,\\mathrm{d}s-a(u)-b(u)r_0\\right)\\;.\n\\] The functions \\(a\\) and \\(b\\) depend on \\(\\kappa\\) and \\(\\sigma\\), but we regard them now as having already been chosen. Therefore, to match the model prices to market prices, we simply have to set \\[\n\\exp\\left(-\\int_0^u \\phi_s\\right) = \\exp\\left(a(u)+b(u)r_0\\right)P^{\\text{mkt}}(0,u)\\;.\n\\qquad(27.31)\\]\nUsually we will only need to solve Equation 27.31 for a finite number of maturities \\(u\\) in order to calibrate the model sufficiently. We will illustrate this in the analysis of coupon bond options in Section 27.13. However, the equation can be solved in principle for each maturity \\(u\\) as follows: take the natural logarithm of both sides, multiply by minus 1, and differentiate with respect to \\(u\\) to obtain \\[\n\\phi(u) = -\\frac{\\partial a(u)}{\\partial u} - \\frac{\\partial b(u)}{\\partial u}r_0 - \\frac{ \\partial \\log P^{\\text{mkt}}(0,u)}{\\partial u}\\;.\n\\qquad(27.32)\\]\nEquation 27.32 gives the solution of the model for \\(\\phi(u)\\), and it also has an important interpretation. We can obviously rearrange it as \\[\n\\phi(u) +\\frac{\\partial a(u)}{\\partial u} + \\frac{\\partial b(u)}{\\partial u}r_0 = -\\frac{ \\partial \\log P^{\\text{mkt}}(0,u)}{\\partial u}\\;.\n\\qquad(27.33)\\]\nThe expression \\[\n-\\frac{\\partial \\log P^{\\text{mkt}}(0,u)}{\\partial u}\n\\] is the market instantaneous forward rate at date \\(0\\) for maturity \\(u\\). The left-hand side of Equation 27.33 is equal to \\[\n-\\frac{\\partial \\log P(0,u)}{\\partial u}\\; ,\n\\] and hence is the model instantaneous forward rate at date \\(0\\) for maturity \\(u\\).\nTherefore, fitting the model to the yield curve is equivalent to fitting model forward rates to market forward rates.^[To understand the interpretation of the derivatives of the log bond prices as forward rates, consider the market prices \\(P^{\\text{mkt}}(0,u)\\). Recall from our discussion in Section 26.2 that to lock in at date \\(0\\) the rate of interest on a $1 loan from dates \\(u\\) to \\(u'\\), one can buy a unit of the discount bond maturing at \\(u\\) and raise the funds \\(P^{\\text{mkt}}(0,u)\\) required by short-selling \\(P^{\\text{mkt}}(0,u)/P^{\\text{mkt}}(0,u')\\) units of the bond maturing at \\(u'\\), which leads to an obligation of \\(P^{\\text{mkt}}(0,u)/P^{\\text{mkt}}(0,u')\\) dollars at date \\(u'\\). The continuously compounded forward rate for the loan between dates \\(u\\) and \\(u'\\) is therefore \\(x\\) defined by \\[\n\\mathrm{e}^{(u'-u)x} = \\frac{P^{\\text{mkt}}(0,u)}{P^{\\text{mkt}}(0,u')}\\;.\n\\] Equivalently, \\[\nx = \\frac{\\log P^{\\text{mkt}}(0,u) -\\log P^{\\text{mkt}}(0,u')}{u'-u} = - \\frac{\\log P^{\\text{mkt}}(0,u') -\\log P^{\\text{mkt}}(0,u)}{u'-u}\\;.\n\\] As we make the maturity of the loan shorter, with \\(u' \\rightarrow u\\), the limit of the above (the forward rate for an instantaneous loan) is by definition the derivative (the usual calculus derivative) of \\(-\\log P^{\\text{mkt}}(0,u)\\).}\nIt is very important to note that if we choose the function \\(\\phi_t\\) at date \\(0\\) to match the market, then when we want to recalibrate the model at some later date to match the market at that date, we will have to select a different \\(\\phi\\) function at the later date. In other words, we use a model today that we know we will discard as incorrect tomorrow. The \\(\\phi\\) function (as well as the \\(\\kappa\\) and \\(\\sigma\\) functions in the general Hull-White model) is continually discarded and refit to match the market. This is an unpleasant reality, but it is not really too different from using implied volatilities in the Black-Scholes formula. We know that the implied volatility curve changes over time, so the volatility we use tomorrow may well be different from the volatility we use today. No model is every a literally correct description of the real world. As has been said, the test of the pudding is in the tasting. The test of a model is whether it generates reasonably correct values and hedges. This is an empirical question, and it is not equivalent to the question of whether the assumptions of the model are correct.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:vasicek_discounts",
    "href": "Chapter_Vasicek.html#sec-s:vasicek_discounts",
    "title": "27  Vasicek and Extensions",
    "section": "27.10 Discount Bond Options, Caps and Floors",
    "text": "27.10 Discount Bond Options, Caps and Floors\nWe can use Black’s formula to value discount bond options in the Vasicek model and in its extensions. As explained in the previous chapter, caps and floors are portfolios of discount bond options, so the values of caps (floors) can be computed by summing the values of the individual caplets (floorlets). The reason we can apply Black’s formula is that the volatility of the forward price of a discount bond is non-random in the Vasicek model and its extensions.\nConsider valuing at date \\(0\\) an option maturing at date \\(T\\) on a discount bond maturing at \\(u&gt;T\\). Because forward must equal spot at maturity, an option written on a forward contract maturing at \\(T\\) is equivalent.5. The forward price of the discount bond at date \\(t \\leq T\\) for a forward contract maturing at \\(T\\) is given by \\[\nF_t =\\frac{P(t,u)}{P(t,T)}\\;.\n\\] From Ito’s formula and the equation~Equation 27.30 for the discount bond returns, we have \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}F_t}{F_t} &= \\text{something}\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} - \\frac{\\,\\mathrm{d}P(t,T)}{P(t,T)}\\\\\n&= \\text{something}\\,\\mathrm{d}t -\\sigma[b(u-t)-b(T-t)]\\,\\mathrm{d}B_t\\;.\n\\end{align*}\\] Thus, the volatility depends on the non-random function \\(b\\).\nIn the continuous-time Ho-Lee model, we have \\[\nb(u-t)-b(T-t) = u-T\\;.\n\\] Therefore, the forward price has a constant volatility equal to \\((u-T)\\sigma\\). In the Hull-White model, we have \\[\nb(u-t)-b(T-t) = \\frac{1}{\\kappa}\\left(\\mathrm{e}^{-\\kappa(T-t)}-\\mathrm{e}^{-\\kappa(u-t)}\\right) = \\frac{\\left(\\mathrm{e}^{-\\kappa T} - \\mathrm{e}^{-\\kappa u}\\right)\\mathrm{e}^{\\kappa t}}{\\kappa} \\;.\n\\] Thus, the volatility is time varying (it depends on \\(t\\)), so we compute the average volatility as in ?sec-s:timevaryingvolatility and Section 13.15. Specifically,\n\\[\n\\sigma_{\\text{avg}} = \\frac{\\sigma\\left(\\mathrm{e}^{-\\kappa T} - \\mathrm{e}^{-\\kappa u}\\right)}{\\kappa} \\sqrt{\\frac{1}{T}\\int_0^T \\mathrm{e}^{2\\kappa t}\\,\\mathrm{d}t}\n\\] \\[\n=\\frac{\\sigma\\left(\\mathrm{e}^{-\\kappa T} - \\mathrm{e}^{-\\kappa u}\\right)}{\\kappa}\\sqrt{\\frac{\\mathrm{e}^{2\\kappa T}-1}{2\\kappa T}}\\;.\n\\qquad(27.34)\\]\nSubstituting \\(P^{\\text{mkt}}(0,u)/P^{\\text{mkt}}(0,T)\\) as the forward price of the discount bond maturing at \\(u\\) in Black’s formula gives the following.\n\n\n\n\n\n\n27.11\n\n\n\nConsider an option with exercise price \\(K\\) maturing at date \\(T\\) on a discount bond maturing at date \\(u&gt;T\\). In the extended Vasicek model, the values at date \\(0\\) of such options are\n\\[\n\\text{Call Price} =P^{\\text{mkt}}(0,u)\\mathrm{N}(d_1) - P^{\\text{mkt}}(0,T)K\\mathrm{N}(d_2)\\;,\n\\qquad(27.35)\\]\n\\[\n\\text{Put Price} = P^{\\text{mkt}}(0,T)K\\mathrm{N}(-d_2)-P^{\\text{mkt}}(0,u)\\mathrm{N}(-d_1)\\;,\n\\qquad(27.36)\\]\nwhere\n\\[\nd_1 = \\frac{\\log P^{\\text{mkt}}(0,u) - \\log\\left(P^{\\text{mkt}}(0,T)K\\right) +\\frac{1}{2}\\sigma_{\\text{avg}}^2T}{\n\\sigma_{\\text{avg}}\\sqrt{T}}\\;,\n\\qquad(27.37)\\]\n\\[\nd_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\;.\n\\qquad(27.38)\\]\nThe volatility \\(\\sigma_{\\text{avg}}\\) is defined as \\(\\sigma_{\\text{avg}} = (u-T)\\sigma\\) in the continuous-time Ho-Lee model and according to Equation 27.34 in the Hull-White model.\n\n\nAs our notation indicates, the discount bond prices appearing in these formulas should be taken to be the market prices of the bonds at the date the options are valued, rather than the model prices. Of course, if we have fit the model to the market prices of discount bonds, there is no distinction. Using model prices that are different from market prices would be similar to inputting a stock price in the Black-Scholes formula obtained from a discounted-cash-flow analysis rather than using the market price of the stock. This is not something that one would normally do.\nBecause the discount bond volatilities are the same in the continuous-time Ho-Lee model as in the basic Vasicek model with \\(\\kappa=0\\) and are the same in the Hull-White model as in the basic Vasicek model with \\(\\kappa&gt;0\\), the formulas for the values of discount bond options are the same in the corresponding models. These extensions of the basic Vasicek model permit one to match model bond prices to market bond prices, but they have no effect on the values of discount bond options, provided we remember to use the market prices in Equation 27.35 - Equation 27.38.\nRather than calculating \\(\\sigma_{\\text{avg}}\\) from the volatility \\(\\sigma\\) of the short rate and the constant \\(\\kappa\\) or function \\(\\kappa_t\\), we will treat \\(\\sigma_{\\text{avg}}\\) as an input into the option pricing formulas. This is necessary if one wants to use (i.e., invert) the following functions to imply \\(\\sigma_{\\text{avg}}\\) from market prices and then used the implied \\(\\sigma_{\\text{avg}}\\) to calibrate the model.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_call(F, K, P, sigma, T):\n    d1 = (np.log(F / K) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return P * (F * norm.cdf(d1) - K * norm.cdf(d2))\n\ndef black_put(F, K, P, sigma, T):\n    d1 = (np.log(F / K) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    return P * (K * norm.cdf(-d2) - F * norm.cdf(-d1))\n\ndef vasicek_discount_bond_call(Underlying, K, MatDisc, sigavg, T):\n    F = Underlying / MatDisc\n    return black_call(F, K, MatDisc, sigavg, T)\n\ndef vasicek_discount_bond_put(Underlying, K, MatDisc, sigavg, T):\n    F = Underlying / MatDisc\n    return black_put(F, K, MatDisc, sigavg, T)\n\n\n# Example usage\nUnderlying = 0.9\nK = 0.9\nMatDisc = 0.88\nsigavg = 0.2\nT = 1\n\n\nprint(\"Vasicek Discount Bond Call:\", vasicek_discount_bond_call(Underlying, K, MatDisc, sigavg, T))\nprint(\"Vasicek Discount Bond Put:\", vasicek_discount_bond_put(Underlying, K, MatDisc, sigavg, T))\n\n\nVasicek Discount Bond Call: 0.13463704635261298\nVasicek Discount Bond Put: 0.026637046352613162\n\n\nAs noted before, these option pricing formulas can be used to value caplets and floorlets. A caplet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\) is equivalent, as discussed in Section 26.9, to \\(1+\\bar{R}\\,\\Delta\\) put options maturing at \\(t_i\\) on the discount bond maturing at \\(t_{i+1}\\), with the exercise price of each option being \\(1/(1+\\bar{R}\\,\\Delta t)\\). When we make these substitutions in the above formulas (and the same for floorlets) we obtain the following.\n\n\n\n\n\n\n27.12\n\n\n\nConsider a caplet and a floorlet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\). Define \\(\\Delta t = t_{i+1}-t_i\\). Let \\(\\bar{R}\\) denote the cap and floor rate. In the extended Vasicek model, the values at date \\(0\\) of the caplet and floorlet are as follows.\n\\[\n\\text{Floorlet Price} =(1+\\bar{R}\\,\\Delta t)P^{\\text{mkt}}(0,t_{i+1})\\mathrm{N}(d_1) - P^{\\text{mkt}}(0,t_i)\\mathrm{N}(d_2)\\;,\n\\qquad(27.39)\\]\n\\[\n\\text{Caplet Price} = P^{\\text{mkt}}(0,t_i)\\mathrm{N}(-d_2)-(1+\\bar{R}\\,\\Delta t)P^{\\text{mkt}}(0,t_{i+1})\\mathrm{N}(-d_1)\\;,\n\\qquad(27.40)\\]\nwhere\n\\[\nd_1 = \\frac{\\log\\left((1+\\bar{R}\\,\\Delta t)P^{\\text{mkt}}(0,t_{i+1})\\right) -\\log P^{\\text{mkt}}(0,t_i)  +\\frac{1}{2}\\sigma_{\\text{avg}}^2t_i}{\n\\sigma_{\\text{avg}}\\sqrt{t_i}}\\;,\n\\qquad(27.41)\\]\n\\[\nd_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{t_i}\\;,\n\\qquad(27.42)\\]\nThe volatility \\(\\sigma_{\\text{avg}}\\) is defined as \\(\\sigma\\,\\Delta t\\) in the continuous-time Ho-Lee model and as \\[\n\\sigma_{\\text{avg}} = \\frac{\\sigma \\mathrm{e}^{-\\kappa t_i}\\left(1- \\mathrm{e}^{-\\kappa \\,\\Delta t}\\right) }{\\kappa}\\sqrt{\\frac{\\mathrm{e}^{2\\kappa t_i}-1}{2\\kappa t_i}}\n\\qquad(27.43)\\] in the Hull-White model.\n\n\nA reasonable way to choose the parameter \\(\\sigma\\) in the continuous-time Ho-Lee model and the parameters \\(\\kappa\\) and \\(\\sigma\\) in the Hull-White model would be to fit the model as well as possible to market prices of caps and/or floors. The function \\(\\phi_t\\) can then be chosen as discussed in the preceding section.\nWe also used Black’s formula to value caplets and floorlets in Section 26.4. However, the formulas in this section and the formulas in Section 26.4 give different values, because they are based on different assumptions. In the Vasicek model and its extensions, the forward price \\[\nF_t = \\frac{P(t,t_{i+1})}{P(t,t_i)}\n\\] of the discount bond corresponding to the caplet with payment date \\(t_{i+1}\\) has a non-random volatility, and this is the assumption on which Equation 27.39 - Equation 27.40 is based. In Section 26.4, we assumed the forward LIBOR rate had a non-random volatility. The definition~Equation 26.2 of the forward rate is \\[\nR_i_t = \\frac{P(t,t_i)}{P(t,t_{i+1})} - 1 = \\frac{1}{F_t}-1\\;.\\] If the forward price has a non-random volatility, then the forward rate is the sum of a variable (\\(1/F_t\\)) with a constant volatility and a constant (\\(-1\\)) and hence will have a random volatility. Likewise, if the forward rate has a non-random volatility, then the forward price will have a random volatility. Therefore, the assumptions of the two models are inconsistent.\n\n\nCode\ndef vasicek_cap(P0, P, rbar, sigavg, N, t0, dt):\n    K = 1 / (1 + rbar * dt)\n    if t0 == 0:\n        cap_value = P[0] * max(0, 1 / P[0] - 1 - rbar * dt)\n    else:\n        MatDisc = P0\n        Underlying = P[0]\n        cap_value = vasicek_discount_bond_put(Underlying, K, MatDisc, sigavg[0], t0)\n    \n    for i in range(1, N):\n        MatDisc = P[i - 1]\n        Underlying = P[i]\n        mat = t0 + i * dt\n        cap_value += vasicek_discount_bond_put(Underlying, K, MatDisc, sigavg[i], mat)\n    \n    return (1 + rbar * dt) * cap_value\n\n# Example\n\nP0 = 0.95\nP = [0.92, 0.89, 0.85, 0.80]\nrbar = 0.03\nN = 4\nt0 = 0.5\ndt = 0.5\n\nprint(\"Vasicek Cap:\", vasicek_cap(P0, P, rbar, [0.2, 0.18, 0.15, 0.12], N, t0, dt))\n\n\nVasicek Cap: 0.2915227189677007",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:vasicek_swaptions",
    "href": "Chapter_Vasicek.html#sec-s:vasicek_swaptions",
    "title": "27  Vasicek and Extensions",
    "section": "27.13 Coupon Bond Options and Swaptions",
    "text": "27.13 Coupon Bond Options and Swaptions\nIn this section, we will discuss the valuation of coupon bond options in the extended Vasicek models. As discussed in Section 26.10, swaptions are equivalent to options on coupon bonds, so the valuation methods can also be applied to swaptions.\nConsider a bond paying a coupon of $\\(c\\) at dates \\(t_1, t_2, \\ldots, t_N\\) and its face value of $1 at date \\(t_N\\). Consider a European call option on the bond maturing at date \\(T\\). In the case of a European swaption, all of the coupon payment dates occur after the option maturity (\\(t_i &gt; T\\) for \\(i=1,\\ldots,N\\)), and the coupon is taken to be \\(c=\\bar{R}\\,\\Delta t\\), where \\(\\bar{R}\\) is the swap rate. In the case of an option on a coupon bond, some of the coupons may occur before the option maturity, but naturally the value of the option depends only on the coupons that occur after the option matures, because those are the only coupons to which an exerciser of the option would be entitled. By focusing only on those coupons, we can take \\(t_i &gt; T\\) for \\(i=1,\\ldots,N\\).\nA coupon bond is a portfolio of discount bonds, so an option on a coupon bond is an option on a portfolio of discount bonds. In general, an option on a portfolio is worth less than a portfolio of options, so an option on a coupon bond should be worth less than a portfolio of discount bond options. However, in any single-factor model, it is possible to define the strike prices of the discount bond options so that the option on the coupon bond is worth exactly the same as a portfolio of discount bond options.6 This reduces the valuation problem for coupon bond options to the problem of valuing discount bond options, which we have already solved for this model. We will use the same technique in Section 27.14 to value options on caps (captions) and options on floors (floortions).\nAs shown in Equation 27.25, the single factor that determines all discount bond prices in this model is the random variable \\(\\hat{r}\\). We let \\(r^*\\) denote the value of \\(\\hat{r}_T\\) such that, according to the model, the coupon bond option will be at the money at maturity when \\(\\hat{r}_T=r^*\\). Being at the money means of course that \\[\n\\sum_{i=1}^N cP(T,t_i) + P(T,t_N) = K\\;.\n\\qquad(27.44)\\]\nThus, based on Equation 27.25 for the discount bond prices, we define \\(r^*\\) by\n\\[\n\\begin{multline}\n\\sum_{i=1}^N c\\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s-a(t_i-T)-b(t_i-T)r^*\\right) \\\\+ \\exp\\left(-\\int_T^{t_N} \\phi_s\\,\\mathrm{d}s-a(t_N-T)-b(t_N-T)r^*\\right) = K\\;.\n\\end{multline}\n\\qquad(27.45)\\]\nAccording to the model, if \\(\\hat{r}_T\\) is lower than \\(r^*\\), then the bond prices will be higher and the call option will be in the money; conversely, if \\(\\hat{r}_T\\) is higher than \\(r^*\\), then the bond prices will be lower and the call option will be out of the money.\nFor \\(i=1,\\ldots,N\\), define \\(K_i\\) to be the model value of the discount bond price \\(P(T,t_i)\\) when \\(\\hat{r}_T=r^*\\). In other words, define \\(K_i\\) as \\[\nK_i = \\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s-a(t_i-T)-b(t_i-T)r^*\\right)\\;.\n\\qquad(27.46)\\]\nNote that equations Equation 27.45 and Equation 27.46 imply \\[\n\\sum_{i=1}^N cK_i + K_N = K\\; .\n\\qquad(27.47)\\]\nConsider for each \\(i\\) (\\(i=1,\\ldots,N\\)) a hypothetical call option maturing at \\(T\\) with the underlying for the option being the discount bond maturing at \\(t_i\\). Let \\(K_i\\) be the exercise price of option \\(i\\). According to the model, the value of the underlying at date \\(T\\) for option \\(i\\) will be \\[\nP(T,t_i) = \\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s-a(t_i-T)-b(t_i-T)\\hat{r}_T\\right)\\;.\n\\] By the definition of \\(K_i\\), therefore, option \\(i\\) will be in the money if and only if \\(\\hat{r}_T &lt; r^*\\). Thus, all of the options are in (or out) of the money in the same circumstances.\nNow consider the portfolio consisting of \\(c\\) units of option \\(i\\) for \\(i=1,\\ldots,N-1\\) and \\(1+c\\) units of option \\(N\\). According to the model, the value of the portfolio will be zero at date \\(T\\) if \\(\\hat{r}_T \\geq r^*\\), and, if \\(\\hat{r}_T&lt;r^*\\), it follows from Equation 27.47 that the value of the portfolio will be \\[\n\\sum_{i=1}^{N-1}c\\big[P(t,t_i)-K_i\\big]+ (1+c)\\big[P(t,T_N)-K_N\\big]\n= \\sum_{i=1}^NcP(t,t_i)+ P(t,T_N) - K,\n\\] which is the intrinsic value of the coupon bond option when \\(r_T&lt;r^*\\). Therefore, according to the model, the coupon bond option is equivalent to this portfolio of discount bond options. We can value the discount bond options from the formulas in the previous section and then value the portfolio and hence the coupon bond option by summing. The same type of reasoning also allows us to value put options on coupon bonds.\nThe only issue in implementing this method is that we need to compute the exercise prices \\(K_i\\). Of course, we define them by Equation 27.46, given \\(r^*\\). To do this requires that we calculate the factor \\[\n\\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s\\right),\n\\qquad(27.48)\\]\nby fitting the model to market bond prices, as discussed in Section 27.9. We will explain this more explicitly in the next paragraph. In order to apply equation~Equation 27.46, we need to compute \\(r^*\\), which is given by equation~Equation 27.45. We can solve~Equation 27.45 for \\(r^*\\) by bisection or some other root-finding method. Again, we need to know the factors Equation 27.48 in order to solve this equation.\nTo compute the factors Equation 27.48, we use Equation 27.31. We repeat it here twice, for maturity dates \\(t_i\\) and \\(T\\): \\[\\begin{align*}\n\\exp\\left(-\\int_0^{t_i} \\phi_s\\,\\mathrm{d}s\\right) &= \\exp\\left(a_{t_i}+b_{t_i}r_0\\right)P^{\\text{mkt}}(0,t_i)\\; ,\\\\\n\\exp\\left(-\\int_0^{T} \\phi_s\\,\\mathrm{d}s\\right) &= \\exp\\left(a_T+b_Tr_0\\right)P^{\\text{mkt}}(0,T)\\;.\n\\end{align*}\\] If we divide the top equation by the bottom, then on the left-hand side we obtain \\[\\begin{align*}\n\\frac{\\exp\\left(-\\int_0^{t_i} \\phi_s\\,\\mathrm{d}s\\right)}{\\exp\\left(-\\int_0^{T} \\phi_s\\,\\mathrm{d}s\\right)} &= \\exp\\left(-\\int_0^{t_i} \\phi_s\\,\\mathrm{d}s + \\int_0^{T} \\phi_s\\,\\mathrm{d}s\\right) \\\\\n&= \\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s\\right)\\; ,\n\\end{align*}\\] which is the number we want. Hence, we obtain by dividing the right-hand sides of the above equations: \\[\n\\exp\\left(-\\int_T^{t_i} \\phi_s\\,\\mathrm{d}s\\right) = \\exp\\left\\{a_{t_i}-a_T + [b_{t_i}-b_T]r_0\\right\\}\\frac{P^{\\text{mkt}}(0,t_i)}{P^{\\text{mkt}}(0,T)}\\;.\n\\qquad(27.49)\\]\n\n\nCode\ndef hwa(sigma, kappa, tau):\n    return -sigma ** 2 * (2 * kappa * tau - np.exp(-2 * kappa * tau) + 4 * np.exp(-kappa * tau) - 3) / (4 * kappa ** 3)\n\ndef hwb(kappa, tau):\n    return (1 - np.exp(-kappa * tau)) / kappa\n\ndef hwsigavg(sigma, kappa, T, u):\n    return max((sigma * (np.exp(-kappa * T) - np.exp(-kappa * u)) / kappa) * np.sqrt((np.exp(2 * kappa * T) - 1) / (2 * kappa * T)),0.001)\n\ndef hw_coup_bond(Coup, N, t1, dt, Cal, r, sigma, kappa, T):\n    x = 0\n    for i in range(N - 1):\n        tau = t1 + i * dt - T\n        a = hwa(sigma, kappa, tau)\n        b = hwb(kappa, tau)\n        x += Coup * Cal[i] * np.exp(-a - b * r)\n    \n    tau = t1 + (N - 1) * dt - T\n    a = hwa(sigma, kappa, tau)\n    b = hwb(kappa, tau)\n    x += (1 + Coup) * Cal[N - 1] * np.exp(-a - b * r)\n    \n    return x\n\ndef hw_coup_bond_call(Coup, N, t1, dt, K, MatDisc, P, r, sigma, kappa, T):\n    tol = 1e-8\n    Cal = np.zeros(N)\n    \n    aT = hwa(sigma, kappa, T)\n    bT = hwb(kappa, T)\n    for i in range(N):\n        tau = t1 + i * dt\n        a = hwa(sigma, kappa, tau)\n        b = hwb(kappa, tau)\n        Cal[i] = np.exp(a - aT + (b - bT) * r) * P[i] / MatDisc\n    \n    lower = 0\n    flower = hw_coup_bond(Coup, N, t1, dt, Cal, lower, sigma, kappa, T) - K\n    while flower &lt; 0:\n        lower -= 1\n        flower = hw_coup_bond(Coup, N, t1, dt, Cal, lower, sigma, kappa, T) - K\n    \n    upper = 1\n    fupper = hw_coup_bond(Coup, N, t1, dt, Cal, upper, sigma, kappa, T) - K\n    while fupper &gt; 0:\n        upper += 1\n        fupper = hw_coup_bond(Coup, N, t1, dt, Cal, upper, sigma, kappa, T) - K\n    \n    guess = 0.5 * (lower + upper)\n    fguess = hw_coup_bond(Coup, N, t1, dt, Cal, guess, sigma, kappa, T) - K\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n        else:\n            upper = guess\n            fupper = fguess\n        guess = 0.5 * (lower + upper)\n        fguess = hw_coup_bond(Coup, N, t1, dt, Cal, guess, sigma, kappa, T) - K\n    \n    rstar = guess\n    x = 0\n    \n    for i in range(N - 1):\n        tau = t1 + i * dt - T\n        a = hwa(sigma, kappa, tau)\n        b = hwb(kappa, tau)\n        strike = Cal[i] * np.exp(-a - b * rstar)\n        sigavg = hwsigavg(sigma, kappa, T, T + tau)\n        x += Coup * vasicek_discount_bond_call(P[i], strike, MatDisc, sigavg, T)\n    \n    tau = t1 + (N - 1) * dt - T\n    a = hwa(sigma, kappa, tau)\n    b = hwb(kappa, tau)\n    strike = Cal[N - 1] * np.exp(-a - b * rstar)\n    sigavg = hwsigavg(sigma, kappa, T, T + tau)\n    x += (1 + Coup) * vasicek_discount_bond_call(P[N - 1], strike, MatDisc, sigavg, T)\n    \n    return x\n\n# Example usage\n\nUnderlying = 0.95\nK = 0.9\nMatDisc = 0.88\nsigavg = 0.2\nT = 1\n\nP0 = 0.95\nP = [0.92, 0.89, 0.85, 0.80]\nrbar = 0.03\nN = 4\nt0 = 0.5\ndt = 0.5\n\nCoup = 0.03\nr = 0.02\nsigma = 0.1\nkappa = 0.1\n\n\nprint(\"HW Coupon Bond Call:\", hw_coup_bond_call(Coup, N, t0, dt, K, MatDisc, P, r, sigma, kappa, T))\n\n\nHW Coupon Bond Call: 0.11555572997069366",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:captions",
    "href": "Chapter_Vasicek.html#sec-s:captions",
    "title": "27  Vasicek and Extensions",
    "section": "27.14 Captions and Floortions",
    "text": "27.14 Captions and Floortions\nIn this section, we will consider options on caps and floors, which are sometimes called captions and floortions respectively. For specificity, we will consider a call option on a cap. A cap is a portfolio of caplets, and each caplet is a call option on a spot rate. Therefore a call option on a cap is a call option on a portfolio of calls on spot rates and hence is a bet on (or insurance against) high spot rates.\nOf course, high spot rates are equivalent to low bond prices, so a call on a cap can also be seen as a bet on low bond prices. We will actually take this latter approach and view a cap as a portfolio of put options on discount bonds, as in Section 27.10. This means that we will analyze a call option on a cap as a call on a portfolio of puts. We will use the trick of the previous section and reduce this call on a portfolio of puts to a portfolio of calls on puts. Each call on a put is a compound option and can be valued as in Chapter 15. The assumptions made in Chapter 15 for compound options are valid here, because the forward prices of the discount bonds (which are the underlyings for the puts) have non-random volatilities in the extended Vasicek models.\nConsider a cap with reset dates \\(t_0,\\ldots t_{N-1}\\) and payment dates \\(t_1,\\ldots, t_N\\), with \\(t_{i+1}-t_i=\\Delta t\\) for each \\(i\\). Let \\(\\bar{R}\\) denote the fixed rate on the cap. We consider a call option on the cap maturing at date \\(T \\leq t_0\\) and having exercise price \\(K\\). In the model, the value of the cap at the option maturity will depend on the random variable \\(\\hat{r}_T\\). As in the previous section, we will let \\(r^*\\) denote the value of \\(\\hat{r}_T\\) such that the call option on the cap is at the money at date \\(T\\) when \\(\\hat{r}_T=r^*\\). If \\(\\hat{r}_T&gt;r^*\\) then the cap will be more valuable, so the call will be in the money; conversely if \\(\\hat{r}_T&lt;r^*\\) the call will be out of the money. Also, similar again to the previous section, we will let \\(K_i\\) denote the value of the caplet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\) (\\(i=0,\\ldots,N-1\\)) when \\(\\hat{r}_T=r^*\\). We consider hypothetical call options on the individual caplets with exercise prices \\(K_i\\). If \\(\\hat{r}_T&gt;r^*\\), then, according to the model, all of the calls on the caplets will be in the money, and the sum of their values will equal the value of the call on the cap. On the other hand, if \\(\\hat{r}_T&lt;r^*\\) then all of the calls on the caplets will be out of the money, as will be the call on the cap. Thus, the value of the call on the cap is the sum of the values of the calls on the caplets.\nIn order to apply the methods developed in Chapter 15 for valuing compound options to value the calls on the caplets (i.e., the calls on puts on discount bonds), all we need to do is to calculate the rate \\(r^*\\) and the exercise prices \\(K_i\\). We will explain this only briefly.\nConsider the caplet with payment date \\(t_{i+1}\\). According to the valuation Equation 27.40, the value of the caplet at date \\(T\\), when there is a remaining time to maturity of \\(t_i-T\\), will be7\n\\[\n\\text{Caplet Value at Date $T$} = P(T,t_{i})N(-d_2) - (1+\\bar{R}\\Delta t)P(T,t_{i+1})N(-d_1)\\;,\n\\qquad(27.50)\\]\nwhere\n\\[\nd_1 = \\frac{\\log\\left((1+\\bar{R}\\Delta t)P(T,t_{i+1})\\right) - \\log P(T,t_{i})+\\frac{1}{2}\\sigma_{\\text{avg}}^2(t_{i}-T)}{\n\\sigma_{\\text{avg}}\\sqrt{t_{i}-T}}\\;,\n\\qquad(27.51)\\]\n\\[\nd_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{t_{i}-T}\\;.\n\\qquad(27.52)\\]\nHere \\(\\sigma_{\\text{avg}}\\) denotes the average volatility of the forward price of the discount bond between the option valuation date \\(T\\) and the option maturity date \\(t_{i}\\). This shows that the values of the caplets and hence the value of the cap depend on the discount bond prices at date \\(T\\), which, according to the model, depend on \\(\\hat{r}_T\\). One can use bisection or some other root-finding method again to find the value of \\(\\hat{r}_T\\) such that, according to the model, the value of the cap will be \\(K\\) at date \\(T\\). Substituting this value of \\(\\hat{r}_T\\) into the bond pricing Equation 27.25 - Equation 27.29 and then substituting the bond prices \\(P(T,t_{i})\\) and \\(P(T,t_{i+1})\\) into Equation 27.50 - Equation 27.52, we define \\(K_i\\) as the caplet value in Equation 27.50.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:HW_yields",
    "href": "Chapter_Vasicek.html#sec-s:HW_yields",
    "title": "27  Vasicek and Extensions",
    "section": "27.15 Yields and Yield Volatilities",
    "text": "27.15 Yields and Yield Volatilities\nWe are denoting the price at date \\(t\\) of a discount bond maturing at \\(u\\), with remaining time to maturity of \\(\\tau = u-t\\), as \\(P(t,u)\\). However, as in Section 25.1, we will denote the corresponding yield as \\(y(t,\\tau)\\). The yield is defined as \\[\ny(t,\\tau) = \\frac{-\\log P(t,u)}{\\tau}\\;.\n\\] In the extended Vasicek model, the yield is given by the bond pricing Equation 27.7 as \\[\ny(t,\\tau) = \\frac{\\int_t^{t+\\tau} \\phi_s\\,\\mathrm{d}s + a(\\tau) + b(\\tau)\\hat{r}_t}{\\tau}\\;.\n\\] Note that the component \\[\n\\frac{a(\\tau) + b(\\tau)\\hat{r}_t}{\\tau}\n\\] of the yield \\(y(t,t+\\tau)\\) is independent of \\(t\\), except for its dependence on \\(\\hat{r}_t\\). For example, in the continuous-time Ho-Lee model, this component equals \\[\n-\\frac{\\sigma^2\\tau^2}{6} + \\hat{r}_t\\;.\n\\] This is a decreasing function of the time to maturity \\(\\tau\\) with intercept equal to \\(\\hat{r}_t\\). At a different date \\(t\\), this component of the yield curve would be the same, except for having a different intercept.^[Note that this part decreases to \\(-\\infty\\) at long maturities (\\(\\tau \\rightarrow \\infty\\)), which is very strange for yields, which should be nonnegative. To compensate for this strange behavior, one needs the part \\[\n\\frac{1}{\\tau}\\int_t^{t+\\tau} \\phi_s\\,\\mathrm{d}s\\; ,\n\\] which is the average of \\(\\phi_s\\) between \\(t\\) and \\(t+\\tau\\) to be growing sufficiently with \\(\\tau\\). This phenomenon is a consequence of the absence of mean reversion.} This is the reason for the statement in Section 27.5 that only parallel shifts in the yield curve are possible in this model (and hence duration hedging works in the model).\nThe volatility at date \\(t\\) of the yield at a fixed maturity \\(\\tau\\) is^[By volatility here we mean the instantaneous standard deviation of \\(\\,\\mathrm{d}y(t,\\tau)\\) not the instantaneous standard deviation of \\(\\,\\mathrm{d}y(t,\\tau)/y(t,\\tau)\\).} \\(\\sigma b(\\tau)/\\tau\\). In the continuous-time Ho-Lee model, this is \\(\\sigma\\) and in the Hull-White model it is \\(\\sigma\\left(1-\\mathrm{e}^{-\\kappa\\tau}\\right)/(\\kappa\\tau)\\). In Section 27.10 we mentioned that one might choose the parameter \\(\\sigma\\) in the Ho-Lee model and the parameters \\(\\sigma\\) and \\(\\kappa\\) in the Hull-White model to fit cap or floor prices as well as possible. An alternative would be to choose them to match estimated yield volatilities. Of course the fit to either cap prices or yield volatilities will be of limited quality, given that there is only one or two parameters in these models. On the other hand, an exact fit can be obtained with the general Hull-White model.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#sec-s:generalHW",
    "href": "Chapter_Vasicek.html#sec-s:generalHW",
    "title": "27  Vasicek and Extensions",
    "section": "27.16 The General Hull-White Model",
    "text": "27.16 The General Hull-White Model\nWe will briefly discuss the general Hull-White model, in which \\[\n\\,\\mathrm{d}r_t = \\theta_t\\,\\mathrm{d}t -\\kappa_tr_t\\,\\mathrm{d}t + \\sigma_t\\,\\mathrm{d}B_t\\;.\n\\qquad(27.53)\\]\nBy differentiating the following, one can see that the short rate \\(r\\) in the general Hull-White model satisfies\n\\[\nr_s = \\phi_s + \\hat{r}_s\\;,\n\\qquad(27.54)\\]\nwhere \\[\n\\phi_s =  \\int_0^s\\exp\\left(-\\int_y^s\\kappa(x)\\,\\mathrm{d}x\\right)\\theta(y)\\,\\mathrm{d}y\\;.\n\\qquad(27.55)\\]\nand \\[\n\\hat{r}_s = \\exp\\left(-\\int_0^s\\kappa(x)\\,\\mathrm{d}x\\right)r_0+\\int_0^s\\exp\\left(-\\int_y^s\\kappa(x)\\,\\mathrm{d}x\\right)\\sigma(y)\\,\\mathrm{d}B(y)\\;.\n\\qquad(27.56)\\]\nAs before, discount bond prices are \\[\nP(t,u) = \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s\\right)\\\\E^R_t \\left[ \\exp\\left(-\\int_t^u \\hat{r}_s\\,\\mathrm{d}s\\right)\\right]\\;.\n\\qquad(27.57)\\]\nMoreover, Equation 27.56 implies, for \\(s&gt;t\\),\n\\[\n\\hat{r}_s = \\exp\\left(-\\int_t^s\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\hat{r}_t+\\int_t^s\\exp\\left(-\\int_y^s\\kappa(x)\\,\\mathrm{d}x\\right)\\sigma(y)\\,\\mathrm{d}B(y)\\;.\n\\qquad(27.58)\\]\nUsing this fact, the expectation in Equation 27.57 can be calculated as before as the expectation of the exponential of a normally distributed random variable, leading to the result\n\\[\nP(t,u) = \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s-a(t,u)-b(t,u)\\hat{r}_t\\right)\\;,\n\\qquad(27.59)\\]\nwhere\n\\[\nb(t,u) = \\int_t^u \\exp\\left(-\\int_t^s\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}s\\; ,\n\\] \\[\na(t,u) =  -\\frac{1}{2}\\int_t^u b(y,u)^2\\sigma(y)^2\\,\\mathrm{d}y\\;.\n\\]\nNote that the functions \\(a\\) and \\(b\\) now depend on the date \\(t\\) of valuation and the date \\(u\\) of maturity rather than being determined entirely by the time to maturity \\(u-t\\). Note also that we can write\n\\[\nb(t,u) = \\exp\\left(\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\int_t^u\\exp\\left(-\\int_0^s\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}s\n\\] \\[\n= \\exp\\left(\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\n\\] \\[\n\\qquad \\times\\left[\\int_0^u\\exp\\left(-\\int_0^s\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}s - \\int_0^t\\exp\\left(-\\int_0^s\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}s\\right]\n\\] \\[\n=\\exp\\left(\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\big(b(0,u)-b(0,t)\\big)\\;.\n\\qquad(27.60)\\]\nTherefore, we can recover the functions \\(b(t,u)\\) and \\(a(t,u)\\) from the functions \\(b(0,t)\\), \\(\\exp\\left(\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\), and \\(\\sigma_t\\).\nThe returns of discount bonds satisfy \\[\n\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} = r_t\\,\\mathrm{d}t - \\sigma_t b(t,u)\\,\\mathrm{d}B_t\\;.\n\\qquad(27.61)\\]\nHence, hedge ratios, which depend on relative volatilities, are determined by the function \\(b\\) as before. Given the functions \\(\\kappa\\) and \\(\\sigma\\), the model can be calibrated to market discount bond prices by choosing the function \\(\\phi\\) exactly as discussed in Section 27.9.\nThe pricing of fixed-income derivatives discussed in Section 27.10 - \\(\\ref{s_captions}\\) was based on forward prices of discount bonds having non-random volatilities. This is true also in the general Hull-White model. Given dates \\(t&lt;T&lt;u\\), the forward price at date \\(t\\) of the discount bond maturing at date \\(u\\), when the forward contract matures at \\(T\\), is, as before, \\(F_t=P(t,u)/P(t,T)\\). In the general Hull-White model, we have \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}F_t}{F_t} &= \\text{something}\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} - \\frac{\\,\\mathrm{d}P(t,T)}{P(t,T)}\\\\\n&= \\text{something}\\,\\mathrm{d}t -\\sigma_t[b(t,u)-b(t,T)]\\,\\mathrm{d}B_t\\\\\n&= \\text{something}\\,\\mathrm{d}t -\\sigma_t\\exp\\left(\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\big[b(0,u)-b(0,T)\\big]\\,\\mathrm{d}B_t\\;.\n\\end{align*}\\] Thus, the average volatility, from date \\(0\\) to date T, is \\[\\sigma_{\\text{avg}} = \\big[b(0,u)-b(0,T)\\big]\\sqrt{\\frac{1}{T}\\int_0^T \\sigma_t^2\\exp\\left(2\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}t}\\; .\\] With this substitution, the pricing of fixed-income derivatives is the same as in the basic Hull-White model discussed in Section 27.10–Section 27.14.\nThe advantage of the general Hull-White model is that it allows more flexibility in fitting the model to current market conditions. This may (though there is certainly no guarantee) provide better pricing and hedging of interest-rate derivatives. Hull and White suggest choosing the volatility function \\(\\sigma\\) to fit anticipated future volatilities of the short rate and choosing the mean-reversion function \\(\\kappa\\) to fit market cap/floor prices or yield volatilities.\nWe will assume that the volatility function \\(\\sigma\\) has been chosen, and we will describe how to choose the mean-reversion function to fit the model to estimated yield volatilities or cap prices. As usual, we let date \\(0\\) denote the date at which we are fitting the model.\nThe simplest approach is to take the function \\(\\kappa_t\\) to be piecewise constant. Consider dates \\(0=t_0 &lt; t_1 &lt; \\cdots t_M\\) with \\(t_i-t_{i-1}=\\Delta t\\) for each \\(i\\). For valuing a swaption, for example, we would want \\(t_M\\) to be the sum of the time to maturity of the swaption and the length of the swap. Thus, we are fitting the model until the end of the swap underlying the swaption. We want to find numbers \\(\\kappa_1,\\ldots,\\kappa_M\\) and will set the function \\(\\kappa\\) to equal \\(\\kappa_i\\) for \\(t\\) between \\(t_{i-1}\\) and \\(t_i\\).\nGiven this definition, we have \\[\\begin{align*}\n\\exp\\left(-\\int_0^{t_1}\\kappa(x)\\,\\mathrm{d}x\\right) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\; ,\\\\\n\\exp\\left(-\\int_0^{t_2}\\kappa(x)\\,\\mathrm{d}x\\right) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\; ,\\\\\n\\exp\\left(-\\int_0^{t_3}\\kappa(x)\\,\\mathrm{d}x\\right) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\mathrm{e}^{-\\kappa_3\\,\\Delta t}\\;,\n\\end{align*}\\] etc. Furthermore, \\[\\begin{align*}\nb(0,t_1) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\Delta t\\; ,\\\\\nb(0,t_2) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\,\\Delta t + \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\,\\Delta t\\; ,\\\\\nb(0,t_3) &= \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\,\\Delta t + \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\,\\Delta t + \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\mathrm{e}^{-\\kappa_3\\,\\Delta t}\\,\\Delta t\\;,\n\\end{align*}\\] etc. This yields the following recursive structure for the \\(b(0,t_i)\\).\n\\[\nb(0,t_1) = \\mathrm{e}^{-\\kappa_1\\,\\Delta t}\\Delta t\\; ,\n\\qquad(27.62)\\] \\[\nb(0,t_2) = b(0,t_1) + b(0,t_1)\\mathrm{e}^{-\\kappa_2\\,\\Delta t}\\; ,\n\\] \\[\n(\\forall i \\geq 3) \\quad b(0,t_i) = b(0,t_{i-1}) + [b(0,t_{i-1})-b(0,t_{i-2})]\\mathrm{e}^{-\\kappa_i\\,\\Delta t}\\;.\n\\qquad(27.63)\\]\nMatching the yield volatilities in the model to estimated market volatilities is extremely simple. The same analysis presented in Section 27.15 for the basic Hull-White model shows that the volatility at date \\(0\\) of the yield at maturity \\(t_i\\) in the general Hull-White model is \\[\n\\frac{\\sigma_0 b(0,t_i)}{t_i}\\;.\n\\] Given the estimated yield volatility, we can define \\(b(0,t_i)\\) by equating the model volatility to the estimated volatility. Using Equation 27.62 - Equation 27.63, the \\(\\kappa_i\\) can be computed from the \\(b(0,t_i)\\) for \\(i=1,2,\\ldots\\).\nIt is equally easy to match the model to market cap or floor prices. Suppose we have estimated implied volatilities for caplets using the pricing Equation 27.39 - Equation 27.40. Suppose the first caplet has reset date \\(t_1\\) and payment date \\(t_2\\), the second has reset date \\(t_2\\) and payment date \\(t_3\\), etc. According to the model, the average volatility of the forward price of the discount bond underlying the caplet with reset date \\(t_i\\) and payment date \\(t_{i+1}\\) is \\[\n\\big[b(0,t_{i+1})-b(0,t_i)\\big]\\sqrt{\\frac{1}{t_i}\\int_0^{t_i} \\sigma_t^2\\exp\\left(2\\int_0^t\\kappa(x)\\,\\mathrm{d}x\\right)\\,\\mathrm{d}t}\\;.\n\\] Notice that everything in this expression, except \\(b(0,t_{i+1})\\), is determined by \\(\\kappa_1,\\ldots,\\kappa_i\\) and the \\(\\sigma\\) function. Therefore, we can select the number \\(b(0,t_{i+1})\\) to match the model volatility to the implied volatility for this caplet. This defines \\(\\kappa_{i+1}\\) from Equation 27.62 - Equation 27.63. Continuing in this way, we can successively define \\(\\kappa_1, \\kappa_2, \\ldots.\\)",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#section-5",
    "href": "Chapter_Vasicek.html#section-5",
    "title": "27  Vasicek and Extensions",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nModify the function Vasicek_Cap so that rather than taking the vector \\(P\\) of discount bond prices as an input, it looks up discount bond prices from a function DiscountBondPrice that returns a discount bond price for any maturity, as in Exercise~\\(\\ref{c_fixedincomederivatives}\\).\\(\\ref{exercise121}\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function ContinuousHoLee_Cap by modifying the function Vasicek_Cap so that the average volatilities are computed as \\(\\sigma\\Delta t\\). In other words, input \\(\\sigma\\) rather than the vector \\(\\sigma_{\\text{avg}}\\). Write the function so that it looks up discount bond prices as in the previous exercise.\n\n\n\n\nExercise 27.1 Create a Python function ContinuousHoLee_ImpliedVol using bisection that takes the same inputs as the previous function, except taking a cap price as input rather than \\(\\sigma\\), and which returns the volatility \\(\\sigma\\) that is consistent with the cap price.\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function HW_Cap by modifying the function Vasicek_Cap so that the average volatilities are calculated from equation~Equation 27.43. Thus, \\(\\sigma\\) and \\(\\kappa\\) should be input rather than the vector \\(\\sigma_{\\text{avg}}\\). Write the function so that it looks up discount bond prices as in the previous exercises.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python code in which the user inputs \\(\\bar{r}\\), \\(\\sigma\\) and \\(\\kappa\\). Compute the values of caps using the function HW_Cap for caps of length \\(N = 1, \\ldots 20\\). Take \\(t_0=0\\) and \\(\\Delta t=0.5\\) and look up discount bond prices. For each \\(N\\), use the function created in Exercise~\\(\\ref{c_vasicek}\\).\\(\\ref{e_holeeimplied}\\) to compute the volatility \\(\\sigma\\) for which the ContinuousHoLee_Cap function gives the same cap price. In other words, compute the implied Ho-Lee volatilities, given the cap prices. What is the pattern in implied volatilities and why?\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function Vasicek_Floor to value a floor in the extended Vasicek model, looking up discount bond prices from the DiscountBondPrice function.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nModify the function HW_Coup_Bond_Call so that it looks up discount bond prices from the DiscountBondPrice function.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function HW_Coup_Bond_Put to value a put option on a coupon bond in the basic Hull-White Model, looking up discount bond prices from the DiscountBondPrice function.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function HW_Payer_Swaption to value a payer swaption in the basic Hull-White Model, looking up discount bond prices from the DiscountBondPrice function.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function HW_Receiver_Swaption to value a receiver swaption in the basic Hull-White Model, looking up discount bond prices as in previous exercises.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Exercise 26.2, assuming the basic Hull-White Model, for various values of \\(\\sigma\\) and \\(\\kappa\\).\n\n\n\n\n\n\n\nHull, J., and A. White. 1990. “Pricing Interest-Rate-Derivative Securities.” Review of Financial Studies 3: 573–92.\n\n\nJamshidian, F. 1989. “An Exact Bond Option Formula” 44: 205–9.\n\n\nVasicek, O. 1977. “An Equilibrium Characterization of the Term Structure.” Journal of Financial Economics 5: 177–88.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Vasicek.html#footnotes",
    "href": "Chapter_Vasicek.html#footnotes",
    "title": "27  Vasicek and Extensions",
    "section": "",
    "text": "These results on the mean and variance of \\(r_s\\) follow from the solution Equation 27.5 of the Vasicek Equation 27.2.↩︎\nOf course, the fit to market bond prices will typically be poorer with fewer parameters; therefore, the Vasicek yield curve will typically not fit as well as a cubic spline.↩︎\nNote that our notation is the reverse of what many people use: here \\(B\\) denotes a Brownian motion under the risk-neutral probability (under which we will primarily operate) and \\(B^*\\) denotes a Brownian motion under the actual measure.↩︎\nSome authors (including Hull and White) do not make this definition—i.e., they denote by \\(\\kappa_t\\theta_t\\) what we are denoting by \\(\\theta_t\\)—so be careful when combining results from different sources.↩︎\nThis is the same reasoning we used to derive Merton’s formulas from Black’s formulas in Section 13.5↩︎\nThis method was first described by Jamshidian (Jamshidian 1989).↩︎\nWe use now the model prices for the discount bonds at date \\(T\\). Obviously, the market prices at the caption maturity date \\(T\\) are unknown at date \\(0\\), the date at which we are valuing the caption.↩︎",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Vasicek and Extensions</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html",
    "href": "Chapter_Survey.html",
    "title": "28  Term Structure Models",
    "section": "",
    "text": "28.1 Ho-Lee\nThis chapter presents very brief descriptions of several important models. The list of models is certainly not exhaustive, and our descriptions will be far from complete. As mentioned previously, there are many good references for this material in book form already, and our goal here is merely to provide a short introduction.\nThe Ho-Lee (Ho and Lee 1986) model is a binomial version of the Vasicek model without mean reversion, in which the one-period interest rate is assumed to have a deterministic drift. This was the first widely-used model that enabled one to fit the current yield curve.\nConsider discrete times \\(0=t_0 &lt; t_1 &lt; \\cdots t_N\\) with \\(t_{i}-t_{i-1}=\\Delta t\\) for each \\(i\\). We denote the one-period interest rate from date \\(t_i\\) to \\(t_{i+1}\\) by \\(r_{t_i}\\). We express the rate as an annualized continuously compounded rate, so the one-period discount factor from date \\(t_i\\) to \\(t_{i+1}\\) is \\(\\mathrm{e}^{-r_{t_i} \\Delta t}\\). We could put this in a continuous-time framework by assuming the short rate is constant (\\(= r_{t_i}\\)) during each time interval \\((t_i, t_{i+1})\\). As always, the risk-neutral probability is the probability measure corresponding to the numeraire \\[\nR_t = \\exp\\left(\\int_0^t r_s\\,\\mathrm{d}s\\right)\\; .\n\\qquad(28.1)\\]\nHowever, we will only be doing valuation at the discrete dates \\(t_0, \\ldots, t_N\\) and at date \\(t_i\\) the accumulation factor Equation 28.1 is \\[R_{t_i} = \\exp\\left(\\sum_{j=0}^{i-1} r(t_{j})\\,\\Delta t\\right)\\; .\\] Thus, the continuous-time framework is not necessary.\nThe model assumes that over each time period \\(t_{i}-t_{i-1}\\) the change \\(\\Delta r_{t_i} = r_{t_i}-r_{t_{i-1}}\\) in the one-period rate is \\[ \\Delta r_{t_i} = \\theta_{t_i}\\,\\Delta t \\pm \\sigma \\sqrt{\\Delta t}\\; ,\\] where the risk-neutral probability of \\(+\\) and \\(-\\) is \\(1/2\\) each and \\(\\theta\\) is a non-random function.\nAs in the discussion of the extended Vasicek model, it is convenient to define a random process \\(\\hat{r}\\) by \\(\\hat{r}_0 = r_0\\) and \\[\\Delta \\hat{r}_{t_i} = \\pm \\sigma \\sqrt{\\Delta t}\\] for each \\(i\\). Also, define \\(\\phi_{t_i} = \\sum_{j=1}^i \\theta_{t_i}\\) for \\(i \\geq 1\\). Then we have, for \\(i &gt;0\\), \\[r_{t_i} = \\phi_{t_i} + \\hat{r}_{t_i}\\; .\\]\nThe following illustrates a three-period tree with initial one-period rate $r_0=$5%, \\(\\Delta t=1\\), \\(\\theta_{t_i}=0\\) for all \\(i\\), and $=$1%.\nTo value a fixed-income derivative, we discount the terminal value backwards through the tree as in Chaps.~\\(\\ref{c_introcomputation}\\) and~\\(\\ref{c_montecarlo}\\). The new feature is that the discount rate is changing over time. So, we now have three trees to consider: the tree for the underlying, the tree for the one-period interest rate, and the tree for the derivative value. However, the tree for the underlying can be created from the interest-rate tree, so the interest-rate tree is the basic input instead of the tree for the underlying.\nTo clarify this, we will start with the simplest example: valuing a discount bond. Consider the above interest-rate tree and a discount bond that matures at date 3. The value of the bond is 1 at maturity. Because we are using continuous compounding, the discount factor is \\(\\mathrm{e}^{-.07} = 0.932\\) at the top node at date 2. This is also the value of the discount bond at that node. Likewise, the value of the bond at the middle node at date 2 is \\(\\mathrm{e}^{-.05} = 0.951\\). This implies that the value of the bond at the top node at date 1 is \\[\n\\mathrm{e}^{-.06}\\left(\\frac{1}{2} \\times 0.932 + \\frac{1}{2} \\times 0.951\\right) = 0.887\\; .\n\\] Continuing in this way, we derive the following tree for the discount bond, concluding that its price at date \\(0\\) should be $0.861.\nIn general, the price at date \\(0\\) of a discount bond maturing at date \\(t_n\\) is\n\\[\nP(0,t_n) = \\\\E^R\\left[\\exp\\left(-\\sum_{i=0}^{n-1} r_{t_i}\\,\\Delta t\\right)\\right]\n\\] \\[\n= \\\\E^R\\left[\\exp\\left(-r(t_0)\\,\\Delta t - \\sum_{i=1}^{n-1} [\\hat{r}_{t_i} + \\phi_{t_i} ]\\,\\Delta t\\right)\\right]\n\\] \\[\n= \\exp\\left(-r(t_0)\\,\\Delta t-\\sum_{i=1}^{n-1}\\phi_{t_i}\\,\\Delta t \\right)\\\\E^R\\left[\\exp\\left(-\\sum_{i=1}^{n-1} \\hat{r}_{t_i} \\,\\Delta t\\right)\\right]\\;.\n\\qquad(28.2)\\]\nGiven the parameter \\(\\sigma\\), the expectation in the last line of the above can easily be computed.\nThe parameters \\(\\phi(t_n)\\) can be chosen to equate model prices of discount bonds maturing at \\(t_1, \\ldots, t_N\\) to market prices. This is done simply by choosing \\(\\phi(t_n)\\) to satisfy the following equation, which we will derive below: \\[\n\\mathrm{e}^{-\\phi(t_n)\\,\\Delta t} = \\frac{2\\mathrm{e}^{r_0\\,\\Delta t}}{ \\mathrm{e}^{n\\sigma\\sqrt{\\Delta t}\\,\\Delta t} +  \\mathrm{e}^{-n\\sigma\\sqrt{\\Delta t}\\,\\Delta t}}\\times \\frac{P^{\\text{mkt}}(0,t_{n+1})}{P^{\\text{mkt}}(0,t_{n})}.\n\\qquad(28.3)\\]\nBecause the ratio of market prices \\(P^{\\text{mkt}}(0,t_{i+1})/P^{\\text{mkt}}(0,t_{i})\\) is the reciprocal of one plus the market forward rate at date \\(0\\) for loans from date \\(t_i\\) to \\(t_{i+1}\\), this formula for the parameters \\(\\phi_{t_i}\\) is equivalent to equating model forward rates to market forward rates, as was discussed for the Hull-White and continuous-time Ho-Lee models in Section 27.9. In fact, the fitting of the Ho-Lee model to market bond prices is often expressed by saying the market forward rate curve is an input to the model. This idea was developed further by Heath, Jarrow and Morton (Heath, Jarrow, and Morton 1992)—see Section 28.7.\nAs for options on equities and currencies, the binomial model for interest rates is especially useful for valuing early exercise features.\nHowever, it should be noted that, even though this model is very easy to use, it has important limitations. The assumption of a constant volatility for the one-period rate and no mean reversion implies excessive uncertainty about the level of the one-period rate at long horizons, as discussed in Section 27.1. To offset this, one could use a smaller volatility when valuing long-maturity options. However, for options with early exercise features, this would imply too little uncertainty about the level of the one-period rate at short horizons and thereby undervalue the early exercise option.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#ho-lee",
    "href": "Chapter_Survey.html#ho-lee",
    "title": "28  Term Structure Models",
    "section": "",
    "text": "Theory Extra\n\n\n\n\n\n## We will conclude this section with a proof of Equation 28.3. Let \\(\\varepsilon_{t_i}\\) denote independent random variables that equal \\(\\pm \\sigma \\sqrt{\\Delta t}\\) with probability \\(1/2\\) each under the risk-neutral probability. Then we can write \\[\\hat{r}_{t_i} = r_0 + \\sum_{j=1}^i \\varepsilon_{t_j}\\; .\\] This implies that \\[\\begin{align*}\n\\sum_{i=0}^{n-1}\\hat{r}_{t_i}  \n&= (n-1)r_0 + \\sum_{i=1}^{n-1}\\sum_{j=1}^i \\varepsilon_{t_j}\\\\\n&= (n-1)r_0 + (n-1)\\varepsilon(t_1) + (n-2)\\varepsilon(t_2) + \\cdots + \\varepsilon(t_{n-1})\\\\\n&= (n-1)r_0 + \\sum_{i=1}^{n-1} (n-i)\\varepsilon_{t_i}\\;.\n\\end{align*}\\] Therefore, Equation 28.2 gives us \\[\nP(0,t_n) = \\exp\\left(-nr_0\\,\\Delta t-\\sum_{i=1}^{n-1}\\phi_{t_i}\\,\\Delta t \\right)\\\\E^R\\left[\\exp\\left(-\\sum_{i=1}^{n-1} (n-i)\\varepsilon_{t_i}\\Delta t\\right)\\right]\\;.\n\\] Moreover, \\[\\begin{multline*}\n\\\\E^R\\left[\\exp\\left(-\\sum_{i=1}^{n-1}(n-i)\\varepsilon_{t_i}\\,\\Delta t\\right)\\right]  = \\\\E^R \\left[ \\prod_{i=1}^{n-1}\\exp\\left(-(n-i)\\varepsilon_{t_i}\\,\\Delta t\\right)\\right]\\\\\n= \\prod_{i=1}^{n-1} \\\\E^R \\left[ \\exp\\left(-(n-i)\\varepsilon_{t_i}\\,\\Delta t\\right)\\right]\\\\\n= \\prod_{i=1}^{n-1} \\left( \\frac{1}{2} \\exp\\left((n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-(n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right)\\;.\n\\end{multline*}\\] Thus, \\[\\begin{multline*}\nP(0,t_n) = \\exp\\left(-nr_0\\,\\Delta t-\\sum_{i=1}^{n-1}\\phi_{t_i}\\,\\Delta t\\right) \\\\\n\\times \\prod_{i=1}^{n-1} \\left( \\frac{1}{2} \\exp\\left((n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-(n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right).\n\\end{multline*}\\] Likewise, \\[\\begin{multline*}\nP(0,t_{n+1})  = \\exp\\left(-(n+1)r_0\\,\\Delta t-\\sum_{i=1}^n\\phi_{t_i}\\,\\Delta t\\right)\\\\\n\\times \\prod_{i=1}^n \\left( \\frac{1}{2} \\exp\\left((n+1-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-(n+1-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right)\\; ,\n\\end{multline*}\\] which we can write as \\[\\begin{multline*}\n\\exp\\left(-(n+1)r_0\\,\\Delta t-\\sum_{i=1}^n\\phi_{t_i}\\,\\Delta t\\right)\\\\\n\\times \\prod_{i=0}^{n-1} \\left( \\frac{1}{2} \\exp\\left((n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-(n-i)\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right)\n\\\\= \\exp\\left(-r_0\\,\\Delta t-\\phi(t_n)\\,\\Delta t\\right)\\\\\n\\times \\left( \\frac{1}{2} \\exp\\left(n\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-n\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right)P(0,t_n)\\;.\n\\end{multline*}\\] Thus, the ratio of model prices is \\[\\begin{multline*}\n\\frac{P(0,t_{n+1})}{P(0,t_n)} = \\exp\\left(-r_0\\,\\Delta t-\\phi(t_n)\\,\\Delta t\\right)\\\\\n\\times \\left( \\frac{1}{2} \\exp\\left(n\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right) + \\frac{1}{2} \\exp\\left(-n\\sigma\\sqrt{\\Delta t}\\,\\Delta t\\right)\\right)\\; .\n\\end{multline*}\\] Equating this to the ratio of market prices \\(P^{\\text{mkt}}(0,t_{n+1})/P^{\\text{mkt}}(0,t_{n})\\) gives Equation 28.3.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#black-derman-toy",
    "href": "Chapter_Survey.html#black-derman-toy",
    "title": "28  Term Structure Models",
    "section": "28.2 Black-Derman-Toy",
    "text": "28.2 Black-Derman-Toy\nThe Black-Derman-Toy (Black, Derman, and Toy 1990) model is, like the Ho-Lee model and the Black-Karasinski model discussed in the next section, a binomial model of the one-period interest rate. The model assumes that \\[\n\\Delta \\log r_{t_i} = \\eta_{t_i}\\,\\Delta t \\pm \\sigma_{t_i}\\sqrt{\\Delta t},\n\\qquad(28.4)\\]\nwhere \\(+\\) and \\(-\\) have probability one-half each under the risk-neutral probability. The volatility \\(\\sigma_{t_i}\\) has the interpretation of the percentage volatility of the one-period rate (rather than the absolute volatility, as in the Vasicek and Ho-Lee models). The model implies that the one-period rate will always be nonnegative.\nA significant feature of the model is that the volatility is allowed to be time-varying. This would produce a non-recombining tree except that the drift \\(\\eta_{t_i}\\) is allowed to vary across the date–\\(t_{i-1}\\) nodes, i.e., to be a random variable, depending on the level of the one-period rate at date \\(t_{i-1}\\). To understand this, consider the following two-period tree. For convenience, we write \\(a_i\\) for \\(\\eta_{t_i}\\,\\Delta t\\) and \\(b_i\\) for \\(\\sigma_{t_i}\\sqrt{\\Delta t}\\).\nWe have written \\(a_{2u}\\) and \\(a_{2d}\\) to demonstrate that the drift between date 1 and date 2 can vary, depending on whether we are at the top or bottom node at date 1. If we arrive at the node marked with a question mark via a down move from the top node at date 1, the value will be \\[\n\\log r_0+a_1+b_1+a_{2u}-b_2\\; .\n\\] On the other hand, if we arrive at it via an up move from the bottom node at date 1, the value will be \\[\n\\log r_0 + a_1-b_1+a_{2d}+b_2\\; .\n\\] For the tree to be recombining, these values must be the same, which implies \\[\na_{2d} = a_{2u} + 2b_1-2b_2\\; .\n\\] In general, at each date there are two free parameters: the volatility and the drift at one of the nodes, the drifts at the other nodes then being determined by the requirement that the tree be recombining.\nThe dependence of the drift on the node can be expressed as a linear dependence on the logarithm of the one-period rate. In other words, it is possible (and convenient) to write the Black-Derman-Toy model Equation 28.4 as \\[\n\\Delta \\log r_{t_i} = \\kappa_{t_i}[\\theta_{t_i} - \\log r_{t_{i-1}}]\\,\\Delta t \\pm \\sigma_{t_i}\\sqrt{\\Delta t},\n\\qquad(28.5)\\]\nwhere now the functions \\(\\kappa_{t_i}\\), \\(\\theta_{t_i}\\), and \\(\\sigma_{t_i}\\) are deterministic—i.e., depending on time but constant across nodes at each date.\nIn the two-period example above, we have \\[a_{2u} = \\kappa(t_2)[\\theta(t_2) - \\{\\log r(t_0) +a_1+b_1\\}]\\,\\Delta t\\; ,\\] and \\[\na_{2d} = \\kappa(t_2)[\\theta(t_2) - \\{\\log r(t_0) +a_1-b_1\\}]\\,\\Delta t\\; ,\n\\] so the relation \\(a_{2d} = a_{2u} + 2b_1-2b_2\\) is equivalent to \\[\n\\kappa(t_2) = \\frac{b_1-b_2}{b_1\\,\\Delta t} = - \\frac{1}{\\sigma(t_1)}\\times\\frac{\\sigma(t_2)-\\sigma(t_1)}{\\Delta t} = - \\frac{1}{\\sigma(t_1)}\\times\\frac{\\Delta \\sigma(t_2)}{\\Delta t}.\n\\qquad(28.6)\\]\nThis same relationship holds at each node at each date (just consider the two-period example as two periods extending from any node in the tree); thus, in general, we have \\[\n\\kappa_{t_i} = - \\frac{1}{\\sigma_{t_{i-1}}}\\times\\frac{\\Delta \\sigma_{t_i}}{\\Delta t}.\n\\qquad(28.7)\\]\nEquation 28.5 and Equation 28.7 define the Black-Derman-Toy model. The free parameters at each date are \\(\\sigma_{t_i}\\) and \\(\\theta_{t_i}\\), and the parameter \\(\\kappa_{t_i}\\) is defined by Equation 28.7. Alternatively, one can view \\(\\kappa_{t_i}\\) and \\(\\theta_{t_i}\\) as free parameters and define \\(\\sigma_{t_i}\\) from Equation 28.7. Note that \\(\\kappa_{t_i}\\) can be interpreted as a mean-reversion parameter for \\(\\log r_{t_i}\\), at least when it is positive (i.e., when \\(\\Delta \\sigma_{t_i}&lt;0\\)). Because there are two free parameters at each date rather than one (as in the Ho-Lee model) it is possible to match both market bond prices and market yield volatilities or cap prices.\nIn continuous time, we would write Equation 28.7 as \\[\n\\kappa_t = -\\frac{\\,\\mathrm{d}\\log \\sigma_t}{\\,\\mathrm{d}t}\\; .\n\\] Therefore, the continuous-time version of the Black-Derman-Toy model is \\[\\,\\mathrm{d}\\log r_t = -\\frac{\\,\\mathrm{d}\\log \\sigma_t}{\\,\\mathrm{d}t}[\\theta_t-\\log r_t]\\,\\mathrm{d}t + \\sigma_t\\,\\mathrm{d}B_t\\; ,\\] with \\(B\\) being a Brownian motion under the risk-neutral probability.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#black-karasinski",
    "href": "Chapter_Survey.html#black-karasinski",
    "title": "28  Term Structure Models",
    "section": "28.3 Black-Karasinski",
    "text": "28.3 Black-Karasinski\nThe Black-Karasinski (Black and Karasinski 1991) model is similar to the Black-Derman-Toy model—it assumes Equation 28.5 for the changes in the logarithm of the one-period rate—but it removes the linkage Equation 28.7 between the mean-reversion parameter and the volatility. It does this by allowing the lengths of the time steps to vary. Denote the length of the time-step \\(t_i-t_{i-1}\\) by \\(\\tau_i\\). Consider again the two-period example of the previous section. As a necessary condition for the tree to be recombining, we deduced (in Equation 28.6) that \\[\n\\kappa(t_2) = \\frac{b_1-b_2}{b_1\\,\\tau_2}\\; .\n\\] In this model, we have \\(b_i = \\sigma_{t_i}\\sqrt{\\tau_i}\\). Making this substitution, we obtain \\[\n\\kappa(t_2) = \\frac{\\sigma(t_1)\\sqrt{\\tau_1} - \\sigma(t_2)\\sqrt{\\tau_2}}{\\sigma(t_1)\\sqrt{\\tau_1}\\tau_2}\\; ,\n\\] which we can rewrite as \\[\n\\kappa(t_2)\\sigma(t_1)\\sqrt{\\tau_1}\\tau_2 + \\sigma(t_2)\\sqrt{\\tau_2} - \\sigma(t_1)\\sqrt{\\tau_1} = 0\\; .\n\\] This is a quadratic equation in the unknown \\(\\sqrt{\\tau_2}\\) with the unique positive solution (assuming \\(\\kappa(t_2)&gt;0\\)) \\[\n\\sqrt{\\tau_2} = \\frac{\\sqrt{\\sigma(t_2)^2 + 4\\kappa(t_2)\\sigma(t_1)^2\\sqrt{\\tau_1}} - \\sigma(t_2)}{2\\kappa(t_2)\\sigma(t_1)\\sqrt{\\tau_1}}\\; .\n\\] This relation must hold at each date. Thus, squaring both sides, we obtain the general formula \\[\n\\tau_i = \\frac{\\left[\\sqrt{\\sigma_{t_i}^2 + 4\\kappa_{t_i}\\sigma_{t_{i-1}}^2\\sqrt{\\tau_{i-1}}} - \\sigma_{t_i}\\right]^2}{4\\kappa_{t_i}^2\\sigma_{t_{i-1}}^2 \\tau_{i-1}}.\n\\qquad(28.8)\\]\nTo summarize, the Black-Karasinski model is given by Equation 28.5 with three free parameters—\\(\\kappa_{t_i}\\), \\(\\theta_{t_i}\\), and \\(\\sigma_{t_i}\\)—at each date. It is implemented in a recombining tree by defining the length of each time step \\(\\tau_i = t_i-t_{i-1}\\) for \\(i \\geq 2\\) according to Equation 28.8. The length of the first time step \\(\\tau_1\\) can be chosen arbitrarily.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#sec-s:cir",
    "href": "Chapter_Survey.html#sec-s:cir",
    "title": "28  Term Structure Models",
    "section": "28.4 Cox-Ingersoll-Ross",
    "text": "28.4 Cox-Ingersoll-Ross\nCox, Ingersoll, and Ross (Cox, Ingersoll, and Ross 1985) introduced a continuous-time model1 in which the short rate satisfies \\[\n\\,\\mathrm{d}r_t=\\kappa [\\theta-r_t]\\,\\mathrm{d}t+\\sigma \\sqrt{r_t}\\,\\mathrm{d}B_t,\n\\qquad(28.9)\\]\nwhere \\(\\kappa\\), \\(\\theta\\), and \\(\\sigma\\) are positive constants and \\(B\\) is a Brownian motion under the risk-neutral probability. Like the Vasicek model, this short rate process has a long-run mean of \\(\\theta\\). The difference between the CIR model and the Vasicek model is that the volatility in the CIR model is proportional to the square root of the short rate rather than being constant. Because of this fact, the short rate can never be negative. Intuitively, the reason is that the volatility \\(\\sigma\\sqrt{r_t}\\) is very small if \\(r_t\\) is near zero, so the drift will dominate the change in \\(r_t\\), pushing it upwards towards \\(\\theta\\). This interest rate model was mimicked by Heston (Heston 1993) in his stochastic volatility model discussed in Chapter 17. We will briefly discuss three topics in connection with this model: discount bond prices, calibrating the model to the current market, and pricing fixed-income derivatives.\n\nDiscount Bond Prices in the CIR Model\nDiscount bond prices can be most easily computed in the CIR model by solving the fundamental partial differential equation (pde) discussed in Chapter 22. Let \\(P(t,u)\\) denote the price at date \\(t\\) of a discount bond maturing at date \\(u\\), having remaining time to maturity of \\(\\tau = u-t\\). The discount bond price will depend on the remaining time to maturity and the short rate at date \\(t\\), because, as in the Vasicek model, the short rate is the only random factor in this model. Thus, there must be some deterministic function \\(f\\) such that \\(P(t,u) = f(r_t,\\tau).\\) As in Chapter 22, the fundamental pde is obtained by applying Ito’s formula to \\(f\\) to compute \\(\\,\\mathrm{d}f\\) in terms of the partial derivatives of \\(f\\) and then using the fact that the expected return of the discount bond (hence the drift of \\(\\,\\mathrm{d}f/f\\)) must equal the short rate under the risk-neutral probability.\nFrom Ito’s formula and Equation 28.9 of \\(\\,\\mathrm{d}r\\), we have\n\\[\n\\,\\mathrm{d}f = \\frac{\\partial f}{\\partial \\tau}\\,\\mathrm{d}\\tau + \\frac{\\partial f}{\\partial r}\\,\\mathrm{d}r + \\frac{1}{2}\\frac{\\partial^2 f}{\\partial r^2}\\,(\\,\\mathrm{d}r)^2\n\\] \\[\n= - \\frac{\\partial f}{\\partial \\tau} \\,\\mathrm{d}t + \\frac{\\partial f}{\\partial r}\\left\\{\\kappa [\\theta-r]\\,\\mathrm{d}t+\\sigma \\sqrt{r}\\,\\mathrm{d}B\\right\\} + \\frac{1}{2}\\frac{\\partial^2f}{\\partial r^2}\\sigma^2r\\,\\mathrm{d}t\n\\] \\[\n= \\left(- \\frac{\\partial f}{\\partial \\tau} + \\frac{\\partial f}{\\partial r}\\kappa [\\theta-r] + \\frac{1}{2}\\frac{\\partial^2f}{\\partial r^2}\\sigma^2r\\right)\\,\\mathrm{d}t + \\frac{\\partial f}{\\partial r} \\sigma\\sqrt{r}\\,\\mathrm{d}B\\;.\n\\qquad(28.10)\\]\nEquating the drift to \\(rf\\,\\mathrm{d}t\\) gives us the fundamental pde: \\[\n- \\frac{\\partial f}{\\partial \\tau} + \\frac{\\partial f}{\\partial r}\\kappa [\\theta-r] + \\frac{1}{2}\\frac{\\partial^2f}{\\partial r^2}\\sigma^2r = rf\\;.\n\\qquad(28.11)\\]\nThis equation should be solved for the function \\(f\\) subject to the boundary condition that the value of the discount bond is one at maturity; i.e., \\(f(r,0)=1\\) for all \\(r\\).\nThe solution can be obtained by guessing a solution of the same form as the Vasicek bond pricing Equation 27.7, namely2. \\[\nf(r,\\tau) = \\exp\\left(-a(\\tau)-b(\\tau)r\\right)\n\\qquad(28.12)\\]\nfor deterministic functions \\(a\\) and \\(b\\). The boundary condition \\[\nf(r,0)= \\exp\\left(-a_0-b_0r\\right) = 1\n\\] for all \\(r\\) implies \\(a_0=b_0=0\\), and it can easily be checked that the fundamental pde is equivalent to\n\\[\nb '(\\tau)=1-\\kappa b (\\tau)-\\frac{ 1}{2}\\sigma^2\nb ^2(\\tau)\\;,\n\\qquad(28.13)\\]\nand \\[\na '(\\tau)=\\kappa \\theta b (\\tau)\\;,  \n\\qquad(28.14)\\]\nwhere the primes denote derivatives. By differentiating, one can verify that the solution of Equation 28.13 (which is called a Riccati equation) with the boundary condition \\(b_0=0\\) is\n\\[\nb (\\tau)=\\frac{ 2 \\left( \\mathrm{e}^{\\gamma \\tau}-1 \\right)}{c(\\tau) }\\;,\n\\qquad(28.15)\\]\nwhere \\[\n\\gamma=\\sqrt{ \\kappa^2+2 \\sigma^2 } \\qquad \\text{and} \\qquad c(\\tau) =(\\kappa+\\gamma) \\left( \\mathrm{e}^{\\gamma \\tau}-1 \\right) + 2 \\gamma\\;.\n\\qquad(28.16)\\]\nIntegrating Equation 28.14 then gives \\[\na (\\tau )= -\\frac{ 2 \\kappa \\theta}{\\sigma^2 } \\left[\n\\frac{ (\\kappa +\\gamma)\\tau}{2}+\\log \\frac{ 2\n\\gamma}{c(\\tau)}\\right]\\;.\n\\qquad(28.17)\\]\nTo summarize,\n\n\n\n\n\n\n28.5\n\n\n\nThe price at date \\(t\\) of a discount bond maturing at \\(u&gt;t\\) in the CIR model is \\[\nP(t,u) = \\exp\\left(-a(\\tau)-b(\\tau)r_t\\right)\\;,\n\\] where \\(\\tau = u-t\\) and \\(a(\\tau)\\) and \\(b(\\tau)\\) are defined in Equation 28.15 - Equation 28.17.\n\n\nNote that Equation 28.12 implies \\(\\partial f/\\partial r = - b(\\tau)f\\). Substituting this into Equation 28.10 gives us the discount bond return as \\[\n\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} =\\frac{\\,\\mathrm{d}f}{f} =   r_t\\,\\mathrm{d}t - b(\\tau)\\sigma\\sqrt{r_t}\\,\\mathrm{d}B_t\\;.\n\\qquad(28.18)\\]\nThis is again similar to the Vasicek model except for the appearance of the \\(\\sqrt{\\,r}\\) factor in the volatility. Because of this factor, the volatility is random. Thus, the option pricing formulas of previous chapters cannot be directly applied to price discount bond options (and hence caps, floors, coupon bond options, and swaptions). Nevertheless, the ideas underlying those formulas can be applied to obtain similar valuation formulas.\nHedge ratios depend on relative volatilities, so they are determined by the function \\(b\\), just as discussed in Section 27.5 for the Vasicek model.\n\n\nCalibrating the CIR Model to the Yield Curve\nThe CIR model can be calibrated to current market conditions by taking one or more of the parameters \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\) to be time-varying, as in the extended Vasicek model. This was suggested by Cox, Ingersoll and Ross. However, the simplest way to calibrate the model to discount bond prices, which was also suggested by Cox, Ingersoll and Ross, is to take the short rate to be the sum of a non-random function of time and a square-root process as defined in Equation 28.9. Specifically, let \\[\nr_t = \\phi_t + \\hat{r}_t\\; ,\n\\] where \\(\\phi\\) is a non-random function and \\(\\hat{r}\\) satisfies \\[\n\\,\\mathrm{d}\\hat{r}_t=\\kappa [\\theta-\\hat{r}_t]\\,\\mathrm{d}t+\\sigma \\sqrt{\\hat{r}_t}\\,\\mathrm{d}B_t\\;,\n\\qquad(28.19)\\]\nwith \\(\\hat{r}_0 = r_0\\). Then, as in the Hull-White model, discount bond prices are given by \\[\nP(t,u) = \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s\\right)\\\\E^R_t\\left[\\exp\\left(-\\int_t^u\\hat{r}_s\\,\\mathrm{d}s\\right)\\right]\\; .\n\\] Moreover, the expectation in this equation is the discount bond pricing function calculated in the previous subsection, so we have \\[\nP(t,u) = \\exp\\left(-\\int_t^u \\phi_s\\,\\mathrm{d}s\\right)\\exp\\left(-a(\\tau)-b(\\tau)\\hat{r}_t\\right)\\;.\n\\qquad(28.20)\\]\nIn particular, discount bond prices at date \\(0\\) are \\[P(0,u) = \\exp\\left(-\\int_0^u \\phi_s\\,\\mathrm{d}s\\right)\\exp\\left(-a(u)-b(u)r_0\\right)\\; ,\\] so the model can be calibrated to market prices \\(P^{\\text{mkt}}(0,u)\\) by setting \\[\n\\exp\\left(-\\int_0^u \\phi_s\\,\\mathrm{d}s\\right) = \\exp\\left(a(u)+b(u)r_0\\right)P^{\\text{mkt}}(0,u)\n\\qquad(28.21)\\]\nfor each \\(u\\). Note that the calibration does not affect discount bond returns: the expected return under the risk-neutral probability must still be the short rate and the volatility is unaffected by a deterministic factor. Therefore, we have, as in Equation 28.18, \\[\n\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)}  =   r_t\\,\\mathrm{d}t - b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\,\\mathrm{d}B_t\\;.\n\\qquad(28.22)\\]\nThis can be verified by applying Ito’s formula to Equation 28.20.\n\n\nPricing Fixed-Income Derivatives in the CIR Model\nIn the previous chapter, it was shown for the extended Vasicek model that pricing formulas for caps, floors, coupon bond options, and swaptions can be derived from a pricing formula for discount bond options. The same is true in the CIR model — caps and floors are of course portfolios of discount bond options and, in a single-factor model such as the Vasicek or CIR model, coupon bond options and swaptions can also be priced as portfolios of discount bond options. Here we will explain briefly how to price discount bond options in the CIR model.\nConsider a call option maturing at date \\(T\\) with the underlying being a discount bond maturing at \\(u&gt;T\\). Let \\(K\\) denote the strike price. From our fundamental pricing Equation 7.28, the value at date \\(0\\) of the option is \\[\nP(0,u)\\times\\text{prob}^u\\big(P(T,u)&gt;K\\big) - P(0,T)\\times\\text{prob}^T\\big(P(T,u)&gt;K\\big)\\;,\n\\qquad(28.23)\\]\nwhere \\(\\text{prob}^u\\) denotes the probability measure using the discount bond maturing at \\(u\\) as numeraire and \\(\\text{prob}^T\\) denotes the probability measure using the discount bond maturing at \\(T\\) as the numeraire. Using the calibration of the previous subsection, the price of the underlying at date \\(T\\) will be, according to the model, \\[\nP(T,u)  = \\exp\\left(-\\int_T^u \\phi_s\\,\\mathrm{d}s-a(u-T)-b(u-T)\\hat{r}_T\\right)\\; .\n\\] Therefore, the option will finish in the money if and only if \\[\n\\frac{-\\int_T^u \\phi_s\\,\\mathrm{d}s-a(u-T)-\\log K}{b(u-T)} &gt; \\hat{r}_T\\;.\n\\qquad(28.24)\\]\nThus, to price discount bond options, we need to compute the probabilities that \\(\\hat{r}_T\\) is less than a given number, using discount bonds as numeraires.\nConsider the discount bond maturing at \\(u\\). The calculation for the discount bond maturing at \\(T\\) can be done in the same way. We use the fact that \\[\n\\frac{\\mathrm{e}^{\\int_0^t r_s\\,\\mathrm{d}s}}{P(t,u)}\n\\] is a martingale, when \\(P(t,u)\\) is used as the numeraire, for \\(t \\leq u\\). Let \\(Z_t\\) denote this ratio and apply Ito’s formula for ratios to derive \\[\n\\frac{\\,\\mathrm{d}Z_t}{Z_t} = r_t\\,\\mathrm{d}t - \\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)} + \\left(\\frac{\\,\\mathrm{d}P(t,u)}{P(t,u)}\\right)^2\\;.\n\\]\nSubstituting from Equation 28.22 now gives us \\[\\begin{align*}\n\\frac{\\,\\mathrm{d}Z_t}{Z_t} &= b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\,\\mathrm{d}B_t + b(\\tau)^2\\sigma^2\\hat{r}_t\\,\\mathrm{d}t\\\\\n&= b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\left[\\,\\mathrm{d}B_t + b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\,\\mathrm{d}t\\right]\\;.\n\\end{align*}\\] Given that \\(Z\\) is a martingale, \\(\\,\\mathrm{d}Z/Z\\) cannot have a drift, so it must be that \\(B^*\\) defined by \\(B^*_0=0\\) and \\[\n\\,\\mathrm{d}B^*_t = \\,\\mathrm{d}B_t + b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\,\\mathrm{d}t\n\\] is a martingale, and hence a Brownian motion, when \\(P(t,u)\\) is used as the numeraire. Substituting this into Equation 28.19 of \\(\\hat{r}\\), we have\n\\[\n\\,\\mathrm{d}\\hat{r}_t=\\kappa [\\theta-\\hat{r}_t]\\,\\mathrm{d}t+\\sigma \\sqrt{\\hat{r}_t}\\,\\left[\\,\\mathrm{d}B^*_t - b(\\tau)\\sigma\\sqrt{\\hat{r}_t}\\,\\mathrm{d}t\\right]\n\\] \\[\n= \\kappa [\\theta-\\hat{r}_t]\\,\\mathrm{d}t+\\sigma \\sqrt{\\hat{r}_t}\\,\\mathrm{d}B^*_t - \\sigma^2b(\\tau)\\hat{r}_t\\,\\mathrm{d}t\n\\] \\[\n= \\kappa^*_t[\\theta^*_t-\\hat{r}_t]\\,\\mathrm{d}t +\\sigma \\sqrt{\\hat{r}_t}\\,\\mathrm{d}B^*_t\\;,\n\\qquad(28.25)\\]\nwhere we define \\[\n\\kappa^*_t = \\kappa + \\sigma^2b(u-t) \\qquad \\text{and} \\qquad \\theta^*_t = \\frac{\\kappa\\theta}{\\kappa^*_t}\\; .\n\\] Thus, using a discount bond as numeraire, the process \\(\\hat{r}\\) is still a square root process, but now with a time-dependent long-run mean and mean-reversion rate.\nThe random variable \\(\\hat{r}_T\\) defined by \\(\\hat{r}_0=0\\) and Equation 28.25 for \\(t \\leq T\\) is a transformation of a random variable having what is called a non-central chi-square distribution. See Appendix~\\(\\ref{a_bessel}\\) for further discussion and calculation of the probabilities \\(\\text{prob}^u\\big(P(T,u)&gt;K\\big)\\) and \\(\\text{prob}^T\\big(P(T,u)&gt;K\\big)\\).",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#sec-s:ls",
    "href": "Chapter_Survey.html#sec-s:ls",
    "title": "28  Term Structure Models",
    "section": "28.6 Longstaff-Schwartz",
    "text": "28.6 Longstaff-Schwartz\nCox, Ingersoll and Ross suggest adding two independent square-root processes to obtain a two-factor model. This means that we would take \\(r_t=x_1_t+x_2_t\\), where \\[\n\\,\\mathrm{d}x_i_t = \\kappa_i[\\theta_i-x_i_t]\\,\\mathrm{d}t + \\sigma_i\\sqrt{x_i_t}\\,\\mathrm{d}B_i_t\\;,\n\\qquad(28.26)\\]\nwhere \\(B_1\\) and \\(B_2\\) are independent Brownian motions under the risk-neutral probability and \\(\\kappa_i\\), \\(\\theta_i\\) and \\(\\sigma_i\\) are positive constants for \\(i=1,2\\). Longstaff and Schwartz (Longstaff and Schwartz 1992) investigate this model further, including providing an equilibrium foundation, deriving discount bond option prices, and estimating the coefficients. The model is usually called the Longstaff-Schwartz model. \nAn important observation made by Longstaff and Schwartz is that the model can be rewritten so that the short rate and its volatility are the factors (rather than the unobservable \\(x_1\\) and \\(x_2\\)).3 Note that the instantaneous variance of \\(r = x_1+x_2\\) is \\[\\left( \\sigma_1\\sqrt{x_1_t}\\,\\mathrm{d}B_1_t +  \\sigma_2\\sqrt{x_2_t}\\,\\mathrm{d}B_2_t\\right)^2 = \\left(\\sigma_1^2x_1_t + \\sigma_2^2x_2_t\\right)\\,\\mathrm{d}t\\; .\n\\] Define \\(V_t = \\sigma_1^2x_1_t + \\sigma_2^2x_2_t\\). We can solve for \\(x_1\\) and \\(x_2\\) in terms of \\(r\\) and \\(V\\) as\n\\[\nx_1 = \\frac{\\sigma_2^2 r - V}{\\sigma_2^2-\\sigma_1^2}\n\\qquad(28.27)\\]\n\\[\nx_2 = \\frac{V-\\sigma_1^2 r}{\\sigma_2^2-\\sigma_1^2}\\;,\n\\qquad(28.28)\\]\nprovided \\(\\sigma_1\\neq \\sigma_2\\). Making these substitutions for \\(x_1\\) and \\(x_2\\) on the right-hand side of Equation 28.26 and noting that \\(\\,\\mathrm{d}r = \\,\\mathrm{d}x_1+\\,\\mathrm{d}x_2\\) and \\(\\,\\mathrm{d}V = \\sigma_1^2\\,\\mathrm{d}x_1 + \\sigma_2^2\\,\\mathrm{d}x_2\\), we obtain the following equations presented by Longstaff and Schwartz:\n\\[\\begin{multline}\n\\,\\mathrm{d}r= \\left(\\alpha\\gamma + \\beta\\eta - \\frac{\\beta\\delta-\\alpha\\xi}{\\beta-\\alpha}r - \\frac{\\xi-\\delta}{\\beta-\\alpha}V\\right)\\,\\mathrm{d}t \\\\+ \\alpha\\sqrt{\\frac{\\beta r-V}{\\alpha(\\beta-\\alpha)}}\\,\\mathrm{d}B_1 + \\beta\\sqrt{\\frac{V-\\alpha r}{\\beta(\\beta-\\alpha)}}\\,\\mathrm{d}B_2\\;,\n\\end{multline}\\] {#eq-vasicekvbacap}\n\\[\\begin{multline}\n\\,\\mathrm{d}V= \\left(\\alpha^2\\gamma + \\beta^2\\eta - \\frac{\\alpha\\beta(\\delta-\\xi)}{\\beta-\\alpha}r - \\frac{\\beta\\xi-\\alpha\\delta}{\\beta-\\alpha}V\\right)\\,\\mathrm{d}t \\\\+ \\alpha^2\\sqrt{\\frac{\\beta r-V}{\\alpha(\\beta-\\alpha)}}\\,\\mathrm{d}B_1 + \\beta^2\\sqrt{\\frac{V-\\alpha r}{\\beta(\\beta-\\alpha)}}\\,\\mathrm{d}B_2\\;,\n\\end{multline}\\] {#eq-vasicekvbacap}\nwhere \\(\\delta=\\kappa_1\\), \\(\\xi=\\kappa_2\\), \\(\\alpha = \\sigma_1^2\\), \\(\\beta=\\sigma_2^2\\), \\(\\gamma = \\kappa_1\\theta_1/\\sigma_1^2\\), and \\(\\eta = \\kappa_2\\theta_2/\\sigma_2^2\\). Thus, this can be regarded as a two-factor model in which the factors are the short rate and its instantaneous variance, with the six parameters \\(\\delta\\), \\(\\xi\\), \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), and \\(\\eta\\).\nThe simplest way to compute discount bond prices in this model is to return to the definition \\(r=x_1+x_2\\). Discount bond prices are \\[\\begin{align*}\nP(t,u) &= \\\\E_t\\left[\\exp\\left(-\\int_t^u r_s\\,\\mathrm{d}s\\right)\\right]\\\\\n&= \\\\E_t\\left[\\exp\\left(-\\int_t^u x_1_s\\,\\mathrm{d}s\\right)\\exp\\left(-\\int_t^u x_2_s\\,\\mathrm{d}s\\right)\\right]\\\\\n&= \\\\E_t\\left[\\exp\\left(-\\int_t^u x_1_s\\,\\mathrm{d}s\\right)\\right] \\\\E_t\\left[\\exp\\left(-\\int_t^u x_2_s\\,\\mathrm{d}s\\right)\\right]\\;,\n\\end{align*}\\] due to the independence of \\(x_1\\) and \\(x_2\\). Moreover, these expectations have the same form as discount bond prices in the CIR model, namely \\[\n\\\\E_t\\left[\\exp\\left(-\\int_t^u x_i_s\\,\\mathrm{d}s\\right)\\right] = \\exp\\left(-a_i(\\tau)-b_i(\\tau)x_i_t\\right)\\;,\n\\qquad(28.29)\\]\nwhere the functions \\(a_i\\) and \\(b_i\\) are defined in Equation 28.15 - Equation 28.17, using the parameters \\(\\kappa_i\\), \\(\\theta_i\\) and \\(\\sigma_i\\). The expectations Equation 28.29 can be written in terms of \\(r_t\\) and \\(V_t\\) by substituting from Equation 28.27 - Equation 28.28.\nThe Vasicek, CIR and Longstaff-Schwartz models are examples of affine models. An affine model is defined by a set of factors \\(x_1, \\ldots, x_n\\), where\n\nThe short rate is an affine function of the factors;4 i.e., \\(r_t = \\alpha_0 + \\sum_{i=1}^n \\alpha_ix_i_t\\) for constants \\(\\alpha_i\\),\nThe drift of each factor is an affine function of the factors.\nThe instantaneous variance of each factor is an affine function of the factors.\nThe instantaneous covariance of each pair of factors is an affine function of the factors.\n\nIn any affine model, discount bond prices are of the form \\[\nP(t,u) = \\exp\\left(-a(\\tau)-\\sum_{i=1}^n b_i(\\tau)x_i_t\\right)\n\\qquad(28.30)\\]\nfor deterministic functions \\(a\\) and \\(b_i\\) for \\(i=1,\\ldots,n\\), as we have seen is true for the Vasicek, CIR, and Longstaff-Schwartz models. Most, but certainly not all, of the continuous-time models studied in the finance literature are affine.\nIn any single-factor affine model, the short rate can be used as the factor. Thus, the general affine one-factor model is of the form \\[\\,\\mathrm{d}r = \\kappa(\\theta-r)\\,\\mathrm{d}t + \\sqrt{\\alpha + \\beta r}\\,\\mathrm{d}B\\; ,\n\\] for constants \\(\\kappa\\), \\(\\theta\\), \\(\\alpha\\) and \\(\\beta\\), where \\(B\\) is a Brownian motion under the risk-neutral probability. The Vasicek model is the special case \\(\\beta = 0\\) (\\(\\alpha\\) being the same as the parameter \\(\\sigma^2\\)). The CIR model is the special case \\(\\alpha = 0\\) (\\(\\beta\\) being the same as the parameter \\(\\sigma^2\\)).\nBecause yields of discount bonds are affine functions of the factors in an affine model, as Equation 28.30 shows, the short rate and yields at \\(n-1\\) fixed times-to-maturity \\(\\tau_i\\) can be chosen to be the \\(n\\) factors (except in the rare case that the linear transformation from factors to the short rate and yields fails to be invertible). The transformation from factors to yields is analogous to the transformation from \\((x_1,x_2)\\) to \\((r,V)\\) in the Longstaff-Schwartz model. Important papers on affine models include Duffie and Kan (Duffie and Kan 1996) and Dai and Singleton (Dai and Singleton 2000).",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#sec-s:hjm",
    "href": "Chapter_Survey.html#sec-s:hjm",
    "title": "28  Term Structure Models",
    "section": "28.7 Heath-Jarrow-Morton",
    "text": "28.7 Heath-Jarrow-Morton\nHeath, Jarrow and Morton (Heath, Jarrow, and Morton 1992) propose an alternative framework for modelling. Rather than modelling the evolution of the short rate (and possibly other factors such as the volatility of the short rate or other yields), Heath, Jarrow and Morton (hereafter, HJM) propose modelling the evolution of instantaneous forward rates. They derive a formula for the drifts of instantaneous forward rates under the risk-neutral probability, in terms of the volatilities of the forward rates. A model is therefore completely defined by specifying the volatilities of forward rates. A model of this type is easily fit to market discount bond prices by simply using the initial term structure of forward rates as an input. By calibrating the volatility structure, the model can also be fit to other market prices. Any of the continuous-time models we have discussed can be written in the HJM form. The virtue of the HJM approach is that it facilitates the construction of new models. The disadvantage of the HJM approach is that models of this form will generally be path-dependent—bond prices and the prices of other fixed-income instruments at any point in time depend on the entire history of the forward rate processes, rather than depending only on the values of a small set of factors. This makes computation quite difficult, just as computation with non-recombining binomial trees is much more difficult than with recombining trees.\nAs discussed in Section 27.9, the forward rate at date \\(t\\) for an instantaneous loan at date \\(u \\geq t\\) is \\(f(t,u)\\) defined by \\[\nf(t,u)= -\\frac{  \\,\\mathrm{d}\\,\\log P(t,u)}{\\,\\mathrm{d}u}\\;.\n\\qquad(28.31)\\]\nThe short rate at time \\(t\\) is the forward rate for maturity date \\(t\\); i.e., \\(r_t=f(t,t)\\). By integrating Equation 28.31, one can see that discount bond prices are written in terms of forward rates as: \\[\nP(t,u)= \\exp\\left( - \\int _t^u f(t,s)\\,\\mathrm{d}s \\right)\\; .\n\\qquad(28.32)\\]\nHeath, Jarrow and Morton use Equation 28.32 and the fact that the expected return of a discount bond under the risk-neutral probability must be the short rate to derive a formula for the drifts of forward rates under the risk-neutral probability.\nAssume, for the sake of simplicity, that there is only a single source of uncertainty (i.e., a single Brownian motion) driving the yield curve.\nThen, for each fixed \\(u\\), the forward rate \\(f(t,u)\\) at date \\(t&lt;u\\) will evolve as \\[\n\\,\\mathrm{d}f(t,u)=\\mu(t,u)\\,\\mathrm{d}t+\\sigma(t,u)\\,\\mathrm{d}B_t\\;,\n\\qquad(28.33)\\]\nfor some \\(\\mu\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion under the risk-neutral probability. In general \\(\\mu(t,u)\\) and \\(\\sigma(t,u)\\) could depend on the entire history of the Brownian motion through date \\(t\\). Heath, Jarrow and Morton show that \\[\n\\mu(t,u)=\\sigma(t,u) \\int_t^u \\sigma(t,s)\\,\\mathrm{d}s\\;.\n\\qquad(28.34)\\]\nOne can show that \\(\\int_t^u \\sigma(t,s)\\,\\mathrm{d}s\\) is the volatility of \\(P(t,u)\\). Therefore, Equation 28.34 states that the drift of the forward rate is the product of the volatilities of the forward rate and the discount bond return. A model is fully specified by specifying initial forward rates—i.e., \\(f(0,u)\\) for all \\(u\\)—and the volatility processes \\(\\sigma(t,u)\\) for each \\(u\\) and \\(t \\leq u\\). The generalization to multiple Brownian motions is straightforward and allows for forward rates that are not instantaneously perfectly correlated. An important application of the HJM modelling framework is work by Brace, Gatarek and Musiela (Brace, Gatarek, and Musiela 1996) and Miltersen, Sandmann, and Sondermann (Miltersen, Sandermann, and Sondermann 1997), who derive conditions on the volatility processes \\(\\sigma(t,u)\\) that guarantee forward LIBOR rates of a fixed maturity (e.g., quarterly or semi-annual rates) have deterministic volatilities, thus justifying the use of Black’s formula in Section 26.4 for valuing caps and floors.\nTo see how some of the models we have discussed can be written in the HJM form, let us re-examine the Hull-White model. From the Hull-White bond price Equation 27.25 - Equation 27.29, the instantaneous forward rate in the Hull-White model is \\[\\begin{align*}\nf(t,u) & = \\phi(u)  + \\frac{\\partial}{\\partial u} a(u-t) + \\hat{r}_t\\frac{\\partial}{\\partial u} b(u-t)\\\\\n&= \\phi(u) -\\frac{\\sigma^2}{2\\kappa^2}\\left(1 + \\mathrm{e}^{-2\\kappa(u-t)} -2 \\mathrm{e}^{-\\kappa(u-t)}\\right) + \\mathrm{e}^{-\\kappa(u-t)}\\hat{r}_t\\;.\n\\end{align*}\\] Applying Ito’s formula yields \\[\n\\,\\mathrm{d}f(t,u) = -\\frac{\\sigma^2}{\\kappa}\\left(\\mathrm{e}^{-2\\kappa(u-t)}-\\mathrm{e}^{-\\kappa(u-t)}\\right)\\,\\mathrm{d}t + \\sigma \\mathrm{e}^{-\\kappa(u-t)}\\,\\mathrm{d}B\\; .\n\\] Therefore, in the HJM notation, \\[\n\\mu(t,u) = -\\frac{\\sigma^2}{\\kappa}\\left(\\mathrm{e}^{-2\\kappa(u-t)}-\\mathrm{e}^{-\\kappa(u-t)}\\right) \\qquad \\text{and} \\qquad \\sigma(t,u) =  \\sigma \\mathrm{e}^{-\\kappa(u-t)}\\; .\n\\] A direct calculation shows that these functions \\(\\mu\\) and \\(\\sigma\\) satisfy the HJM Equation 28.34, as we knew they must, given that the HJM equation is based only on the assumption that expected returns of discount bonds equal the short rate under the risk-neutral probability. The initial forward rate curve in the Hull-White model is \\(f(0,u) = \\phi(u)\\) which is chosen to fit the market forward rate curve, as discussed in Section 27.9. Thus, rather than defining the Hull-White model as we did in Chapter 27, it could be defined alternatively as an HJM model in which the volatility process is the deterministic function \\(\\sigma(t,u) = \\sigma \\mathrm{e}^{-\\kappa(u-t)}\\) for positive constants \\(\\sigma\\) and \\(\\kappa\\). The normal distribution of the short rate in the Hull-White model is a consequence of the volatility \\(\\sigma(t,u)\\) being non-random.\nLikewise, the Cox-Ingersoll-Ross model fit to market bond prices as we discussed in Section 28.4 could be described as an HJM model. Calculations of the sort we have just done show that the volatility process in the CIR model is \\(\\sigma(t,u) = \\sigma b'(\\tau)\\sqrt{\\hat{r}}_t\\), where \\(\\tau = u-t\\) and the function \\(b\\) is defined in Equation 28.15 - Equation 28.17. In this case, the volatility is random, but it depends only on the short rate at date \\(t\\). Similarly, in any factor model, such as the Longstaff-Schwartz model, the volatilities \\(\\sigma(t,u)\\) of the forward rates will depend only on the factors at each date \\(t\\). As mentioned at the beginning of this section, such a factor structure simplifies calculations considerably.\nHJM models are sometimes written in a slightly different fashion than we have done here. If we define \\[\n\\Sigma(t,u) = \\int_t^u \\sigma(t,s)\\,\\mathrm{d}s\n\\] then we have \\(\\,\\mathrm{d}\\Sigma(t,u)/\\,\\mathrm{d}u = \\sigma(t,u)\\), and the HJM Equation 28.34 can be written as \\[\n\\mu(t,u) = \\Sigma(t,u)\\frac{\\,\\mathrm{d}\\Sigma(t,u)}{\\,\\mathrm{d}u}\\;\n\\] so the evolution of forward rates can be written as \\[\n\\,\\mathrm{d}f(t,u) = \\Sigma(t,u)\\frac{\\,\\mathrm{d}\\Sigma(t,u)}{\\,\\mathrm{d}u}\\,\\mathrm{d}t + \\frac{\\,\\mathrm{d}\\Sigma(t,u)}{\\,\\mathrm{d}u}\\,\\mathrm{d}B_t\\; .\n\\] For example, in the Hull-White model we have \\(\\Sigma(t,u) = \\sigma b(\\tau)\\) where \\(b\\) is defined in Equation 27.25 - Equation 27.29, and in the CIR model, we have \\(\\Sigma(t,u) = \\sigma b(\\tau)\\sqrt{\\hat{r}_t}\\), where \\(b\\) is defined in Equation 28.15 - Equation 28.17.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#market-models-again",
    "href": "Chapter_Survey.html#market-models-again",
    "title": "28  Term Structure Models",
    "section": "28.8 Market Models Again",
    "text": "28.8 Market Models Again\nMany fixed-income derivatives (e.g., caps, floors, and swaps) have cash flows that depend on simple interest rates (e.g., LIBOR). In this chapter and the preceding chapter, we discussed valuation formulas for fixed-income derivatives based on (i) models of the short rate or one-period rate and possibly other factors, or (ii) models of instantaneous forward rates. However, it is possible, and simpler for many purposes, to model simple interest rates directly. For example, we observed in Chapter 26 that Black’s formula can be applied to value caps and floors when the underlying simple interest rates have nonrandom volatilities. Models of this type are called market models or LIBOR models or, sometimes, BGM models, the last name referring to the paper of Brace, Gatarek and Musiela (Brace, Gatarek, and Musiela 1996).5 This class of models has become quite popular in recent years. A thorough and very readable account is given by Rebonato (Rebonato 2002).\nAs in Chapter 26, we will use LIBOR as a generic name for simple interest rates. One important fact about forward LIBOR rates that we have already essentially derived is that they are martingales under the corresponding forward measures. As was discussed in Section 13.12, a probability measure corresponding to a discount bond being the numeraire is called a forward measure, because the forward price of any contract maturing at the same time as the discount bond is a martingale under that measure. We showed in Section 26.3 that forward LIBOR rates are forward prices of portfolios that pay spot rates. Specifically, considering a LIBOR rate of term (also called tenor) \\(\\Delta t\\) and the forward LIBOR rate corresponding to loans over a period \\(u\\) to \\(u+\\Delta t\\), the forward LIBOR rate is a martingale under the measure corresponding to the discount bond maturing at \\(u+\\Delta t\\).\nTo price derivatives other than caps and floors (e.g., swaptions), it is important to know the dynamics of forward LIBOR rates under other probability measures as well—for example, it is useful to know the dynamics under the forward measures corresponding to discount bonds maturing at dates \\(T \\neq u+\\Delta t\\), or under the risk-neutral probability, or under the measure that uses as numeraire the portfolio consisting of rolling over an investment at spot LIBOR rates.6 We will derive here the dynamics under different forward measures.\nConsider dates \\(t_1 &lt; t_2 &lt; \\cdots &lt; t_N\\) with \\(t_i-t_{i-1} = \\Delta t\\) for each \\(i\\). At dates \\(t\\leq t_i\\), we denote the forward LIBOR rate for the time period \\((t_i, t_{i+1} )\\) by \\(\\mathcal{R}_i_t\\). The forward LIBOR rate satisfies equation~Equation 26.2, which we repeat here: \\[\n\\frac{P(t,t_i)}{P(t,t_{i+1})}=1+\\mathcal{R}_i_t\\,\\Delta t\\;.\n\\qquad(28.35)\\]\nFix a date \\(t_n\\). We will compute the drift of each rate \\(\\mathcal{R}_i_t\\) when we use the discount bond maturing at \\(t_{n}\\) as the numeraire.\nLet \\(\\sigma_i_t\\) denote the volatility of rate \\(\\mathcal{R}_i_t\\) at date \\(t\\). This means that \\[\n\\frac{\\,\\mathrm{d}\\mathcal{R}_i_t}{\\mathcal{R}_i_t} = \\mu_i_t\\,\\mathrm{d}t + \\sigma_i_t\\,\\mathrm{d}B_i_t\\;,\n\\qquad(28.36)\\]\nfor some \\(\\mu_i\\), where the \\(B_i\\) are Brownian motions when \\(P(t,t_n)\\) is used as the numeraire. The different rates should be correlated, so the Brownian motions will be correlated. Let \\(\\rho_{ij}\\) denote the correlation of \\(B_i\\) and \\(B_j\\). We will show that the drifts \\(\\mu_i\\) are determined by the volatilities and correlations, in analogy to the HJM result for instantaneous forward rates.\nSpecifying the volatilities and correlations of forward rates, and inputting initial forward rates, must therefore determine the value of any security whose cash flows depend on the LIBOR rates of term \\(\\Delta t\\) at the dates \\(t_1, \\ldots, t_N\\). Of course, this does not mean that there are simple formulas. Obviously, the easiest case is when the volatilities and correlations are nonrandom. In this case, we can use Black’s formula to price caps and floors as in Chapter 26. However, even when the \\(\\sigma_i\\) are nonrandom, forward swap rates will have random volatilities, as mentioned in Section 26.8.\nIf \\(i = n-1\\), then Equation 28.35 implies \\[\n\\mathcal{R}_i_t = \\frac{P(t,t_{n-1})-P(t,t_n)}{P(t,t_n)\\,\\Delta t}\\; .\n\\] Hence, it is the ratio of a dividend-reinvested asset (portfolio) price to the price of the numeraire asset. Consequently, it is a martingale, and we have \\(\\mu_{n-1}=0\\). This is the case discussed in the second paragraph of this section. Consider now \\(i \\neq n-1\\).\nDefine \\[\nY_t = \\frac{P(t,t_{i+1})}{P(t,t_n)}\\;,\n\\qquad(28.37)\\]\nand \\[\nZ_t = \\mathcal{R}_i_tY_t\\;.\n\\qquad(28.38)\\]\nNote that \\(Y\\) is the ratio of a dividend-reinvested asset price to the price of the numeraire asset and hence is a martingale. Furthermore, Equation 28.35 gives us \\[\nZ_t = \\frac{P(t,t_{i})-P(t,t_{i+1})}{P(t,t_n)\\,\\Delta t}\\; ,\n\\] and hence \\(Z\\) is also the ratio of a dividend-reinvested asset (portfolio) price to the price of the numeraire asset and consequently a martingale.\nIto’s formula applied to Equation 28.38 yields \\[\n\\frac{\\,\\mathrm{d}Z}{Z} = \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i} + \\frac{\\,\\mathrm{d}Y}{Y} + \\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)\\; .\n\\] Because both \\(Z\\) and \\(Y\\) are martingales, the drift of \\(\\,\\mathrm{d}\\,\\mathcal{R}_i/\\mathcal{R}_i\\) must cancel the product (covariance) term in this equation, implying \\[\n\\mu_i\\,\\mathrm{d}t = - \\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right)\\;.\n\\qquad(28.39)\\]\nTo compute the covariance, it is helpful to define \\[\nX_j_t = 1+ \\mathcal{R}_j_t\\,\\Delta t\n\\qquad(28.40)\\]\nfor \\(j = 1, \\ldots , N\\). Then we have \\[\n\\frac{\\,\\mathrm{d}X_j}{X_j} = \\left(\\frac{\\mathcal{R}_j\\,\\Delta t}{1+\\mathcal{R}_j\\,\\Delta t}\\right)\\big(\\mu_j\\,\\mathrm{d}t + \\sigma_j\\,\\mathrm{d}B_j\\big)\\;.\n\\qquad(28.41)\\]\nWe distinguish two cases. If \\(i &lt; n-1\\), then the definitions Equation 28.35, Equation 28.37 and Equation 28.40 imply \\[\\begin{align*}\nY_t &= \\frac{P(t,t_{i+1})}{P(t,t_{i+2})} \\times \\frac{P(t,t_{i+2})}{P(t,t_{i+3})} \\cdots \\times \\frac{P(t,t_{n-1})}{P(t,t_n)}\\\\\n&= X_{i+1}_t\\times X_{i+2}_t \\times \\cdots \\times X_{n-1}_t\\;.\n\\end{align*}\\] In this case, Equation 28.36 and Equation 28.41 yield \\[\\begin{align*}\n\\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right) &= \\sum_{j=i+1}^{n-1} \\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}X_j}{X_j}\\right)\\\\\n&= \\sum_{j=i+1}^{n-1} \\left(\\frac{\\mathcal{R}_j\\,\\Delta t}{1+\\mathcal{R}_j\\,\\Delta t}\\right)\\sigma_i\\sigma_j\\rho_{ij}\\,\\mathrm{d}t\\;.\n\\end{align*}\\] On the other hand, if \\(i &gt; n-1\\), then the definitions Equation 28.35, Equation 28.37 and Equation 28.40 imply \\[\\begin{align*}\n\\frac{1}{Y_t} &= \\frac{P(t,t_{n})}{P(t,t_{n+1})} \\times \\frac{P(t,t_{n+1})}{P(t,t_{n+2})} \\times \\cdots \\times \\frac{P(t,t_{i})}{P(t,t_{i+1})}\\\\\n&= X_{n}_t\\times X_{n+1}_t \\times \\cdots \\times X_{i}_t\\;.\n\\end{align*}\\] In this case, Equation 28.36 and Equation 28.41 yield \\[\\begin{align*}\n\\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}Y}{Y}\\right) &= -\\sum_{j=n}^{i} \\left( \\frac{\\,\\mathrm{d}\\,\\mathcal{R}_i}{\\mathcal{R}_i}\\right)\\left(\\frac{\\,\\mathrm{d}X_j}{X_j}\\right)\\\\\n&= -\\sum_{j=n}^{i} \\left(\\frac{\\mathcal{R}_j\\,\\Delta t}{1+\\mathcal{R}_j\\,\\Delta t}\\right)\\sigma_i\\sigma_j\\rho_{ij}\\,\\mathrm{d}t\\;.\n\\end{align*}\\] We conclude:\n\n\n\n\n\n\n28.9\n\n\n\nWhen we use the discount bond maturing at \\(t_n\\) as the numeraire, the drift of (expected percentage change in) the forward rate \\(\\mathcal{R}_i\\) is \\[\n\\mu_i_t = \\begin{cases}\n\\sum_{j=i+1}^{n-1} \\left(\\frac{\\mathcal{R}_j_t\\,\\Delta t}{1+\\mathcal{R}_j_t\\,\\Delta t}\\right)\\sigma_i\\sigma_j\\rho_{ij} & \\text{if $i &lt; n-1$}\\; ,\\\\\n0 & \\text{if $i = n-1$}\\; ,\\\\\n-\\sum_{j=n}^{i} \\left(\\frac{\\mathcal{R}_j_t\\,\\Delta t}{1+\\mathcal{R}_j_t\\,\\Delta t}\\right)\\sigma_i\\sigma_j\\rho_{ij} & \\text{if $i &gt; n-1$}\\;. \\end{cases}\n\\]",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#section-2",
    "href": "Chapter_Survey.html#section-2",
    "title": "28  Term Structure Models",
    "section": "",
    "text": "Exercise\n\n\n\n\n\nCreate a Python program demonstrating a four-period Ho-Lee model. Allow the user to input \\(\\sigma\\), \\(\\Delta t\\), and \\(P^{\\text{mkt}}(t_n)\\) for \\(n=1, \\ldots, 5\\). Compute \\(\\phi(t_n)\\) from Equation 28.3 for \\(n=1,\\ldots, 4\\). Create the one-period interest rate tree (starting from \\(r_0 = -\\log P^{\\text{mkt}}(t_1)/\\Delta t\\)) and the valuation tree for a discount bond maturing at \\(t_5\\). Verify that the tree gives the price \\(P^{\\text{mkt}}(t_5)\\). Note: to create a binomial tree in a spreadsheet, it is probably easiest to put the topmost (or bottommost) nodes along one row and the other nodes in a triangle below (or above).\n\n\n\n\nExercise 28.1 Modify the preceding exercise to include the valuation tree for a caplet with \\(t_4\\) as its reset date and \\(t_5\\) as its payment date. Note that the payoff of the caplet at date \\(t_5\\) is \\[\\max\\left(0, \\mathcal{R}(t_4)-\\bar{\\mathcal{R}}\\right)\\Delta t,\\] where \\[\\mathcal{R}(t_4) = \\frac{1}{P(t_4,t_5)}-1.\\] Allow the user to input \\(\\bar{\\mathcal{R}}\\).\n\n\nExercise 28.2 Create a function Ho_Lee_Caplet that values a caplet in the Ho-Lee model. Look up market discount bond prices from a function such as DiscountBondPrice in Exercise 26.1 and calibrate to the market from Equation 28.3. The inputs to the function should be \\(\\bar{\\mathcal{R}}\\), \\(\\sigma\\), \\(T_1\\), \\(T_2\\), \\(N_1\\) and \\(N_2\\), where \\(T_1\\) is the reset date for the caplet, \\(T_2\\) is the payment date for the caplet, \\(N_1\\) is the number of periods between date \\(0\\) and \\(T_1\\), and \\(N_2\\) is the number of periods between \\(T_1\\) and \\(T_2\\). Note that the payoff of the caplet at date \\(T_2\\) is \\[\\max\\left(0, \\mathcal{R}(T_1)-\\bar{\\mathcal{R}}\\right) \\times (T_2-T_1),\\] where \\[\\mathcal{R}(T_1) = \\frac{1}{P(T_1,T_2)}-1.\\]\n\n\nExercise 28.3 Create a Python program demonstrating a four-period Black-Derman-Toy model. Allow the user to input \\(\\Delta t\\), \\(r_0\\), and \\(\\sigma_{t_i}\\) and \\(\\theta_{t_i}\\) for \\(i=1,\\ldots, 4\\). Create the one-period interest rate and the valuation tree for a discount bond maturing at \\(t_5\\).\n\n\nExercise 28.4 Modify the preceding exercise by including the valuation tree for a caplet with reset date \\(t_4\\) and payment date \\(t_5\\), as in Exercise 28.1.\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nRepeat Probs.~\\(\\ref{e_bdt}\\) and \\(\\ref{e_bdt2}\\) for the Black-Karasinski model, allowing the user to also input \\(\\kappa_{t_i}\\) for \\(i=1,\\ldots, 4\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nCreate a Python function CIR_Caplet_MC that values a caplet in the CIR model using Monte Carlo, without calibrating the model to the current yield curve. Simulate the CIR process as described in ?sec-s:stochasticvolatility for the Heston model. The inputs should be \\(\\bar{\\mathcal{R}}\\), \\(r_0\\), \\(\\kappa\\), \\(\\theta\\), \\(\\sigma\\), \\(T_1\\), \\(T_2\\), \\(N\\) and \\(M\\), where \\(T_1\\) is the reset date for the caplet, \\(T_2\\) is the payment date for the caplet, \\(N\\) is the number of periods between 0 and \\(T_1\\), and \\(M\\) is the number of simulations. The payoff of the caplet is as in Exercise 28.2, where \\(P(T_1,T_2)\\) is the function of \\(r(T_1)\\) and \\(T_2-T_1\\) given in Equation 28.20 with \\(\\phi=0\\).\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\n\nModify the function in the preceding exercise to create a function CIR_Calibrated_Caplet_MC that values a caplet in the CIR model using Monte Carlo, with the model calibrated to the market. Look up market discount bond prices from a function such as DiscountBondPrice in Exercise 26.1. To compute \\(\\phi_{t_i}\\) for \\(i=1,\\ldots, N\\) from market bond prices, use Equation 28.21 for dates \\(t_i\\) and \\(t_{i+1}\\) as in Section 27.13.\n\n\n\n\n\n\n\nBlack, F., E. Derman, and W. Toy. 1990. A One-Factor Model of Interest Rates and Its Application to Treasury Bond Options. Financial Analysts Journal. January/February, 33–39.\n\n\nBlack, F., and P. Karasinski. 1991. Bond and Option Pricing When Short Rates Are Lognormal. Financial Analysts Journal. July-August, 52–59.\n\n\nBrace, A., D. Gatarek, and M. Musiela. 1996. “The Market Model of Interest Rate Dynamics.” Mathematical Finance 7: 127–54.\n\n\nCox, J., J. Ingersoll, and S. Ross. 1985. “A Theory of the Term Structure of Interest Rates.” Econometrica 53: 385–408.\n\n\nDai, Q., and K. Singleton. 2000. “Specification Analysis of Affine Term Structure Models.” Journal of Finance 55: 1943–78.\n\n\nDuffie, D., and R. Kan. 1996. “A Yield-Factor Model of Interest Rates” 6: 379–406.\n\n\nHeath, D., R. Jarrow, and A. Morton. 1992. “Bond Pricing and the Term Structure of Interest Rates: A New Methodology for Contingent Claims Valuation.” Econometrica 60: 77–105.\n\n\nHeston, S. 1993. “A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.” Review of Financial Studies 6: 327–44.\n\n\nHo, T., and S. Lee. 1986. “Term Structure Movements and Pricing Interest Rate Contingent Claims.” Journal of Finance 41: 1011–29.\n\n\nJamshidian, F. 1997. “LIBOR and Swap Market Models and Measures.” Finance and Stochastics 1: 293–330.\n\n\nLongstaff, F., and E. Schwartz. 1992. “Interest Rate Volatility and the Term Structure: A Two-Factor General Equilibrium Model” 47: 1259–82.\n\n\nMiltersen, K. R., K. Sandermann, and D. Sondermann. 1997. “Closed Form Solutions for Term Structure Derivatives with Log-Normal Interest Rates” 52: 409–30.\n\n\nRebonato, R. 2002. Modern Pricing of Interest-Rate Derivatives. The LIBOR Market Model; Beyond, Princeton University Press, Princeton, New Jersey.",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Survey.html#footnotes",
    "href": "Chapter_Survey.html#footnotes",
    "title": "28  Term Structure Models",
    "section": "",
    "text": "Cox, Ingersoll and Ross (hereafter CIR) also discuss a variety of other continuous-time models, but this particular model is so well known that it is often simply called the CIR model.↩︎\nThis guess works because the CIR model, like the Vasicek model, is an affine model. See Section 28.6↩︎\nOf course, the volatility is also not directly observable. Longstaff and Schwartz use a GARCH model to estimate it and then use the time series of estimated volatilities and the time series of short rates to estimate the parameters of the model.↩︎\nAn affine function of a real variable \\(x\\) is a function \\(f(x) = a + bx\\) for constants \\(a\\) and \\(b\\). This is often called a linear function, but technically a linear function is of the form \\(f(x)=bx\\). Thus, an affine function is a constant plus a linear function.↩︎\nOther important work on this topic includes Miltersen, Sandmann, and Sondermann (Miltersen, Sandermann, and Sondermann 1997) and Jamshidian (Jamshidian 1997).↩︎\nActually, for this theory, it is not even necessary that the short rate exist, so the risk-neutral probability may not even be defined. The risk-neutral probability uses as numeraire the portfolio that consists of continuously rolling over an investment at the instantaneously risk-free rate, and the more natural object in a market model is the portfolio that consists of rolling over an investment at spot LIBOR rates.↩︎",
    "crumbs": [
      "Part VII: Fixed Income",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Term Structure Models</span>"
    ]
  },
  {
    "objectID": "AppendixA.html",
    "href": "AppendixA.html",
    "title": "Miscellaneous Facts about Continuous-Time Models",
    "section": "",
    "text": "Girsanov’s Theorem\nIn ?sec-s_girsanov, we were able to compute the expected return of an asset under different numeraires directly, by using Ito’s formula and the fact that the ratio of a non-dividend-paying asset price to the numeraire asset price is a martingale under the measure associated with the numeraire. In other cases (e.g., Heston’s stochastic volatility model and Vasicek’s model) the drift of a process could not be computed directly when we changed numeraires, because the process (volatility in Heston’s model and the short rate in Vasicek’s model) was not an asset price. In general, the change in the drift of a process when we change numeraires (or, more generally, change probability measures) is given by Girsanov’s theorem.\nAn heuristic explanation of Girsanov’s theorem is as follows. Let \\(\\lambda\\) be a constant, and let \\(B\\) be a Brownian motion under a probability measure that we will denote by \\(\\text{prob}\\). Let \\(B^*(t)=B(t)+\\lambda t\\); i.e., \\(\\mathrm{d} B^* = \\mathrm{d} B + \\lambda\\,\\mathrm{d} t\\).\nGirsanov’s theorem shows how to change the probability measure so that the drift of \\(B^*\\) is zero, i.e., how to change the probability measure to make \\(B^*\\) a martingale and hence (by Levy’s theorem) a Brownian motion.\nConsider discrete time periods of length \\(\\Delta t\\) and approximate \\(B\\) by a binomial process that steps up or down by \\(\\sqrt{\\Delta t}\\) in each time period, with up and down being equally likely. This approximation implies that the changes \\(\\Delta B\\) of the binomial process have mean equal to zero and variance equal to \\(\\Delta t\\), just as for a true Brownian motion. We have \\(\\Delta B^*=\\lambda\\,\\Delta t\\pm\\sqrt{\\Delta t}\\). If we change the probability of the up move to \\((1-\\lambda\\sqrt{\\Delta t})/2\\) and the probability of the down move to \\((1+\\lambda\\sqrt{\\Delta t})/2\\), then the expected change in \\(B^*\\) will be \\[\n\\left(\\frac{1-\\lambda\\sqrt{\\Delta t}}{2}\\right)\\left(\\lambda\\,\\Delta t+\\sqrt{\\Delta t}\\right)+\n\\left(\\frac{1+\\lambda\\sqrt{\\Delta t}}{2}\\right)\n\\left(\\lambda\\,\\Delta t-\\sqrt{\\Delta t}\\right) = 0\\; .\n\\] Therefore, \\(B^*\\) is a martingale under these revised probabilities.\nChanging the probabilities of each branch of the binomial tree in this way implies that the probability of a path through the tree is changed as follows. The probability of a path is the product of the probabilities of the branches, so, letting \\(\\text{prob}^*\\) denote the revised probabilities, we have \\[\\begin{multline*}\n\\frac{\\text{prob}^*(\\text{path through time } t)}{\\text{prob}\\,(\\text{path through time } t)}\\\\=\n\\frac{\\text{prob}^*(\\text{path through time } t\\!-\\!\\Delta t)}{\\text{prob}\\,(\\text{path through time } t\\!-\\!\\Delta t)} \\times\n\\frac{\\text{prob}^*(\\text{branch at } t)}{\\text{prob}\\,(\\text{branch at } t)}\\; .\n\\end{multline*}\\] Note that our definitions imply \\[\\begin{align*}\n\\frac{\\text{prob}^*(\\text{up branch at } t)}{\\text{prob}\\,(\\text{up branch at } t)}&=\\frac{\\frac{1}{2}\\left(1-\\lambda\\sqrt{\\Delta t}\\right)}{1/2} =1-\\lambda\\,\\Delta B(t)\\;,\\\\\n\\frac{\\text{prob}^*(\\text{down branch at } t)}{\\text{prob}\\,(\\text{down branch at } t)}&=\\frac{\\frac{1}{2}\\left(1+\\lambda\\sqrt{\\Delta t}\\right)}{1/2} =1+\\lambda\\,\\Delta B(t)\\;.\n\\end{align*}\\] Therefore, \\[\\begin{multline*}\n\\frac{\\text{prob}^*(\\text{path through time } t)}{\\text{prob}\\,(\\text{path through time } t)}\\\\=\n\\frac{\\text{prob}^*(\\text{path through time } t\\!-\\!\\Delta t)}{\\text{prob}\\,(\\text{path through time } t\\!-\\!\\Delta t)} \\times\n\\big(1-\\lambda\\,\\Delta B(t)\\big)\\; .\n\\end{multline*}\\] If we let \\(Y(t)\\) denote the ratio of path probabilities through time \\(t\\), this shows that the percent change in \\(Y\\) at time \\(t\\) is \\(-\\lambda\\,\\Delta B(t)\\), i.e., \\[Y(t) = Y(t-\\Delta t) \\times\n\\big(1-\\lambda\\,\\Delta B(t)\\big) \\Longrightarrow \\frac{ Y(t)- Y(t-\\Delta t)}{Y(t-\\Delta t)}=-\\lambda\\,\\Delta B(t)\\; .\\] A continuous-time formulation of this equation is \\[\\frac{\\mathrm{d} Y(t)}{Y(t)} = -\\lambda\\,\\mathrm{d} B(t)\\; .\\] This equation implies that \\(Y\\) is a geometric Brownian motion with explicit solution (given that the ratio of path probabilities at date \\(0\\) is \\(Y(0)=1\\)) \\[\nY(t)=\\exp\\left(-\\lambda^2 t/2 - \\lambda B(t)\\right)\\;.\n\\qquad(1)\\]\nThe above heuristic argument suggests that the process Equation 1 defines a ratio of path probabilities, \\(\\text{prob}^*\\) to \\(\\text{prob}\\), such that \\(B^*\\) is a martingale under \\(\\text{prob}^*\\).\nBecause \\(B^*\\) is continuous and its quadratic variation through each date \\(t\\) is equal to \\(t\\) (because the addition of \\(\\lambda t\\) to \\(B\\) does not alter the quadratic variation of \\(B\\)), Levy’s theorem implies that \\(B^*\\) must in fact be a Brownian motion relative to the measure \\(\\text{prob}^*\\). This is the content of Girsanov’s theorem. In the formal statement, there is no reference to ratios of path probabilities, because individual paths actually have zero probability under either \\(\\text{prob}\\) or \\(\\text{prob}^*\\). Instead, the theorem states that \\(B^*\\) is converted to a Brownian motion by multiplying the probability of any event (set of paths) by the conditional expectation of \\(Y\\), given the event.\nThere is no need to assume \\(\\lambda\\) is a constant, provided the random process \\(\\lambda\\) is sufficiently regular that the general form of Equation 1, i.e., \\[\nY(t) \\equiv \\exp \\left\\{ -\\frac{ 1}{2}\\int_0^t \\lambda^2(u)\\,du - \\int _0^t\n\\lambda(u)\\,\\mathrm{d} B(u) \\right\\},\n\\qquad(2)\\]\nis a martingale.^[The process Equation 2 is an Ito process with zero drift. A sufficient condition for it to be a martingale is that \\[E \\left[ \\exp \\left\\{ \\frac{ 1]{2}\\int _0^T \\lambda^2(u)\\,du \\right\\} \\right]\n&lt; \\infty\\; .\\] This is called Novikov’s condition. See, e.g., Karatzas and Shreve (Karatzas and Shreve 1988).}\nThe definition of \\(\\text{prob}^*\\) in the boxed statement emphasizes the ratio of probabilities aspect. It is equivalent to the definition \\[\n\\text{prob}^*(A) =  E\\left[1_AY(T)\\right]\n\\qquad(5)\\]\nfor each event \\(A\\). Thus, it is consistent with Equation 7.23 of the probability of an event \\(A\\) when we use a non-dividend-paying asset price \\(S\\) as the numeraire. The relation between the two is that the ratio of path probabilities \\(Y(T)\\) equals \\(\\phi(T)S(T)/S(0)\\), where \\(\\phi(T)\\) denotes the random state price at date \\(T\\).\nNote also that for any random variable \\(X\\) (for which the mean exists) the mean of \\(X\\) under \\(\\text{prob}^*\\), which we denote by \\(E^*[X]\\), is given by \\[\nE^*[X] = E[Y(T)X]\\;.\n\\qquad(6)\\]\nIn some cases we may be given (perhaps by equilibrium arguments) the random variable \\(Y\\) defining the change of measure, and we wish to compute the change in the drift of a Brownian motion (in order to compute, for example, the drift of a volatility or an interest rate). Thus, we need to reverse the above process, in which we started with the change of drift \\(\\lambda\\) and computed \\(Y\\). This is straightforward. Given \\(Y(T)\\), define \\(Y(t) = E_t[Y(T)]\\), i.e., the expectation of \\(Y(T)\\) under the original measure, given information at date \\(t\\). Equation Equation 2 shows that \\[\\frac{\\mathrm{d} Y}{Y} = -\\lambda\\,\\mathrm{d} B\\; .\\] Therefore, \\[-(\\mathrm{d} B)\\left(\\frac{\\mathrm{d} Y}{Y}\\right) = \\lambda\\,\\mathrm{d} t\\; .\\] It follows that the definition \\[\\mathrm{d} B^* = \\mathrm{d} B - (\\mathrm{d} B)\\left(\\frac{\\mathrm{d} Y}{Y}\\right)\\] gives us a Brownian motion \\(B^*\\) relative to the measure \\(\\text{prob}^*\\). In other words, the drift of \\(B\\) under the measure \\(\\text{prob}^*\\) is \\((\\mathrm{d} B)(\\mathrm{d} Y)/Y\\).",
    "crumbs": [
      "Appendix",
      "Miscellaneous Facts about Continuous-Time Models"
    ]
  },
  {
    "objectID": "AppendixA.html#sec-a_girsanov",
    "href": "AppendixA.html#sec-a_girsanov",
    "title": "Miscellaneous Facts about Continuous-Time Models",
    "section": "",
    "text": "Rule\n\n\n\nGirsanov’s Theorem: Let \\(B\\) be a Brownian motion on a time horizon \\([0,T]\\) and let \\(\\lambda\\) be a stochastic process such that \\(Y\\) defined by Equation 2 is a martingale. Define \\[\nB^*(t)=B(t)+\\int_0^t \\lambda(u)\\,du,\n\\qquad(3)\\]\nand define a new probability measure \\(\\text{prob}^*\\) by setting \\(\\text{prob}^*(A)=0\\) for each event \\(A\\) such that \\(\\text{prob}(A)=0\\), and by defining \\[\n\\text{prob}^*(A) = E \\big[ Y(T) | A \\big]\\times \\text{prob}(A)\n\\qquad(4)\\]\nfor each event \\(A\\) such that \\(\\text{prob}(A)&gt;0\\). Then \\(B^*\\) is a Brownian motion on the time horizon \\([0,T]\\) relative to \\(\\text{prob}^*\\).\n\n\n\n\n\n\n\nDistribution of the Minimum of a Geometric Brownian Motion\nHere we will give an explanation of formulas used in ?sec-c_exotics for valuing barrier and lookback options. From a mathematical point of view, our discussion will be decidedly informal.\nConsider an asset price \\(S\\) satisfying \\[\n\\mathrm{d}\\log S = \\mu\\,\\mathrm{d} t+\\sigma\\,\\mathrm{d} B\\; ,\\] for constants \\(\\mu\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion. Consider constants \\(K \\geq L\\) with \\(L&lt; \\log S(0)\\). Define \\(z = \\min_{0 \\leq t \\leq T} S(t)\\). Define \\[x = \\begin{cases} 1 & \\text{if $S(T)&gt; K$ and $z&gt; L$}\\;,\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\\] To price a down-and-out call, we need to compute \\(\\text{prob}(x=1)\\). As in ?sec-s_barriers, define \\[y = \\begin{cases} 1 & \\text{if $S(T)&gt; K$ and $z \\leq L$}\\;,\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\\] The event \\(S(T)&gt;K\\) is the union of the disjoint events \\(x=1\\) and \\(y=1\\), so we have \\[\\begin{align*}\n\\text{prob}(x=1) &= \\text{prob}(S(T)&gt;K) - \\text{ prob}(y=1)\\\\\n&= \\mathrm{N}(d) - \\text{prob}(y=1)\\;,\n\\end{align*}\\] where \\[\nd = \\frac{\\log \\left(\\frac{S(0)}{K}\\right)+ \\mu T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(7)\\]\nThus, the remaining task is to compute \\(\\text{prob}(y=1)\\).\nTo price lookback options, it is necessary to know the cumulative distribution function of \\(z\\), i.e., we need to know \\(\\text{prob}(z \\leq L)\\) for arbitrary \\(L\\).\nThe event \\(z \\leq L\\) is the union of the disjoint events \\(S(T) \\leq L\\) and \\(y=1\\), where we specialize to the case \\(K=L\\) in the definition of \\(y\\). Thus, \\[\\begin{align*}\n\\text{prob}(z \\leq L) &= \\text{prob}(S(T)\\leq L) + \\text{prob}(y=1)\\\\\n&= \\mathrm{N}(-d) + \\text{ prob}(y=1)\\;,\n\\end{align*}\\] where again we take \\(K = L\\) in the definition of \\(d\\). Thus, for pricing lookbacks also, the key task is to compute \\(\\text{prob}(y=1)\\).\nAssume first that \\(\\mu=0\\), so \\(\\log S\\) is a Brownian motion with zero drift. We want to compute the probability of the paths of \\(\\log S\\) that dip below \\(\\log L\\) and end above \\(\\log K\\). Each such path has a twin defined by reflecting the path (as in a mirror image) through the horizontal line \\(x(t)=\\log L\\) after the first time \\(\\log S\\) hits \\(\\log L\\). The original path increases by at least \\(\\log K - \\log L\\) after hitting \\(\\log L\\) (otherwise, it could not end above \\(\\log K\\)). So, the twin decreases by at least \\(\\log K - \\log L\\) after hitting \\(\\log L\\). This means that it ends below \\(2\\log L - \\log K\\). Moreover, each path ending below \\(2\\log L - \\log K\\) is the twin in this sense of a path hitting \\(\\log L\\) and then ending above \\(\\log K\\). Because \\(\\log S\\) has no drift, the twins are equally likely. Therefore, when \\(\\mu=0\\), \\[\\begin{align*}\n\\text{prob}(y=1) &= \\text{prob}\\big(\\log S(T) \\leq 2\\log L - \\log K\\big)\\\\\n&= \\text{prob}\\left(\\frac{B(T)}{\\sqrt{T}} \\leq \\frac{2 \\log L - \\log K - \\log S(0)-\\mu T}{\\sigma\\sqrt{T}}\\right)\\\\\n&= \\mathrm{N}(d^*)\\;,\n\\end{align*}\\] where \\[\nd^* = \\frac{\\log \\left(\\frac{L^2}{KS(0)}\\right) }{\\sigma\\sqrt{T}}\\;.\n\\qquad(8)\\]\nNow consider the case \\(\\mu \\neq 0\\), the case in which we are really interested. By Girsanov’s theorem, the process \\(B^*\\) defined by \\(B^*(0)=0\\) and \\[\\mathrm{d} B^* = \\mathrm{d} B + \\frac{\\mu}{\\sigma}\\,\\mathrm{d} t\\] is a Brownian motion under the measure \\(\\text{prob}^*\\) defined by Equation 1 and Equation 4, where we take \\(\\lambda = \\mu/\\sigma\\) in the definition of \\(Y(T)\\). The purpose of this definition is that we have \\[\\mathrm{d}\\log S = \\mu\\,\\mathrm{d} t + \\sigma\\left(\\mathrm{d} B^* - \\frac{\\mu}{\\sigma}\\,\\mathrm{d} t\\right) = \\sigma\\,\\mathrm{d} B^*\\; .\\] Letting \\(E\\) denote expectation relative to the measure under which \\(B\\) is a Brownian motion and \\(E^*\\) denote expectation relative to \\(\\text{prob}^*\\), we have from Equation 6 that\n\\[\n\\text{prob}(y=1) =E[y] = E \\left[Y(T)\\frac{y}{Y(T)}\\right]\n\\] \\[\n= E^*\\left[\\frac{y}{Y(T)}\\right]\n\\] \\[\n= E^*\\left[\\exp\\left(\\frac{1}{2}\\lambda^2T + \\lambda B(T)\\right)y\\right]\n\\] \\[\n= E^*\\left[\\exp\\left(\\frac{1}{2}\\lambda^2T + \\lambda [B^*(T)-\\lambda T]\\right)y\\right]\n\\] \\[\n=E^*\\left[\\exp\\left(-\\frac{1}{2}\\lambda^2T + \\lambda B^*(T)\\right)y\\right]\\;.\n\\qquad(9)\\]\nBecause \\(\\log S\\) has no drift under \\(\\text{prob}^*\\), the twin paths described before are equally likely under \\(\\text{prob}^*\\). However, the reflection leads to low values of \\(\\log S(T)\\) and hence to low values of \\(B^*(T)\\) rather than high values, and we must compensate for this in Equation 9. Specifically, for a path of \\(\\log S\\) that ends above \\(\\log K\\), we have \\[\nB^*(T) = \\frac{\\log K - \\log S(0) + \\varepsilon}{\\sigma}\n\\qquad(10)\\]\nfor some \\(\\varepsilon&gt;0\\) and the reflection of this path has \\[\nB^*(T) = \\frac{2\\log L - \\log K - \\log S(0) - \\varepsilon}{\\sigma}\n\\qquad(11)\\]\nfor the same \\(\\varepsilon\\). Therefore, to use the reflected path, we compute \\[\\varepsilon = 2\\log L - \\log K - \\log S(0) - \\sigma B^*(T)\\] from Equation 11 and substitute this into the right-hand side of Equation 10 to obtain \\[\\begin{multline*}\n\\frac{\\log K - \\log S(0) + 2\\log L - \\log K - \\log S(0) - \\sigma B^*(T)}{\\sigma} \\\\= \\frac{2\\log L - 2\\log S(0)}{\\sigma} - B^*(T)\n\\end{multline*}\\] as the value that should replace \\(B^*(T)\\) in Equation 9 when we use the reflected paths. As in the case \\(\\mu=0\\), using the reflected paths means replacing the random variable \\(y\\) with \\(y'\\) defined as \\[y' = \\begin{cases} 1 & \\text{if $\\log S(T)\\leq 2 \\log L - \\log K$}\\;,\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\\] Substituting into Equation 9 and employing some algebra gives us\n\\[\n\\text{prob}(y=1) = E^*\\left[\\exp\\left(-\\frac{1}{2}\\lambda^2T + \\lambda\\left[\\frac{2\\log L - 2\\log S(0)}{\\sigma} - B^*(T)\\right]\\right)y'\\right]\n\\] \\[\n= \\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}E^*\\left[\\exp\\left(-\\frac{1}{2}\\lambda^2T - \\lambda [B(T)+\\lambda T]\\right)y'\\right]\n\\] \\[\n=\\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}E^*\\left[\\exp\\left(-\\frac{3}{2}\\lambda^2T - \\lambda B(T)\\right)y'\\right]\n\\] \\[\n= \\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}E\\left[\\exp\\left(-2\\lambda^2T - 2\\lambda B(T)\\right)y'\\right]\\;,\n\\qquad(12)\\]\nwhere for the last equality we used Equation 6 again.\nNow we will define another change of measure. Set \\(\\delta = 2\\lambda\\), \\[Z(T) = \\exp\\left(-\\delta^2 T/2 - \\delta B(T)\\right)\\] and \\(\\text{prob}^{**}(A) = E[1_A Z(T)]\\) for each event \\(A\\). From the definition of \\(\\delta\\) and Equation 6 we have\n\\[\nE\\left[\\exp\\left(-2\\lambda^2T - 2\\lambda B(T)\\right)y'\\right] = E\\left[\\exp\\left(-\\frac{1}{2}\\delta^2T - \\delta B(T)\\right)y'\\right]\n\\] \\[\n= E^{**}[y']\n\\] \\[\n= \\text{prob}^{**}(y'=1)\\;.\n\\qquad(13)\\]\nMoreover, Girsanov’s theorem states that \\(\\mathrm{d} B^{**} = \\mathrm{d} B + \\delta\\,\\mathrm{d} t\\) defines a Brownian motion \\(B^{**}\\) under the measure \\(\\text{prob}^{**}\\). The event \\(y'=1\\) is equivalent to\n\\[\n\\log S(0) + \\mu T + \\sigma B(T) \\leq  \\log \\left(\\frac{L^2}{K}\\right)\n\\] \\[\n\\Longleftrightarrow \\log S(0) + \\mu T + \\sigma [B^{**}(T) - \\delta T] \\leq \\log \\left(\\frac{L^2}{K}\\right)\n\\] \\[\n\\Longleftrightarrow \\log S(0) - \\mu T + \\sigma B^{**}(T) \\leq \\log \\left(\\frac{L^2}{K}\\right)\n\\] \\[\n\\Longleftrightarrow \\frac{B^{**}(T)}{\\sqrt{T}} \\leq d'\\;,\n\\qquad(14)\\]\nwhere we define \\[\nd' = \\frac{\\log \\left(\\frac{L^2}{KS(0)}\\right) + \\mu T }{\\sigma\\sqrt{T}}\\;.\n\\qquad(15)\\]\nCombining Equation 12, Equation 13 and Equation 14 yields \\[\\text{prob}(y=1) = \\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}\\mathrm{N}(d')\\; .\\] Summarizing, we have\n\n\n\n\n\n\nRule\n\n\n\nAssume \\(\\mathrm{d}\\log S = \\mu\\,\\mathrm{d} t+\\sigma\\,\\mathrm{d} B\\) where \\(B\\) is a Brownian motion. Define \\(z = \\min_{0 \\leq t \\leq T} S(t)\\). For \\(K \\geq L\\) and \\(L \\leq \\log S(0)\\),\n\nThe probability that \\(S(T)&gt;K\\) and \\(z &gt; L\\) is \\[\\mathrm{N}(d) - \\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}\\mathrm{N}(d')\\; ,\\] where \\(d\\) is defined in Equation 7 and \\(d'\\) is defined in Equation 15.\nThe probability that \\(z \\leq L\\) is \\[\\mathrm{N}(-d) + \\left(\\frac{L}{S(0)}\\right)^{2\\mu/\\sigma^2}\\mathrm{N}(d')\\; ,\\] where \\(d\\) is defined in Equation 7 and \\(d'\\) is defined in Equation 15, substituting \\(K=L\\) in both.",
    "crumbs": [
      "Appendix",
      "Miscellaneous Facts about Continuous-Time Models"
    ]
  },
  {
    "objectID": "AppendixA.html#sec-a_bessel",
    "href": "AppendixA.html#sec-a_bessel",
    "title": "Miscellaneous Facts about Continuous-Time Models",
    "section": "Bessel Squared Processes and the CIR Model",
    "text": "Bessel Squared Processes and the CIR Model\nThis section will present additional results regarding the CIR square-root short rate process discussed in ?sec-s_cir. The ideas described here are one way (though not the only way) to derive the CIR discount bond option pricing formula. We begin with the following simpler process \\[\n\\mathrm{d} x(t) = \\delta\\,\\mathrm{d} t + 2 \\sqrt{x(t)}\\,\\mathrm{d} Z\n\\qquad(16)\\]\nfor a Brownian motion \\(Z\\) and constant \\(\\delta&gt;0\\). This is called a Bessel-squared process with parameter \\(\\delta\\). The parameter \\(\\delta\\) determines whether \\(x\\) can ever reach zero. If \\(\\delta \\geq 2\\), then with probability one, \\(x(t)\\) is strictly positive for all \\(t\\); whereas, if \\(\\delta &lt; 2\\), then with positive probability, \\(x\\) will sometimes hit zero (but will never go negative).\nIn the particular (rare) case that \\(\\delta\\) is an integer, the squared length of a \\(\\delta\\)-dimensional vector of independent Brownian motions is a process \\(x\\) satisfying~Equation 16. To see this, let \\(B_1, \\ldots, B_\\delta\\) be independent Brownian motions starting at given values \\(b_i\\); i.e., \\(B_i(0) = b_i\\). Define \\(x(t) = \\sum_{i=1}^\\delta B_i(t)^2\\). Then Ito’s formula gives us \\[\\begin{align*}\n\\mathrm{d} x(t) &= \\sum_{i=1}^\\delta 2B_i(t)\\,\\mathrm{d} B_i(t) + \\sum_{i=1}^\\delta \\mathrm{d} t\\\\\n&= \\delta\\,\\mathrm{d} t + 2 \\sqrt{x(t)}\\sum_{i=1}^\\delta \\frac{B_i(t)}{\\sqrt{x(t)}}\\,\\mathrm{d} B_i(t).\n\\end{align*}\\] The process \\(Z\\) defined by \\(Z(0)=0\\) and \\[\\mathrm{d} Z = \\sum_{i=1}^\\delta \\frac{B_i(t)}{\\sqrt{x(t)}}\\,\\mathrm{d} B_i(t)\\] is a Brownian motion (because it is a continuous martingale with \\((\\mathrm{d} Z)^2=\\mathrm{d} t\\)); thus, we obtain Equation 16.\nContinuing to assume that \\(\\delta\\) is an integer and that \\(x(t) = \\sum_{i=1}^\\delta B_i(t)^2\\), note that, for any \\(t\\), the random variables \\(\\xi_i\\) defined as \\(\\xi_i = [B_i(t)-B_i(0)]/\\sqrt{t}\\) are independent standard normals, and we have \\[\\begin{align*}\nx(t) &= \\sum_{i=1}^\\delta \\big[b_i + B_i(t)-B_i(0)\\big]^2\\\\\n&= t\\times \\sum_{i=1}^\\delta \\left(\\frac{b_i}{\\sqrt{t}} + \\xi_i\\right)^2.\n\\end{align*}\\] A random variable of the form \\(\\sum_{i=1}^\\delta \\left(\\gamma_i + \\xi_i\\right)^2\\), where the \\(\\gamma_i\\) are constants and the \\(\\xi_i\\) are independent standard normals, is said to have a non-central chi-square distribution with \\(\\delta\\) degrees of freedom and noncentrality parameter \\(\\sum_{i=1}^\\delta \\gamma_i^2\\). Thus, \\(x(t)\\) is equal to \\(t\\) times a non-central chi-square random variable with \\(\\delta\\) degrees of freedom and noncentrality parameter \\[\\sum_{i=1}^\\delta \\frac{b_i^2}{t} = \\frac{x(0)}{t}\\; .\\] The noncentral chi-square distribution can be defined for a non-integer degrees of freedom also, and a process \\(x\\) satisfying Equation 16 for a non-integer \\(\\delta\\) has the same relation to it, namely,\n\n\n\n\n\n\nRule\n\n\n\nIf \\(x\\) satisfies Equation 16, then for any \\(t\\) and \\(\\alpha&gt;0\\), the probability that \\(x(t)  \\leq \\alpha\\) is equal to the probability that \\(z \\leq \\alpha/t\\), where \\(z\\) is a random variable with a non-central chi-square distribution with \\(\\delta\\) degrees of freedom and noncentrality parameter \\(x(0)/t\\).\n\n\nNow consider the CIR process Equation 28.9. Define \\(\\delta = 4 \\kappa\n\\theta/ \\sigma^2\\) and define \\(x\\) by Equation 16, with \\(x(0)= r(0)\\). Set1 \\[h(t)=\\frac{ \\sigma^2}{4 \\kappa} \\left( \\mathrm{e}^{\\kappa t}-1 \\right)\\; ,\\] and \\[r(t) = \\mathrm{e}^{-\\kappa t}x(h(t))\\; .\\] Then it can be shown^[The key to this calculation is the fact that if \\(Z\\) is a Brownian motion and \\(h\\) is a continuously differentiable function with \\(h'(s)&gt;0\\) for all \\(s&gt;0\\) then \\(B\\) defined by \\[B(t) = \\int_0^t \\frac{1]{\\sqrt{h'(s)}}\\,\\mathrm{d} Z_{h(s)}\\] is a Brownian motion also.} that \\(r\\) satisfies the CIR Equation 28.9, namely \\[\n\\mathrm{d} r = \\kappa(\\theta-r)\\,\\mathrm{d} t + \\sigma\\sqrt{r}\\,\\mathrm{d} B\n\\qquad(17)\\]\nfor a Brownian motion \\(B\\). For any \\(t\\) and \\(\\alpha&gt;0\\), the probability that \\(r(t) \\leq \\alpha\\) is equal to the probability that \\(x(h(t)) \\leq \\mathrm{e}^{\\kappa t}\\alpha\\). In view of the previous boxed statement, this implies:\n\n\n\n\n\n\nRule\n\n\n\nIf \\(r\\) satisfies the CIR Equation 17 where \\(\\kappa\\), \\(\\theta\\) and \\(\\sigma\\) are positive constants, then, for any \\(t&gt;0\\) and any \\(\\alpha\\), the probability that \\(r(t) \\leq \\alpha\\) is the probability that \\(z\\leq \\mathrm{e}^{\\kappa t}\\alpha/h(t)\\), where \\(z\\) is a random variable with a non-central chi-square distribution with \\(\\delta = 4 \\kappa\n\\theta/ \\sigma^2\\) degrees of freedom and noncentrality parameter \\(r(0)/h(t)\\).\n\n\nTo derive the discount bond option pricing formula for the CIR model, we need to know the distribution of \\(r(T)\\) when the parameters \\(\\kappa\\) and \\(\\theta\\) are time-dependent. Let \\(w\\) denote either \\(u\\) (the maturity of the underlying) or \\(T\\) (the maturity of the option). Using the discount bond maturing at \\(w\\) as the numeraire, we repeat here Equation 28.25, dropping now the hat on \\(\\hat{r}\\): \\[\n\\mathrm{d} r(t)= \\kappa^*(t)[\\theta^*(t)-r(t)]\\,\\mathrm{d} t +\\sigma \\sqrt{r(t)}\\,\\mathrm{d} B^*(t)\\;,\n\\qquad(18)\\]\nwhere \\[\n\\kappa^*(t) = \\kappa + \\sigma^2b(w-t) \\qquad \\text{and} \\qquad \\theta^*(t) = \\frac{\\kappa\\theta}{\\kappa^*(t)}\\; .\\] Because \\(\\kappa^*(t)\\theta^*(t) = \\kappa\\theta\\), we again define \\(\\delta = 4 \\kappa\n\\theta/ \\sigma^2\\) but now set \\[h^*(t) = \\frac{ \\sigma^2}{4}\\int_0^t \\exp\\left(\n\\int _0^s \\kappa^*(y)\\,\\mathrm{d} y \\right) \\,\\mathrm{d} s\\] and \\[r(t) = \\exp\\left(-\\int_0^t \\kappa^*(s)\\,\\mathrm{d} s\\right)x(h^*(t))\\; .\\] Then it can be shown that \\(r\\) satisfies Equation 18 for a Brownian motion \\(B^*\\). Thus, as in the previous paragraphs, the probability that \\(r(T) \\leq \\alpha\\), where \\(r\\) satisfies Equation 18, is the probability that \\[z \\leq \\frac{\\exp\\left(\\int_0^T \\kappa^*(s)\\,\\mathrm{d} s\\right)\\alpha}{h^*(T)}\\; ,\\] where \\(z\\) has a non-central chi-square distribution with \\(\\delta\\) degrees of freedom and noncentrality parameter \\(r(0)/h^*(T)\\).\nStraightforward calculations, using in particular the fact that \\(b(\\tau) = a'(\\tau)/(\\kappa\\theta)\\) and \\[\\int \\frac{\\mathrm{e}^{\\gamma t}}{c(t)^2}\\,\\mathrm{d} t = -\\frac{1}{(\\kappa+\\gamma)\\gamma} \\int \\frac{\\mathrm{d}}{\\mathrm{d} t}\\left(\\frac{1}{c(t)}\\right)\\,\\mathrm{d} t = -\\frac{1}{(\\kappa+\\gamma)\\gamma c(t)}\\] give us: \\[\\exp\\left(\\int_0^T \\kappa^*(s)\\,\\mathrm{d} s\\right) = \\frac{\\mathrm{e}^{-\\gamma T}c(w)^2}{c(w-T)^2}\\] and \\[h^*(T) =\\frac{\\sigma^2\\mathrm{e}^{-\\gamma w}c(w)}{4(\\kappa + \\gamma)\\gamma}\\left[\\frac{c(w)}{c(w-T)}-1\\right]\\; ,\\] where \\(\\gamma\\) and \\(c\\) are defined in Equation 28.15 - Equation 28.17. This simplifies somewhat in the case \\(w=T\\) because \\(c(0) = 2\\gamma\\). Thus, the probabilities in the CIR option pricing Equation 28.23, which are the probabilities of the event shown in Equation 28.24, are as follows:\n\n\\(\\text{prob}^u\\big(P(T,u)&gt;K\\big)\\) is the probability that \\[z \\leq -\\frac{\\mu_u}{\\lambda_u}\\left(\\frac{\\int_T^u \\phi(s)\\,\\mathrm{d} s+a(u-T)+\\log K}{b(u-T)}\\right)\\; ,\\] where \\(z\\) has a non-central chi-square distribution with \\(4\\kappa\\theta/\\sigma^2\\) degrees of freedom and noncentrality parameter \\(r(0)/\\lambda_u\\), and \\[\\begin{align*}\n\\mu_u & = \\frac{\\mathrm{e}^{-\\gamma T}c(u)^2}{c(u-T)^2}\\; ,\\\\\n\\lambda_u & = \\frac{\\sigma^2\\mathrm{e}^{-\\gamma u}c(u)}{4(\\kappa + \\gamma)\\gamma}\\left[\\frac{c(u)}{c(u-T)}-1\\right]\\;.\n\\end{align*}\\]\n\\(\\text{prob}^T\\big(P(T,u)&gt;K\\big)\\) is the probability that \\[z \\leq -\\frac{\\mu_T}{\\lambda_T}\\left(\\frac{\\int_T^u \\phi(s)\\,\\mathrm{d} s+a(u-T)+\\log K}{b(u-T)}\\right)\\; ,\\] where \\(z\\) has a non-central chi-square distribution with \\(4\\kappa\\theta/\\sigma^2\\) degrees of freedom and noncentrality parameter \\(r(0)/\\lambda_T\\), and \\[\\begin{align*}\n\\mu_T & = \\frac{\\mathrm{e}^{-\\gamma T}c(T)^2}{4\\gamma^2}\\; ,\\\\\n\\lambda_T & = \\frac{\\sigma^2\\mathrm{e}^{-\\gamma T}c(T)}{4(\\kappa + \\gamma)\\gamma}\\left[\\frac{c(T)}{2\\gamma}-1\\right]\\;.\n\\end{align*}\\]\n\n\n\n\n\nKaratzas, I., and S. Shreve. 1988. Brownian Motion and Stochastic Calculus. Springer, New York Berlin Heidelberg.",
    "crumbs": [
      "Appendix",
      "Miscellaneous Facts about Continuous-Time Models"
    ]
  },
  {
    "objectID": "AppendixA.html#footnotes",
    "href": "AppendixA.html#footnotes",
    "title": "Miscellaneous Facts about Continuous-Time Models",
    "section": "",
    "text": "I learned this transformation from unpublished lecture notes of Hans Buehlmann.↩︎",
    "crumbs": [
      "Appendix",
      "Miscellaneous Facts about Continuous-Time Models"
    ]
  }
]