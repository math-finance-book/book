[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pricing and Hedging Derivative Securities",
    "section": "",
    "text": "Preface\nThis is an incomplete and in-progress draft of a python-based introduction to derivative security pricing.\nThe chat icon below the book title on the top left is a link to a chatbot that can answer questions using the book as a source. Like any chatbot, it can make mistakes, so check its answers with the sources in the book that it should provide. The Github icon next to the chat icon is a link to a Github repository of Jupyter notebooks. The notebooks contain all of the code in the book and include  buttons. The notebooks can be opened in Colab or downloaded from the Github repo (or you can clone the repo). The icon to the right of the Github icon enables toggling between light and dark modes.\nFigures in the text are interactive. Hover your cursor over plot elements to see additional data. Also, hover over footnote numbers to see footnotes.\nThe book is Hypothesis enabled. Click the icons at the top right to log in or sign up and to create annotations or to highlight text. The annotations and highlights will be visible to you in subsequent visits to the book once you log in to your Hypothesis account. We prefer that you do not post annotations or highlights to the Public account.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Chapter_IntroDerivatives.html",
    "href": "Chapter_IntroDerivatives.html",
    "title": "1  Derivative Securities",
    "section": "",
    "text": "1.1 Types of Derivative Securities\nDerivative securities are financial instruments whose value is derived from an underlying asset, index, or rate. These instruments are used for hedging risks and for speculation. The underlying assets can be stocks, bonds, commodities, currencies, interest rates, or market indices. The fundamental characteristic of derivatives is that their values fluctuate based on changes in the price of the underlying assets.\nDerivatives play a significant role in financial markets by allowing investors to manage risk exposures and take speculative positions with a relatively small amount of capital. They are also widely used by corporations and financial institutions to hedge against fluctuations in interest rates, currency values, and commodity prices. The rapid growth of the derivatives market over the past few decades has made these instruments an essential part of global financial markets.\nOne of the key advantages of derivatives is their ability to provide leverage. Investors can control large positions with relatively small amounts of capital, amplifying potential gains. However, this also increases the risk of substantial losses. Furthermore, derivatives facilitate price discovery, enhance market efficiency, and contribute to overall liquidity by allowing market participants to express diverse opinions about future asset prices.\nMajor derivative securities can be broadly classified into four main types:",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroDerivatives.html#types-of-derivative-securities",
    "href": "Chapter_IntroDerivatives.html#types-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "",
    "text": "Forwards\nForwards are customized contracts between two parties to buy or sell an asset at a predetermined future date and price. Unlike standardized contracts, forwards are traded over-the-counter (OTC), making them more flexible but less liquid. Forwards are commonly used in the foreign exchange and commodities markets to hedge against price fluctuations.\nOne key feature of forward contracts is that they are non-standardized, meaning that the terms, such as contract size, expiration date, and settlement procedure, are determined by the parties involved. However, this flexibility also increases counterparty risk, as the default risk is not mitigated through a clearinghouse. Another drawback is the potential for price manipulation due to the lack of regulatory oversight in OTC markets.\n\n\nFutures\nFutures are standardized contracts traded on exchanges, obligating the buyer to purchase and the seller to sell an underlying asset at a specific price on a future date. Futures markets are highly liquid and regulated, reducing counterparty risk. They are used extensively for hedging and speculative purposes across various asset classes, including commodities, equities, interest rates, and foreign exchange.\nA key advantage of futures contracts is that they are cleared through centralized clearinghouses, reducing default risk. Additionally, futures contracts require margin deposits, which serve as collateral and help maintain market stability. The presence of daily mark-to-market settlements ensures that gains and losses are realized continuously, preventing excessive accumulation of risk.\nFutures markets are crucial for global trade and investment. For example, agricultural futures help farmers lock in prices for their crops, ensuring financial stability amid unpredictable market conditions. Similarly, crude oil futures allow energy companies to hedge against fluctuations in oil prices.\n\n\nOptions\nOptions give the holder the right, but not the obligation, to buy (call option) or sell (put option) an asset at a predetermined price before or at expiration. They are widely used for hedging and speculative purposes. Options are traded both on exchanges and in OTC markets.\nOptions provide strategic flexibility for investors, as they allow for various trading strategies, including covered calls, protective puts, straddles, and spreads. The pricing of options depends on several factors, including the price of the underlying asset, volatility, time to expiration, interest rates, and dividends. The Black-Scholes model and binomial tree model are widely used for option pricing.\nThe versatility of options allows investors to construct positions that range from conservative hedging strategies to highly speculative trades. For example, covered call strategies can generate income in sideways markets, while long straddles can profit from significant price swings in either direction.\n\n\nSwaps\nSwaps involve the exchange of cash flows based on different financial instruments. The most common types include interest rate swaps, currency swaps, and credit default swaps (CDS). Swaps are mainly traded in OTC markets and are primarily used for hedging risks associated with fluctuating interest rates and currency values.\nInterest rate swaps, for instance, allow two parties to exchange fixed and floating interest rate payments, enabling companies to manage interest rate exposure. Currency swaps help multinational corporations hedge against exchange rate fluctuations. Credit default swaps played a crucial role in the 2008 financial crisis, as they were used to transfer credit risk between financial institutions.\nSwaps have evolved to become sophisticated financial tools, providing tailored risk management solutions. However, their complexity also necessitates rigorous risk assessment and regulatory oversight to prevent systemic risks.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroDerivatives.html#historical-evolution-of-derivative-securities",
    "href": "Chapter_IntroDerivatives.html#historical-evolution-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "1.2 Historical Evolution of Derivative Securities",
    "text": "1.2 Historical Evolution of Derivative Securities\nThe origins of derivative securities date back to ancient civilizations. The first recorded derivatives can be traced to Mesopotamian grain contracts and ancient Greek olive oil options. Modern derivatives markets evolved significantly in the 20th century:\n\nChicago Board of Trade (CBOT) was established in 1848, marking the beginning of organized futures trading.\nChicago Mercantile Exchange (CME) introduced financial futures in the 1970s, expanding the scope of derivatives markets.\nBlack-Scholes Model (1973) provided a theoretical framework for option pricing, revolutionizing derivatives trading and making options more accessible.\nGrowth of OTC Markets in the late 20th and early 21st centuries expanded the use of swaps and structured derivatives, allowing institutions to tailor risk management solutions.\n\nThe rapid expansion of derivatives markets has been driven by advancements in financial engineering, technology, and increased globalization. However, the complexity of these instruments has also led to significant regulatory challenges and financial crises, necessitating increased oversight and risk management practices.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroDerivatives.html#trading-of-derivative-securities",
    "href": "Chapter_IntroDerivatives.html#trading-of-derivative-securities",
    "title": "1  Derivative Securities",
    "section": "1.3 Trading of Derivative Securities",
    "text": "1.3 Trading of Derivative Securities\n\nExchange-Traded Derivatives\nThese derivatives are traded on regulated exchanges such as the CME, NYSE Euronext, and Intercontinental Exchange (ICE). Exchange-traded derivatives are standardized and cleared through central counterparties, reducing counterparty risk. The standardization ensures price transparency and facilitates liquidity, making these markets highly efficient.\n\n\nOver-the-Counter (OTC) Derivatives\nOTC derivatives are privately negotiated contracts between two parties, offering greater customization but higher counterparty risk. Common OTC derivatives include forward contracts, swaps, and exotic options. The flexibility of OTC markets allows financial institutions to create tailored risk management solutions, but the lack of centralized clearing increases default risk.\nThe growth of electronic trading platforms and regulatory reforms has transformed the OTC derivatives market, improving transparency and reducing systemic risks.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroDerivatives.html#size-of-the-derivatives-market",
    "href": "Chapter_IntroDerivatives.html#size-of-the-derivatives-market",
    "title": "1  Derivative Securities",
    "section": "1.4 Size of the Derivatives Market",
    "text": "1.4 Size of the Derivatives Market\nThe global derivatives market is one of the largest financial markets. According to estimates from the Bank for International Settlements (BIS), the notional value of outstanding derivatives contracts exceeded $667 trillion at the end of 2023, with interest rate derivatives accounting for approximately $530 trillion and foreign exchange derivatives reaching $118 trillion. (BIS Report)\nThe rapid expansion of derivatives markets highlights their importance in global finance, but it also underscores the need for sound risk management practices.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Derivative Securities</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html",
    "href": "Chapter_IntroOptions.html",
    "title": "2  Options Markets",
    "section": "",
    "text": "2.1 Option Basics\nOptions are among the most actively traded financial instruments in the world, with billions of contracts changing hands annually across global exchanges. These versatile contracts provide investors with tools for speculation, hedging, and income generation that are impossible to replicate with assets and bonds alone.\nThis chapter provides an introduction to the mechanics and motives for trading options. Recall from Chapter 1 that a call option is the right to buy an underlying asset at a fixed price called the strike or strike price. Symmetrically, a put option is the right to sell an underlying asset at the strike price. The underlying asset can be a stock, index, exchange-traded fund (ETF), commodity, or other financial instrument. The buyer of an option pays the seller upfront for the right to exercise the option later, at the buyer’s discretion.\nOptions have a finite lifetime, with each contract specifying an expiration date. Most exchange-traded options can be exercised at any time prior to expiration (American options), while others can only be exercised at the expiration date (European options). Despite their names, both types trade on exchanges worldwide.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#option-basics",
    "href": "Chapter_IntroOptions.html#option-basics",
    "title": "2  Options Markets",
    "section": "",
    "text": "Key Options Terminology\n\n\n\n\nPremium: The price paid to buy an option (like an insurance premium)\nStrike Price: The fixed price at which the option can be exercised\nExpiration Date: When the option contract ends\nExercise: Using the right granted by the option\nUnderlying Asset: The financial instrument (stock, index, etc.) that the option is based on\nContract Size: Most equity options represent 100 shares of the underlying stock\n\n\n\n\nRights, Obligations, and Motivations\nAn option buyer pays the premium upfront. Subsequently, the buyer has rights (they can choose whether to exercise the option) but they have no obligations. The maximum loss of an option buyer is the option premium. On the other hand, option sellers receive the premium upfront but subsequently they have obligations: they must fulfill the contract if the option is exercised. They face potentially unlimited losses (especially for calls). The motivation for buying an option can be to speculate on the underlying asset price or it can be to hedge an existing risk. The motivation for selling an option is always to receive the option premium.\nIn more detail, the motivations for trading options are:\n\nSpeculation and Leverage: One motive for buying options is to speculate on price movements with higher leverage than direct ownership of the underlying asset. A small price change in the underlying can produce large percentage changes in option value, amplifying both potential gains and losses.\nHedging and Insurance: Options serve as insurance contracts for existing positions. For example, owning a protective put on your stock holdings limits downside risk, much like buying car insurance protects against accident costs. The option premium represents the insurance cost for this protection.\nIncome Generation: Option sellers collect premiums upfront, similar to insurance companies collecting policy premiums. However, this income comes with obligations and potential risks if the market moves against the seller’s position.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#trading-options-on-exchanges",
    "href": "Chapter_IntroOptions.html#trading-options-on-exchanges",
    "title": "2  Options Markets",
    "section": "2.2 Trading Options on Exchanges",
    "text": "2.2 Trading Options on Exchanges\nOptions are actively traded on organized exchanges and also arranged as private contracts (called over-the-counter or OTC). Exchange-traded options offer standardized contracts with transparent pricing, while OTC options can be customized but involve counterparty risk.\nMost option positions on exchanges are closed before expiration through offsetting trades rather than exercise. This allows traders to capture profits, limit losses, or adjust strategies as market conditions change.\n\nStrikes and Maturities\nExchanges determine which strike prices and expiration dates are available for trading. As time passes and options expire, new expiration cycles are introduced. New strike prices are also added when the underlying price moves, ensuring strikes bracket the current market price. The number of available strikes and expirations depends on trading interest and exchange policies.\n\n\nOrder Types and Execution\nAs in stock markets, traders can submit either market orders or limit orders. Market orders execute immediately “at market,” which is explained below. Limit orders are price-contingent orders. A limit buy order specifies a maximum price the trader is willing to pay, and a limit sell order specifies a minimum price the trader is willing to accept. A limit order can execute immediately if someone else is willing to take the other side. Otherwise, it joins the queue of limit orders and will eventually execute against an incoming market order when and if the limit price becomes the best available price for the counterparty (the highest price among limit buy orders or the lowest price among limit sell orders) and when it achieves time priority among other limit orders at the same price (i.e., it was the first to arrive).\nFor an option sell order, trading “at market” means trading at the highest limit buy price in the market. This is the best price, from the seller’s point of view, that other traders are bidding for the option, and it is called the bid price. For an option buy order, trading at market means trading at the lowest limit sell price in the market. This is the best price that other traders are asking for the option, and it is called the ask price. In summary,\n\nMarket Orders execute immediately at the best available price:\n\nMarket buy order → executes at the ask price\nMarket sell order → executes at the bid price\n\nLimit Orders specify a maximum buy price or minimum sell price:\n\nMay get better execution price but risks non-execution\n\nExample: If you want to buy a call option trading at bid $2.50 / ask $2.60:\n\nMarket order: Pay $2.60 immediately\n\nLimit order at $2.55: Wait for seller willing to accept $2.55 (may never happen)\nLimit order at $2.40: Less likely to execute than a limit order at $2.55\n\n\n\n\nOpen Interest and Contract Creation\nWe say that an option buyer has a long position, and an option seller has a short position. Unlike stocks, options have no pre-existing supply. At any time, the number of long positions exactly equals the number of short positions, and this total is called open interest. When a new option series (specific strike/expiration combination) is introduced, open interest starts at zero. Options are created through trading activity:\n\nFirst trade: 1 buyer + 1 seller → Open interest = 1\nNew position created: New buyer + New seller → Open interest increases\n\nPosition closed: Existing holder sells to new buyer → Open interest unchanged\nBoth parties close: Existing buyer and seller offset → Open interest decreases\n\n\n\nThe Role of the Clearinghouse\nExchange clearinghouses serve as the counterparty to every options trade, providing several crucial functions:\n\nCounterparty Guarantee:\n\nLong call holders have the right to buy from the clearinghouse (not from the original seller)\nShort call writers have an obligation to deliver to the clearinghouse (if assigned)\nLikewise, long put holders have the right to sell to the clearinghouse (not from the original seller) and short put writers have an obligation to buy from the clearinghouse (if assigned)\nThis eliminates counterparty risk for traders\n\nExercise and Assignment Process:\n\nOption holder notifies broker of exercise decision\nBroker notifies clearinghouse\n\nClearinghouse randomly selects a short position for assignment\nUnderlying shares and strike payment flow through clearinghouse\n\nMargin:\n\nOption sellers must post collateral (margin) to ensure they can meet their obligations.\nThis protects the clearinghouse from default risk.\n\nBenefits of the Clearinghouse System:\n\nReduced counterparty default risk for all market participants\nAbility to close positions by making trades with different traders than your original counterparty",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#patterns-in-option-prices",
    "href": "Chapter_IntroOptions.html#patterns-in-option-prices",
    "title": "2  Options Markets",
    "section": "2.3 Patterns in Option Prices",
    "text": "2.3 Patterns in Option Prices\nFigure 2.1 allows us to browse current market data for exchange-traded options. The columns of the table are:\n\nStrike: the price at which the owner of a call (put) has the right to buy (sell) the underlying asset.\nBid price: the price that a market sell order will pay (it is the best price that limit orders are bidding for the option)\nAsk price: the price that a price buy order will pay (it is the best price that limit orders are asking for the option)\nLast price: the last price at which the option traded.\nTime of last trade: the day and time at which the option last traded.\nVolume: the number of contracts traded during the day. Each contract is for 100 shares of the underlying asset.\nOpen interest: The number of contracts for which there are currently outstanding positions.\n\n\n\n\n\n\n\n\nFigure 2.1: The options market data is from the CBOE and is proivided courtesy of Yahoo Finance. Hover over the table to reveal a vertical slider.\n\n\n\nExperimenting with Figure 2.1 reveals consistent patterns in how options are priced relative to each other. Understanding these patterns helps build intuition about option values. We should see the following:\n\nStrike Price Effects:\n\nCall Options: Prices decrease as strike prices increase. For example, a call with strike $50 is worth more than a call with strike $100, so it trades at a higher premium.\nPut Options: Prices increase as strike prices increase. For example, a put with strike $100 is worth more than a put with strike $50, so it trades at a higher premium.\n\nTime to Expiration Effects: Longer-dated options cost more because they provide:\n\nMore time for favorable price movements\nGreater flexibility (American options can be exercised over a longer period)",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#intrinsic-value-time-value-and-moneyness",
    "href": "Chapter_IntroOptions.html#intrinsic-value-time-value-and-moneyness",
    "title": "2  Options Markets",
    "section": "2.4 Intrinsic Value, Time Value, and Moneyness",
    "text": "2.4 Intrinsic Value, Time Value, and Moneyness\nThe intrinsic value of an option is what the option would be worth if it had to be exercised immediately or would expire. For a call option, this is the difference between the underlying asset price and the strike of the call, if that is positive, and is zero otherwise. Letting \\(S\\) denote the price of the underlying asset and \\(K\\) the strike price, the intrinsic value of a call is\n\\[\\begin{cases} S-K & \\text{if $S&gt;K$}\\\\\n0 & \\text{if $S \\le K$}\\end{cases}\\,.\\]\nThis can be written more compactly as \\(\\max(S-K, 0)\\). For example, if the underlying asset is trading at $50, and the strike is $40, then the intrinsic value is $10. This reflects the fact that we could pay $10 for the option, pay the strike of $40 to exercise, then sell the underlying asset in the market for $50 and break even. Symmetrically, the intrinsic value of a put option is\n\\[\\max(K-S, 0) =\n\\begin{cases} K-S & \\text{if $K&gt;S$}\\\\\n0 & \\text{if $K \\le S$}\\end{cases}\\,.\\]\nIf the intrinsic value of an option is positive, then the option is said to be in the money. Thus, a call option with strike \\(K\\) is in the money if \\(S&gt;K\\), and a put option with strike \\(K\\) is in the money if \\(S&lt;K\\). If \\(S=K\\) (or, in practice, approximately equal), then a call is said to be at the money. If an option is neither in the money nor out of the money, then it is out of the money.\nAmerican options are always worth at least their intrinsic values, because exercising immediately is a possibility. If one could buy an in-the-money American option at less than its intrinsic value, then buying it and immediately exercising would be an arbitrage opportunity. It is safe to assume we will not find such arbitrage opportunities in the market.\nPrior to expiration, the value of an option is usually larger than its intrinsic value. This is because there is time remaining for the underlying asset to move in a direction that is favorable for the option holder. The excess of the value over the intrinsic value is called the option’s time value. As time passes and the option approaches expiration, the time value decreases. This phenomenon is called time decay.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#payoff-and-profit-diagrams",
    "href": "Chapter_IntroOptions.html#payoff-and-profit-diagrams",
    "title": "2  Options Markets",
    "section": "2.5 Payoff and Profit Diagrams",
    "text": "2.5 Payoff and Profit Diagrams\nUnderstanding option payoffs is fundamental to options trading. A payoff diagram shows the intrinsic value of an option position as a function of the price of the underlying asset. This is the value the option position would have at expiration. A profit diagram shows the profit from putting on an option position and holding to maturity as a function of the price of the underlying asset at maturity. The difference between the profit and the payoff is the premium paid (for long positions) or received (for short positions). Here are the payoff and profit diagrams for each of the four basic option positions:\n\nLong Call\nA long call position benefits if the underlying asset does well. The maximum loss is limited to the premium paid, while the potential profit is unlimited. The breakeven point is at the strike price plus the premium.\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\n\n# Parameters\nK = 100  # Strike price\npremium = 5  # Option premium\nS = np.concatenate([np.linspace(0, K, 50), np.linspace(K, 140, 50)])[:-1]  # Include 0 and strike price\n\n# Long call payoff and profit\ncall_payoff = np.maximum(S - K, 0)\ncall_profit = call_payoff - premium\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=call_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=call_profit,\n    mode='lines',\n    name='Profit or Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\n# Add vertical line at x=0 (y-axis)\n# fig.add_vline(x=0, line_dash=\"solid\", line_color=\"black\", line_width=1)\n\n# Formatting\nfig.update_layout(\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Payoff or Profit ($)\",\n    template=\"plotly_white\",\n    autosize=True,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.2: Payoff and profit diagrams of a long call position (buying a call option), assuming the call premium was $5.00.\n\n\n\n\n\n\nLong Put\nA long put position benefits when the underlying asset does poorly. Like a long call, the maximum loss is the premium paid. Unlike a long call, the maximum profit of a long put is limited, but it is limited only by the fact that the underlying asset price cannot fall below zero. The breakeven point is at the strike price minus the premium.\n\n\nCode\n# Long put payoff and profit\nput_payoff = np.maximum(K - S, 0)\nput_profit = put_payoff - premium\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=put_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=put_profit,\n    mode='lines',\n    name='Profit or Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Payoff or Profit ($)\",\n    template=\"plotly_white\",\n    autosize=True,\n    height=400,\n    legend=dict(x=0.2, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.3: Payoff and profit diagrams of a long put position (buying a put option), assuming the put premium was $5.00.\n\n\n\n\n\n\nShort Call\nA short call position (writing a call) benefits if the underlying asset does poorly, like a long put. However, the potential profit and loss of a short call are very different from those of a long put. The maximum profit is the premium received, while the potential loss is unlimited.\n\n\nCode\n# Short call payoff and profit (opposite of long call)\nshort_call_payoff = -call_payoff\nshort_call_profit = premium - call_payoff\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=short_call_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=short_call_profit,\n    mode='lines',\n    name='Profit or Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Payoff or Profit ($)\",\n    template=\"plotly_white\",\n    autosize=True,\n    height=400,\n    legend=dict(x=0.02, y=0.8, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.4: Payoff and profit diagrams of a short call position (writing a call option), assuming the call premium was $5.00.\n\n\n\n\n\n\nShort Put\nA short put position (writing a put) benefits if the underlying asset does well, like a long call. But, the profit and loss possibilities for a short put are very different from those of a long call. The maximum profit is the premium received, while the maximum loss occurs if the underlying asset price falls to zero (loss = strike price - premium).\n\n\nCode\nshort_put_payoff = -put_payoff\nshort_put_profit = premium - put_payoff\n\nfig = go.Figure()\n\n# Add payoff line\nfig.add_trace(go.Scatter(\n    x=S, y=short_put_payoff,\n    mode='lines',\n    name='Payoff at Expiration',\n    line=dict(color='blue', width=2)\n))\n\n# Add profit line\nfig.add_trace(go.Scatter(\n    x=S, y=short_put_profit,\n    mode='lines',\n    name='Profit or Loss',\n    line=dict(color='red', width=2, dash='dash')\n))\n\n# Add strike price line\nfig.add_vline(x=K, line_dash=\"dot\", line_color=\"gray\",\n              annotation_text=f\"Strike = ${K}\")\n\nfig.update_layout(\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Payoff orProfit ($)\",\n    template=\"plotly_white\",\n    autosize=True,\n    height=400,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.5: Payoff and profit diagrams of a short put position (writing a put option), assuming the put premium was $5.00.\n\n\n\n\n\n\nSummary of Basic Option Positions\nThe four basic option positions can be summarized as follows:\n\n\n\n\n\n\n\n\n\n\nPosition\nMarket View\nMax Profit\nMax Loss\nBreakeven\n\n\n\n\nLong Call\nBullish\nUnlimited\nPremium paid\nStrike + Premium\n\n\nLong Put\nBearish\nStrike - Premium\nPremium paid\nStrike - Premium\n\n\nShort Call\nBearish\nPremium received\nUnlimited\nStrike + Premium\n\n\nShort Put\nBullish\nPremium received\nStrike - Premium\nStrike - Premium\n\n\n\nThese basic positions form the building blocks for more complex option strategies such as spreads, straddles, and collars.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#option-portfolios",
    "href": "Chapter_IntroOptions.html#option-portfolios",
    "title": "2  Options Markets",
    "section": "2.6 Option Portfolios",
    "text": "2.6 Option Portfolios\nIndividual options can be combined with each other and with the underlying asset to create portfolios with specific risk-reward profiles. These strategies allow investors to implement sophisticated views about market direction, volatility, and risk management. We examine several common option portfolios below. We present the payoff diagram for each.\nThe payoff of a portfolio is the sum of the payoffs of its constituent positions. Frequently, an easy way to compute the payoff diagram of a portfolio is to add the payoffs at a single point on the \\(x\\)-axis (the origin is often a good place to start) and then add the slopes of the individual positions. For example, if the sum of the slopes is \\(+1\\), then the portfolio payoff diagram will slope upwards, one-for-one with the underlying asset price. If the sum of the slopes is zero, then the portfolio payoff will be flat; if the sum of the slopes is \\(-1\\), then the portfolio payoff diagram will slope downwards, one-for-one with the underlying asset price. In each figure, we show the payoffs of the individual positions and the combined portfolio payoff.\n\nProtective Put\nA protective put combines a long position in the underlying asset with a long put option. The protective put acts like insurance for a long position in the underlying asset. The value of the portfolio at maturity is always at least the put strike price, because the asset can be delivered in exchange for the strike by exercising the put. This strategy provides downside protection while maintaining upside potential.\n\n\nCode\n# Parameters for all strategies\nS0 = 100  # Current asset price\nK_put = 95   # Put strike\nK_call = 105 # Call strike (for other strategies)\nput_premium = 3\ncall_premium = 2\n\nS = np.arange(161)\n# Protective put: Long asset + Long put\nasset_payoff = S  # asset value at maturity\nput_payoff = np.maximum(K_put - S, 0)  # Put payoff at maturity\nprotective_put_payoff = asset_payoff + put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=asset_payoff, mode='lines', \n                        name='Long Underlying Asset', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=put_payoff, mode='lines', \n                        name='Long Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=protective_put_payoff, mode='lines', \n                        name='Protective Put', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_put, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Put Strike = ${K_put}\")\n\n# Add vertical line at x=0 (y-axis)\nfig.add_vline(x=0, line_dash=\"solid\", line_color=\"black\", line_width=1)\n\nfig.update_layout(\n    title=\"Protective Put Strategy\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.6: Payoff diagram of a protective put position (long the underlying asset and long a put option).\n\n\n\n\n\n\nSelling Covered Calls\nA common option strategy is to sell an out-of-the-money call option on an asset that one owns. This is called selling a covered call (the risk exposure from writing the call is “covered” by owning the underlying asset).Selling a covered call generates premium income, at the expense of reducing the maximum gain on the asset (it is capped at the call strike). Whether this turns out to be profitable depends on how high the underlying goes prior to the option maturity - if it goes up sufficiently far, then the trader will regret having sold the call; if it goes up less, or doesn’t go up at all, then the trader will be happy to have captured the call premium.\n\n\nCode\ncall_payoff = np.maximum(S - K_call, 0)  # \ncovered_call_payoff = asset_payoff - call_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=asset_payoff, mode='lines', \n                        name='Long Underlying Asset', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=-call_payoff, mode='lines', \n                        name='Short Call', line=dict(color='orange', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=covered_call_payoff, mode='lines', \n                        name='Covered Call', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_call, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Call Strike = ${K_call}\")\n\nfig.update_layout(\n    title=\"Covered Call Strategy\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.7: Payoff diagram of a covered call position (long the underlying asset and short a call option).\n\n\n\n\n\n\nCollar\nA collar combines a protective put with selling a covered call. This strategy provides downside protection and pays for some or all of the protection by capping the upside potential. The portfolio value is limited to a minimum of the put strike and a maximum of the call strike, regardless of how far the underlying asset price moves. If the premium received from the call that is sold equals (or, in practice, is approximately equal to) the premium paid for the put, then the collar is called a zero-cost collar.\n\n\nCode\n# Collar: Long asset + Long put + Short call\ncall_payoff = -np.maximum(S - K_call, 0)  # Short call payoff at maturity\ncollar_payoff = asset_payoff + put_payoff + call_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=asset_payoff, mode='lines', \n                        name='Long Underlying Asset', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=put_payoff, mode='lines', \n                        name='Long Put', line=dict(color='green', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=call_payoff, mode='lines', \n                        name='Short Call', line=dict(color='orange', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=collar_payoff, mode='lines', \n                        name='Collar', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_put, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Put Strike = ${K_put}\",\n              annotation_position=\"top left\")\nfig.add_vline(x=K_call, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Call Strike = ${K_call}\")\n\nfig.update_layout(\n    title=\"Collar Strategy\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black',\n    yaxis_range=[-50, 200]\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.8: Payoff diagram of a collar (long the underlying asset, long a put option, and short a call option at a higher strike).\n\n\n\n\n\n\nBull Call Spread\nA profit diagram is derived from a payoff diagram by subtracting the premium paid for each long position and adding the premium received for each short position. There is a simple rule for determining from the payoff diagram whether the net premium is positive or negative. If the payoff diagram lies entirely at or above the \\(x\\)-axis, then a net premium must be paid to put on the position. Otherwise there would be an arbitrage opportunity. Thus, the profit diagram lies below the payoff diagram (and goes below the \\(x\\) axis into negative territory somewhere) if the payoff is always greater than or equal to zero. Symmetrically, the profit diagram lies above the payoff diagram (and goes above the \\(x\\)-axis into positive territory) if the payoff is always less than or equal to zero.\nA bull call spread involves buying a call option and selling another call option with a higher strike price. This strategy profits from moderate upward price movements. Because the payoff diagram lies above the \\(x\\)-axis, we know that a net premium is paid to put on the position. In fact, the call with a higher strike that is sold will be cheaper than the call with a lower strike that is bought, and the investor will have to pay the difference to put on the position. Remember that the purpose of selling options is always to receive the premium income. In this case, the call with the higher strike is sold to partially offset the cost of the call with the lower strike. Consequently, a bull call spread is a relatively low cost bet on the upside of an asset.\n\n\nCode\n# Bull call spread parameters\nK_low = 95   # Lower strike (long call)\nK_high = 105 # Higher strike (short call)\nlow_call_premium = 7\nhigh_call_premium = 3\n\n# Bull call spread: Long low-strike call + Short high-strike call\nlong_call_payoff = np.maximum(S - K_low, 0)  # Long call payoff at maturity\nshort_call_payoff = -np.maximum(S - K_high, 0)  # Short call payoff at maturity\nbull_spread_payoff = long_call_payoff + short_call_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=long_call_payoff, mode='lines', \n                        name=f'Long {K_low} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=short_call_payoff, mode='lines', \n                        name=f'Short {K_high} Call', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=bull_spread_payoff, mode='lines', \n                        name='Bull Call Spread', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_low, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low Strike = ${K_low}\",\n              annotation_position=\"top left\")\nfig.add_vline(x=K_high, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High Strike = ${K_high}\")\n\nfig.update_layout(\n    title=\"Bull Call Spread\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.9: Payoff diagram of a bull call spread (long a call and short a call at a higher strike).\n\n\n\n\n\n\nBear Put Spread\nA bear put spread involves buying a put option and selling another put option with a lower strike price. This strategy profits from moderate downward price movement. The motivation for putting on a bear spread is the desire to own a put either for protection (i.e., hedging/insurance) or as a bet on the downside of an asset. This protection or bet is provided by the put with the higher strike. The put with the lower strike is sold to reduce the cost of the bet. As with a bull call spread, the payoff is always nonnegative, so there must be a net premium paid to put it on (the put that is sold will have a lower price than the put that is bought, so the trader must pay the difference).\n\n\nCode\n# Bear put spread: Long high-strike put + Short low-strike put\nhigh_put_premium = 8\nlow_put_premium = 4\n\nlong_put_payoff = np.maximum(K_high - S, 0)  # Long put payoff at maturity\nshort_put_payoff = -np.maximum(K_low - S, 0)  # Short put payoff at maturity\nbear_spread_payoff = long_put_payoff + short_put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=long_put_payoff, mode='lines', \n                        name=f'Long {K_high} Put', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=short_put_payoff, mode='lines', \n                        name=f'Short {K_low} Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=bear_spread_payoff, mode='lines', \n                        name='Bear Put Spread', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_low, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low Strike = ${K_low}\",\n              annotation_position=\"top left\")\nfig.add_vline(x=K_high, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High Strike = ${K_high}\")\n\nfig.update_layout(\n    title=\"Bear Put Spread\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.77, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.10: Payoff diagram of a bear put spread (long a put and short a put at a lower strike).\n\n\n\n\n\n\nStraddle\nA straddle involves buying both a call and a put option with the same strike price. This strategy profits from large price movements in either direction (high volatility). The profit diagram lies below the payoff diagram and will be in negative territory if the underlying finishes near the straddle strike.\n\n\nCode\n# Straddle: Long call + Long put (same strike)\nK_straddle = 100\nstraddle_call_premium = 5\nstraddle_put_premium = 5\n\nstraddle_call_payoff = np.maximum(S - K_straddle, 0)  # Call payoff at maturity\nstraddle_put_payoff = np.maximum(K_straddle - S, 0)  # Put payoff at maturity\nstraddle_payoff = straddle_call_payoff + straddle_put_payoff\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=straddle_call_payoff, mode='lines', \n                        name=f'Long {K_straddle} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=straddle_put_payoff, mode='lines', \n                        name=f'Long {K_straddle} Put', line=dict(color='green', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=straddle_payoff, mode='lines', \n                        name='Long Straddle', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_straddle, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Strike = ${K_straddle}\")\n\nfig.update_layout(\n    title=\"Long Straddle\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.6, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black',\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.11: Payoff diagram of a straddle (long a call and put with the same strike).\n\n\n\n\n\n\nButterfly Spread\nA butterfly spread involves buying options at two different strike prices and selling two options at a strike price midway between the other two strikes. This strategy profits when the underlying asset price stays near the middle strike (low volatility). As with the other spreads we have examined, the payoff is nonnegative, so the trader must pay a net premium to put the position on.\n\n\nCode\n# Butterfly spread parameters\nK_low_bf = 90\nK_mid_bf = 100\nK_high_bf = 110\nlow_call_bf_premium = 12\nmid_call_bf_premium = 6\nhigh_call_bf_premium = 2\n\n# Butterfly: Long low call + Short 2 middle calls + Long high call\nbf_low_call = np.maximum(S - K_low_bf, 0)  # Long low call payoff at maturity\nbf_mid_call = -2 * np.maximum(S - K_mid_bf, 0)  # Short 2 middle calls payoff at maturity\nbf_high_call = np.maximum(S - K_high_bf, 0)  # Long high call payoff at maturity\nbutterfly_payoff = bf_low_call + bf_mid_call + bf_high_call\n\nfig = go.Figure()\n\n# Individual components\nfig.add_trace(go.Scatter(x=S, y=bf_low_call, mode='lines', \n                        name=f'Long {K_low_bf} Call', line=dict(color='blue', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=bf_mid_call, mode='lines', \n                        name=f'Short 2x {K_mid_bf} Calls', line=dict(color='green', dash='dot')))\nfig.add_trace(go.Scatter(x=S, y=bf_high_call, mode='lines', \n                        name=f'Long {K_high_bf} Call', line=dict(color='orange', dash='dot')))\n\n# Combined strategy\nfig.add_trace(go.Scatter(x=S, y=butterfly_payoff, mode='lines', \n                        name='Butterfly Spread', line=dict(color='red', width=3)))\n\nfig.add_vline(x=K_low_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Low = ${K_low_bf}\",\n              annotation_position=\"top left\")\nfig.add_vline(x=K_mid_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"Mid = ${K_mid_bf}\",\n              annotation_position=\"left\")\nfig.add_vline(x=K_high_bf, line_dash=\"dot\", line_color=\"gray\", \n              annotation_text=f\"High = ${K_high_bf}\",\n              annotation_position=\"bottom right\")\n\nfig.update_layout(\n    title=\"Butterfly Spread\",\n    xaxis_title=\"Underlying Asset Price at Expiration ($)\",\n    yaxis_title=\"Portfolio Value ($)\",\n    template=\"plotly_white\", \n    height=400,\n    autosize=True,\n    legend=dict(x=0.02, y=0.98, xanchor='left', yanchor='top'),\n    yaxis_zeroline=False,\n    xaxis_zeroline=True,\n    xaxis_zerolinecolor='black'\n)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 2.12: Payoff diagram of a butterfly spread (long a call at a low strike, short two calls at a middle strike, and long a call at a high strike, with the middle strike being the average of the low and high strikes.).\n\n\n\n\n\n\nInteractive Portfolio Builder\nThe strategies shown above represent just a few of the many possible option combinations. The interactive figure below allows you to experiment with option portfolios. The value at maturity of a portfolio of options is plotted, assuming all of the options have the same maturity. Enter positive quantities for long positions in options and negative quantities for short positions. Long or short positions in the underlying asset can also be included. Cash means a position in a risk-free asset sufficient to deliver the specified amount of cash at the option maturity.\nTry recreating the strategies we’ve discussed above, or experiment with your own combinations to develop intuition about how option portfolios behave.\n\n\n\n\n\n\n\nFigure 2.13",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#volume-and-open-interest-patterns",
    "href": "Chapter_IntroOptions.html#volume-and-open-interest-patterns",
    "title": "2  Options Markets",
    "section": "2.7 Volume and Open Interest Patterns",
    "text": "2.7 Volume and Open Interest Patterns\nUnderstanding trading volume and open interest patterns provides insight into market behavior and liquidity in options markets. These patterns reflect how traders use options and where market activity concentrates.\n\nThe Life Cycle of Open Interest\nWhen an exchange first introduces a new option series (a specific combination of underlying asset, strike price, and expiration date), open interest starts at zero. Open interest represents the total number of outstanding option contracts that have not been closed or exercised.\nInitial Growth Phase: As traders begin to notice and trade the new option, open interest grows. Each time a new buyer purchases an option from a new seller (rather than from someone closing an existing position), open interest increases by one contract. For example:\n\nDay 1: Trader A buys 10 call contracts from Trader B → Open interest = 10\nDay 2: Trader C buys 5 call contracts from Trader D → Open interest = 15\n\nDay 3: Trader E buys 3 call contracts from Trader A (closing A’s position) → Open interest = 15 (unchanged)\n\nPeak Activity: Open interest typically reaches its peak when the option has several weeks or months remaining until expiration and the strike price is reasonably close to the current price of the underlying asset. During this phase, the option attracts both speculators and hedgers.\nDecline Phase: As expiration approaches, open interest generally declines for several reasons:\n\nTraders close positions by making offsetting trades rather than holding to expiration\nSome positions are exercised early (for American options)\nRisk managers prefer not to hold options too close to expiration due to increased time decay and volatility\n\nFinal Settlement: At expiration, remaining open interest is settled through automatic exercise (for in-the-money options) or expires worthless (for out-of-the-money options).\n\n\nWhy Out-of-the-Money Options Are Popular\nExamining Figure 2.1 reveals that trading activity and open interest are often concentrated in out-of-the-money options rather than in-the-money ones. Several factors explain this pattern:\n1. Leverage and Cost Efficiency Out-of-the-money options cost significantly less than in-the-money or at-the-money options. This lower cost provides higher leverage, allowing traders to control more shares with the same dollar investment. A trader with $1,000 might be able to buy:\n\n2 in-the-money calls at $500 each, or\n\n20 out-of-the-money calls at $50 each\n\n2. Speculative Appeal Out-of-the-money options offer the potential for large percentage returns if the underlying asset moves favorably. While the probability of profit may be lower, the potential rewards are proportionally higher, attracting speculative traders.\n3. Hedging Applications Portfolio managers often use out-of-the-money puts as portfolio insurance. These tail risk hedges provide protection against large market declines while minimizing the cost of insurance premiums.\n4. Time Value Focus Out-of-the-money options consist entirely of time value (no intrinsic value). Traders who want to bet on volatility or time decay often prefer these options because their value is most sensitive to these factors.\n\n\nObservable Patterns in Market Data\nWhen examining options market data, several consistent patterns emerge:\nStrike Price Distribution:\n\nVolume and open interest concentrate in strikes within roughly 10-20% of the current price of the underlying asset\nCall activity tends to be higher in strikes above the current price\nPut activity tends to be higher in strikes below the current price\n\nMaturity Effects:\n\nNear-term expirations (1-8 weeks) typically show the highest volume due to active trading\nLonger-term options (3+ months) may show high open interest but lower daily volume\nOptions expiring in less than a week often see volume spikes as traders close positions\n\nTime Decay Impact:\n\nOptions with strikes far from the current price show less frequent trading\nLast trade dates for these deep out-of-the-money options may be days or weeks old\nBid-ask spreads widen significantly for strikes with little trading interest\n\nThese patterns reflect the diverse motivations of options traders: speculation, hedging, income generation, and portfolio management. Understanding these patterns helps explain why certain options trade actively while others remain dormant, and why pricing and liquidity can vary dramatically across different strikes and expirations.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#put-call-parity",
    "href": "Chapter_IntroOptions.html#put-call-parity",
    "title": "2  Options Markets",
    "section": "2.8 Put-Call Parity",
    "text": "2.8 Put-Call Parity\nPut-call parity is one of the most important relationships in option pricing. It establishes a precise connection between the prices of European calls, puts, the underlying asset, and risk-free bonds. This relationship must hold to prevent arbitrage opportunities - riskless profit possibilities that would be quickly eliminated by trader activity.\n\nThe Put-Call Parity Relationship\nFor European options on assets that do not pay dividends prior to option expiry, put-call parity states that:\n\\[\\text{Cash} + \\text{Call} = \\text{Put} + \\text{Underlying}\\]\nMore precisely,\n\\[\\mathrm{e}^{-rT}K + C = P + S\\]\nwhere\n\n\\(C\\) = price of a European call option\n\\(P\\) = price of a European put option\n\n\\(S\\) = current price of the underlying asset\n\\(K\\) = strike price (same for both call and put)\n\\(r\\) = risk-free interest rate\n\\(T\\) = time to expiration\n\nThe term \\(\\mathrm{e}^{-rT}K\\) represents the present value of the strike price - the amount of cash that, when invested at the risk-free rate, will grow to exactly \\(K\\) at expiration. Here we are using continuous compounding/discounting, so \\(\\mathrm{e}^{-rT}\\) is the discount factor. This is a common and convenient way to represent discount factors when considering various fractions of a year. The appropriate discount rate for a particular period can be imputed from the yields of Treasury bonds at nearby maturities.\n\n\nUnderstanding the Economic Logic\nThe put-call parity relationship reflects the fact that two different portfolios have identical payoffs at expiration:\nPortfolio A: Cash + Call\n\nHold cash worth \\(\\mathrm{e}^{-rT}K\\) (which grows to \\(K\\) by expiration)\nOwn a call option with strike \\(K\\)\n\nPortfolio B: Put + Underlying\n\nOwn a put option with strike \\(K\\)\nOwn one share of the underlying asset\n\nLet’s examine what happens at expiration for any possible price \\(S_T\\) of the underlying asset:\n\nCase 1: Asset price at expiration \\(S_T &gt; K\\)\n\nPortfolio A: Cash grows to \\(K\\), call is worth \\(S_T - K\\), total value = \\(K + S_T - K = S_T\\). In other words, the call is exercised at expiration using the accumulated cash, so the total value is the value \\(S_T\\) of the underlying asset.\nPortfolio B: Put expires worthless, underlying asset is worth \\(S_T\\), total value = \\(0 + S_T = S_T\\)\n\nCase 2: Asset price at expiration \\(S_T \\leq K\\)\n\nPortfolio A: Cash grows to \\(K\\), call expires worthless, total value = \\(K + 0 = K\\)\nPortfolio B: Put is worth \\(K - S_T\\), underlying asset is worth \\(S_T\\), total value = \\(K - S_T + S_T = K\\). In other words, the underlying asset is delivered to exercise the put at expiration, so the total value is the strike \\(K\\).\n\n\nBecause both portfolios have identical payoffs in all possible scenarios, they must have the same current value to prevent arbitrage opportunities.\n\n\nPractical Implications\nPut-call parity has several important applications:\n1. Option Pricing: If we know the prices of a call, the underlying asset, and the risk-free rate, we can determine what the put price should be (and vice versa).\n2. Synthetic Instruments: We can create synthetic positions:\n\nSynthetic call: \\(C = P + S - K\\mathrm{e}^{-rT}\\)\n\nSynthetic put: \\(P = C - S + K\\mathrm{e}^{-rT}\\)\nSynthetic underlying: \\(S = C - P + K\\mathrm{e}^{-rT}\\)\n\n3. Conversion and Reversal Strategies: Professional traders use these synthetic relationships to identify mispriced options and construct arbitrage trades.\n\n\nImportant Limitations\nPut-call parity as stated above applies specifically to:\n\nEuropean options (cannot be exercised before expiration)\nNon-dividend-paying assets (dividends complicate the relationship)\nSame strike price and expiration for both call and put\n\nFor American options, the put-call parity relation does not always hold, and, for assets that pay dividends prior to the option’s maturity, the present value of expected dividends must be subtracted from the asset price in the parity relationship. Despite these limitations, put-call parity is one of the most reliable and useful relationships in options theory, providing a foundation for understanding option pricing and identifying trading opportunities.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#early-exercise-of-american-options",
    "href": "Chapter_IntroOptions.html#early-exercise-of-american-options",
    "title": "2  Options Markets",
    "section": "2.9 Early Exercise of American Options",
    "text": "2.9 Early Exercise of American Options\nMost exchange-traded options are American-style, meaning they can be exercised at any time before expiration. However, early exercise is not always optimal and should be considered carefully. Understanding when early exercise might be beneficial requires analyzing the trade-off between immediate payoff and the option’s remaining time value.\nAn option’s value consists of two components:\n\nIntrinsic value: The value if it were expiring now\nTime value: The additional value from the possibility of more favorable price movements before expiration\n\nEarly exercise is optimal when the value is equal to the intrinsic value alone, meaning that the time value has shrunk to zero.\n\nAmerican Calls\nFor American call options on assets that pay no dividends prior to the option maturity, early exercise is never optimal. This important result is sometimes stated as “calls are better alive than dead.” It follows from two facts:\n\nIn financial markets, as in life generally, “keeping your options open” is valuable. In other words, there is value to the flexibility that an option provides. This flexibility is lost once it is exercised.\nEarly exercise of a call means paying the strike early, which has an opportunity cost equal to the foregone interest that could be earned if the cash were held instead of being used to pay the strike.\n\nThe only time that a call should be exercised early is to capture a dividend (or other cash flow) paid by the underlying asset. Call holders do not receive dividends, so it may be optimal to exercise to avoid missing the dividend. Even in this circumstance, individual investors will generally find it better to sell the call in the market rather than exercising. However, institutional investors, who can trade at lower costs, may find it profitable to exercise. Regardless, if anyone finds it optimal to exercise, the bid price of the call must have fallen to the call’s intrinsic value, meaning the time value of the option has shrunk to zero. This typically occurs only just before an ex-dividend date, and even then the dividend must be large enough to offset the value of preserving flexibility for the remaining maturity of the option. In subsequent chapters, we will investigate models for determining how large the dividend must be.\n\n\nAmerican Puts\nIt is more likely that an American put should be exercised early than it is that an American call should be exercised early. This is because the second factor above (the time value of money for the strike) is reversed for puts. Early exercise of a put implies early receipt of the strike, which can be invested to earn interest.\nWhether it is optimal to exercise an American put early depends on how deeply in the money it is and how high interest rates are. When a put is deeply in the money (meaning the underlying asset price is low), there is little value to the flexibility of keeping the option open, because it becomes nearly certain that exercise at some date will be optimal. In this case, one should exercise to get the strike early and forego flexibility. When interest rates are high, the time value of money is high, so again it can be optimal to exercise early. Whether one should exercise early depends on both of these factors - how deeply in the money the option should be before exercising depends on how high interest rates are. The volatility of the underlying asset price is also a critical factor, because it determines the value of maintaining flexibility. Again, we will investigate models for making this determination in later chapters.\n\n\nPut-Call Parity, Option Bounds, and Early Exercise\nThe put-call parity formula for European options on non-dividend-paying assets is \\[ C + \\mathrm{e}^{-rT}K = P + S\\] Because the put value must be at least zero, this gives us the inequality \\[C + \\mathrm{e}^{-rT}K \\ge S \\;\\Leftrightarrow\\; C \\ge S - \\mathrm{e}^{-rT}K &gt; S - K\\,.\\] Thus, we can see that the value of a European call on a non-dividend-paying asset must be strictly greater than the intrinsic value. Because American calls are worth at least as much as their European counterparts, the value of an American call on a non-dividend-paying asset must also be strictly greater than its intrinsic value and hence should not be exercised early.\nThe “strictly greater” rather than “greater than or equal to” is due to the time value of money, as encapsulated in the fact that \\(\\mathrm{e}^{-rT}K &lt; K\\). This is factor #2 described above as to why American calls on non-dividend-paying assets should never be exercised early.\nBecause call values are also at least zero, we can likewise obtain an inequality for put values from put-call parity, namely, \\[\\mathrm{e}^{-rT}K \\le P + S \\; \\Leftrightarrow \\; P \\ge \\mathrm{e}^{-rT}K - S\\,.\\] Put-call parity is for European options, but, because American options are worth at least as much as European options, this inequality also holds for American options on non-dividend-paying assets. However, this does not tell us that early exercise of American puts is suboptimal, because, as discussed before, the time value of money operates in reverse fashion for puts compared to calls (the present value of the strike appears with a positive sign on the right-hand side of the inequality for puts but with a negative sign for calls). In fact, it is possible that \\[K - S = P &gt; \\mathrm{e}^{-rT}K-S\\,.\\] In this circumstance, the time value of the put has shrunk to zero, and early exercise is optimal.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroOptions.html#exercises",
    "href": "Chapter_IntroOptions.html#exercises",
    "title": "2  Options Markets",
    "section": "2.10 Exercises",
    "text": "2.10 Exercises\n\nExercise 2.1 As illustrated in the protective put, covered call, and collar examples, a long position in one unit of the underlying asset has a payoff diagram equal to the 45-degree line. Symmetrically, a short position in one unit of the underlying asset has a payoff diagram equal to the negative of the 45-degree line. What option position would cap the possible loss from a short position? How would you collar a short position? Write python code to generate the payoff diagrams of these porttolios.\n\n\nExercise 2.2 The text explains a bull call spread. Using put-call parity, explain how we can obtain the same payoff diagram using puts. Write python code to generate the payoff diagrams of the bull call spread and the bull put spread.\n\n\nExercise 2.3 Repeat the previous exercise, but for a bear spread in calls and puts.\n\n\nExercise 2.4 Write python code to generate the payoff diagram of a short straddle (short call and short put with the same strike and expiration). What option positions would cap the possible losses from a short straddle? Write python code to generate the payoff diagram of the short straddle with these additional options. Using put-call parity, explain the similarity of this payoff diagram with the payoff diagram of a butterfly spread.\n\n\nExercise 2.5 Suppose you have a short position in an asset. You can protect the short position and pay for the protection by collaring the shortposition as in Exercise 2.1. There are other options that could be sold to pay for protection (options that do not create a collar). Write python code to generate the payoff diagrams of the following option portfolios combined with the short position in the underlying asset: (a) a long call and two short calls with higher strikes, (b) a short call and two long calls with higher strikes.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Options Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html",
    "href": "Chapter_IntroFutures.html",
    "title": "3  Futures Markets",
    "section": "",
    "text": "3.1 Margin and Marking to Market\nFutures contracts are among the oldest and most important derivative securities, with organized futures trading dating back centuries. These contracts are standardized agreements to buy or sell an asset at a predetermined price on a future date. The predetermined price is the price at which the trade takes place when the contract is bought by one party and sold by the other and is called the futures price. The futures price is determined by the market, like stock and option prices. Traders can submit either limit orders or market orders to buy or sell futures contracts.\nFutures trading is similar to options trading. The exchange determines the contracts that are traded. A clearinghouse stands as the counterparty to each trade, guaranteeing the fulfillment of the contract. The clearinghouse imposes margin requirements to ensure that traders have the financial wherewithal to meet their obligations. There is no pre-existing supply of futures contracts. Contracts are created by trade. The number of outstanding long contracts is always equal to the number of short contracts and is called open interest.\nA contrast between futures markets options markets is that both buyers and sellers of futures contracts have future obligations, and both parties must post margin. In options markets, only the seller of an option has a future obligation and must post margin. A related contrast is that the buyer of a futures contract does not pay the seller at the time of the trade. Instead, buyers and sellers both post margin and make gains or losses based on changes in the futures price subsequent to the trade (as is explained below).\nThe buyer of a futures contract (who is said to be long the contract) has the obligation to accept delivery of the underlying asset at the futures expiration date and to pay the futures price at which he bought the contract. The seller of a contract (who is said to be short the contract) has an obligation to deliver the underlying asset at the futures price at the futures expiration date. For example, the buyer of a corn contract will get corn and pay for it (if she does not offset the obligations by selling a contract prior to the contract’s expiration) and the seller of a corn contract will deliver corn and receive payment (if he does not offset the obligations by buying a contract prior to the contract’s expiration).\nLike options, most traders unwind positions by making offsetting trades rather than holding positions to expiration. For example, a corn farmer might sell a corn futures contract at a price of $5.00 per bushel. The farmer can deliver on the contract and receive $5.00. However, the farmer could instead sell the contract at a later date at the market futures price. Suppose for example that the spot price of corn is near $4.00 per bushel near the contract’s expiration. Then the futures price will be also be near $4.00, because a near-term futures contract is essentially a spot contract (this is called spot-futures convergence). As an alternative to delivering on the futures contract at $5.00, the farmer could instead sell the futures contract in the market at $4.00, canceling the delivery obligation. In this scenario, the farmer makes $1.00 per bushel from selling the contract at $5.00 and buying it at $4.00. The farmer can then sell her corn in the spot market for $4.00. Combined with the $1.00 profit on the futures contract, the net proceeds for the farmer are again $5.00 per bushel.\nThe delivery terms on futures contracts are standardized and specified by the exchange. The exchange designates a delivery location and a delivery date. The exchange also specifies the quantity and quality of the underlying asset that must be delivered. For some contracts, different qualities can be delivered, and there are specifications for price adjustments based on the quality. The specification of the corn futures contract on the CME gives a good sense for how this works.\nSome futures contracts are cash settled. For such contracts, there are no provisions for physical delivery. Instead, contracts that are held to expiration are settled based a formula tied to an underlying asset at the time of expiration. For example, the e-mini S&P 500 futures contract at the CME is cash settled. The contract is settled based on the value of the S&P 500 index at the time of expiration. This eliminates the need to deliver or receive delivery of the 500 stocks that make up the index. The “quantity” specification for cash settled contracts is a multiplier that determines the dollar value of a contract. The e-mini S&P 500 contract has a multiplier of 50 dollars per unit of the index.1 If someone buys a contract at a futures price of 6000 and holds to expiration and the index is at 6500 on the expiration date, then that trader makes 50 \\(\\,\\times\\,\\) (6500 - 6000) \\(\\,=\\,\\) 250,000 dollars profit on the trade.\nFutures contracts in the modern sense began trading in the United States in 1851, but cash-settled contracts did not begin trading until 1981.2 Part of the complication with introducing cash-settled contracts is that they blur the line between trading and gambling. The buyer and seller of an S&P 500 futures contract are clearly betting on how the S&P 500 index will perform. The buyer wins if the index finishes above the futures price, and the seller wins otherwise. There are other cash settled contracts that do not even involve an underlying asset. For example, there are weather contracts that are cash settled based on the number of heating degree days in a particular time frame. The distinction that has been drawn between legal trading of cash-settled futures contracts and possibly illegal gambling is that futures contracts must satisfy legitimate risk-management needs for some market participants. For example, an equity fund manager who wants to reduce her stock market exposure at a minimal trading cost can sell S&P 500 futures contracts to hedge the fund’s stock portfolio.\nOne of the most distinctive features of futures trading is the daily settlement or marking to market process. This mechanism virtually eliminates counterparty risk and enables leverage while maintaining market integrity.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html#margin-and-marking-to-market",
    "href": "Chapter_IntroFutures.html#margin-and-marking-to-market",
    "title": "3  Futures Markets",
    "section": "",
    "text": "The Daily Settlement Process\nEach trading day, the exchange establishes a settlement price (based on end-of-day transaction prices) for each futures contract. All open positions are marked to this price. The daily profit or loss on each position is calculated and immediately transferred between accounts.\nAs an example, suppose you buy one e-mini S&P 500 futures contract at 6000 and the following happens:\n\nDay 1: Settlement price = 6010 → Gain = (6010 - 6000) × $50 = $500 (credited to your account)\nDay 2: Settlement price = 5990 → Loss = (5990 - 6010) × $50 = $1,000 (debited from your account)\nDay 3: Settlement price = 6020 → Gain = (6020 - 5990) × $50 = $1,500 (credited to your account)\n\nAt the end of day 3, you have had a net sum of $1,000 credited to your account. If you close your position by selling the contract at the end of day 3, you walk away with a $1,000 gain, which is simply the increase in the futures price over the time you held the contract (6020 - 6000) times the $50 multiplier.\n\n\nMargin Requirements\nThe exchange determines a minimum amount of margin required to open a futures position. This is called the initial margin. The initial margin is typically 3-12% of the contract value. The exchange also determines a minimum (smaller) amount of margin required to keep a futures position open. This is called the maintenance margin. If the account balance falls below the maintenance margin, a margin call occurs. The margin call is a demand for additional margin to be posted to bring the account balance back to the initial margin level. If the trader fails to meet the margin call, the position will be liquidated.\nTrading a futures contract with 10% margin means being levered 10 to 1. If the futures price moves 1% against the trader, the trader will lose 10% of the margin deposit. If the futures price moves 1% in favor of the trader, the trader will gain 10% of the margin deposit. These high leverage ratios are feasible because of the marking to market process.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html#the-expectations-hypothesis",
    "href": "Chapter_IntroFutures.html#the-expectations-hypothesis",
    "title": "3  Futures Markets",
    "section": "3.2 The Expectations Hypothesis",
    "text": "3.2 The Expectations Hypothesis\nThe expectations hypothesis states that futures prices represent the market’s unbiased expectation of future spot prices. This is a simple theory of the determination of futures prices and provides a convenient way to infer investors’ beliefs about the future from currently observable prices.\nThe motivation for the hypothesis is the idea that, if the futures price were lower than the expected spot price, then traders “should” buy the futures contract and plan to sell the spot asset when delivered on the futures at maturity. This strategy has a positive expected profit when the futures price is lower than the expected spot price. This buying activity should drive up the price of the futures contract, until it converges to the expected spot price. Symmetrically, investors “should” sell the futures if its price is above the expected spot price, planning to buy the spot asset at the futures maturity to cover the delivery obligation on the futures, and this selling activity should cause the futures price to fall, until it converges to the expected spot price. Thus, in equilibrium, futures prices “should” equal the expected spot price.\nAll of the quotation marks around “should” in the previous paragraph reflect the fact that the theory presumes risk neutrality on the part of a large enough group of investors to move the futures price to the expected spot price. If investors are risk averse, then they may buy a limited quantity of the futures when its price is low relative to the expected spot price and sell a limited quantity of the futures when its price is high relative to the expected spot price, generating an expected profit as described in the previous paragraph. However, risk averse investors will weigh the expected profit against the risk, considering their other investments as well, and only allocate a limited amount of capital to the bet. This amount of capital may not be enough to move the futures price fully to the expected spot price. Empirically, futures prices seem to frequently deviate from expected spot prices in significant ways.\nFrom the general theory of asset pricing, which is developed in this book, the difference between the futures price and the expected spot price depends on the covariance of the spot price with market risk factors. For example, the Capital Asset Pricing Model asserts that it depends on the covariance of the spot price with the aggregate market return.\nDespite the presence of a risk premium, the expectations of traders regarding future spot prices are undoubtedly a prime determinant of futures prices. They are also a prime determinant of today’s spot prices. The linkage between today’s spot price and today’s futures prices is known as spot-futures parity.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html#spot-futures-parity",
    "href": "Chapter_IntroFutures.html#spot-futures-parity",
    "title": "3  Futures Markets",
    "section": "3.3 Spot-Futures Parity",
    "text": "3.3 Spot-Futures Parity\nIn contrast to the expectations hypothesis, which predicts a relationship between today’s futures price and the expected future spot price, spot-futures parity is a relationship between today’s futures price and today’s spot price. The foundation for spot-futures parity is arbitrage activity (making riskless profits) rather than making positive expected return but risky investments (as for the expectations hypothesis). The arbitrage involves either (i) buying the spot asset and simultaneously selling a futures contract, or (ii) borrowing and selling the spot asset and simultaneously buying a futures contract. The exact relationship between the spot and futures price depends on the differences between holding the underlying asset and being long a futures contract. There are four potential differences, which are normally grouped into two categories.\n\nCost of carry: The cost of carry is the cost of holding the underlying asset over a period of time. There are no costs of owning a futures contract (ignoring the margin account).\n\nOne component of the cost of carry is that holding the underlying asset ties up funds, and we incur an opportunity cost of the foregone interest that could be earned by depositing the funds instead.\n\nThere can also be significant storage costs involved in holding commodities.\n\n\nConvenience yield: There can also be advantages to owning the underlying asset. These are collectively called the convenience yield.\n\nIf the underlying asset pays dividends or other cash flows, then these are part of the “convenience” of holding the spot asset.\nFor commodities, there can be other advantages to holding the spot asset today rather than getting it in the future. These may be difficult to quantify but can be very real. For example, during a time of strained crude oil supply and elevated prices that is expected to be temporary, oil companies will not be indifferent about having crude now versus having it later.\n\n\nThe spot futures-parity formula is\n\\[F = \\mathrm{e}^{(c-y)T}S\\]\nwhere\n\n\\(F=\\,\\) futures price,\n\\(S=\\,\\) current spot price,\n\\(c=\\,\\) cost of carry expressed as a continuously compounded rate,\n\\(y=\\,\\) convenience yield expressed as a continuously compounded rate,\n\\(T=\\,\\) time to expiration.\n\n\nArbitrage When Parity Is Violated\nTo see why the formula must be true, first consider the simplest case in which there are no storage costs, no dividends or other cash flows, and no other forms of convenience yield, so the opportunity cost of foregone interest is the only factor present. In this case, \\(c=r\\), the risk-free interest rate, and \\(y=0\\).\n1. Buy spot and sell futures:\nLet’s suppose first that spot-futures parity is violated in the direction \\(F&gt;\\mathrm{e}^{rT}S\\) and see how that can be arbitraged. The arbitrage is to buy the cheaper side of the inequality and sell the more expensive side (buy low and sell high, of course). So, this means that we buy the underlying asset. We do that by borrowing \\(S\\) dollars. We simultaneously sell the futures contract at price \\(F\\). At expiration, we deliver the spot asset that we bought to fulfill the futures contract and receive \\(F\\). We will at this time owe \\(\\mathrm{e}^{rT}S\\) on the loan, and we can repay the loan and pocket the surplus \\(F-\\mathrm{e}^{rT}S\\).\n2. Sell spot and buy futures:\nNow suppose that spot-futures parity is violated in the direction \\(F&lt;\\mathrm{e}^{rT}S\\). Again, we buy low and sell high. Here, that means that we buy the futures contract and sell the underlying asset. We sell the underlying asset by borrowing it and then selling (called short selling). Later, we have to return it to whomever we borrowed it from. Because the lender will not be missing any dividend payments or other cash flows and there is no other convenience of holding the underlying asset, we assume we can cover the loan of the asset by returning the same amount that we borrowed. In practice, the lender will charge a small fee, but we ignore that here. Because we bought the futures contract, we pay \\(F\\) at maturity, accept delivery of the asset, and then deliver the asset to the lender. We earn interest on the proceeds from selling the asset, so we net \\(\\mathrm{e}^{rT}S - F\\).\nThis type of arbitraging activity will move market prices until spot-futures parity holds. It is an activity in which institutions regularly engage. It is thus safe to assume that spot-futures parity always holds to a reasonably high degree of approximation.\nThis reasoning extends directly to including storage costs, which are clearly another expense of holding the underlying asset, when such costs are nonnegligible. Likewise, dividends received or other advantages of holding the underlying asset act in the opposite direction of carrying costs and so should be subtracted from the cost of carry. This reasoning leads to the general spot-futures parity formula.\n\n\nForward Curves\nThe relationship between the contract maturity and the futures price is known as the forward curve. The spot-futures parity formula tells us that the futures price should depend on the contract maturity \\(T\\) based on the factor \\(\\mathrm{e}^{(c-y)T}\\).\nGold is an asset that has negligible storage costs, does not pay dividends, and has no other forms of convenience yield. Thus, \\(c-y\\) for gold is just the risk-free interest rate \\(r\\). Consequently, spot-futures parity for gold states that gold futures prices are higher than spot prices and increase with maturity. Figure 3.1 presents the gold forward curve at a single point in time. The upward slope reflects the fact that the future value factor \\(\\mathrm{e}^{rT}\\) is larger for larger \\(T\\).\nFor financial assets, such as stock portfolios, the only cost of carry is the interest rate, and the only convenience yield is the dividend yield. Consequently, in the spot-futures parity formula for financial assets, \\(c=r\\) and \\(r-y\\) is the difference between the interest rate and the dividend yield.\nWhether \\(r-y\\) is positive or negative determines whether futures prices are higher than spot prices (and increase with maturity) or whether the opposite is true.\nFor currency futures, the dividend yield (by which we mean in general the cash flow earned from holding the underlying asset) is the interest rate that can be earned by investing the currency. Thus, for currency futures, \\(c-y=r-r_f\\), where \\(r_f\\) is the foreign interest rate. Figure 3.1 presents the forward curves for the Japanese yen and Mexican peso at a single date. On that date, the dollar interest rate was higher than the yen interest rate - so \\(c-y&gt;0\\) and the forward curve was upward sloping - and lower than the peso interest rate - so \\(c-y&lt;0\\) and the forward curve was downward sloping. Figure 3.1 also presents the forward curve for S&P 500 futures at a time when interest rates were lower than the dividend yields on stock, so \\(c-y&lt;0\\) and the forward curve was downward sloping. When interest rates are higher, the S&P 500 forward curve is upward sloping.\n\n\nCode\nimport pandas as pd\nfrom dateutil.relativedelta import relativedelta\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndf = pd.read_csv('https://www.dropbox.com/s/832hth1es40f4g7/newfutures.csv?dl=1', index_col=0)\ndf = df[df.date&gt;='2010-01-01']\ndf.date = pd.to_datetime(df.date)\n\n# Function to add months and set day to 15th\ndef add_months_and_set_day(date, months_to_add):\n    new_date = date + relativedelta(months=int(months_to_add))\n    new_date = new_date.replace(day=15)\n    return new_date\n\n# Apply the function to create the new column\ndf['new_to_date'] = df.apply(\n    lambda row: add_months_and_set_day(row['date'], row['months past front month']), \n    axis=1\n)\ndf = df.reset_index(drop=True).set_index(['code', 'date', 'new_to_date']).settle\n\nyen = df.loc[('CME_JY', '2022-06-29')]\npeso = df.loc[('CME_MP', '2022-06-29')]\ngold = df.loc[('CME_GC', '2022-06-29')]\nsp500 = df.loc[('CME_ES', '2020-06-01')]\n\n# Create figure with 2x2 subplots with horizontal spacing\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('Gold (2022-06-29)', 'S&P 500 (2020-06-01)', \n                    'Japanese Yen (2022-06-29)', 'Mexican Peso (2022-06-29)'),\n    specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n           [{\"secondary_y\": False}, {\"secondary_y\": False}]],\n    horizontal_spacing=0.12  # Add horizontal spacing between columns\n)\n\n# Add Gold trace (top left)\nfig.add_trace(\n    go.Scatter(x=gold.index, y=gold.values, \n               name='Gold',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=1, col=1\n)\n\n# Add S&P 500 trace (top right)\nfig.add_trace(\n    go.Scatter(x=sp500.index, y=sp500.values, \n               name='S&P 500',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=1, col=2\n)\n\n# Add Yen trace (bottom left)\nfig.add_trace(\n    go.Scatter(x=yen.index, y=yen.values, \n               name='Japanese Yen',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=2, col=1\n)\n\n# Add Peso trace (bottom right)\nfig.add_trace(\n    go.Scatter(x=peso.index, y=peso.values, \n               name='Mexican Peso',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=2, col=2\n)\n\n# Update layout - set width=None for auto-sizing\nfig.update_layout(\n    height=600,\n    width=None,  # Auto-adjust width to container\n    showlegend=False,\n    autosize=True,  # Enable responsive sizing\n    template='plotly_white',  # Use plotly white template\n    margin=dict(t=60)  # Add top margin to prevent overlap with plotly icons\n)\n\n# Update axes labels with smaller font\nfig.update_xaxes(title_text=\"Maturity Date\", row=2, col=1)\nfig.update_xaxes(title_text=\"Maturity Date\", row=2, col=2)\nfig.update_yaxes(title_text=\"Futures Price\", row=1, col=1)\nfig.update_yaxes(title_text=\"\", row=1, col=2)\nfig.update_yaxes(title_text=\"Futures Price\", row=2, col=1)\nfig.update_yaxes(title_text=\"\", row=2, col=2)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 3.1: Forward curves for CME futures contracts on the dates specified.\n\n\n\n\n\n\nCommodities\nSpot-futures parity for commodities is more complex than for financial assets, because of storage costs and convenience yields. Because the convenience yield by definition is never negative, the spot-futures parity formula gives us \\(F \\leq  \\mathrm{e}^{rT}S\\), where, for commodities, \\(c\\) is the interest rate plus the storage cost rate. The difference between the futures price \\(F\\) and \\(\\mathrm{e}^{rT}S\\) depends on the convenience yield \\(y\\) and the contract maturity \\(T\\). We generally have no direct measure of the convenience yield except for this difference, so the spot-futures parity formula for commodities, while true and a useful concept, may have little predictive power. An additional complication is that storage costs are very high for some commodities, such as electricity and natural gas, which can make the upper bound \\(F \\leq \\mathrm{e}^{rT}S\\) nearly meaningless.\nAs a result of these factors, forward curves for commodities are in general more complex than forward curves for financial assets. Figure 3.2 presents forward curves for crude oil, natural gas, and corn at various dates. April 20, 2020 is the day that crude famously “went negative.” This was at the onset of the coronavirus crisis, when demand had plummeted, and storage facilities at Cushing, Oklahoma (the delivery point for the CME WTI contract) were full. Some traders were willing to pay others to get out of their obligations to accept delivery in Cushing – they sold their oil at a negative price!. To connect to our discussion, note that the extremely large positive slope of the forward curve means that \\(c-y\\) must be extremely large. This was true because storage costs were extremely high and the convenience yield was zero.\nThe crude oil forward curve was steeply downward sloping in March 2022 following the Russian invasion of Ukraine, as seen in Figure 3.2. This means that \\(c-y&lt;0\\) and large in absolute value. We can attribute this to a high convenience yield of being in possession of oil at a time when future supplies were very uncertain.\nThe forward curve for natural gas is always cyclical as seen in Figure 3.2. The initial upward sloping section in that figure reflects the high storage cost of natural gas (that is, a high \\(c\\)) The “buy spot, sell futures” arbitrage strategy described above is not an arbitrage here, because of the high storage cost of holding natural gas from summer to winter. The downward sloping segment from winter to summer reflects the high convenience yield of owning natural gas in the winter when demand and spot market prices are high. The overall slope of the natural gas forward curve in Figure 3.2 is downward, but that varies over time, depending on the convenience yield of owning natural gas at the time of the futures trading; that is, it depends on supply and demand conditions in the spot market.\nThe corn forward curve also has a cyclical pattern, as seen in Figure 3.2. The cyclical pattern is a consequence of cyclicality in the convenience yield and storage costs of corn. The convenience yield is highest in the summer before harvest, when corn is relatively scarce, and storage costs are highest after harvest, when silos are relatively full. As is the case with natural gas, the overall slope of the forward curve for corn depends on demand and supply conditions in the spot market at the time of the futures trading.\n\n\nCode\ncrude1 = df.loc[('CME_CL', '2020-04-20')]\ncrude2 = df.loc[('CME_CL', '2022-03-08')]\ngas = df.loc[('CME_NG', '2018-06-08')]\ncorn = df.loc[('CME_C', '2018-06-08')]\n\n\n# Create figure with 2x2 subplots with horizontal spacing\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('Crude Oil (2020-04-20)', 'Crude Oil (2022-03-08)', \n                    'Natural Gas (2018-06-08)', 'Corn (2018-06-08)'),\n    specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n           [{\"secondary_y\": False}, {\"secondary_y\": False}]],\n    horizontal_spacing=0.12  # Add horizontal spacing between columns\n)\n\n# Add Gold trace (top left)\nfig.add_trace(\n    go.Scatter(x=crude1.index, y=crude1.values, \n               name='Crude (2020-04-20)',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=1, col=1\n)\n\n# Add S&P 500 trace (top right)\nfig.add_trace(\n    go.Scatter(x=crude2.index, y=crude2.values, \n               name='Crude (2022-03-08)',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=1, col=2\n)\n\n# Add Yen trace (bottom left)\nfig.add_trace(\n    go.Scatter(x=gas.index, y=gas.values, \n               name='Natural Gas (2018-06-08)',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=2, col=1\n)\n\n# Add Peso trace (bottom right)\nfig.add_trace(\n    go.Scatter(x=corn.index, y=corn.values, \n               name='Corn (2018-06-08)',\n               mode='lines+markers',\n               hovertemplate='%{x|%b %Y}&lt;br&gt;Price: %{y}&lt;extra&gt;&lt;/extra&gt;'),\n    row=2, col=2\n)\n\n# Update layout - set width=None for auto-sizing\nfig.update_layout(\n    height=600,\n    width=None,  # Auto-adjust width to container\n    showlegend=False,\n    autosize=True,  # Enable responsive sizing\n    template='plotly_white',  # Use plotly white template\n    margin=dict(t=60)  # Add top margin to prevent overlap with plotly icons\n)\n\n# Update axes labels with smaller font\nfig.update_xaxes(title_text=\"Contract Date\", row=2, col=1)\nfig.update_xaxes(title_text=\"Contract Date\", row=2, col=2)\nfig.update_yaxes(title_text=\"Futures Price\", row=1, col=1)\nfig.update_yaxes(title_text=\"\", row=1, col=2)\nfig.update_yaxes(title_text=\"Futures Price\", row=2, col=1)\nfig.update_yaxes(title_text=\"\", row=2, col=2)\n\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 3.2: Forward curves for CME futures contracts on the dates specified.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html#options-on-futures",
    "href": "Chapter_IntroFutures.html#options-on-futures",
    "title": "3  Futures Markets",
    "section": "3.4 Options on Futures",
    "text": "3.4 Options on Futures\nMany exchanges trade options on futures contracts, creating a derivative on a derivative. A call option on a futures contract is the right to buy the futures contract at the strike. A put option is the right to sell the futures contract at the strike. Compared to trading options on the underlying asset, options on futures benefit from the liquidity of the futures market and the leverage present in futures. Moreover, they allow traders to avoid the issues of physical delivery and storage that are associated with options on the underlying asset.\nExercise of an option of a futures contract creates a long (for a call) or short (for a put) position in the futures contract for the party that exercises. When an option is exercised, the clearinghouse randomly selects someone who has sold the option and assigns to them the opposite contract: a short (for the seller of a call) or long (for the seller of a put) position in the futures contract. Both parties are immediately marked to market, and there are corresponding cash transfers based on the strike of the futures option and the current market futures price.\nAn example should make this clearer. Suppose a trader buys a call option on corn futures with a strike of $5.00 (per bushel). The trader later exercises the option when the corn futures price is $5.50. The trader will be assigned a long futures contract, marked to market at $5.50 and will receive in cash the $0.50 difference between the futures price and the strike price. The option writer who is selected by the clearinghouse will have $0.50 deducted from her margin account and will be assigned a short futures contract at $5.50. If they desire to do so, both the party who exercised and the option writer can trade out of their futures contracts at the market price and walk away with the $0.50 gain or loss and no further obligations.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_IntroFutures.html#footnotes",
    "href": "Chapter_IntroFutures.html#footnotes",
    "title": "3  Futures Markets",
    "section": "",
    "text": "The term “e-mini” is an historical artifact. When the S&P 500 futures contract was first introduced, it had a multiplier of $500. When the index rose, so that a contract represented a higher dollar value of stocks, this was reduced to $250. The e-mini was simultaneously traded with a multiplier of $50. Currently, the e-mini contract has the largest multiplier of any S&P 500 contract at the CME (there is another contract with a multiplier of $5, called the “micro e-mini”).↩︎\nMillo, Y., 2007, “Making Things Deliverable: The Origins of Index-Based Derivatives”, Sociological Review, vol. 55.↩︎",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Futures Markets</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html",
    "href": "Chapter_Trees.html",
    "title": "4  Binomial Tree Models",
    "section": "",
    "text": "4.1 One-Period Binomial Model\nThis chapter introduces binomial tree models for valuing derivative securities. We begin with the fundamental concepts of arbitrage pricing in a one-period model, extend to multi-period trees, and then discuss practical implementation and parameter calibration.\nWe start with the simplest possible model. A stock has price \\(S\\) today (date 0) and will have one of two possible values at date \\(t\\): either \\(S_u\\) (up state) or \\(S_d\\) (down state), where \\(S_u &gt; S_d\\). There is also a risk-free asset earning a continuously compounded rate \\(r\\).",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#one-period-binomial-model",
    "href": "Chapter_Trees.html#one-period-binomial-model",
    "title": "4  Binomial Tree Models",
    "section": "",
    "text": "Delta Hedging and Replication\nConsider a European call option with strike \\(K\\) and maturity \\(t\\). Its payoff will be \\(C_u = \\max(0, S_u - K)\\) in the up state and \\(C_d = \\max(0, S_d - K)\\) in the down state.\nThe key insight is that we can replicate the option payoff using a portfolio of the stock and risk-free asset. Let \\(\\delta\\) be the number of shares we hold. This delta is chosen so that the portfolio has the same payoff as the option in both states:\n\\[\\delta = \\frac{C_u - C_d}{S_u - S_d}\\]\nTo see why this works, consider a portfolio that holds \\(\\delta\\) shares of stock and borrows an amount \\(B\\) at the risk-free rate. The portfolio value at maturity will be: - Up state: \\(\\delta S_u - B e^{rt}\\) - Down state: \\(\\delta S_d - B e^{rt}\\)\nFor replication, we need these to equal the option payoffs: \\[\\delta S_u - B e^{rt} = C_u\\] \\[\\delta S_d - B e^{rt} = C_d\\]\nSubtracting the second equation from the first: \\[\\delta(S_u - S_d) = C_u - C_d\\]\nThis gives us our delta formula. We can solve for the borrowing amount: \\[B = e^{-rt}(\\delta S_u - C_u) = e^{-rt}(\\delta S_d - C_d)\\]\nThe initial cost of this replicating portfolio is: \\[\\text{Portfolio Cost} = \\delta S - B = \\delta S - e^{-rt}(\\delta S_u - C_u)\\]\nBy no-arbitrage, this must equal the option price.\n\n\n\n\n\n\nExample\n\n\n\n\n\nSuppose \\(S = 100\\), \\(S_u = 110\\), \\(S_d = 90\\), \\(K = 105\\), \\(r = 0.05\\), \\(t = 1\\). Then: - \\(C_u = \\max(0, 110 - 105) = 5\\) - \\(C_d = \\max(0, 90 - 105) = 0\\) - \\(\\delta = \\frac{5 - 0}{110 - 90} = 0.25\\) - \\(B = e^{-0.05}(0.25 \\times 110 - 5) = e^{-0.05} \\times 22.5 \\approx 21.43\\) - Option price \\(= 0.25 \\times 100 - 21.43 = 3.57\\)\nVerification: In the up state, the portfolio is worth \\(0.25 \\times 110 - 22.5 = 5\\), matching \\(C_u\\). In the down state, it’s worth \\(0.25 \\times 90 - 22.5 = 0\\), matching \\(C_d\\).\nThis delta hedging shows that by holding 0.25 shares and borrowing $21.43, we can perfectly replicate the option payoff.\n\n\n\n\n\nRisk-Neutral Valuation\nWe can rearrange the replication formula to express the option value as:\n\\[C = \\pi_u C_u + \\pi_d C_d\\]\nwhere the state prices are:\n\\[\\pi_u = \\frac{S - \\mathrm{e}^{-rt}S_d}{S_u - S_d}, \\quad \\pi_d = \\frac{\\mathrm{e}^{-rt}S_u - S}{S_u - S_d}\\]\nThese state prices satisfy: - \\(\\pi_u, \\pi_d &gt; 0\\) (under no-arbitrage condition \\(S_u/S &gt; \\mathrm{e}^{rt} &gt; S_d/S\\)) - \\(\\pi_u \\mathrm{e}^{rt} + \\pi_d \\mathrm{e}^{rt} = 1\\)\nThis motivates defining risk-neutral probabilities:\n\\[p_u = \\pi_u \\mathrm{e}^{rt}, \\quad p_d = \\pi_d \\mathrm{e}^{rt}\\]\nThen:\n\\[C = \\mathrm{e}^{-rt}[p_u C_u + p_d C_d]\\]\nThe option value is the discounted expected payoff under the risk-neutral probability measure. Note that:\n\\[p_u = \\frac{\\mathrm{e}^{rt} - S_d/S}{S_u/S - S_d/S}\\]",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#two-period-model",
    "href": "Chapter_Trees.html#two-period-model",
    "title": "4  Binomial Tree Models",
    "section": "4.2 Two-Period Model",
    "text": "4.2 Two-Period Model\nNow consider a two-period model where the stock price evolves over two time steps of length \\(\\Delta t = t/2\\). To simplify notation and ensure the tree recombines, we parameterize the price movements using multiplicative factors \\(u &gt; 1\\) and \\(d = 1/u &lt; 1\\).\nStarting from \\(S\\), after one period the stock price is either \\(uS\\) or \\(dS\\). After two periods, the possible prices are: - \\(u^2S\\) (two up moves) - \\(udS = S\\) (one up, one down)\n- \\(d^2S\\) (two down moves)\nThe tree recombines because \\(ud = du = 1\\), so the middle node has price \\(S\\) regardless of the path taken.\n\nBackward Induction Process\nThe key to valuing options in multi-period trees is backward induction. We start at maturity and work backwards to find today’s value.\nStep 1: Final Period (t = 2) Calculate option payoffs at each terminal node: - Node (2,2): \\(C_{uu} = \\max(0, u^2S - K)\\) - Node (2,1): \\(C_{ud} = \\max(0, udS - K) = \\max(0, S - K)\\) - Node (2,0): \\(C_{dd} = \\max(0, d^2S - K)\\)\nStep 2: Intermediate Period (t = 1) At each node, calculate the option value as the discounted risk-neutral expectation of the next period’s values.\nAt the up node (1,1) with stock price \\(uS\\): \\[C_u = e^{-r\\Delta t}[p \\cdot C_{uu} + (1-p) \\cdot C_{ud}]\\]\nAt the down node (1,0) with stock price \\(dS\\): \\[C_d = e^{-r\\Delta t}[p \\cdot C_{ud} + (1-p) \\cdot C_{dd}]\\]\nStep 3: Initial Period (t = 0) Finally, calculate today’s option value: \\[C_0 = e^{-r\\Delta t}[p \\cdot C_u + (1-p) \\cdot C_d]\\]\nFor American Options: At each intermediate node, compare continuation value with immediate exercise: - Up node: \\(C_u = \\max(\\text{continuation value}, \\max(0, uS - K))\\) - Down node: \\(C_d = \\max(\\text{continuation value}, \\max(0, dS - K))\\)\nThis backward induction process automatically finds the optimal exercise strategy by comparing holding vs. exercising at each node.\n\n\nCode\nimport numpy as np\ndef binomial_american_detailed(S0, K, r, sigma, T, N, option_type='put'):\n    \"\"\"\n    Price American option using binomial tree with detailed backward induction\n    \n    This function shows exactly how backward induction works step by step\n    \"\"\"\n    # Step 1: Set up tree parameters\n    dt = T / N                          # Time per step\n    u = np.exp(sigma * np.sqrt(dt))     # Up factor\n    d = 1 / u                           # Down factor (ensures recombining tree)\n    p = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability\n    disc = np.exp(-r * dt)              # Discount factor\n    \n    print(f\"Tree parameters: u={u:.4f}, d={d:.4f}, p={p:.4f}\")\n    \n    # Step 2: Initialize option values at maturity (time N)\n    # At maturity, we have N+1 possible stock prices\n    V = np.zeros(N+1)  # Option values\n    S = np.zeros(N+1)  # Stock prices\n    \n    for j in range(N+1):\n        S[j] = S0 * (u**j) * (d**(N-j))  # Stock price at node j\n        if option_type == 'call':\n            V[j] = max(0, S[j] - K)      # Call payoff\n        else:\n            V[j] = max(0, K - S[j])      # Put payoff\n    \n    print(f\"\\nAt maturity (time {N}):\")\n    print(f\"Stock prices: {[f'{s:.2f}' for s in S]}\")\n    print(f\"Option values: {[f'{v:.4f}' for v in V]}\")\n    \n    # Step 3: Backward induction through the tree\n    for i in range(N-1, -1, -1):  # Work backwards from time N-1 to 0\n        print(f\"\\nTime step {i}:\")\n        \n        # At time i, we have i+1 nodes\n        new_V = np.zeros(i+1)\n        new_S = np.zeros(i+1)\n        \n        for j in range(i+1):\n            # Stock price at this node\n            new_S[j] = S0 * (u**j) * (d**(i-j))\n            \n            # Continuation value (discounted expected value)\n            continuation = disc * (p * V[j+1] + (1-p) * V[j])\n            \n            # Immediate exercise value\n            if option_type == 'call':\n                exercise = max(0, new_S[j] - K)\n            else:\n                exercise = max(0, K - new_S[j])\n            \n            # American option: take maximum of continuation and exercise\n            new_V[j] = max(continuation, exercise)\n            \n            print(f\"  Node {j}: S={new_S[j]:.2f}, Cont={continuation:.4f}, \"\n                  f\"Exercise={exercise:.4f}, Value={new_V[j]:.4f}\")\n        \n        # Update for next iteration\n        V = new_V.copy()\n        S = new_S.copy()\n    \n    return V[0]\n\n# Example with small tree to see the process\nprint(\"Detailed backward induction for 2-step American put:\")\nS0, K, r, sigma, T, N = 100, 105, 0.05, 0.2, 1.0, 2\nput_value = binomial_american_detailed(S0, K, r, sigma, T, N, 'put')\nprint(f\"\\nFinal American put value: {put_value:.4f}\")\n\n\nDetailed backward induction for 2-step American put:\nTree parameters: u=1.1519, d=0.8681, p=0.5539\n\nAt maturity (time 2):\nStock prices: ['75.36', '100.00', '132.69']\nOption values: ['29.6362', '5.0000', '0.0000']\n\nTime step 1:\n  Node 0: S=86.81, Cont=15.5952, Exercise=18.1877, Value=18.1877\n  Node 1: S=115.19, Cont=2.1754, Exercise=0.0000, Value=2.1754\n\nTime step 0:\n  Node 0: S=100.00, Cont=9.0883, Exercise=5.0000, Value=9.0883\n\nFinal American put value: 9.0883\n\n\nThe numerical output above shows the exact backward induction process for our 2-step example. Let’s visualize this same tree to better understand how the calculations flow through the nodes:\n\n\nCode\nimport pydot\nfrom IPython.display import Image, display\nimport numpy as np\n\n# Use the same parameters as the detailed example above\nS0 = 100  # Initial stock price\nK = 105   # Strike price  \nr = 0.05  # Risk-free rate\nsigma = 0.2  # Volatility\nT = 1.0   # Time to maturity\nN = 2     # Number of periods\n\n# Calculate tree parameters\ndt = T / N\nu = np.exp(sigma * np.sqrt(dt))\nd = 1 / u\np = (np.exp(r * dt) - d) / (u - d)\ndisc = np.exp(-r * dt)\n\n# Calculate all stock prices and option values using same logic as detailed function\nV = np.zeros(N+1)  # Option values\nS = np.zeros(N+1)  # Stock prices\n\n# Time 2 (maturity) - put option payoffs\nfor j in range(N+1):\n    S[j] = S0 * (u**j) * (d**(N-j))\n    V[j] = max(0, K - S[j])  # Put payoff\n\nS_20, S_21, S_22 = S[0], S[1], S[2]\nV_20, V_21, V_22 = V[0], V[1], V[2]\n\n# Time 1 - backward induction  \nV_new = np.zeros(2)\nS_new = np.zeros(2)\nfor j in range(2):\n    S_new[j] = S0 * (u**j) * (d**(1-j))\n    continuation = disc * (p * V[j+1] + (1-p) * V[j])\n    exercise = max(0, K - S_new[j])\n    V_new[j] = max(continuation, exercise)\n\nS_10, S_11 = S_new[0], S_new[1]\nV_10, V_11 = V_new[0], V_new[1]\nV = V_new.copy()\n\n# Time 0 - final backward induction\nS_00 = S0\ncontinuation = disc * (p * V[1] + (1-p) * V[0])\nexercise = max(0, K - S_00)\nV_00 = max(continuation, exercise)\n\n# Create the graph\ngraph = pydot.Dot(graph_type='digraph', rankdir='LR', bgcolor='white')\ngraph.set_node_defaults(shape='circle', style='filled', fillcolor='lightblue', \n                       fontname='Arial', fontsize='9')\ngraph.set_edge_defaults(fontname='Arial', fontsize='8')\n\n# Time 0\ngraph.add_node(pydot.Node('t0', \n                         label=f't=0\\\\nS={S_00:.2f}\\\\nV={V_00:.4f}',\n                         fillcolor='lightgreen'))\n\n# Time 1\ngraph.add_node(pydot.Node('t1_u', \n                         label=f't=1 Up\\\\nS={S_11:.2f}\\\\nV={V_11:.4f}',\n                         fillcolor='lightyellow'))\ngraph.add_node(pydot.Node('t1_d', \n                         label=f't=1 Down\\\\nS={S_10:.2f}\\\\nV={V_10:.4f}',\n                         fillcolor='lightyellow'))\n\n# Time 2 (maturity)\ngraph.add_node(pydot.Node('t2_uu', \n                         label=f't=2 UU\\\\nS={S_22:.2f}\\\\nV={V_22:.4f}',\n                         fillcolor='lightcoral'))\ngraph.add_node(pydot.Node('t2_ud', \n                         label=f't=2 UD\\\\nS={S_21:.2f}\\\\nV={V_21:.4f}',\n                         fillcolor='lightcoral'))\ngraph.add_node(pydot.Node('t2_dd', \n                         label=f't=2 DD\\\\nS={S_20:.2f}\\\\nV={V_20:.4f}',\n                         fillcolor='lightcoral'))\n\n# Add edges\ngraph.add_edge(pydot.Edge('t0', 't1_u', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t0', 't1_d', label=f'1-p={1-p:.3f}'))\n\ngraph.add_edge(pydot.Edge('t1_u', 't2_uu', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t1_u', 't2_ud', label=f'1-p={1-p:.3f}'))\ngraph.add_edge(pydot.Edge('t1_d', 't2_ud', label=f'p={p:.3f}'))\ngraph.add_edge(pydot.Edge('t1_d', 't2_dd', label=f'1-p={1-p:.3f}'))\n\n# Save and display\ngraph.write_png('two_step_tree.png')\ndisplay(Image('two_step_tree.png'))\n\nprint(f\"Tree parameters matching the numerical example:\")\nprint(f\"u = {u:.4f}, d = {d:.4f}\")\nprint(f\"Risk-neutral probability p = {p:.4f}\")\nprint(f\"\\nThis tree shows the exact same values computed in the numerical output above.\")\n\n\n\n\n\n\n\n\nFigure 4.1: Two-step binomial tree showing the same numerical example with backward induction\n\n\n\n\n\nTree parameters matching the numerical example:\nu = 1.1519, d = 0.8681\nRisk-neutral probability p = 0.5539\n\nThis tree shows the exact same values computed in the numerical output above.\n\n\nThe tree visualization above corresponds exactly to the numerical backward induction process shown in the previous output. You can verify that the option values at each node match the calculations displayed in the step-by-step algorithm.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#n-period-model",
    "href": "Chapter_Trees.html#n-period-model",
    "title": "4  Binomial Tree Models",
    "section": "4.3 N-Period Model",
    "text": "4.3 N-Period Model\nThe extension to N periods is straightforward. With parameters \\(u\\) and \\(d = 1/u\\), after \\(n\\) periods we have \\(n+1\\) nodes with stock prices:\n\\[S_j = u^j d^{n-j} S = u^{2j-n} S, \\quad j = 0, 1, \\ldots, n\\]\nThe critical insight for efficient implementation is backward induction rather than computing all possible paths.\n\nInteractive N-Period Trees\nNow let’s explore how N-period binomial trees behave with different parameters using an interactive tool:\n\n\n\n\n\n\n\nFigure 4.2: Interactive Binomial Trees Explorer. This tool allows you to experiment with N-period binomial trees. Key features: - Interest rate: Enter the rate per period (for annual rate with N periods, use r/N) - Up move: This corresponds to \\((u-1)\\) where \\(u\\) is our up factor - Down move: The model automatically sets \\(d = 1/u\\) to ensure recombination - Number of periods: See how increasing N affects option values and convergence - Option types: Compare European and American option pricing - Parameters: Observe how volatility, strike price, and time to maturity affect values\n\n\n\n\n\nBackward Induction Implementation\nFor American options especially, we must use backward induction. Here’s the streamlined version for practical use:\n\n\nCode\ndef binomial_american_fast(S0, K, r, sigma, T, N, option_type='put'):\n    \"\"\"\n    Efficient American option pricing using backward induction\n    \n    This version uses vectorized operations for speed\n    \"\"\"\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    disc = np.exp(-r * dt)\n    \n    # Initialize option values at maturity\n    # Use vectorized operations for efficiency\n    j_values = np.arange(N+1)\n    S_final = S0 * (u**j_values) * (d**(N-j_values))\n    \n    if option_type == 'call':\n        V = np.maximum(S_final - K, 0)\n    else:\n        V = np.maximum(K - S_final, 0)\n    \n    # Backward induction\n    for i in range(N-1, -1, -1):\n        j_values = np.arange(i+1)\n        S_current = S0 * (u**j_values) * (d**(i-j_values))\n        \n        # Continuation values (vectorized)\n        V_new = disc * (p * V[1:i+2] + (1-p) * V[0:i+1])\n        \n        # Exercise values\n        if option_type == 'call':\n            exercise = np.maximum(S_current - K, 0)\n        else:\n            exercise = np.maximum(K - S_current, 0)\n        \n        # Take maximum (American feature)\n        V = np.maximum(V_new, exercise)\n    \n    return V[0]\n\n# Examples\nprint(\"\\nAmerican option values:\")\nput_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'put')\ncall_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'call')\nprint(f\"American put (K=105): {put_american:.4f}\")\nprint(f\"American call (K=105): {call_american:.4f}\")\n\n\n\nAmerican option values:\nAmerican put (K=105): 8.7476\nAmerican call (K=105): 8.0262\n\n\n\n\nHow the Code Works\nKey algorithmic insights:\n\nVectorization: Instead of nested loops, we use NumPy arrays to compute all nodes at each time step simultaneously\nMemory efficiency: We only store option values for the current time step, not the entire tree\nBackward induction logic:\n\nStart with payoffs at maturity\nAt each prior time step, compute continuation value as discounted expectation\nFor American options, compare with immediate exercise value\nTake the maximum (American feature)\n\nRisk-neutral probability: The tree converges to the Black-Scholes model when \\(p = \\frac{e^{r\\Delta t} - d}{u - d}\\) and we use the Cox-Ross-Rubinstein parameters.\n\nComputational complexity: - Time: \\(O(N^2)\\) for American options (must visit all nodes)\n- Space: \\(O(N)\\) (only current time step stored) - This is much better than the \\(O(2^N)\\) complexity of path enumeration",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#parameter-calibration",
    "href": "Chapter_Trees.html#parameter-calibration",
    "title": "4  Binomial Tree Models",
    "section": "4.4 Parameter Calibration",
    "text": "4.4 Parameter Calibration\nThe key question is how to choose the parameters \\(u\\), \\(d\\), and \\(p\\) so that the binomial model approximates the continuous-time Black-Scholes model as \\(N \\to \\infty\\).\n\nCox-Ross-Rubinstein Parameters\nThe most popular choice, proposed by Cox, Ross, and Rubinstein, sets:\n\\[u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u}, \\quad p = \\frac{\\mathrm{e}^{(r-q)\\Delta t} - d}{u - d}\\]\nwhere \\(q\\) is the dividend yield. This choice ensures: - The tree recombines (\\(ud = 1\\)) - The discrete model converges to geometric Brownian motion - The risk-neutral probability is well-defined when \\(d &lt; \\mathrm{e}^{(r-q)\\Delta t} &lt; u\\)\n\n\nMatching Moments\nFor the binomial model to converge properly to the continuous-time model, we need:\n\\[\\frac{\\mathbb{E}[\\Delta \\log S]}{\\Delta t} \\to r - q - \\frac{\\sigma^2}{2}\\]\n\\[\\frac{\\mathrm{Var}[\\Delta \\log S]}{\\Delta t} \\to \\sigma^2\\]\nThe Cox-Ross-Rubinstein parameters satisfy these conditions. With \\(u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}\\) and \\(d = 1/u\\):\n\n\\(\\log u = \\sigma\\sqrt{\\Delta t}\\) and \\(\\log d = -\\sigma\\sqrt{\\Delta t}\\)\nThe variance of \\(\\log(S_{t+\\Delta t}/S_t)\\) is approximately \\(\\sigma^2 \\Delta t\\) for small \\(\\Delta t\\)\n\n\n\nAlternative Parameters\nOther popular choices include:\nJarrow-Rudd: Set \\(p = 1/2\\) and adjust \\(u\\) and \\(d\\) to match the mean and variance: \\[u = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t + \\sigma\\sqrt{\\Delta t}\\right)\\] \\[d = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t - \\sigma\\sqrt{\\Delta t}\\right)\\]\nEqual Probabilities: This choice simplifies calculations but requires different up and down factors.\n\n\nConvergence and Accuracy\nThe binomial model converges to the continuous-time limit as \\(N \\to \\infty\\), but convergence is not monotonic. For European options: - Accuracy improves roughly as \\(O(1/N)\\) - Oscillations occur due to the discrete nature of the tree - Using \\(N \\approx 100\\) typically gives prices accurate to a few cents\nFor American options: - The binomial model provides one of the most efficient numerical methods - Early exercise boundaries can be extracted from the tree - Smooth convergence requires larger \\(N\\) than for European options\n\n\n\n\n\n\n\nFigure 4.3: Binomial Convergence to Continuous-Time Limit The binomial model (blue dots) converges to the continuous-time limit (red dotted line) for European options as the number of time steps is increased. The deviations from the continuous-time values are the same for both calls and puts, reflecting put-call parity in both the discrete and continuous-time models.\n\n\n\nAs \\(N \\to \\infty\\), the binomial model converges to the Black-Scholes model (see Chapter 9), which provides the analytical solution for European options in the continuous-time setting.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#summary",
    "href": "Chapter_Trees.html#summary",
    "title": "4  Binomial Tree Models",
    "section": "4.5 Summary",
    "text": "4.5 Summary\nThe binomial tree model provides an intuitive and flexible framework for option pricing:\n\nOne-period model: Introduces replication and risk-neutral valuation\nMulti-period extension: Uses backward induction for path-independent claims\nParameter choice: Cox-Ross-Rubinstein parameters with \\(u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}\\) and \\(d = 1/u\\) ensure convergence\nImplementation: Efficient for American options and provides exercise boundaries\n\nThe model’s strength lies in its simplicity and ability to handle early exercise features. However, for path-dependent options or multiple underlying assets, the computational requirements grow exponentially, making Monte Carlo methods more attractive in those cases.",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_Trees.html#exercises",
    "href": "Chapter_Trees.html#exercises",
    "title": "4  Binomial Tree Models",
    "section": "4.6 Exercises",
    "text": "4.6 Exercises\n\nOne-Period Model Exercises\n\nExercise 4.1 In a one-period binomial model with \\(S = 50\\), \\(S_u = 60\\), \\(S_d = 40\\), and \\(r = 0.05\\): a) Calculate the risk-neutral probabilities b) Price a call option with strike \\(K = 55\\) c) Verify your answer using delta hedging\n\n\nExercise 4.2 Create a Python function in which the user inputs \\(S\\), \\(S_d\\), \\(S_u\\), \\(K\\), \\(r\\) and \\(t\\). Check that the no-arbitrage condition is satisfied (\\(S_d &lt; Se^{rt} &lt; S_u\\)). Compute the value of a call option in each of the following ways:\n\nCompute the delta and use the replication formula\nCompute the state prices and use linear pricing\nCompute the risk-neutral probabilities and use discounted expectation\nCompute the probabilities using the stock as numeraire\n\nVerify that all of these methods produce the same answer.\n\n\nExercise 4.3 In a two-state model, a put option is equivalent to \\(\\delta_p\\) shares of the stock, where \\(\\delta_p = (P_u-P_d)/(S_u-S_d)\\) (this will be negative, meaning a short position) and some money invested in the risk-free asset. Derive the amount of money \\(x\\) that should be invested in the risk-free asset to replicate the put option. The value of the put at date \\(0\\) must be \\(x+\\delta_pS\\).\n\n\nExercise 4.4 Using the result of the previous exercise, repeat Exercise 4.2 for a put option using all four pricing methods.\n\n\n\nTwo-Period and Multi-Period Exercises\n\nExercise 4.5 Modify the visual tree code to create a two-period tree for an American put option with \\(S_0 = 100\\), \\(K = 105\\), \\(r = 0.05\\), \\(\\sigma = 0.3\\), and \\(T = 0.5\\). At each intermediate node, show both the continuation value and the immediate exercise value, highlighting when early exercise is optimal.\n\n\nExercise 4.6 Compare the detailed backward induction algorithm with the fast vectorized version for pricing American options. Time both implementations for \\(N = 50, 100, 200, 500\\) time steps. At what point does the speed difference become significant? Verify that both give identical results.\n\n\nExercise 4.7 Show that in the Cox-Ross-Rubinstein model, the expected return on the stock under the risk-neutral measure equals the risk-free rate: \\(\\mathbb{E}^p[S_{t+\\Delta t}/S_t] = \\mathrm{e}^{r\\Delta t}\\)\n\n\n\nParameter Calibration and Convergence\n\nExercise 4.8 Consider an at-the-money European call option on a dividend-reinvested stock with six months to maturity. Take the initial stock price to be $50, the interest rate to be 5% and \\(\\sigma = 30\\%\\). Compute the value in a binomial model with \\(N = 10, 11, \\ldots, 30\\) and plot the values against \\(N\\). Is convergence monotone? Comment on the oscillations you observe.\n\n\nExercise 4.9 Consider the same option as in the previous problem. Roughly what value of \\(N\\) is needed to get penny accuracy? (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)\n\n\nExercise 4.10 Compare the convergence of European option prices using: a) Cox-Ross-Rubinstein parameters: \\(u = e^{\\sigma\\sqrt{\\Delta t}}\\), \\(d = 1/u\\) b) Jarrow-Rudd parameters: \\(p = 1/2\\), adjust \\(u\\) and \\(d\\) to match moments\nPlot the option values against the number of time steps \\(N\\) for both methods. Which converges faster? Which is more stable?\n\n\nExercise 4.11 Verify that the Cox-Ross-Rubinstein parameters satisfy the moment-matching conditions: a) Show that \\(\\frac{\\mathbb{E}[\\Delta \\log S]}{\\Delta t} \\to r - q - \\frac{\\sigma^2}{2}\\) as \\(\\Delta t \\to 0\\) b) Show that \\(\\frac{\\mathrm{Var}[\\Delta \\log S]}{\\Delta t} \\to \\sigma^2\\) as \\(\\Delta t \\to 0\\)\nwhere the expectation and variance are under the risk-neutral measure.\n\n\n\nAmerican Options and Early Exercise\n\nExercise 4.12 The early exercise premium is the difference between the value of an American option and the value of a European option with the same parameters. Compute the early exercise premium for an American put with varying: a) Interest rates (\\(r = 0\\%, 2\\%, 5\\%, 10\\%\\)) b) Exercise prices (\\(K = 80, 90, 100, 110, 120\\) with \\(S_0 = 100\\)) c) Time to maturity (\\(T = 0.25, 0.5, 1, 2\\) years)\nUnder what circumstances is the early exercise premium relatively large?\n\n\nExercise 4.13 Implement a function to compute the early exercise boundary for an American put option. Plot the boundary as a function of time to maturity for different parameter values. Explain intuitively why the boundary has the shape it does.\n\n\nExercise 4.14 For an American call option on a dividend-paying stock, show analytically that it may be optimal to exercise just before an ex-dividend date. Implement this in your binomial tree by adding discrete dividend payments and compare American and European call values.\n\n\n\nAdvanced Applications\n\nExercise 4.15 A shout option is an option where the holder is entitled to “shout” at any time before expiration. Upon shouting, the holder receives the immediate exercise value paid at expiration, plus an at-the-money option with the same expiration. The payoff if the holder shouts at time \\(\\tau\\) is \\(\\max(0, S(\\tau)-K, S_T-S(\\tau))\\) where \\(K\\) is the original strike.\n\nShow that it is better to shout at some time where \\(S(\\tau) &gt; K\\) than to never shout at all\nModify the backward induction algorithm to find the optimal shouting strategy\nPlot the optimal shouting boundary\n\n\n\nExercise 4.16 A down-and-out barrier option is a call option that becomes worthless if the stock price ever falls below a barrier \\(B &lt; S_0\\). Modify the binomial tree algorithm to price such options by setting the option value to zero at any node where \\(S \\leq B\\). Compare the barrier option price to a standard call for different barrier levels.\n\n\nExercise 4.17 Extend the binomial model to a trinomial model with three possible moves at each step: up by factor \\(u\\), stay the same, or down by factor \\(d\\). a) Derive the risk-neutral probabilities \\(p_u\\), \\(p_m\\), \\(p_d\\) for the three states b) Implement trinomial backward induction c) Compare trinomial and binomial convergence for the same \\(\\Delta t\\)",
    "crumbs": [
      "Part 1: Introduction",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Binomial Tree Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html",
    "href": "Chapter_BrownianMotion.html",
    "title": "5  Brownian Motion",
    "section": "",
    "text": "5.1 Brownian Paths\nBrownian motion is a fundamental tool for modeling variables that change randomly over time. Consider predicting a future stock price. We don’t know today what the price will be tomorrow, nor what it will be the following day, nor what it will be the day after that. We can regard the price three days from now as today’s price plus the change from today to tomorrow plus the change from tomorrow to the following day plus the change from that day to the next. Thus, there are three random changes in this small example. A simple way to model this situation is to assume that each change is a normally distributed random variable with some mean and variance. Thus, the price in three days is viewed as today’s price plus the sum of three normal increments.\nRather than predicting daily changes as in the previous paragraph, we might be interested in predicting hourly changes or even minute-to-minute changes. This will lead to more, but smaller, increments. A Brownian motion is a model of changes at all frequencies, with all changes being normally distributed.\nWe will ultimately deal with different means and different variances, but we start with what is called a standard Brownian motion, which is similar to beginning the study of normal random variables by studying a standard normal variable, that is, a normal random variable with a zero mean and a unit variance. The definition of a standard Brownian motion is that its change over any time interval\nThe last bullet point reflects the fact that things are more uncertain the further into the future we look.1\nWe call a variable that changes randomly over time a stochastic process. A path of a stochastic process is a random function of time, recording how it evolves over time. We can plot an approximate path of a Brownian motion by summing up normally distributed changes. We take an interval of time \\([0, t]\\) and split it up as \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] where the times \\(t_i\\) are equally spaced, meaning that \\(t_i-t_{i-1} = t/n\\), which we will call \\(\\Delta t\\). We generate \\(n\\) normally distributed random variables with zero means and variance equal to \\(\\Delta t\\) and define the approximate Brownian motion, which we call \\(B\\), as the cumulative sum of the normal variables. By convention, we start any Brownian motion at \\(B_0=0\\). Our approximation fits the definition of a standard Brownian motion, except that we have limited the frequency of the changes to \\(n\\) changes within the interval. By taking \\(n\\) larger, we can always get a better approximation. An introduction to simulation (also called Monte Carlo analysis) is provided in the appendis (Chapter 16).\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\n\n# generate dB for each time step\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\n\n# B starts at 0 and is cumulative sum of the dB\nB = np.zeros(n+1)\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Approximate Brownian Motion',\n    template='plotly_white',\n    height=300,\n    autosize=True\n)\n\nfig.show()\n#| out-width: \"100%\"\n\n\n\n\n                                                \n\n\nFigure 5.1: A path of an approximate Brownian motion with 1,000 normally distributed steps.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#sec-s:brownian_binomial",
    "href": "Chapter_BrownianMotion.html#sec-s:brownian_binomial",
    "title": "5  Brownian Motion",
    "section": "5.2 Binomial Approximation",
    "text": "5.2 Binomial Approximation\nWe can also generate an approximate path of a Brownian motion by taking only up or down steps of a fixed size at each date, rather than using normally distributed steps. We call this a binomial model. A binomial model approximates the normally distributed increments of a Brownian Motion due to the Central Limit Theorem, which says that an appropriately scaled sum of a large number of random variables has approximately a normal distribution. The binomial approximation is often useful for pricing options, especially American options, as we will see. An introduction to binomial models is provided in the appendix. (Chapter 15).\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nn = 1000   # number of subdivisions\nt = 0.5    # last date\ndt = t/n\nsqdt = np.sqrt(dt)\n\n# generate dB for each time step\ndB = np.random.choice([-sqdt, sqdt], size=n)\nB = np.zeros(n+1)\n\n# Brownian path starts at 0 and is cumulative sum of the dB\nB[1:] = dB.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=B, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Binomial Process',\n    template='plotly_white',\n    height=300,\n    autosize=True\n)\n\nfig.show()\n#| out-width: \"100%\"\n\n\n\n\n                                                \n\n\nFigure 5.2: A path of an approximate Brownian motion with 1,000 binomial steps.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#sec-s:quadraticvariation",
    "href": "Chapter_BrownianMotion.html#sec-s:quadraticvariation",
    "title": "5  Brownian Motion",
    "section": "5.3 Nonzero Quadratic Variation",
    "text": "5.3 Nonzero Quadratic Variation\nFigure 5.1 and Figure 5.2 illustrate a distinctive characteristic of a Brownian motion: it jiggles rapidly, moving up and down in a very erratic way. The name Brownian motion derives from the botanist Robert Brown’s observations of the erratic behavior of particles suspended in a fluid. The plot of other functions with which we may be familiar will be much smoother. This is captured in the concept of quadratic variation.\nConsider a discrete partition \\[0=t_0 &lt; t_1 &lt; t_2 &lt; \\cdots &lt; t_n=t\\] of the time interval \\([0,t]\\) as before. Let \\(B\\) be a Brownian motion and calculate the sum of squared changes \\[\\sum_{i=1}^n (\\Delta B_{t_i})^2\\; ,\\] where \\(\\Delta B_{t_i}\\) denotes the change \\(B_{t_i}-B_{t_{i-1}}.\\) If we consider finer partitions with the length of each time interval \\(t_i-t_{i-1}\\) going to zero, the limit of the sum is called the quadratic variation of the process. For a Brownian motion, the quadratic variation over an interval \\([0,t]\\) is equal to \\(t\\) with probability one. Here is a plot of the quadratic variation (that is, the cumulative sum of squared changes) of the previous approximation of a Brownian motion. The plot shows that the approximation has quadratic variation through each date \\(s \\le t\\) that is approximately equal to \\(s\\).\n\n\nCode\n# using the approximate path created in the previous code block\n# quadratic variation is cumulative sum of squared changes\n\ndQ = dB**2\nQ = np.zeros(n+1)\nQ[1:] = dQ.cumsum()\n\nfig = go.Figure()\nfig.add_trace(\n  go.Scatter(\n    x=np.arange(0, t+dt, dt), \n    y=Q, \n    mode='lines', \n    hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;' \n    )\n)\n\nfig.update_layout(\n    showlegend=False,\n    xaxis_title='Time',\n    yaxis_title='Quadratic Variation',\n    template='plotly_white',\n    height=300,\n    autosize=True\n)\nfig.show()\n#| out-width: \"100%\"\n\n\n\n\n                                                \n\n\nFigure 5.3: Quadratic variation of an approximate Brownian motion path with 1,000 normally distributed steps.\n\n\n\n\nTo better visualize the convergence of the quadratic variation of a Brownian motion as the number \\(n\\) of subdivisions of the interval \\([0, t]\\) grows, we encourage readers to interact with the plot below, which simulates a handful of approximate Brownian paths and their quadratic variations.\n\n\n\n\n\n\n\nFigure 5.4: Convergence of quadratic variation of approximate Brownian motions. Five approximate paths of a Brownian motion are generated, and the quadratic variation is computed for each. The second figure also shows the true theoretical quadratic variation \\(\\int_0^t(\\mathrm{d}B_s)^2 = \\int_0^t \\mathrm{d}s = t\\). If the two figures do not appear side-by-side, hover over the plot area to reveal a vertical slider.\n\n\n\nThe typical functions with which we are familiar are continuously differentiable. If \\(x\\) is a continuously differentiable function of time, then the quadratic variation of \\(x\\) is zero. A simple example is a linear function: \\(x_s = as\\) for all \\(s\\) for a constant \\(a\\). Then, using the previous partition of the interval \\([0, t]\\), the sum of squared changes of the function from \\(0\\) to \\(t\\) is \\[\\sum_{i=1}^n (\\Delta x_{t_i})^2 = \\sum_{i=1}^n  [a\\,\\Delta t]^2 = na^2 (\\Delta t)^2 = na^2 \\left(\\frac{t}{n}\\right)^2 = \\frac{a^2t^2}{n} \\rightarrow 0\\] as \\(n \\rightarrow \\infty\\). For example, if \\(a=1\\) and \\(n=1000\\), then the sum of squared changes from date \\(0\\) to date \\(1\\) is \\(1000 \\times 0.001^2 = 0.001\\). Essentially the same argument shows that the quadratic variation of any continuously differentiable function is zero, because such a function is approximately linear at each point. Thus, the jiggling of a Brownian motion, which leads to the nonzero quadratic variation, is quite unusual.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#infinite-total-variation",
    "href": "Chapter_BrownianMotion.html#infinite-total-variation",
    "title": "5  Brownian Motion",
    "section": "5.4 Infinite Total Variation",
    "text": "5.4 Infinite Total Variation\nTo explain exactly how unusual the nonzero quadratic variation is, it is helpful to consider total variation, which is defined in the same way as quadratic variation but with the squared changes \\((\\Delta B_{t_i})^2\\) replaced by the absolute values of the changes \\(|\\Delta B_{t_i}|.\\) A general mathematical theorem states that, if the quadratic variation of a continuous function is nonzero, then its total variation is infinite. Therefore, each path of a Brownian motion has infinite total variation (with probability one). This means that, to draw a true path of a Brownian motion on a blackboard, we would need an infinite amount of chalk!\nIf we zoom in close enough in Figure 5.1, we can see the linear steps \\(\\Delta B\\). However, if we could zoom in on a segment of a path of a true Brownian motion, it would look much the same as the entire picture does to the naked eye—no matter how small the segment, we would still see the characteristic jiggling. That jiggling, even at microscopic scales, is the source of the infinite variation.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#continuous-martingales-and-levys-theorem",
    "href": "Chapter_BrownianMotion.html#continuous-martingales-and-levys-theorem",
    "title": "5  Brownian Motion",
    "section": "5.5 Continuous Martingales and Levy’s Theorem",
    "text": "5.5 Continuous Martingales and Levy’s Theorem\nOne may well question why we should be interested in this curious mathematical object. The reason is that asset pricing inherently involves martingales (variables that evolve randomly over time in such a way that their expected changes are always zero), as our fundamental pricing formula (?eq-formula) establishes. Furthermore, continuous processes (variables whose paths are continuous functions of time) are much more tractable mathematically than are processes that can jump at some instants. So, we are led to a study of continuous martingales. An important fact is that any non-constant continuous martingale must have infinite total variation. So, the normal functions with which we are familiar are left behind once we enter the study of continuous martingales.\nThere remains perhaps the question of why we focus on Brownian motion within the world of continuous martingales. The answer here is that any continuous martingale is really just a transformation of a Brownian motion. This is a consequence of the following important fact, which is known as Levy’s theorem: \n\n\n\n\n\n\nImportant Principle\n\n\n\nA continuous martingale is a Brownian motion if and only if its quadratic variation over each time interval \\([s, t]\\) equals \\(t-s\\).\n\n\nThus, among continuous martingales, a Brownian motion is distinguished by the condition that its quadratic variation over each time interval is equal to the length of the interval. This is really just a normalization. A different continuous martingale may have a different quadratic variation, but it can be converted to a Brownian motion by changing the clock speed to measure time according to the quadratic variation. Furthermore, many continuous martingales can be constructed as stochastic integrals with respect to a Brownian motion. We take up that topic in the next chapter.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#sec-s:correlation",
    "href": "Chapter_BrownianMotion.html#sec-s:correlation",
    "title": "5  Brownian Motion",
    "section": "5.6 Correlation of Brownian Motions",
    "text": "5.6 Correlation of Brownian Motions\nConsider two standard Brownian motions \\(B_1\\) and \\(B_2\\). The relation between the two Brownian motions is determined by their covariance or correlation. Given dates \\(s&lt;t\\), we know that both changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\) are normally distributed with zero means and variances equal to \\(t-s\\), given information at date \\(s\\). There is a stochastic process \\(\\rho\\) such that the covariance of these two normally distributed random variables, given the information at date \\(s\\), is \\[\\mathbb{E}_s \\left[\\int_s^t \\rho_u\\mathrm{d}   u\\right]\\; .\\] The process \\(\\rho\\) is called the correlation process of the two Brownian motions. The correlation of the changes \\(B_{1t}-B_{1s}\\) and \\(B_{2t}-B_{2s}\\), given information at date \\(s\\), is \\[\\frac{\\text{covariance}}{\\text{product of standard deviations}}  = \\frac{\\mathbb{E}_s\\int_s^t \\rho_u \\mathrm{d}   u}{\\sqrt{t-s} \\sqrt{t-s}} = \\frac{1}{t-s}\\mathbb{E}_s\\int_s^t \\rho_u \\mathrm{d}   u\\; .\\] Thus, the correlation is the expected average value of \\(\\rho_u\\). In particular, when \\(\\rho\\) is constant, the correlation of the changes is \\(\\rho\\). The two Brownian motions are independent if \\(\\rho=0\\). In this case, knowledge of one Brownian motion – even knowledge of its future values – will not help to predict the other.\nJust as we computed quadratic variation by taking a limit of sums of squared changes, we compute what is called joint variation by taking a limit of sums of products of changes. For the two Brownian motions, the joint variation over an interval \\([0, t]\\) is \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n \\Delta B_{1t_i} \\times \\Delta B_{2t_i} \\] given increasingly fine partitions \\(0=t_0 &lt; \\cdots &lt; t_n=t\\) as before. The joint variation of two Brownian motions equals the integral of their correlation process; that is, the joint variation over \\([0, t]\\) equals \\(\\int_0^t \\rho_s\\mathrm{d} s\\), with probability one. Thus, the expected joint variation equals the covariance.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#exercises",
    "href": "Chapter_BrownianMotion.html#exercises",
    "title": "5  Brownian Motion",
    "section": "5.7 Exercises",
    "text": "5.7 Exercises\n\nExercise 5.1 Consider a discrete partition \\(0=t_0 &lt; t_1 &lt; \\cdots t_n=t\\) of the time interval \\([0,t]\\) with \\(t_i - t_{i-1} = \\Delta t = t/n\\) for each \\(i\\). Consider the function \\[X_t=\\mathrm{e}^t\\; .\\] Write a function that computes and plots \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\), where \\[\\Delta X_{t_i} = X_{t_i}-X_{t_{i-1}} = \\mathrm{e}^{t_i} - \\mathrm{e}^{t_{i-1}}\\; .\\]\n\n\nExercise 5.2 Repeat the previous problem for the function \\(X_t = t^3\\). In both this and the previous problem, can you tell what happens to \\(\\sum_{i=1}^n (\\Delta X_{t_i})^2\\) as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 5.3 Write a function to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^2\\) from a partition of an interval \\([0, t]\\), for given \\(t\\) and \\(n\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 5.4 Repeat the previous problem to compute \\(\\sum_{i=1}^n (\\Delta B_{t_i})^3\\), where \\(B\\) is a simulated Brownian motion. For a given \\(t\\), what happens to the sum as \\(n \\rightarrow \\infty\\)?\n\n\nExercise 5.5 Repeat the previous problem, computing instead \\(\\sum_{i=1}^n |\\Delta B_{t_i}|\\) where \\(| \\cdot |\\) denotes the absolute value. What happens to this sum as \\(n \\rightarrow \\infty\\)?",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_BrownianMotion.html#footnotes",
    "href": "Chapter_BrownianMotion.html#footnotes",
    "title": "5  Brownian Motion",
    "section": "",
    "text": "A formal definition of a Brownian motion would include a specification of the information that we have for predicting the future. The definition given here is correct when the only information is the past history of the Brownian motion.↩︎",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html",
    "href": "Chapter_Ito.html",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "6.1 Examples\nWe use the changes of a Brownian motion to model randomness. We build other stochastic processes using those changes. The general idea is \\[\\text{change} = \\text{mean} + \\text{std dev} \\times \\text{change in Brownian motion}\\,.\\] The mathematical foundations for our construction were created by K. Ito. The key concepts are the Ito integral, Ito processes, and Ito’s formula (also called Ito’s lemma). Using these foundations, we can build quite general processes from changes in Brownian motions, including processes with non-normal distributions.\nWe begin with some simple examples. Consider a discrete partition of a time interval: \\[0=t_0 &lt; t_1&lt; \\cdots &lt; t_{n-1} &lt; t_n=t\\] with equally spaced times. Let \\(\\Delta t\\) denote the difference between successive times.\nFirst, let’s drop the randomness entirely. Consider the equation \\[X_{t_i} -  X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t \\qquad(6.1)\\] for a constant \\(\\mu\\). Thus, we have change \\(\\,=\\,\\) mean, where the mean is proportional to the previous value with proportionality factor \\(\\mu \\Delta t\\). Figure 6.1 presents a plot of \\(X\\), for particular values of \\(X_0\\), \\(\\mu\\), and \\(\\Delta t\\).\nIf we increase \\(n\\), making \\(\\Delta t\\) smaller, then \\(X\\) converges to the solution of the ordinary differential equation \\[\\mathrm{d} X_t = \\mu X_t\\mathrm{d}  t\\,. \\qquad(6.2)\\] Equation 6.2 has a known solution, which is \\[X_t = X_0 \\mathrm{e}^{\\mu t}\\,. \\qquad(6.3)\\] To verify this, we only need to differentiate \\(X\\) defined in Equation 6.3: \\[\\frac{\\mathrm{d} X_t}{\\mathrm{d} t} = \\mu X_0 \\mathrm{e}^{\\mu t} = \\mu X_t\\,.\\] The function presented in Equation 6.3 is also shown in Figure 6.1.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nn = 10   # number of subdivisions\nt = 1     # last date\nDeltat = t/n\nX1 = np.ones(n+1)\nfor i in range(1, n+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat\n\nX2 = np.exp(mu * np.arange(0, t+Deltat, Deltat))\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    autosize=True,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n#| out-width: \"100%\"\n\n\n\n\n                                                \n\n\nFigure 6.1: The functions \\(X\\) satisfying Equation 6.1 (difference equation) and Equation 6.3 (differential equation) for X0 = 1, mu = 1, and Delta t = 0.1.\nNow, let’s include randomness. Let’s make the noise proportional to the value of \\(X\\), So, let \\(B\\) be a standard Brownian motion and consider the equation \\[X_{t_i} - X_{t_{i-1}} = \\mu X_{t_{i-1}}\\Delta t + \\sigma X_{t_{i-1}} \\Delta B_{t_i} \\qquad(6.4)\\] where \\(\\sigma\\) is another constant, and \\(\\Delta B_{t_i} = B_{t_i} - B_{t_{i-1}}\\). A solution \\(X\\) of this equation has random paths, due to the random noise \\(\\Delta B_{t_i}\\). An example of a path is shown in Figure 6.2. Ito showed how we can take the limit of this equation as we make \\(\\Delta t\\) smaller and make sense of the equation \\[\n\\mathrm{d} X_t = \\mu X_t\\mathrm{d}  t + \\sigma X_t \\mathrm{d}  B_t\\,.\n\\qquad(6.5)\\] The solution \\(X\\) of Equation 6.5 is \\[X_t = \\mathrm{e}^{(\\mu  - \\sigma^2/2)t + \\sigma B_t}\\,. \\qquad(6.6)\\] We can show that \\(X\\) defined in Equation 6.6 satisfies Equation 6.5 by differentiating, as we showed that \\(X\\) defined in Equation 6.3 satisfies Equation 6.2. However, we first need to explain Ito’s formula, which is a formula for differentiating functions of Brownian motions and, more generally, functions of Ito processes. An approximate path of \\(X\\) is shown in Figure 6.2. It is generated by taking \\(\\Delta t\\) very small, just as we generated approximate paths of Brownian motions in Chapter 5.\nCode\nimport numpy as np\nimport plotly.graph_objects as go\n\nmu = 1\nsigma = 1\nt = 1\n\n# Brownian path\nn = 1000   \ndt = t/n\ndB = np.random.normal(scale = np.sqrt(dt), size=n)\nB = np.zeros(n+1)\nB[1:] = np.cumsum(dB)\n\n# Brownian path with discrete steps\nn_discrete = 10\nDeltat = t/n_discrete\nB_discrete = B[::int(n/n_discrete)]\nDeltaB = np.diff(B_discrete)\n\n# X in discrete-time \nX1 = np.ones(n_discrete+1)\nfor i in range(1, n_discrete+1):\n    X1[i] = X1[i-1] + mu * X1[i-1] * Deltat + sigma * X1[i-1] * DeltaB[i-1]\n\n# Continuous-time\nX2 = np.exp((mu - 0.5 * sigma**2) * np.arange(0, t+dt, dt) + sigma * B)\n\nfig = go.Figure()\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+Deltat, Deltat), \n        y=X1, \n        mode='markers', \n        name='Difference Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=np.arange(0, t+dt, dt), \n        y=X2, \n        mode='lines', \n        name='Differential Eq.',\n        hovertemplate='t = %{x:.2f}&lt;br&gt;B = %{y:.2f}&lt;extra&gt;&lt;/extra&gt;'  # \n    )\n)\nfig.update_layout(\n    showlegend=True,\n    xaxis_title='Time',\n    yaxis_title='',\n    template='plotly_white',\n    height=300,\n    autosize=True,\n    legend=dict(\n        x=0.1,\n        y=1,\n        xanchor=\"left\",\n        yanchor=\"top\",\n    )\n)\n\nfig.show()\n#| out-width: \"100%\"\n\n\n\n\n                                                \n\n\nFigure 6.2: Paths of the processes satisfying Equation 6.4 (difference equation) and Equation 6.6 (differential equation) for X0 = 1, mu = 1, Delta t = 0.1, and sigma = 1.\nThe functions and processes \\(X\\) defined in this section have important interpretations. Equation 6.1 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t\\). This could represent the value of a savings account that earns interest of \\(\\mu \\Delta t\\) in each period of length \\(\\Delta t\\). This is the common way of calculating, for example, monthly interest, where \\(\\mu\\) is called the annual rate of interest and \\(\\Delta t\\) would be \\(1/12\\). The limiting Equation 6.3 is called continuous compounding of interest.\nSimilarly, Equation 6.4 can be rewritten to say that the percent change in \\(X\\) is \\(\\mu \\Delta t + \\sigma \\Delta B\\). This represents a random rate of return – for example, the return of a stock. The expected rate of return in this case is \\(\\mu \\Delta t\\), and the variance of the rate of return is \\(\\sigma^2 \\Delta t\\). The limiting Equation 6.3 is called continuous compounding of returns.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:discreteito",
    "href": "Chapter_Ito.html#sec-s:discreteito",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "Theory Extra\n\n\n\n\n\nTo see how one might guess that Equation 6.3 is the solution of Equation 6.2, we can examine the logarithm of \\(X\\). A general rule gives us \\(\\mathrm{d} \\log X = \\mathrm{d} X / X\\), so \\(\\mathrm{d} \\log X = \\mu \\mathrm{d} t\\). We can integrate both sides of this to obtain \\(\\log X_t - \\log X_0 = \\mu t\\). Now, rearranging and exponentiating gives \\(X_t = X_0\\mathrm{e}^{\\mu t}\\). Later, we follow similar steps to see that Equation 6.6 is the solution of Equation 6.5.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itoprocesses",
    "href": "Chapter_Ito.html#sec-s:itoprocesses",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.2 Ito Processes",
    "text": "6.2 Ito Processes\nThe meaning of Equation 6.2 is that, for all \\(t  &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\mathrm{d} s\\,.\\] We assume the reader is familiar with integrals, so we do not explain this further. The function of time \\(X\\) defined in Equation 6.3 satisfies this equation. Similarly, the meaning of Equation 6.5 is that, for all \\(t &gt; 0\\), \\[X_t = X_0 +  \\int_0^t \\mu X_s \\mathrm{d} s + \\int_0^t \\sigma X_s \\mathrm{d} B_s\\,.\\] The first integral in this formula is an ordinary integral. The second is an Ito integral, which is to be explained. The sum of an ordinary integral and an Ito integral is called an Ito process. An Ito process always has continuous paths.\nLet’s depart from the example of the previous section and consider a process \\(X\\) satisfying, for all \\(t&gt;0\\), \\[X_t = \\int_0^t \\alpha_s\\mathrm{d} s + \\int_0^t \\theta_s \\mathrm{d} B_s\\,. \\qquad(6.7)\\] where \\(\\alpha\\) and \\(\\theta\\) can be stochastic processes. The example of the previous section fits this form, because we could take \\(\\alpha_s = \\mu X_s\\) and \\(\\theta_s = \\sigma X_s\\). The definition of the Ito integral \\[\\int_0^t \\theta_s \\mathrm{d} B_s\\] is relatively complicated. It is enough for our purposes to know that it can be approximated by a discrete sum \\[\\sum_{i=1}^n \\theta_{t_{i-1}}(B_{t_i} - B_{t_{i-1}})\\,,\\] given a partition \\[ 0 = t_0 &lt; \\cdots &lt; t_n = t\\,,\\] when \\(n\\) is large and the time between successive dates is small. The Ito integral exists provided \\(\\theta\\) does not anticipate the future (so \\(\\theta_{t_{i-1}}\\) is independent of the increment \\(B_{t_i}- B_{t_{i-1}}\\)) and provided \\(\\theta\\) does not explode to \\(\\pm \\infty\\) in finite time, so \\[\\int_0^t \\theta_s^2 \\mathrm{d} s &lt; \\infty\\] for all \\(t &gt; 0\\), with probability one.\nWe also write Equation 6.7 as \\[\n\\mathrm{d} X_t = \\alpha_t\\mathrm{d} t + \\theta_t \\mathrm{d} B_t\\,.\n\\qquad(6.8)\\] We interpret this as change \\(=\\) mean \\(+\\) noise with \\(\\alpha_t \\mathrm{d} t\\) being the mean and \\(\\theta_t\\mathrm{d} B_t\\) being the mean-zero random noise. The quantity \\(\\alpha_t\\) is also called the drift of the process \\(X\\) at time \\(t\\). The coefficient \\(\\theta_t\\) is called the diffusion coefficient of \\(X\\) at time \\(t\\). If \\(\\alpha\\) and \\(\\theta\\) are constant, it is standard to refer to an Ito process \\(X\\) as a \\((\\alpha,\\theta)\\)–Brownian motion. When they are constant, we obtain \\[X_t= X_0 + \\alpha t + \\theta B_t\\,.\\]\nAn Ito process as in Equation 6.7 can be a martingale only if \\(\\alpha=0\\). This should seem sensible, because \\(\\alpha\\mathrm{d}  t\\) is the expected change in \\(X\\), and a process is a martingale only if its expected change is zero. This observation plays a fundamental role in deriving asset pricing formulas. Conversely, if \\(\\alpha=0\\) and \\[\n\\mathbb{E} \\left[\\int_0^t \\theta^2_s\\mathrm{d}   s\\right] &lt; \\infty\n\\qquad(6.9)\\] for each \\(t\\), then the Ito process is a continuous martingale, and the variance of its date–\\(t\\) value, calculated with the information available at date \\(0\\), is: \\[\\mathrm{var}(X_t) = \\mathbb{E} \\left[\\int_0^t \\theta^2_t\\mathrm{d}  s\\right]\\; .\\]",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "href": "Chapter_Ito.html#quadratic-and-joint-variation-of-ito-processes",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.3 Quadratic and Joint Variation of Ito Processes",
    "text": "6.3 Quadratic and Joint Variation of Ito Processes\nTo compute the quadratic variation of an Ito process, we use the following simple and important rules (for the sake of brevity, we drop the subscript \\(t\\) from \\(B_t\\) here and sometimes later). These rules should be regarded as mnemonic devices. The calculations we do with them lead to the correct results, but the objects have no real mathematical meaning.\n\n\n\n\n\n\nImportant Principle\n\n\n\n\\[\n(\\mathrm{d}  t)^2 = 0\\;,\n\\qquad(6.10)\\]\n\\[\n(\\mathrm{d}  t)(\\mathrm{d}  B) =0\\;,\n\\qquad(6.11)\\]\n\\[\n(\\mathrm{d}  B)^2 =\\mathrm{d}  t\\;.\n\\qquad(6.12)\\]\n\n\nWe apply these rules to compute the quadratic variation of any Ito proces \\(X\\) as follows:\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(\\mathrm{d}  X = \\alpha\\mathrm{d}   t + \\theta\\mathrm{d}   B\\) for a Brownian motion \\(B\\), then \\[\\begin{align}\n(\\mathrm{d}  X)^2 &= (\\alpha\\mathrm{d} t+\\theta\\mathrm{d}   B)^2\\\\\n&= \\alpha^2(\\mathrm{d}  t)^2 + 2\\alpha\\theta(\\mathrm{d}  t)(\\mathrm{d}  B) + \\theta^2(\\mathrm{d}  B)^2\\\\\n&= \\theta^2\\mathrm{d}   t\\;.\n\\end{align}\\] To compute the quadratic variation of the Ito process \\(X\\) over any particular period of time, we integrate \\((\\mathrm{d} X)^2\\) over that period as1] \\[\n\\int_0^t (\\mathrm{d}  X_s)^2 = \\int_0^t \\theta^2_s\\mathrm{d}   s\\;.\n\\qquad(6.13)\\]\n\n\nNow consider two Ito processes: \\[\n\\mathrm{d}  X_{1t} = \\mu_{1t}\\mathrm{d}   t + \\sigma_{1t}\\mathrm{d}   B_{1t}\\;,\n\\qquad(6.14)\\]\n\\[\n\\mathrm{d}  X_{2t} = \\mu_{2t}\\mathrm{d}   t + \\sigma_{2t}\\mathrm{d}   B_{2t}\\;,\n\\qquad(6.15)\\]\nwhere \\(B_1\\) and \\(B_2\\) are standard Brownian motions. We calculate the product of differentials of Ito processes as follows.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(X_1\\) and \\(X_2\\) are Ito processes as in Equation 6.14 and Equation 6.15, then \\[(\\mathrm{d} X_1)(\\mathrm{d} X_2) = (\\sigma_{1}\\mathrm{d} B_{1})(\\sigma_{2}\\mathrm{d} B_{2})= \\sigma_1\\sigma_2\\rho\\mathrm{d} t \\qquad(6.16)\\] where \\(\\rho\\) is the correlation process of the two Brownian motions.\n\n\nThe real meaning of this rule is that it is possible to calculate the joint variation (i.e., limit of sum of products of changes) of the two Ito processes from \\(0\\) to \\(t\\) as \\[\\int_0^t (\\mathrm{d} X_{1s})(\\mathrm{d} X_{2s}) = \\int_0^t (\\sigma_{1s}\\mathrm{d} B_{1s})(\\sigma_{2s}\\mathrm{d} B_{2s}) = \\int_0^t \\sigma_{1s}\\sigma_{2s}\\rho_s\\mathrm{d} s\\,.\n\\qquad(6.17)\\] The last integral in this equation is the correct formula for the quadratic variation. As with squaring differentials, taking products of differentials is a mnemonic device to get us to the correct formula.2",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#sec-s:itosformula",
    "href": "Chapter_Ito.html#sec-s:itosformula",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.4 Introduction to Ito’s Formula",
    "text": "6.4 Introduction to Ito’s Formula\nFirst we recall some facts of the ordinary calculus. If \\(y=f(x)\\) and \\(x_t = g(t)\\) with \\(f\\) and \\(g\\) being continuously differentiable functions, then \\[\\frac{\\mathrm{d}  y}{\\mathrm{d}  t} = \\frac{\\mathrm{d}  y}{\\mathrm{d}  x}\\times \\frac{\\mathrm{d}  x}{\\mathrm{d}  t} = f**(x_t)g**(t)\\; .\\] This implies that, for each \\(t&gt;0\\), \\[y_t = f(x_t) = y_0 + \\int_0^t \\frac{\\mathrm{d}  y}{\\mathrm{d}  s}\\mathrm{d}   s = y_0 + \\int_0^t f**(x_s)g**(s)\\mathrm{d}   s\\; .\\] Substituting \\(\\mathrm{d} x_s = g**(s)\\mathrm{d}   s\\), we can also write this as \\[\ny_t = f(x_t) = y_0 + \\int_0^t f**(x_s)\\mathrm{d}   x_s\\,,\n\\qquad(6.18)\\] or, in differential form, \\[\ndy_t = f**(x_t)\\mathrm{d} x_t \\,.\n\\qquad(6.19)\\] What people frequently remember about integrals from their calculus courses is that there are a lot of tricky substitutions that can be made to simplify the calculation of various integrals. We won’t need those in this book. All we will use are equations of the form of Equation 6.18, which is a special case of the Fundamental Theorem of Calculus, which says that a function is the integral of its derivative. Intuitively, we can think of Equation 6.18 as saying that the change in \\(y\\) over a discrete interval (from \\(0\\) to \\(t\\)) is the continuous sum (integral) of its infinitesimal changes.\nWe will contrast Equation 6.18 with the following special case of Ito’s formula for the calculus of Ito processes.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(B\\) is a Brownian motion and \\(Y = f(B)\\) for a twice-continuously differentiable function \\(f\\), then \\[\\mathrm{d}   Y_t = f**(B_t)\\mathrm{d}   B_t + \\frac{1}{2}f****(B_t)\\mathrm{d}   t  \\,.\n\\qquad(6.20)\\]\n\n\nComparing Equation 6.20 to Equation 6.19, we see that Ito’s formula has an extra term involving the second derivative \\(f****\\).\nEquation 6.20 implies that \\(Y=f(B)\\) is an Ito process with drift \\(f****(B_t)/2\\) and diffusion coefficient \\(f**(B_t)\\). The real meaning of Equation 6.20 is the integrated form: \\[\nY_t = f(B_t) = Y_0 + \\int_0^t f**(B_s)\\mathrm{d}   B_s + \\frac{1}{2}\\int_0^t f****(B_s)\\mathrm{d}   s\\;.\n\\qquad(6.21)\\] Thus, the change in \\(Y\\) over a discrete interval is again the continuous sum of its infinitesimal changes, but now the infinitesimal changes are given by Equation 6.20. Note that the first integral in Equation 6.21 is an Ito integral.\nTo gain some intuition for the extra term in Ito’s formula, we return to the ordinary calculus. Given dates \\(s&lt;t\\), the derivative defines a linear approximation of the change in \\(y\\) from \\(s\\) to \\(t\\); that is, setting \\(\\Delta x = x_t-x_s\\) and \\(\\Delta y = y_t - y_s\\), we have the approximation \\[\\Delta y \\approx f**(x_s) \\,\\Delta x\\; .\\] A better approximation is given by the second-order Taylor series expansion \\[\\Delta y \\approx f**(x_s)\\,\\Delta x + \\frac{1}{2} f****(x_s)\\,(\\Delta x)^2\\; .\\] An interpretation of Equation 6.18 is that the linear approximation works perfectly for infinitesimal time periods \\(\\mathrm{d}  s\\), because we can compute the change in \\(y\\) over the time interval \\([0,t]\\) by summing up the infinitesimal changes \\(f**(x_s)\\mathrm{d}   x_s\\). In other words, the second-order term \\(\\frac{1}{2} f****(x_s)\\,(\\Delta x)^2\\) vanishes when we consider very short time periods.\nThe second-order Taylor series expansion in the case of \\(Y=f(B)\\) is \\[\\Delta Y \\approx f**(B_s)\\,\\Delta B + \\frac{1}{2} f****(B_s)\\,(\\Delta B)^2\\; .\\] For example, given a partition \\(0=t_0 &lt; t_1 &lt; \\cdots &lt; t_n=t\\) of the time interval \\([0,t]\\), we have, with the same notation we have used earlier,\n\\[\nY_t = Y_0 + \\sum_{i=1}^n \\Delta Y_{t_i}  \n\\approx Y_0 + \\sum_{i=1}^n f**(B_{t_{i-1}})\\,\\Delta B_{t_i} + \\frac{1}{2} \\sum_{i=1}^n f****(B_{t_{i-1}})\\,(\\Delta B_{t_i})^2\\;.\n\\qquad(6.22)\\]\nIf we make the time intervals \\(t_i-t_{i-1}\\) shorter, letting \\(n \\rightarrow \\infty\\), then we cannot expect that the extra term here will disappear, leading to the result of the ordinary calculus shown in Equation 6.18, because we know that \\[\\lim_{n \\rightarrow \\infty} \\sum_{i=1}^n (\\Delta B_{t_i})^2 = t\\; ,\\] whereas for the continuously differentiable function \\(x_t = g(t)\\), the same limit is zero. In fact it seems sensible to interpret the limit of \\((\\Delta B)^2\\) as \\((\\mathrm{d}  B)^2 =\\mathrm{d}  t\\). This is perfectly consistent with Ito’s formula: if we take the limit in Equation 6.22, replacing the limit of \\((\\Delta B_{t_i})^2\\) with \\((\\mathrm{d}  B)^2 = \\mathrm{d}  t\\), we obtain Equation 6.21.\nTo see the accuracy of Ito’s approximation over different time steps, as well as the impact of the second-derivative term \\(\\int_0^t (1/2)f****(B_s)\\mathrm{d} s\\), we encourage readers to interact with the plot below. It examines the function \\(f(x)=\\mathrm{e}^{x}\\) (for which we have \\(f**(x)=\\mathrm{e}^x\\) and \\(f****(x) = \\mathrm{e}^x\\)). It simulates an approximate path of a Brownian motion as we have done before. It then compares the true value of \\(\\mathrm{e}^{B_{t_i}}\\) to the Ito expansion \\[\\mathrm{e}^{B_t}=1 + \\int_0^t \\mathrm{e}^{B_s} \\mathrm{d} B_s + \\frac{1}{2}\\int_0^t \\mathrm{e}^{B_s} \\mathrm{d} s\\] using the discretization \\[\\Delta \\mathrm{e}^{B_{t_i}}= \\mathrm{e}^{B_{t_{i-1}}} \\Delta B_{t_i} + \\frac{1}{2} \\mathrm{e}^{B_{t_{i-1}}} \\Delta t \\,.\\] Notice that the discretization is just a second-order Taylor series expansion. The discretization approximates the true value better if we take \\(n\\) larger and \\(\\Delta t\\) smaller. The important take-away from the figure is that the cumulative second-derivative terms in the discretization do not vanish as we take \\(n\\) larger but instead continue to contribute significantly to the approximation.\n\n\n\n\n\n\n\nFigure 6.3: Accuracy of the Ito Approximation.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-a-brownian-motion",
    "href": "Chapter_Ito.html#functions-of-time-and-a-brownian-motion",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.5 Functions of Time and a Brownian Motion",
    "text": "6.5 Functions of Time and a Brownian Motion\nWe extend the example in the previous section slightly. Consider a process \\(Y\\) defined as \\(Y_t = f(t, B_t)\\) for some function \\(f\\). The following rule states that \\(Y\\) is an Ito process with drift equal to \\[\\frac{\\partial f}{\\partial t} + \\frac{1}{2} \\frac{\\partial^2 f}{\\partial B^2}\\] and diffusion coefficient equal to \\(\\partial f/\\partial B\\). This is what we need to remember to make calculations. The real meaning of \\((\\mathrm{d} B)^2\\) is \\(\\mathrm{d} t\\), so we can (and will) substitute that in the following rule, but it may be easier to remember \\((\\mathrm{d} B)^2\\). This becomes more important when we consider more complex examples in the next sections.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(f(t, B)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(B\\) and \\(Y_t= f(t, B_t)\\) for a standard Brownian motion \\(B\\), then \\[\\mathrm{d} Y = \\frac{\\partial f(t, B)}{\\partial t}\\mathrm{d} t + \\frac{\\partial f(t, B)}{\\partial B}\\mathrm{d} B + \\frac{1}{2} \\frac{\\partial^2 f(t, B)}{\\partial B^2}(\\mathrm{d} B)^2\\,.\n\\qquad(6.23)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe can finish the discussion in Section 6.1 regarding the process defined in Equation 6.6 by applying Equation 6.23. We want to show that the process satisfies Equation 6.5. We do that by differentiating and applying the Equation 6.23. For \\(f(t, B) = \\mathrm{e}^{(\\mu - \\sigma^2/2)t + \\sigma B}\\), we have \\[\\frac{\\partial f}{\\partial t} = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)f(t, B)\\,,\\quad \\frac{\\partial f}{\\partial B} = \\sigma f(t, B)\\,, \\quad \\frac{\\partial^2 f}{\\partial B^2} = \\sigma^2f(t, B)\\,.\\] Therefore, \\[\\mathrm{d} Y = \\left(\\mu-\\frac{1}{2}\\sigma^2\\right)Y\\mathrm{d} t + \\sigma Y \\mathrm{d} B + \\frac{1}{2}\\sigma^2 Y\\,(\\mathrm{d} B)^2 = \\mu Y\\mathrm{d} t + \\sigma Y \\mathrm{d} B\\] This verifies Equation 6.5.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-an-ito-process",
    "href": "Chapter_Ito.html#functions-of-time-and-an-ito-process",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.6 Functions of Time and an Ito Process",
    "text": "6.6 Functions of Time and an Ito Process\nNow consider the more general case \\(Y_t = f(t, X_t)\\) where \\(X\\) is an Ito process. As explained before, this means that \\[\\mathrm{d} X_t = \\alpha_t\\mathrm{d} t + \\theta_t \\mathrm{d} B_t\n\\qquad(6.24)\\] for some stochastic processes \\(\\alpha\\) and \\(\\theta\\), where \\(B\\) is a standard Brownian motion. Then, from our previous rules, \\((\\mathrm{d} X)^2 = \\theta^2\\mathrm{d} t\\). Ito’s formula in this more general case takes the same form as Calculation Rule \\(\\ref{ruleito1}\\), replacing the Brownian motion \\(B\\) with the Ito process \\(X\\).\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(f(t, X)\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X\\) and \\(Y_t= f(t, X_t)\\) where \\(X\\) is an Ito process, then \\[\\mathrm{d} Y = \\frac{\\partial f(t, X)}{\\partial t}\\mathrm{d} t + \\frac{\\partial f(t, X)}{\\partial X}\\mathrm{d} X + \\frac{1}{2} \\frac{\\partial^2 f(t, X)}{\\partial X^2}(\\mathrm{d} X)^2\\,.\n\\qquad(6.25)\\]\n\n\nWe can write Equation 6.25 in terms of \\(\\mathrm{d} t\\) and \\(\\mathrm{d} B\\) terms by substituting from Equation 6.24 and using \\((\\mathrm{d} X)^2 = \\theta^2\\mathrm{d} t\\). This produces \\[\\mathrm{d} Y = \\left(\\frac{\\partial f(t, X)}{\\partial t} + \\alpha\\frac{\\partial f(t, X)}{\\partial X} + \\frac{1}{2}\\theta^2 \\frac{\\partial^2 f(t, X)}{\\partial X^2}\\right)\\mathrm{d} t + \\theta\\frac{\\partial f(t, X)}{\\partial X}\\mathrm{d} B\\,.\\]\nHere are some important examples of Ito’s formula.\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y = X^\\alpha\\) for a constant \\(\\alpha\\), then \\[\\mathrm{d} Y = \\alpha X^{\\alpha-1}\\mathrm{d} X + \\frac{1}{2}\\alpha (\\alpha - 1)X^{\\alpha-2}(\\mathrm{d} X)^2\\,.\\] This is equivalent to \\[\\frac{\\mathrm{d} Y}{Y} = \\alpha \\frac{\\mathrm{d} X}{X} + \\frac{\\alpha(\\alpha-1)}{2}\\left(\\frac{\\mathrm{d} X}{X}\\right)^2\\,.\n\\] {#ito-powerformula}\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y=\\mathrm{e}^X\\), then \\[\\frac{\\mathrm{d}  Y}{Y}=\\mathrm{d}  X + \\frac{(\\mathrm{d}  X)^2}{2}\\;.\n\\qquad(6.26)\\]\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Y=\\log X\\), then \\[\n\\mathrm{d}  Y=\\frac{\\mathrm{d}  X}{X} - \\frac{1}{2}\\left(\\frac{\\mathrm{d}  X}{X}\\right)^2\\;.\n\\qquad(6.27)\\]\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\nWe showed in the previous Example that \\(X\\) defined in Equation 6.6 satisfies Equation 6.5, but it is also useful to see how we can start from Equation 6.5 and deduce that Equation 6.6 is the solution. We can do that by taking logarithms. Set \\(Y_t = \\log X_t\\). Then, using Equation 6.27 and substituting from Equation 6.5, we have \\[\\mathrm{d} \\log X = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d} t + \\sigma\\mathrm{d} B\\,.\\] There is no \\(X\\) on the right-hand side of this, so we can simply integrate to compute \\(\\log X_t\\) as \\[\\log X_t = \\log X_0 + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\,.\\] Exponentiating gives Equation 6.6.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#functions-of-time-and-multiple-ito-processes",
    "href": "Chapter_Ito.html#functions-of-time-and-multiple-ito-processes",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.7 Functions of Time and Multiple Ito Processes",
    "text": "6.7 Functions of Time and Multiple Ito Processes\nUsing Equation 6.16 for products of differentials, we can state Ito’s formula for a function of time and two Ito processes as follows.\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf \\(Y_t = f(t, X_{1t}, X_{2t})\\) where \\(X_1\\) and \\(X_2\\) are Ito processes and \\(f\\) is continuously differentiable in \\(t\\) and twice continuously differentiable in \\(X_1\\) and \\(X_2\\), then \\[\\begin{multline}\n\\mathrm{d}  Y =  \\frac{\\partial f}{\\partial t}\\mathrm{d}   t + \\frac{\\partial f}{\\partial X_1}\\mathrm{d}   X_1 +  \\frac{\\partial f}{\\partial X_2}\\mathrm{d}   X_2 \\\\+ \\frac{1}{2} \\frac{\\partial^2 f}{\\partial X_1^2}\\,(\\mathrm{d}  X_1)^2 +  \\frac{1}{2}  \\frac{\\partial^2 f}{\\partial X_2^2}\\,(\\mathrm{d}  X_2)^2\n+ \\frac{\\partial^2 f}{\\partial X_1\\partial X_2}\\,(\\mathrm{d}  X_1)(\\mathrm{d}  X_2)\\;.\n\\end{multline} \\qquad(6.28)\\]\n\n\nThis is analogous to a second-order Taylor series expansion in the variables \\(X_1\\) and \\(X_2\\). A similar formula applies to functions of more two Ito processes. We just need to include a term for each \\(\\mathrm{d} X_i\\), each \\((\\mathrm{d} X_i)^2\\) and each \\((\\mathrm{d} X_i)(\\mathrm{d} X_j)\\).\nHere are some important examples. We switch notation from \\(X_1\\) and \\(X_2\\) to \\(X\\) and \\(Y\\) and from \\(Y\\) to \\(Z\\) so we can drop the subscripts. These formulas follow from Equation 6.28 by taking \\(f(x,y)=xy\\) or \\(f(x,y)=y/x\\).\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Z=XY\\), then \\(\\mathrm{d}  Z=X\\mathrm{d}   Y+Y\\mathrm{d}   X + (\\mathrm{d}  X)(\\mathrm{d}  Y)\\). We can write this as \\[\n\\frac{\\mathrm{d}  Z}{Z}=\\frac{\\mathrm{d}  X}{X} + \\frac{\\mathrm{d}  Y}{Y} + \\left(\\frac{\\mathrm{d}  X}{X}\\right)\\left(\\frac{\\mathrm{d}  Y}{Y}\\right)\\;.\n\\qquad(6.29)\\]\n\n\n\n\n\n\n\n\nKey Result\n\n\n\nIf \\(Z=Y/X\\), then \\[\\frac{\\mathrm{d}  Z}{Z} = \\frac{\\mathrm{d}  Y}{Y} -\\frac{\\mathrm{d}  X}{X} - \\left(\\frac{\\mathrm{d}  Y}{Y}\\right)\\left(\\frac{\\mathrm{d}  X}{X}\\right) + \\left(\\frac{\\mathrm{d}  X}{X}\\right)^2\\;.\n\\qquad(6.30)\\]\n\n\nThe following is a special case of Equation 6.29 that we encounter often.\n\n\n\n\n\n\nKey Result\n\n\n\nLet\n\\[Y_t =\\exp\\left(\\int_0^t q_s\\mathrm{d}   s\\right)\\] for some (possibly random) process \\(q\\) and define \\(Z=XY\\) for any Ito process \\(X\\). Equation 6.29 gives us \\[\n\\frac{\\mathrm{d}  Z}{Z}=q\\mathrm{d}   t + \\frac{\\mathrm{d}  X}{X}\\;.\n\\qquad(6.31)\\] This is the same as in the usual calculus.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#exercises",
    "href": "Chapter_Ito.html#exercises",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "6.8 Exercises",
    "text": "6.8 Exercises\n\nExercise 6.1 Ito’s Lemma can be used in different ways to get the same answer. For example, let \\(X_t = a t + b B_t\\) and use Ito’s lemma on the function \\(e^{X_t}\\). Alternatively, let \\(f(t, B_t) = e^{a t + bB_t}\\). Use Ito’s lemma on \\(f(,)\\).\n\n\nExercise 6.2 Let \\(\\mathrm{d} X_t = \\mu X_t \\mathrm{d} t + \\sigma X_t \\mathrm{d} B_t\\). Use Ito’s lemma to find \\(\\log(X_t)\\) . What is the expected value and variance of \\(\\log(X_t)\\) ?",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_Ito.html#footnotes",
    "href": "Chapter_Ito.html#footnotes",
    "title": "6  Ito Processes and Ito’s Formula",
    "section": "",
    "text": "In a more formal mathematical presentation, one normally writes \\(\\mathrm{d} \\langle X,X\\rangle\\) for what we are writing here as \\((\\mathrm{d}  X)^2\\). This is the differential of the quadratic variation process, and the quadratic variation through date \\(t\\) is \\[\n\\langle X,X\\rangle _t = \\int_0^t \\mathrm{d} \\langle X,X\\rangle_s = \\int_0^t \\sigma^2_s\\mathrm{d}   s\\;.\n\\] Our mnenomic device of squaring differentials leads us to the correct formula.↩︎\nA somewhat more precise definition than our previous description of the stochastic integral \\(\\int_0^t \\sigma_{1,t} dB_{1t}\\) is when Equation 6.9 holds, the stochastic integral is the (unique) martingale with joint variation with any other Ito process given by Equation 6.17.↩︎",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ito Processes and Ito's Formula</span>"
    ]
  },
  {
    "objectID": "Chapter_GeometricBrownianMotion.html",
    "href": "Chapter_GeometricBrownianMotion.html",
    "title": "7  Geometric Brownian Motion",
    "section": "",
    "text": "7.1 Continuously Compounded Returns\nA random variable \\(\\tilde{y}\\) is lognormally distributed if it can be written as \\(\\tilde{y}=  \\mathrm{e}^{\\tilde{x}}\\) where \\(\\tilde{x}\\) has a normal distribution. Another way of saying this is that \\(\\log \\tilde y\\) is normally distributed. We denote the expected value (mean) of any random variable using the symbol \\(\\mathbb{E}\\). The mean of a lognormal random variable is given by the following.\nAn example of the distribution of a lognormal random variable is shown in Figure 7.1.\nAn important stochastic process is geometric Brownian motion given by \\[\nS_t=S_0\\mathrm{e}^{\\mu t- \\sigma^2 t/2 + \\sigma B_t}\n\\qquad(7.2)\\] for constants \\(\\mu\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion. For each time \\(t\\), the random variable \\(S_t\\) in Equation 7.2 is a lognormal random variable. Ito’s formula for exponentials of Ito processes implies \\[\n\\frac{\\mathrm{d}  S}{S} = \\mu\\mathrm{d}   t+\\sigma\\mathrm{d}   B\\;.\n\\qquad(7.3)\\] When we see an equation of the form Equation 7.3, we should recognize Equation 7.2 as the solution.\nThe process \\(S\\) is called a geometric Brownian motion. We interpret Equation 7.3 as stating that \\(\\mu\\mathrm{d}   t\\) is the expected rate of change of \\(S\\) and \\(\\sigma^2\\mathrm{d}   t\\) is the variance of the rate of change in an instant \\(\\mathrm{d}  t\\). We call \\(\\mu\\) the drift and \\(\\sigma\\) the volatility. The geometric Brownian motion grows at the average rate of \\(\\mu\\), in the sense that \\(\\mathbb{E}[S_t] = \\mathrm{e}^{\\mu t}S_0\\). This can be verified with the aid of Equation 7.1.\nIf \\(\\mu=0\\), then \\(\\mathbb{E}[S_t] = S_0\\). In fact, a geometric Brownian motion \\(S\\) as in Equation 7.2 and Equation 7.3 is a martingale when \\(\\mu=0\\). It is an example of what is called an exponential martingale. An exponential is always positive, so an exponential martingale is always positive.\nTaking the natural logarithm of Equation 7.2 gives an equivalent form of the solution: \\[\n\\log S_t= \\log S_0+\\left(\\mu -\\frac{1}{2}\\sigma^2\\right)t + \\sigma B_t\\;.\n\\qquad(7.4)\\] This shows that \\(\\log S_t - \\log S_0\\) is a \\((\\mu-\\sigma^2/2,\\sigma)\\)–Brownian motion. Given information at time \\(t\\), the logarithm of \\(S(u)\\) for \\(u&gt;t\\) is normally distributed with mean \\((u-t)(\\mu-\\sigma^2/2)\\) and variance \\((u-t)\\sigma^2\\). Because \\(S\\) is the exponential of its logarithm, \\(S\\) can never be negative. For this reason, a geometric Brownian motion is a better model for stock prices than is a Brownian motion. The differential of Equation 7.4 is \\[\n\\mathrm{d}  \\log S_t = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\mathrm{d}   t+ \\sigma\\mathrm{d}   B_t\\;.\n\\qquad(7.5)\\]\nWe can summarize this discussion as follows.\nWe can simulate a path of a geometric Brownian motion \\(S\\) by first simulating \\(\\log S\\) and then computing the exponential. We simulate the changes \\(\\Delta \\log S\\) as normally distributed random variables with mean equal to \\((\\mu-\\sigma^2/2)\\Delta t\\) and variance equal to \\(\\sigma^2\\Delta t\\). We could also simulate the changes \\(\\Delta \\log S\\) using a binomial model as in Section 5.2.\nGiven a rate of return \\(r\\) over a time period of \\(\\Delta t\\) years, the annualized continuously compounded return is defined to be the number \\(x\\) such that \\(\\mathrm{e}^{x\\Delta t} = 1+r\\); equivalently, \\(x = \\log(1+r) / \\Delta t\\). We frequently take annualized for granted and just say continuously compounded return. As an example, if you earn 1% in a month, then the continuously compounded return is \\(\\log (1.01) / (1/12) = 0.1194\\).\nThe reason for the name continuously compounded is that compounding a monthly rate of interest of \\(0.1194/12\\) for a total of \\(n\\) times during a month produces a total return over the month of \\[\\left(1 + \\frac{0.1194/12}{n}\\right)^ n - 1\\,,\\] which converges to \\(0.01\\) as \\(n \\rightarrow \\infty\\). Thus, compounding an infinite number of times during a month at an annual rate of \\(0.1194\\) (equal to a monthly rate of \\(0.1194/12\\)) is equivalent to the actual 1% return.1\nGiven a dividend-reinvested asset price \\(S\\), the rate of return from date \\(t_1\\) to \\(t_2\\) is \\(S_{t_2}/S_{t_1} - 1\\). Denote this rate of return by \\(r\\) and defined the corresponding continuously compounded return \\[x = \\log(1+r) = \\log\\left(\\frac{S_{t_2}}{S_{t_1}}\\right) = \\log S_{t_2} - \\log S_{t_1}\\,.\\] Using Equation 7.4, we see that the continuously compounded return is \\[\nx = \\log S_{t_2} - \\log S_{t_1} = \\left(\\mu -\\frac{1}{2}\\sigma^2\\right)(t_2-t_1)+ \\sigma\\,(B_{t_2} - B_{t_1})\\;.\n\\qquad(7.6)\\] Thus, from the vantage point of date \\(t_1\\), the continuously compounded return is normally distributed with mean \\[\\left(\\mu -\\frac{1}{2}\\sigma^2\\right)\\Delta t\\] and variance \\(\\sigma^2 \\Delta t\\), where we define \\(\\Delta t = t_2-t_1\\). Given historical data on rates of return, the parameters \\(\\mu\\) and \\(\\sigma\\) can be estimated by standard methods.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GeometricBrownianMotion.html#sec-tailprobs",
    "href": "Chapter_GeometricBrownianMotion.html#sec-tailprobs",
    "title": "7  Geometric Brownian Motion",
    "section": "7.2 Tail Probabilities of Geometric Brownian Motions",
    "text": "7.2 Tail Probabilities of Geometric Brownian Motions\nFor each of the numeraires discussed in the previous section, we have \\[\n\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\;,\n\\qquad(7.7)\\]\nfor some \\(\\alpha\\) and \\(\\sigma\\), where \\(B\\) is a Brownian motion under the probability measure associated with the numeraire. Specifically, \\(\\sigma=\\sigma\\), \\(B=B^*\\), and\n\nfor the risk-neutral probability, \\(\\alpha = r-q-\\sigma^2/2\\),\nwhen \\(\\mathrm{e}^{qt}S_t\\) is the numeraire, \\(\\alpha = r-q +\\sigma^2/2\\),\nwhen another risky asset price \\(Y\\) is the numeraire, \\(\\alpha = r-q+\\rho\\sigma\\phi-\\sigma^2/2\\).\n\nWe will assume in this section that \\(\\alpha\\) and \\(\\sigma\\) are constants. The essential calculation in pricing options is to compute \\(\\text{prob}(S_t&gt;K)\\) and \\(\\text{prob}(S_t&lt;K)\\) for a constant \\(K\\) (the strike price of an option), where \\(\\text{prob}\\) denotes the probabilities at date \\(0\\) (the date we are pricing an option) associated with a particular numeraire.\nEquation 7.7 gives us \\[\\log S_t = \\log S_0 + \\alpha T + \\sigma B_t\\; .\\] Given this, we deduce\n\\[\nS_t &gt; K  \\quad\\Longleftrightarrow\\quad \\log S_t &gt; \\log K\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\sigma B_t &gt; \\log K - \\log S_0-\\alpha T\n\\] \\[\n\\quad\\Longleftrightarrow\\quad \\frac{B_t}{\\sqrt{T}} &gt; \\frac{\\log K - \\log S_0-\\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log S_0-\\log K + \\alpha T}{\\sigma\\sqrt{T}}\n\\] \\[\n\\quad\\Longleftrightarrow\\quad -\\frac{B_t}{\\sqrt{T}} &lt; \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(7.8)\\]\nThe random variable on the left-hand side of Equation 7.8 has the standard normal distribution—it is normally distributed with mean equal to zero and variance equal to one. As is customary, we will denote the probability that a standard normal is less than some number \\(d\\) as \\(\\mathrm{N}(d)\\). We conclude:\n\n\n\n\n\n\nKey Result\n\n\n\nAssume \\(\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&gt;K) = \\mathrm{N}(d)\\;,\n\\qquad(7.9)\\] where \\[\nd = \\frac{\\log \\left(\\frac{S_0}{K}\\right) + \\alpha T}{\\sigma\\sqrt{T}}\\;.\n\\qquad(7.10)\\]\n\n\nThe probability \\(\\text{prob}(S_t&lt;K)\\) can be calculated similarly, but the simplest way to derive it is to note that the events \\(S_t&gt;K\\) and \\(S_t&lt;K\\) are complementary—their probabilities sum to one (the event \\(S_t=K\\) having zero probability). Therefore \\(\\text{prob}(S_t&lt;K) = 1-\\mathrm{N}(d)\\). This is the probability that a standard normal is greater than \\(d\\), and by virtue of the symmetry of the standard normal distribution, it equals the probability that a standard normal is less than \\(-d\\). Therefore, we have:\n\n\n\n\n\n\nKey Result\n\n\n\nAssume \\(\\mathrm{d}  \\log S = \\alpha\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\), where \\(B\\) is a Brownian motion. Then, for any number \\(K\\), \\[\n\\text{prob}(S_t&lt;K) = \\mathrm{N}(-d)\\;,\n\\qquad(7.11)\\] where \\(d\\) is defined in Equation 7.10.",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GeometricBrownianMotion.html#exercises",
    "href": "Chapter_GeometricBrownianMotion.html#exercises",
    "title": "7  Geometric Brownian Motion",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\nExercise 7.1 Use Ito’s Lemma to derive the stochastic differential equation for \\(S_t^2\\). Show that \\(S(t)^2\\) is a geometric Brownian motion if \\(\\mu\\) and \\(\\sigma\\) are constants and find \\(\\mathbb{E}[S(t)^2]\\).\n\n\nExercise 7.2 Let \\[\\begin{align*}\n\\frac{\\mathrm{d} S_1}{S_1} &= \\mu_1\\mathrm{d} t + \\sigma_1 \\mathrm{d} B_1\\\\\n\\frac{\\mathrm{d} S_2}{S_2} &= \\mu_1\\mathrm{d} t + \\sigma_2 \\mathrm{d} B_2\n\\end{align*}\\] where the \\(\\mu_i\\) and \\(\\sigma_i\\) are constants and \\(B_1\\) and \\(B_2\\) are Brownian motions with constant correlation \\(\\rho\\).\n\nDefine \\(Y=S_1S_2\\). Show that \\(Y\\) is a geometric Brownian motion and calculate its drift and volatility.\nRepeat for \\(Y=S_1/S_2\\).\n\nHint: use the facts \\(\\mathrm{e}^{x+y}=\\mathrm{e}^x \\times \\mathrm{e}^y\\) and \\(\\mathrm{e}^x/\\mathrm{e}^y = \\mathrm{e}^{x-y}\\).\n\n:",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_GeometricBrownianMotion.html#footnotes",
    "href": "Chapter_GeometricBrownianMotion.html#footnotes",
    "title": "7  Geometric Brownian Motion",
    "section": "",
    "text": "The reason for considering this concept is that compound returns like \\((1+r_1)(1+r_2)\\) are simpler to analyze in some contexts as \\(\\mathrm{e}^{x_1+x_2}\\).↩︎",
    "crumbs": [
      "Part 2: Mathematical Foundations",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Geometric Brownian Motion</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html",
    "href": "Chapter_ArbitragePricing.html",
    "title": "8  Arbitrage Pricing",
    "section": "",
    "text": "8.1 Linear Pricing\nThis chapter develops the fundamental principles of arbitrage pricing, starting from the concept of linear pricing and building up to continuous-time models with change of numeraire.\nThe fundamental concept underlying most finance theory, from Miller-Modigliani to the Black-Scholes model, is linear pricing. The concept of linear pricing is essentially the same as asking for the price of five apples and six oranges. Of course, this is the price of one apple times five plus the price of one orange times six. However, instead of pricing bundles of commodities today, we will find prices of dollars in different contingencies at times in the future.\nAn arbitrage opportunity is a trading strategy that produces nonnegative cash flows at all times in all contingencies with a strictly positive cash flow at some time in some contingency. If such an opportunity were to exist, traders would exploit it until prices adjust to eliminate the possibility. Although simple, this has powerful implications.\nConsider a world where there are \\(J\\) possible states of the world at time \\(t\\). No arbitrage then implies the following properties:\nThis conclusion generalizes to other models, including models in which the stock price takes a continuum of possible values, interpreting the sum in that case as an integral.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#linear-pricing",
    "href": "Chapter_ArbitragePricing.html#linear-pricing",
    "title": "8  Arbitrage Pricing",
    "section": "",
    "text": "If \\(X\\) and \\(Y\\) are time \\(t\\) random cash flows, the time 0 price of the random cash flow \\(aX+bY\\) is \\(a\\) times the time 0 price of \\(X\\) plus \\(b\\) times the time 0 price of \\(Y\\). If \\(P(\\cdot)\\) is a pricing function that gives us the price of a random cash flow today, then \\(P(aX+bY)=aP(X) + bP(Y)\\). In other words, the pricing operator is linear. This follows because if this fails to hold, there is an arbitrage assuming an agent can buy and sell any quantities at these prices. Because the pricing operator is linear, it must have the form \\(P(X) = \\sum_{j=1}^J \\pi_j X_j\\) where \\(X_j\\) is the random cash flow in state~\\(j\\). We call \\(\\pi_j\\) the price of a dollar at time \\(t\\) in state \\(j\\) or a state price.\nThe price of any positive nonzero random cash flow at time \\(t\\) is strictly positive. Again, this follows from no arbitrage (think how much of an asset paying a positive dividend you would want if it were free or even if you were paid to take the asset). This implies the state prices are strictly positive.\nThe pricing operator obeys time value of money: \\(1=\\sum_{j=1}^J \\pi_j e^{rt}\\), where \\(r\\) is the continuously compounded yield to maturity of a bond maturing at \\(t\\). This is the present value rule: the present value of the future value \\(e^{rt}\\) is one or, equivalently, the present value of a dollar paid at \\(t\\) is \\(e^{-rt}\\).\nThe pricing operator must be consistent with observable prices. The price \\(S_0\\) of a traded asset with random cash flows at time \\(t\\) is given by \\(S_0= \\sum_{j=1}^J \\pi_j S_j\\) where \\(S_j\\) is the random cash flow in state \\(j\\).\n\n\n\n\n\n\n\nImportant Principle\n\n\n\nIn the absence of arbitrage opportunities, there exist positive state prices such that the price of any security is the sum across the states of the world of its payoff multiplied by the state price.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#state-prices-in-the-binomial-model",
    "href": "Chapter_ArbitragePricing.html#state-prices-in-the-binomial-model",
    "title": "8  Arbitrage Pricing",
    "section": "8.2 State Prices in the Binomial Model",
    "text": "8.2 State Prices in the Binomial Model\nIn the single-period binomial model with up and down states, we have two equations for the state prices \\(\\pi_u\\) and \\(\\pi_d\\):\n\\[ 1 = \\pi_u e^{rt} + \\pi_d e^{rt} \\] \\[ S = \\pi_u S_u + \\pi_d S_d \\]\nThe first equation prices the risk-free asset (invest $1 today, receive \\(e^{rt}\\) in both states). The second prices the stock.\nSolving these equations gives:\n\\[\\pi_u  = \\frac{S-e^{-rt}S_d}{S_u - S_d}, \\quad \\pi_d = \\frac{e^{-rt}S_u-S}{S_u - S_d}\\]\nNotice that the requirement \\(\\pi_u, \\pi_d &gt; 0\\) is precisely the no-arbitrage condition:\n\\[\\frac{S_u}{S} &gt; e^{rt} &gt; \\frac{S_d}{S}\\]\nWe can think of any security as a portfolio of Arrow securities. An Arrow security pays $1 at time \\(t\\) if a specific state occurs and pays nothing otherwise. In our binomial model, \\(\\pi_u\\) is the price of an Arrow security paying $1 in the up state, and \\(\\pi_d\\) is the price of an Arrow security paying $1 in the down state.\nFor any derivative with payoffs \\(C_u\\) and \\(C_d\\):\n\\[C = \\pi_u C_u + \\pi_d C_d\\]\n\nRisk-Neutral Probabilities\nDefine \\(p_u = \\pi_u e^{rt}\\) and \\(p_d = \\pi_d e^{rt}\\). Since \\(p_u + p_d = 1\\) and both are positive, we can interpret them as probabilities—the risk-neutral probabilities. Then:\n\\[C = e^{-rt}[p_u C_u + p_d C_d]\\]\nThe asset price equals its expected payoff discounted at the risk-free rate, where the expectation uses risk-neutral probabilities. Note that:\n\\[p_u = \\frac{e^{rt} - S_d/S}{S_u/S - S_d/S}\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#multiple-states",
    "href": "Chapter_ArbitragePricing.html#multiple-states",
    "title": "8  Arbitrage Pricing",
    "section": "8.3 Multiple States",
    "text": "8.3 Multiple States\nNow consider a market with \\(J &gt; 2\\) possible states at time \\(t\\). We need to find \\(J\\) state prices \\(\\pi_1, \\ldots, \\pi_J\\). If we have \\(J\\) traded assets (including the risk-free asset) with linearly independent payoffs, we can solve:\n\\[\\begin{bmatrix}\ne^{rt} & e^{rt} & \\cdots & e^{rt} \\\\\nS_1^{(1)} & S_2^{(1)} & \\cdots & S_J^{(1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nS_1^{(J-1)} & S_2^{(J-1)} & \\cdots & S_J^{(J-1)}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\pi_1 \\\\ \\pi_2 \\\\ \\vdots \\\\ \\pi_J\n\\end{bmatrix} =\n\\begin{bmatrix}\n1 \\\\ S^{(1)} \\\\ \\vdots \\\\ S^{(J-1)}\n\\end{bmatrix}\\]\nwhere \\(S^{(i)}\\) is the current price of asset \\(i\\) and \\(S_j^{(i)}\\) is its payoff in state \\(j\\).\nWith state prices determined, we can value any derivative:\n\\[V = \\sum_{j=1}^J \\pi_j V_j\\]\nThe risk-neutral probabilities are \\(p_j = \\pi_j e^{rt}\\), giving:\n\\[V = e^{-rt} \\sum_{j=1}^J p_j V_j = e^{-rt} \\mathbb{E}^p[V_t]\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#martingale-pricing",
    "href": "Chapter_ArbitragePricing.html#martingale-pricing",
    "title": "8  Arbitrage Pricing",
    "section": "8.4 Martingale Pricing",
    "text": "8.4 Martingale Pricing\nA martingale is a stochastic process for which the expected value of tomorrow’s value is today’s value. In our framework, discounted values of non-dividend paying trading strategies are martingales under the risk-neutral measure.\nIf \\(X(0)\\) is today’s value of a portfolio with random payoff \\(X\\) at time \\(t\\):\n\\[\\frac{X(0)}{R(0)} = \\sum_{s=1}^S p_s \\frac{X_s}{e^{rt}} = \\mathbb{E}^R\\left[\\frac{X}{R_t}\\right]\\]\nwhere \\(R(0) = 1\\) and \\(R_t = e^{rt}\\). The ratio of any asset price to the risk-free asset price is a martingale under the risk-neutral measure.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#continuous-time",
    "href": "Chapter_ArbitragePricing.html#continuous-time",
    "title": "8  Arbitrage Pricing",
    "section": "8.5 Continuous Time",
    "text": "8.5 Continuous Time\nWe now extend to continuous-time models where the stock price can take a continuum of values. The principle becomes:\n\n\n\n\n\n\nImportant Principle\n\n\n\nIf there are no arbitrage opportunities, then there exists for each date \\(t\\) a strictly positive random variable \\(m_t\\), called a stochastic discount factor, such that the date-0 value of any dividend-reinvested asset with price \\(P\\) is:\n\\[P_0 = \\mathbb{E}[m_t P_t]\\]\n\n\nThe stochastic discount factor \\(m_t\\) generalizes state prices to continuous distributions. For a finite number of states, \\(m_t = \\pi_j/\\text{prob}_j\\) in state \\(j\\), where \\(\\text{prob}_j\\) is the actual probability.\n\nConnection to Risk-Neutral Probabilities\nThe risk-free asset satisfies:\n\\[1 = \\mathbb{E}[m_t e^{rt}]\\]\nThis means \\(m_t e^{rt}\\) has expectation 1. We can define a new probability measure by:\n\\[\\mathbb{E}^R[Z] = \\mathbb{E}[m_t e^{rt} Z]\\]\nfor any random variable \\(Z\\). Under this risk-neutral measure:\n\\[P_0 = e^{-rt} \\mathbb{E}^R[P_t]\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#change-of-numeraire",
    "href": "Chapter_ArbitragePricing.html#change-of-numeraire",
    "title": "8  Arbitrage Pricing",
    "section": "8.6 Change of Numeraire",
    "text": "8.6 Change of Numeraire\nOur choice of the risk-free asset as numeraire was arbitrary. Any strictly positive non-dividend paying trading strategy can serve as a numeraire.\nFor a dividend-reinvested asset \\(Y\\) with strictly positive value:\n\\[Y(0) = \\mathbb{E}[m_t Y_t]\\]\nDefine new probabilities by:\n\\[\\text{prob}^Y_s = \\frac{\\mathbb{E}[m_t Y_t \\mathbf{1}_{\\{s\\}}]}{Y(0)}\\]\nwhere \\(\\mathbf{1}_{\\{s\\}}\\) is the indicator function for state \\(s\\). Then:\n\\[S(0) = Y(0) \\mathbb{E}^Y\\left[\\frac{S_t}{Y_t}\\right]\\]\nThe ratio \\(S_t/Y_t\\) is a martingale under the probability measure induced by using \\(Y\\) as numeraire.\n\nFundamental Pricing Formula\n\n\n\n\n\n\nImportant Principle\n\n\n\nIn the absence of arbitrage opportunities, prices \\(P\\) and \\(Y\\) of dividend-reinvested assets satisfy, for all \\(s &lt; t\\):\n\\[Y_s = P_s \\mathbb{E}^P_s \\left[\\frac{Y_t}{P_t}\\right]\\]\n\n\nThis is the fundamental pricing formula. The value at time \\(s\\) of asset \\(Y\\) is the expectation, under the appropriate probability measure, of its value \\(Y_t\\) at time \\(t\\) discounted by the factor \\(P_s/P_t\\).\nWhen \\(P\\) is the risk-free asset:\n\\[Y_s = e^{-r(t-s)} \\mathbb{E}^R_s[Y_t]\\]\n\n\nChanging Probability Measures\nFor continuous distributions, the probability of event \\(A\\) using \\(S\\) as numeraire is:\n\\[\\text{prob}^S(A) = \\mathbb{E}\\left[\\mathbf{1}_A m_t \\frac{S_t}{S_0}\\right]\\]\nThe expectation of any random variable \\(X\\) using \\(S\\) as numeraire is:\n\\[\\mathbb{E}^S[X] = \\mathbb{E}\\left[X m_t \\frac{S_t}{S_0}\\right]\\]\nDifferent numeraires lead to different probability measures but the same derivative prices.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#stock-as-numeraire",
    "href": "Chapter_ArbitragePricing.html#stock-as-numeraire",
    "title": "8  Arbitrage Pricing",
    "section": "8.7 Stock as Numeraire",
    "text": "8.7 Stock as Numeraire\nUsing the stock as numeraire is particularly useful for certain derivatives. In the binomial model, define:\n\\[\\text{prob}^S_u = \\frac{\\pi_u S_u}{S}, \\quad \\text{prob}^S_d = \\frac{\\pi_d S_d}{S}\\]\nThese sum to 1 and are positive. For a call option:\n\\[\\frac{C}{S} = \\text{prob}^S_u \\frac{C_u}{S_u} + \\text{prob}^S_d \\frac{C_d}{S_d}\\]\nThe ratio \\(C/S\\) (number of shares the call is worth) is a martingale under the stock numeraire measure.\nIn continuous time, for any derivative \\(V\\) on stock \\(S\\):\n\\[V_0 = S_0 \\mathbb{E}^S\\left[\\frac{V_T}{S_T}\\right]\\]\nThis formulation is often convenient for options that depend on the stock price relative to some level.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#changes-of-probability-and-girsanovs-theorem",
    "href": "Chapter_ArbitragePricing.html#changes-of-probability-and-girsanovs-theorem",
    "title": "8  Arbitrage Pricing",
    "section": "8.8 Changes of Probability and Girsanov’s Theorem",
    "text": "8.8 Changes of Probability and Girsanov’s Theorem\nWhen we change probability measures, we cannot expect a process \\(B\\) that was a Brownian motion to remain a Brownian motion. The expected change in a Brownian motion must always be zero, but when we change probabilities, the expected change of \\(B\\) is likely to become nonzero. However, the Brownian motion \\(B\\) will still be an Ito process under the new probability measure.\nChanging probabilities only changes the drift of an Ito process—the diffusion coefficient remains unchanged. This is because the diffusion coefficient determines how much each path “jiggles,” which is unaffected by changing the probability measure.\n\nExample: Risk-Neutral Probability\nSuppose the stock price follows:\n\\[\\frac{\\mathrm{d}S}{S} = \\mu \\mathrm{d}t + \\sigma \\mathrm{d}B\\]\nwhere \\(B\\) is a Brownian motion under the actual probability measure. Under the risk-neutral measure, the drift must be the risk-free rate \\(r\\):\n\\[\\frac{\\mathrm{d}S}{S} = r \\mathrm{d}t + \\sigma \\mathrm{d}B^*\\]\nwhere \\(B^*\\) is a Brownian motion under the risk-neutral probability.\nThe details of how to construct these new probability measures using Girsanov’s Theorem are covered in the next chapter, where we apply them to derive the Black-Scholes formula.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#exercises",
    "href": "Chapter_ArbitragePricing.html#exercises",
    "title": "8  Arbitrage Pricing",
    "section": "8.9 Exercises",
    "text": "8.9 Exercises\n\nLinear Pricing and State Prices\n\nExercise 8.1 Consider a market with 3 possible states at time \\(T = 1\\). There are two traded assets: - Risk-free bond: pays \\(e^{0.05}\\) in all states\n- Risky asset: pays \\((10, 15, 5)\\) in states \\((1, 2, 3)\\) respectively, currently priced at \\(S_0 = 9\\)\n\nSet up the system of equations to find state prices \\((\\pi_1, \\pi_2, \\pi_3)\\)\nSolve for the state prices\nFind the risk-neutral probabilities \\((p_1, p_2, p_3)\\)\nPrice a derivative that pays \\((0, 20, 0)\\) in the three states\nVerify that the risk-neutral expected return on the risky asset equals the risk-free rate\n\n\n\nExercise 8.2 In the three-state model from the previous exercise: a) What is the price of an Arrow security that pays $1 in state 2 and $0 in states 1 and 3? b) Show that any derivative payoff can be written as a portfolio of Arrow securities c) Price a “digital option” that pays $100 if the risky asset’s payoff exceeds $12, and $0 otherwise d) Compare this to pricing the same payoff using risk-neutral probabilities\n\n\nExercise 8.3 Consider a two-period binomial model where the stock can go from \\(S_0 = 100\\) to either \\(S_u = 120\\) or \\(S_d = 80\\) in the first period, with risk-free rate \\(r = 5\\%\\) per period.\n\nFind the no-arbitrage bounds: show that \\(S_d &lt; S_0 e^r &lt; S_u\\) must hold\nCalculate the risk-neutral probability \\(p\\) for the up move\nIf the stock goes to \\(S_u = 120\\) in the first period, it can go to \\(S_{uu} = 144\\) or \\(S_{ud} = 96\\) in the second period. If the stock goes to \\(S_d = 80\\), it can go to \\(S_{du} = 96\\) or \\(S_{dd} = 64\\). Verify that the tree recombines (\\(S_{ud} = S_{du}\\))\nCalculate the state prices for all four final states: \\((\\pi_{uu}, \\pi_{ud}, \\pi_{du}, \\pi_{dd})\\)\n\n\n\n\nRisk-Neutral Measures and Martingales\n\nExercise 8.4 In the Black-Scholes model with constant dividend yield \\(q\\), show that: a) \\(e^{-qt}S_t\\) is a martingale under the risk-neutral measure b) \\(S_t/R_t\\) is a martingale under the risk-neutral measure, where \\(R_t = e^{rt}\\) c) If \\(V_t\\) is the value of any derivative, then \\(e^{-rt}V_t\\) is a martingale under the risk-neutral measure\n\n\nExercise 8.5 Use simulation to verify the martingale property in a simple setting. Generate 10,000 paths of geometric Brownian motion under the risk-neutral measure: \\[\\frac{dS}{S} = (r-q) dt + \\sigma dB^R\\]\nWith parameters \\(S_0 = 100\\), \\(r = 5\\%\\), \\(q = 2\\%\\), \\(\\sigma = 20\\%\\), and \\(T = 1\\):\n\nVerify that \\(\\mathbb{E}^R[S_T e^{-qT}] \\approx S_0\\) (martingale property)\nVerify that \\(\\mathbb{E}^R[e^{-rT}S_T] \\approx S_0 e^{-qT}\\) (discounted expectation)\nCalculate the sample variance of both expressions and comment on the simulation error\n\n\n\n\nChange of Numeraire\n\nExercise 8.6 Use simulation to verify the change of numeraire for digital options. Consider a digital option that pays \\(1\\) if \\(S_T \\geq K\\) with \\(S_0 = 100\\), \\(K = 105\\), \\(r = 5\\%\\), \\(q = 2\\%\\), \\(\\sigma = 20\\%\\), \\(T = 0.5\\).\nPrice this option using two methods: a) Risk-neutral measure: \\(\\mathbb{E}^R[e^{-rT} \\mathbf{1}_{\\{S_T \\geq K\\}}]\\) b) Stock numeraire: \\(S_0 \\mathbb{E}^S[\\frac{1}{S_T} \\mathbf{1}_{\\{S_T \\geq K\\}}]\\)\nUnder the stock numeraire, the stock follows: \\[\\frac{dS}{S} = (r-q+\\sigma^2) dt + \\sigma dB^S\\]\nVerify that both methods give the same price up to simulation error.\n\n\nExercise 8.7 Calculate the price of a “share digital” option that pays \\(S_T\\) if \\(S_T \\leq K\\) and \\(0\\) otherwise, using the Black-Scholes model assumptions.\n\nUse the stock as numeraire to show the price is \\(S_0 \\mathbb{E}^S[\\mathbf{1}_{\\{S_T \\leq K\\}}]\\)\nUnder the stock numeraire measure, show that \\(\\log S_T\\) is normally distributed\nCalculate the price analytically in terms of the normal CDF\nVerify your result by simulation\n\n\n\nExercise 8.8 Suppose two assets \\(S\\) and \\(V\\) follow geometric Brownian motions under the risk-neutral measure: \\[\\frac{dS}{S} = r dt + \\sigma_S dB_S^R\\] \\[\\frac{dV}{V} = r dt + \\sigma_V dB_V^R\\]\nwith correlation \\(\\rho\\) between the Brownian motions.\nFind the value of an option that pays \\(V_T \\mathbf{1}_{\\{V_T \\geq S_T\\}}\\) using \\(V\\) as the numeraire.\nHint: Under the \\(V\\)-numeraire measure, determine the dynamics of \\(S/V\\) and use the fact that \\(S_T/V_T \\leq 1\\) when \\(V_T \\geq S_T\\).\n\n\n\nFundamental Pricing Formula\n\nExercise 8.9 The fundamental pricing formula states that for any two assets \\(P\\) and \\(Y\\): \\[Y_s = P_s \\mathbb{E}^P_s\\left[\\frac{Y_t}{P_t}\\right]\\]\n\nVerify this formula when \\(P\\) is the risk-free asset and \\(Y\\) is a stock\nVerify this formula when \\(P\\) is a stock and \\(Y\\) is the risk-free asset\n\nShow that this implies \\(Y_t/P_t\\) is a martingale under the \\(P\\)-numeraire measure\nUse this formula to derive the Black-Scholes formula by setting \\(P\\) as the risk-free asset and \\(Y\\) as a call option\n\n\n\nExercise 8.10 In a single-period model with stochastic discount factor \\(m\\): a) Show that if there are no arbitrage opportunities, then \\(\\mathbb{E}[m] &gt; 0\\) and the law of one price holds b) Prove that \\(\\mathbb{E}[mR] = 1\\) where \\(R = e^{rT}\\) is the gross risk-free return c) Show that the risk-neutral probabilities are given by \\(p_j = \\frac{m_j \\cdot \\text{prob}_j}{\\mathbb{E}[m]}\\) where \\(\\text{prob}_j\\) is the actual probability of state \\(j\\) d) Verify that under the risk-neutral measure, all assets have expected return equal to the risk-free rate\n\n\n\nAdvanced Applications\n\nExercise 8.11 A quanto option pays in domestic currency but depends on a foreign asset price. Consider a call option that pays \\((S_T^f - K)^+\\) dollars, where \\(S^f\\) is a foreign stock price.\nIf the exchange rate is \\(X_t\\) (domestic per foreign currency), the foreign stock in domestic currency is \\(S_t = X_t S_t^f\\).\n\nShow that under the domestic risk-neutral measure, if \\(S^f\\) and \\(X\\) are correlated with correlation \\(\\rho\\), then \\(S^f\\) has drift \\(r^d - r^f - \\rho \\sigma_X \\sigma_S\\)\nPrice the quanto call option using this adjusted drift\nCompare this to a standard call option on the domestic value \\(S_t = X_t S_t^f\\)\n\nNote: \\(r^d\\) and \\(r^f\\) are domestic and foreign risk-free rates respectively.\n\n\nExercise 8.12 Consider a “rainbow option” that pays \\(\\max(S_T^{(1)}, S_T^{(2)}, K)\\) where \\(S^{(1)}\\) and \\(S^{(2)}\\) are two correlated stocks.\n\nUsing the fundamental pricing formula, show that this can be priced as \\(\\mathbb{E}^R[e^{-rT}\\max(S_T^{(1)}, S_T^{(2)}, K)]\\)\nExplain why you cannot easily use a single asset as numeraire for this payoff\nSet up a Monte Carlo simulation to price this option with realistic parameters\nCompare the rainbow option price to the sum of two individual call options minus a call on the minimum of the two stocks",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_ArbitragePricing.html#summary",
    "href": "Chapter_ArbitragePricing.html#summary",
    "title": "8  Arbitrage Pricing",
    "section": "8.10 Summary",
    "text": "8.10 Summary\nWe have developed a unified framework for derivative pricing based on the absence of arbitrage:\n\nLinear pricing implies the existence of state prices\nState prices can be converted to risk-neutral probabilities\n\nAsset price ratios are martingales under appropriate probability measures\nAny positive asset can serve as numeraire, inducing its own probability measure\nThe fundamental pricing formula expresses values as expectations of discounted payoffs\nGirsanov’s Theorem provides the mathematical machinery to change between probability measures in continuous time\n\nThis framework extends from simple binomial models to general continuous-time models, providing the foundation for modern derivative pricing theory.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Arbitrage Pricing</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html",
    "href": "Chapter_BlackScholes_updated.html",
    "title": "9  The Black-Scholes Model",
    "section": "",
    "text": "9.1 Digital Options as Building Blocks\nIn the previous chapter, we developed a general framework for derivative pricing based on the absence of arbitrage. We saw how linear pricing leads to state prices, risk-neutral probabilities, and the fundamental pricing formula. We also introduced change of numeraire methods, which allow us to compute option values as expectations under different probability measures. In this chapter, we apply these principles to derive and analyze the celebrated Black-Scholes formula for European option pricing.\nA fundamental insight is that standard European options can be expressed as combinations of digital options. Understanding this connection provides both theoretical insight and practical computational advantages.\nThe Black-Scholes model assumes that the underlying asset pays a constant dividend yield \\(q\\) and has price \\(S\\) satisfying\n\\[\\frac{\\mathrm{d}S}{S} = (\\mu - q) \\mathrm{d}t + \\sigma \\mathrm{d}B\\]\nfor a Brownian motion \\(B\\), where \\(\\sigma\\) is assumed constant and \\(\\mu\\) can be a quite general random process. We also assume a constant continuously-compounded risk-free rate \\(r\\).\nBefore deriving the Black-Scholes formula, we need to understand how standard options relate to digital options. A digital option (also called binary option) has a discontinuous payoff—it pays a fixed amount if a condition is met, zero otherwise.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#digital-options-as-building-blocks",
    "href": "Chapter_BlackScholes_updated.html#digital-options-as-building-blocks",
    "title": "9  The Black-Scholes Model",
    "section": "",
    "text": "Two Types of Digitals\nConsider a call option with strike \\(K\\) and maturity \\(T\\). Its payoff \\((S_T - K)^+\\) can be decomposed as:\n\\[(S_T - K)^+ = \\mathbf{1}_{\\{S_T &gt; K\\}} S_T - K \\mathbf{1}_{\\{S_T &gt; K\\}}\\]\nThis reveals that a call option is the difference between two digital options:\n\nShare digital: Pays \\(S_T\\) when \\(S_T &gt; K\\), zero otherwise\nCash digital: Pays \\(K\\) when \\(S_T &gt; K\\), zero otherwise\n\nSimilarly, a put option with payoff \\((K - S_T)^+\\) can be written as:\n\\[(K - S_T)^+ = K \\mathbf{1}_{\\{S_T &lt; K\\}} - \\mathbf{1}_{\\{S_T &lt; K\\}} S_T\\]\nThis is \\(K\\) cash digitals minus share digitals, both paying when \\(S_T &lt; K\\).\n\n\nWhy This Decomposition Matters\nThis decomposition is powerful because:\n\nComputational efficiency: Digital options have closed-form expressions involving only normal probabilities\nTheoretical insight: It connects discrete payoffs to continuous probability distributions\nRisk management: Greeks can be computed directly from the normal density function\nGeneralization: The approach extends to exotic options and other underlying processes",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#girsanovs-theorem-in-the-black-scholes-model",
    "href": "Chapter_BlackScholes_updated.html#girsanovs-theorem-in-the-black-scholes-model",
    "title": "9  The Black-Scholes Model",
    "section": "9.2 Girsanov’s Theorem in the Black-Scholes Model",
    "text": "9.2 Girsanov’s Theorem in the Black-Scholes Model\nTo value digital options, we need to understand how probability measures change in continuous time. When we change probability measures, a process \\(B\\) that was a Brownian motion cannot be expected to remain a Brownian motion under the new measure. However, Girsanov’s Theorem tells us exactly how the drift changes.\nIn the Black-Scholes model, the dividend-reinvested stock price follows:\n\\[\\mathrm{d}S_t = \\mu S_t \\mathrm{d}t + \\sigma S_t \\mathrm{d}B_t\\]\nWe can rewrite this as:\n\\[\\mathrm{d}S_t = r S_t \\mathrm{d}t + \\sigma S_t \\mathrm{d}\\left(B_t + \\frac{\\mu - r}{\\sigma}t\\right)\\]\nDefine \\(\\kappa = \\frac{\\mu - r}{\\sigma}\\), called the market price of risk or Sharpe ratio.\n\n\n\n\n\n\nImportant Principle\n\n\n\nGirsanov’s Theorem: Define the exponential martingale:\n\\[Z_t = \\exp\\left(-\\frac{1}{2}\\kappa^2 t - \\kappa B_t\\right)\\]\nSince \\(Z_T\\) is lognormal, \\(\\mathbb{E}[Z_T] = 1\\). Under the probability measure defined by:\n\\[\\mathbb{E}^\\kappa[Y] = \\mathbb{E}[Z_T Y]\\]\nfor any function \\(Y\\) of \\(B_t\\) (\\(0 \\leq t \\leq T\\)), the process \\(B_t^\\kappa = B_t + \\kappa t\\) is a Brownian motion. Moreover, if \\(M_t\\) is a martingale under the new measure, then \\(Z_t M_t\\) is a martingale under the original measure.\n\n\nThis theorem tells us how to construct the risk-neutral measure from the original measure. Using Ito’s lemma, we can verify that \\(Z_t \\frac{S_t}{R_t}\\) is indeed a martingale:\n\\[Z_t \\frac{S_t}{R_t} = S_0 \\exp\\left(-\\frac{1}{2}(\\sigma - \\kappa)^2 t + (\\sigma - \\kappa)B_t\\right)\\]\nTherefore:\n\\[\\mathbb{E}\\left[Z_t \\frac{S_t}{R_t}\\right] = S_0\\]\n\nStock as Numeraire\nWhen using the stock as numeraire, we need the process \\(\\frac{R_t}{S_t}\\) to be a martingale. Following similar analysis with Girsanov’s Theorem, we find that under the stock numeraire measure:\n\\[\\mathrm{d}S_t = (r + \\sigma^2) S_t \\mathrm{d}t + \\sigma S_t \\mathrm{d}B_t^S\\]\nwhere \\(B_t^S = B_t^R - \\sigma t\\) is a Brownian motion under the stock numeraire measure.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#derivation-of-the-black-scholes-formula",
    "href": "Chapter_BlackScholes_updated.html#derivation-of-the-black-scholes-formula",
    "title": "9  The Black-Scholes Model",
    "section": "9.3 Derivation of the Black-Scholes Formula",
    "text": "9.3 Derivation of the Black-Scholes Formula\nNow we apply the valuation theory from Chapter 3 (Arbitrage Pricing) and the tail probability calculations from Chapter 2 (Geometric Brownian Motion) to derive the Black-Scholes formula.\n\nCash Digital Options\nA cash digital option paying $1 when \\(S_T &gt; K\\) has value under the risk-neutral measure:\n\\[e^{-r(T-t)} \\mathbb{E}_t^R[\\mathbf{1}_{\\{S_T &gt; K\\}}] = e^{-r(T-t)} \\text{prob}^R(S_T &gt; K)\\]\nUnder the risk-neutral measure, the stock price follows:\n\\[\\frac{\\mathrm{d}S}{S} = (r - q) \\mathrm{d}t + \\sigma \\mathrm{d}B^R\\]\nThis means:\n\\[\\mathrm{d}\\log S = \\left(r - q - \\frac{\\sigma^2}{2}\\right) \\mathrm{d}t + \\sigma \\mathrm{d}B^R\\]\nFrom Chapter 2, we know this has the solution:\n\\[S_T = S_t \\exp\\left(\\left(r - q - \\frac{\\sigma^2}{2}\\right)(T-t) + \\sigma B_{T-t}^R\\right)\\]\nApplying the tail probability formula from Section 7.2 with \\(\\alpha = r - q - \\sigma^2/2\\):\n\\[\\text{prob}^R(S_T &gt; K) = N(d_2)\\]\nwhere:\n\\[d_2 = \\frac{\\log(S_t/K) + (r - q - \\frac{\\sigma^2}{2})(T-t)}{\\sigma\\sqrt{T-t}}\\]\n\n\nShare Digital Options\nFor the share digital paying \\(S_T \\mathbf{1}_{\\{S_T &gt; K\\}}\\), we use the stock as numeraire. From the change of numeraire theory in Chapter 3:\n\\[\\text{Value} = S_t \\mathbb{E}_t^S[\\mathbf{1}_{\\{S_T &gt; K\\}}] = S_t \\cdot \\text{prob}^S(S_T &gt; K)\\]\nUnder the stock numeraire measure:\n\\[\\mathrm{d}\\log S = \\left(r - q + \\frac{\\sigma^2}{2}\\right) \\mathrm{d}t + \\sigma \\mathrm{d}B^S\\]\nApplying the tail probability formula from Section 7.2 with \\(\\alpha = r - q + \\sigma^2/2\\):\n\\[\\text{prob}^S(S_T &gt; K) = N(d_1)\\]\nwhere:\n\\[d_1 = \\frac{\\log(S_t/K) + (r - q + \\frac{\\sigma^2}{2})(T-t)}{\\sigma\\sqrt{T-t}} = d_2 + \\sigma\\sqrt{T-t}\\]\n\n\nCombining the Results\nNow we can derive the Black-Scholes formula by combining our digital option results. A European call option has payoff:\n\\[(S_T - K)^+ = \\mathbf{1}_{\\{S_T &gt; K\\}} S_T - K \\mathbf{1}_{\\{S_T &gt; K\\}}\\]\nThe first term is a share digital worth \\(S_t \\cdot \\text{prob}^S(S_T &gt; K) = S_t N(d_1)\\).\nThe second term is \\(K\\) cash digitals worth \\(K \\cdot e^{-r(T-t)} \\cdot \\text{prob}^R(S_T &gt; K) = K e^{-r(T-t)} N(d_2)\\).\nSince we need \\(e^{-q(T-t)}\\) in front of the share digital to account for dividends, the call value is:\n\n\nThe Black-Scholes Formula\nThis derivation shows how the fundamental arbitrage pricing theory leads directly to the Black-Scholes formula. The key steps were:\n\nLinear pricing: From Chapter 3, any security’s value is a linear combination of Arrow securities (digitals)\nChange of numeraire: Different measures give different probabilities for the same event\n\nTail probabilities: From Chapter 2, we can compute \\(\\text{prob}(S_T &gt; K)\\) under any measure\nGirsanov’s Theorem: Provides the mathematical foundation for changing measures\n\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a European call option is:\n\\[C(t, S_t) = e^{-q(T-t)} S_t N(d_1) - e^{-r(T-t)} K N(d_2)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined above and \\(N(\\cdot)\\) is the standard normal cumulative distribution function.\n\n\nFor a European put option:\n\n\n\n\n\n\nKey Result\n\n\n\n\\[P(t, S_t) = e^{-r(T-t)} K N(-d_2) - e^{-q(T-t)} S_t N(-d_1)\\]\n\n\nThe call and put values satisfy put-call parity:\n\\[e^{-r(T-t)} K + C(t, S_t) = e^{-q(T-t)} S_t + P(t, S_t)\\]\n\n\nInteractive Black-Scholes Explorer\nThe following interactive tool allows you to explore how the Black-Scholes formula behaves as you vary the input parameters. You can see how option prices change with stock price, volatility, time to expiration, interest rates, and dividend yields.\n\n\n\n\n\n\n\nFigure 9.1: Black-Scholes Explorer. This interactive calculator shows how call and put option prices vary with the underlying parameters. Notice how the option prices change smoothly with the stock price, and observe the effects of time decay and volatility on option values.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#replication-and-delta-hedging",
    "href": "Chapter_BlackScholes_updated.html#replication-and-delta-hedging",
    "title": "9  The Black-Scholes Model",
    "section": "9.4 Replication and Delta Hedging",
    "text": "9.4 Replication and Delta Hedging\nThe arbitrage pricing principle requires that we can replicate option payoffs through dynamic trading. Following Merton’s argument, we construct a portfolio holding \\(\\delta_t\\) shares of stock and \\(\\alpha_t\\) units of the risk-free asset, with value:\n\\[W_t = \\alpha_t e^{rt} + \\delta_t S_t\\]\nFor continuous trading with no cash inflows or outflows:\n\\[\\mathrm{d}W_t = \\delta_t \\mathrm{d}S_t + \\delta_t q S_t \\mathrm{d}t + \\alpha_t r e^{rt} \\mathrm{d}t\\]\nIf the option value is \\(C(t, S_t)\\), then by Ito’s lemma:\n\\[\\mathrm{d}C = \\frac{\\partial C}{\\partial t} \\mathrm{d}t + \\frac{\\partial C}{\\partial S} \\mathrm{d}S + \\frac{1}{2} \\frac{\\partial^2 C}{\\partial S^2} \\sigma^2 S^2 \\mathrm{d}t\\]\nMatching the stochastic terms requires:\n\\[\\delta_t = \\frac{\\partial C}{\\partial S}\\]\nThis is the option’s delta—the number of shares needed to hedge the option. By no-arbitrage, \\(W_t = C(t, S_t)\\), leading to the fundamental partial differential equation.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#the-fundamental-pde",
    "href": "Chapter_BlackScholes_updated.html#the-fundamental-pde",
    "title": "9  The Black-Scholes Model",
    "section": "9.5 The Fundamental PDE",
    "text": "9.5 The Fundamental PDE\nAny European derivative with payoff \\(V(S_T)\\) at maturity \\(T\\) must satisfy:\n\\[r V = \\frac{\\partial V}{\\partial t} + \\frac{\\partial V}{\\partial S}(r - q)S + \\frac{1}{2} \\frac{\\partial^2 V}{\\partial S^2} \\sigma^2 S^2\\]\nwith boundary condition \\(V(S_T, T) = V(S_T)\\).\nThis PDE has several important interpretations:\n\nRisk-neutral expectation: The solution is \\(V(t, S_t) = \\mathbb{E}_t^R[e^{-r(T-t)} V(S_T)]\\)\nReplication: The portfolio holds \\(\\frac{\\partial V}{\\partial S}\\) shares and \\(V - \\frac{\\partial V}{\\partial S}S\\) in cash\nHedging condition: The drift term equals the risk-free return when perfectly hedged\n\nThe Black-Scholes formula satisfies this PDE with the appropriate boundary conditions for calls and puts.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#greeks",
    "href": "Chapter_BlackScholes_updated.html#greeks",
    "title": "9  The Black-Scholes Model",
    "section": "9.6 Greeks",
    "text": "9.6 Greeks\nThe sensitivities of option values to various inputs are called Greeks. From the Black-Scholes formula:\n\nDelta (\\(\\delta\\))\nThe sensitivity to stock price changes:\n\\[\\delta_{call} = e^{-q(T-t)} N(d_1)\\] \\[\\delta_{put} = -e^{-q(T-t)} N(-d_1)\\]\n\n\nGamma (\\(\\Gamma\\))\nThe rate of change of delta:\n\\[\\Gamma = \\frac{e^{-q(T-t)} n(d_1)}{S \\sigma \\sqrt{T-t}}\\]\nwhere \\(n(\\cdot)\\) is the standard normal density. Gamma is the same for calls and puts.\n\n\nTheta (\\(\\Theta\\))\nThe time decay (using \\(\\partial/\\partial(-T)\\) so positive theta means value increases as time passes):\n\\[\\Theta_{call} = -\\frac{e^{-q(T-t)} S n(d_1) \\sigma}{2\\sqrt{T-t}} + q e^{-q(T-t)} S N(d_1) - r e^{-r(T-t)} K N(d_2)\\]\n\n\nVega (\\(\\mathcal{V}\\))\nThe sensitivity to volatility:\n\\[\\mathcal{V} = e^{-q(T-t)} S n(d_1) \\sqrt{T-t}\\]\n\n\nRho (\\(\\rho\\))\nThe sensitivity to interest rates:\n\\[\\rho_{call} = (T-t) e^{-r(T-t)} K N(d_2)\\]\n\n\nInteractive Greeks Explorer\nThe Greeks measure how option prices change with respect to various parameters. The following interactive tool lets you visualize how the Greeks behave across different stock prices and parameter values.\n\n\n\n\n\n\n\nFigure 9.2: Black-Scholes Greeks Explorer. This tool shows how delta, gamma, theta, vega, and rho vary with the stock price and other parameters. Pay particular attention to how gamma peaks near the strike price and how theta becomes more negative as expiration approaches.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#theta-and-gamma-in-delta-hedges",
    "href": "Chapter_BlackScholes_updated.html#theta-and-gamma-in-delta-hedges",
    "title": "9  The Black-Scholes Model",
    "section": "9.7 Theta and Gamma in Delta Hedges",
    "text": "9.7 Theta and Gamma in Delta Hedges\nThe relationship between theta and gamma provides deep insight into option hedging. Consider a delta-hedged portfolio (short call, long \\(\\delta\\) shares). From the fundamental PDE and our Greeks:\n\\[\\Theta + \\frac{1}{2} \\Gamma \\sigma^2 S^2 = r C - (r - q) S \\delta\\]\nIn continuous time, the portfolio change is:\n\\[-\\Theta \\mathrm{d}t - \\frac{1}{2} \\Gamma \\sigma^2 S^2 \\mathrm{d}t + q \\delta S \\mathrm{d}t + (C - \\delta S) r \\mathrm{d}t\\]\nThese terms exactly cancel—the time decay and dividends received offset losses from being short gamma and interest payments. This perfect cancellation only holds with continuous rebalancing.\nWith discrete rebalancing, the hedge is imperfect. The portfolio is short gamma, meaning it loses money when the stock moves significantly between rebalances. This loss is approximately:\n\\[\\frac{1}{2} \\Gamma (\\Delta S)^2\\]\nwhere \\(\\Delta S\\) is the stock price change. The hedging error increases with: - Larger gamma (near the strike at expiration) - Higher volatility - Longer time between rebalances\n\nDiscretely Rebalanced Delta Hedges\nThe theoretical analysis above assumes continuous rebalancing, but in practice, hedging must be done at discrete intervals. This introduces hedging error that we can analyze through simulation.\n\n\nThe Discrete Hedging Problem\nConsider a delta hedge that is rebalanced at discrete times \\(0 = t_0 &lt; t_1 &lt; \\cdots &lt; t_N = T\\) with \\(\\Delta t = T/N\\). Between rebalancing dates, the hedge portfolio consists of: - Short position in the option - Long \\(\\delta_{t_i}\\) shares of stock (where \\(\\delta_{t_i}\\) is computed at the last rebalancing date) - Cash position to finance the hedge\nThe key insight from the analysis in ?sec-s_deltahedging is that perfect continuous hedging relies on the relationship:\n\\[-\\Theta \\,\\mathrm{d} t - \\frac{1}{2}\\Gamma \\sigma^2S^2\\,\\mathrm{d} t+ q \\delta S\\,\\mathrm{d} t+(C-\\delta S)r\\,\\mathrm{d} t = 0\\]\nWith discrete rebalancing, this balance is disrupted. The portfolio gains and losses come from:\n\nTime decay: \\(-\\Theta \\Delta t\\) (predictable, typically positive for short option)\nGamma exposure: \\(-\\frac{1}{2}\\Gamma (\\Delta S)^2\\) (stochastic losses when short gamma)\nInterest and dividends: Financing costs and dividend income\nDelta drift: Changes in delta between rebalancing dates\n\n\n\nSimulation of Discrete Hedging\nThe following code simulates the performance of discretely rebalanced delta hedges:\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using Black-Scholes formula.'''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return np.exp(-q*T)*S0 * (-norm.cdf(-d1,0,1)) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ndef blackscholes_delta(S0, K, r, q, sig, T, call = True):\n    '''Calculate option delta using Black-Scholes formula.'''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    if call:\n        return np.exp(-q*T)*norm.cdf(d1,0,1)\n    else:\n        return np.exp(-q*T)*norm.cdf(-d1,0,1)\n\ndef simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, pct):\n    \"\"\"\n    Simulate profits/losses from discretely rebalanced delta hedge\n    \n    Parameters:\n    S0: initial stock price\n    K: strike price  \n    r: risk-free rate\n    sigma: volatility\n    q: dividend yield\n    T: time to maturity\n    mu: expected stock return (actual, not risk-neutral)\n    M: number of simulations\n    N: number of rebalancing periods\n    pct: percentile to return\n    \"\"\"\n    dt = T / N\n    vol_dt = sigma * np.sqrt(dt)\n    drift = (mu - q - 0.5 * sigma**2) * dt\n    discount = np.exp(r * dt)\n    div_factor = np.exp(q * dt) - 1\n    \n    # Initial setup\n    call_0 = blackscholes(S0, K, r, q, sigma, T, True)\n    delta_0 = blackscholes_delta(S0, K, r, q, sigma, T, True)\n    cash_0 = call_0 - delta_0 * S0\n    \n    profits = np.zeros(M)\n    \n    np.random.seed(42)  # For reproducible results\n    \n    for i in range(M):\n        log_s = np.log(S0)\n        cash = cash_0\n        s = S0\n        delta = delta_0\n        \n        # Rebalancing loop\n        for j in range(1, N):\n            # Stock price evolution\n            log_s += drift + vol_dt * np.random.randn()\n            new_s = np.exp(log_s)\n            \n            # New delta for rebalancing\n            time_remaining = T - j * dt\n            new_delta = blackscholes_delta(new_s, K, r, q, sigma, time_remaining, True)\n            \n            # Update cash position: interest + dividends - rebalancing cost\n            cash = (discount * cash + \n                   delta * s * div_factor - \n                   (new_delta - delta) * new_s)\n            \n            s = new_s\n            delta = new_delta\n        \n        # Final period\n        log_s += drift + vol_dt * np.random.randn()\n        final_s = np.exp(log_s)\n        \n        # Final hedge value\n        final_hedge_value = (discount * cash + \n                           delta * s * div_factor + \n                           delta * final_s)\n        \n        # Profit = hedge value - option payoff\n        option_payoff = max(final_s - K, 0)\n        profits[i] = final_hedge_value - option_payoff\n    \n    return np.percentile(profits, pct * 100)\n\n# Example: Hedge a call option with discrete rebalancing\nS0 = 100      # Initial stock price\nK = 100       # Strike price (at-the-money)\nr = 0.05      # Risk-free rate\nsigma = 0.2   # Volatility\nq = 0.02      # Dividend yield\nT = 0.25      # 3 months to maturity\nmu = 0.12     # Expected stock return\n\nprint(\"Discrete Delta Hedging Analysis\")\nprint(\"==============================\")\nprint(f\"Parameters: S0={S0}, K={K}, r={r:.2f}, σ={sigma:.2f}, q={q:.2f}, T={T}\")\nprint(f\"Expected stock return μ={mu:.2f}\\\\n\")\n\n# Test different rebalancing frequencies\nrebalancing_frequencies = [4, 12, 52, 252]  # Weekly, monthly, daily, etc.\nM = 5000  # Number of simulations\n\nprint(\"Hedging Error Analysis (95th percentile of absolute profits):\")\nprint(\"Rebalancing Frequency | Periods | 95th Percentile Error\")\nprint(\"-\" * 55)\n\nfor N in rebalancing_frequencies:\n    # Get both tails of the distribution\n    p95 = simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, 0.95)\n    p5 = simulated_delta_hedge_profit(S0, K, r, sigma, q, T, mu, M, N, 0.05)\n    \n    # Report the larger absolute error\n    max_error = max(abs(p95), abs(p5))\n    \n    freq_name = {4: \"Weekly\", 12: \"Monthly\", 52: \"Daily\", 252: \"Intraday\"}[N]\n    print(f\"{freq_name:&lt;20} | {N:&gt;7} | {max_error:&gt;18.4f}\")\n\nprint(f\"\\\\nNote: Errors should decrease as rebalancing frequency increases.\")\nprint(f\"The Black-Scholes price is {blackscholes(S0, K, r, q, sigma, T, True):.4f}\")\n\n\nDiscrete Delta Hedging Analysis\n==============================\nParameters: S0=100, K=100, r=0.05, σ=0.20, q=0.02, T=0.25\nExpected stock return μ=0.12\\n\nHedging Error Analysis (95th percentile of absolute profits):\nRebalancing Frequency | Periods | 95th Percentile Error\n-------------------------------------------------------\nWeekly               |       4 |             2.8283\nMonthly              |      12 |             1.5545\nDaily                |      52 |             0.7934\nIntraday             |     252 |             0.3629\n\\nNote: Errors should decrease as rebalancing frequency increases.\nThe Black-Scholes price is 4.3359\n\n\n\n\nUnderstanding Hedging Errors\nThe simulation results illustrate several key points about discrete hedging:\n\nGamma is the enemy: When an option has high gamma (near expiration, near the strike), small stock moves between rebalances cause large hedging errors\nFrequency matters: More frequent rebalancing reduces hedging error, but with diminishing returns and higher transaction costs\nVolatility creates error: Higher realized volatility generally increases hedging errors for short gamma positions\nThe hedge is model-independent: Notice that the expected stock return \\(\\mu\\) affects the distribution of stock paths but not the systematic hedging error - this confirms the model-free nature of delta hedging\n\n\n\nPractical Implications\nIn practice, traders must balance: - Hedging accuracy: More frequent rebalancing reduces error - Transaction costs: Every rebalance incurs bid-ask spreads and commissions\n- Market impact: Large hedging flows can move prices unfavorably\nThe discrete hedging analysis shows why options market makers require: - Sophisticated risk management systems for continuous monitoring - Careful consideration of gamma exposure, especially near expiration - Transaction cost models to optimize rebalancing frequency",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#implied-volatilities",
    "href": "Chapter_BlackScholes_updated.html#implied-volatilities",
    "title": "9  The Black-Scholes Model",
    "section": "9.8 Implied Volatilities",
    "text": "9.8 Implied Volatilities\nWhile all other Black-Scholes inputs are observable, volatility must be estimated. Given an option’s market price, we can invert the Black-Scholes formula to find the implied volatility—the \\(\\sigma\\) that produces the observed price.\nImplied volatilities serve several purposes:\n\nPrice quotes: Options are often quoted in terms of implied volatility\nRelative value: Comparing implied volatilities helps identify expensive or cheap options\nMarket views: Implied volatilities reflect market expectations of future volatility\n\n\nThe Volatility Smile\nIf the Black-Scholes model were perfect, all options with the same maturity would have the same implied volatility. In practice, plotting implied volatility against strike typically shows:\n\nHigher implied volatilities for low strikes (out-of-the-money puts)\nLower implied volatilities near the at-the-money strike\nSlightly increasing implied volatilities for high strikes\n\nThis “volatility smile” or “smirk” indicates that market prices reflect: - Fat tails: Higher probability of extreme moves than lognormal - Negative skewness: Larger probability of extreme downward moves\nThe smile has been particularly pronounced for equity index options since the 1987 crash, suggesting market participants price in crash risk.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#exercises",
    "href": "Chapter_BlackScholes_updated.html#exercises",
    "title": "9  The Black-Scholes Model",
    "section": "9.9 Exercises",
    "text": "9.9 Exercises\n\nDigital Options and Building Blocks\n\nExercise 9.1 Consider a cash digital option that pays $1 when \\(S_T &gt; K\\) and a share digital that pays \\(S_T\\) when \\(S_T &gt; K\\). Using Black-Scholes parameters \\(S_0 = 100\\), \\(K = 105\\), \\(r = 5\\%\\), \\(q = 2\\%\\), \\(\\sigma = 20\\%\\), \\(T = 0.25\\):\n\nCalculate the analytical values of both digital options using the formulas from the chapter\nVerify your results using Monte Carlo simulation with 100,000 paths\nShow that a call option can be decomposed as: \\(C = S_0 N(d_1) e^{-qT} - K N(d_2) e^{-rT}\\)\nImplement this decomposition and verify it matches the standard Black-Scholes formula\n\n\n\nExercise 9.2 The delta of a cash digital option that pays $1 when \\(S_T &gt; K\\) is: \\[\\Delta_{\\text{digital}} = \\frac{e^{-rT} n(d_2)}{\\sigma S \\sqrt{T}}\\]\nwhere \\(n(\\cdot)\\) is the standard normal density.\n\nPlot this delta against stock price for \\(S \\in [80, 120]\\) with the parameters from the previous exercise\nCompare the magnitude of digital delta to call option delta near the strike\nExplain why delta hedging a short digital position near expiration and near the strike is problematic\nWhat happens to the digital delta as time to expiration approaches zero?\n\n\n\n\nChange of Numeraire and Girsanov’s Theorem\n\nExercise 9.3 Using simulation, verify the change of numeraire formulas for digital options:\n\nUnder the risk-neutral measure, simulate \\(S_T\\) following \\(dS/S = (r-q)dt + \\sigma dB^R\\)\nUnder the stock numeraire measure, simulate \\(S_T\\) following \\(dS/S = (r-q+\\sigma^2)dt + \\sigma dB^S\\)\n\nCalculate \\(\\mathbb{E}^R[e^{-rT} \\mathbf{1}_{\\{S_T &gt; K\\}}]\\) and \\(S_0 \\mathbb{E}^S[\\mathbf{1}_{\\{S_T &gt; K\\}}/S_T]\\)\nVerify both give the same digital option value up to simulation error\nUse 50,000 simulation paths and report the standard errors\n\n\n\nExercise 9.4 Verify the exponential martingale property in Girsanov’s Theorem. With \\(\\kappa = (\\mu - r)/\\sigma\\):\n\nSimulate paths of \\(Z_t = \\exp(-\\frac{1}{2}\\kappa^2 t - \\kappa B_t)\\) where \\(B_t\\) is standard Brownian motion\nVerify that \\(\\mathbb{E}[Z_T] = 1\\) for various values of \\(T\\)\nShow that \\(Z_t S_t/R_t\\) is a martingale under the original measure\nCompare the distribution of \\(B_t + \\kappa t\\) to standard Brownian motion under the new measure\n\n\n\n\nBlack-Scholes Formula and Properties\n\nExercise 9.5 Implement the complete Black-Scholes formula with all Greeks:\n\nCreate a Python class BlackScholesOption that calculates price, delta, gamma, theta, vega, and rho\nInclude both calls and puts with proper dividend yield handling\nVerify put-call parity: \\(C - P = S_0 e^{-qT} - K e^{-rT}\\)\nTest your implementation against the interactive Black-Scholes explorer values\n\n\n\nExercise 9.6 Analyze the limiting behavior of the Black-Scholes formula:\n\nShow that as \\(T \\to 0\\), the call value approaches \\(\\max(S_0 - K, 0)\\)\nShow that as \\(\\sigma \\to 0\\), the formula approaches the deterministic payoff present value\nWhat happens to call and put values as \\(\\sigma \\to \\infty\\)? Explain intuitively.\nAnalyze the behavior as \\(r \\to 0\\) and as \\(r \\to \\infty\\)\n\n\n\nExercise 9.7 Using the interactive Black-Scholes explorer or your own implementation:\n\nFor an at-the-money option, plot call value against volatility for \\(\\sigma \\in [0.1, 1.0]\\)\nRepeat for options that are 10% in-the-money and 10% out-of-the-money\nFor which moneyness is the option price most sensitive to volatility changes?\nExplain this pattern in terms of the option’s probability of finishing in-the-money\n\n\n\n\nGreeks and Risk Management\n\nExercise 9.8 Create comprehensive plots of the Greeks using the interactive Greeks explorer as reference:\n\nPlot delta, gamma, theta, vega, and rho against stock price for an at-the-money option\nRepeat for different times to expiration: 1 month, 3 months, 6 months, 1 year\nIdentify where gamma is maximized and explain why this matters for hedging\nShow how theta changes as expiration approaches and explain the time decay acceleration\n\n\n\nExercise 9.9 Consider delta and gamma hedging a short call option using the underlying and a put with the same strike and maturity:\n\nDerive the positions in stock and put needed for a delta-gamma neutral portfolio\nShow that this hedge never needs adjustment (relate to put-call parity)\nImplement this strategy and compare hedging errors to delta-only hedging\nWhat are the practical limitations of this “perfect” hedge?\n\n\n\nExercise 9.10 Calculate the Greeks for exotic payoffs:\n\nFor a derivative paying \\(S_T^2\\), find the value, delta, and gamma using risk-neutral valuation\nFor a derivative paying \\(\\log(S_T)\\), repeat the calculation\nVerify both satisfy the fundamental PDE: \\(rV = \\frac{\\partial V}{\\partial t} + (r-q)S\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}\\)\nCompare the hedging difficulty (gamma exposure) of these payoffs to standard options\n\n\n\n\nDiscrete Hedging and Practical Implementation\n\nExercise 9.11 Extend the discrete hedging simulation from the chapter:\n\nCompare hedging errors for different rebalancing frequencies: daily, weekly, monthly\nAnalyze how hedging errors scale with volatility and time to expiration\n\nStudy the impact of transaction costs: assume 0.1% bid-ask spread on each rebalance\nFind the optimal rebalancing frequency that minimizes total cost (hedging error + transaction costs)\n\n\n\nExercise 9.12 Implement synthetic portfolio insurance using the discrete hedging framework:\n\nCreate a protective put position (\\(\\max(K, S_T)\\)) using dynamic hedging\nThe delta of the protective put is \\(1 + \\Delta_{\\text{put}} = N(d_1)\\)\nCompare the final portfolio values to buying an actual put option\nAnalyze performance during high volatility periods vs. low volatility periods\n\n\n\nExercise 9.13 Analyze the gamma scalping strategy:\n\nShow that a delta-hedged short option position has P&L approximately equal to \\(-\\frac{1}{2}\\Gamma(\\Delta S)^2\\)\nSimulate this P&L for different realized volatilities vs. implied volatility\nDemonstrate that selling options when implied volatility &gt; realized volatility is profitable\nAccount for the theta decay and show the complete P&L attribution\n\n\n\n\nImplied Volatility and Market Practice\n\nExercise 9.14 Implement an implied volatility calculator:\n\nUse numerical methods (bisection or Newton-Raphson) to invert the Black-Scholes formula\nTest with market-like option prices and verify convergence\nHandle edge cases: very deep ITM/OTM options, very short/long expirations\nCompare computational efficiency of different numerical methods\n\n\n\nExercise 9.15 Analyze volatility smile patterns:\n\nUsing hypothetical option prices, construct a volatility smile curve\nFit different smile models: quadratic, cubic, SVI (Stochastic Volatility Inspired)\nAnalyze how the smile changes with time to expiration\nExplain the economic interpretation of smile skew and convexity\n\n\n\nExercise 9.16 Explore Black-Scholes model limitations:\n\nGenerate stock paths with jumps (Merton jump-diffusion model) and price options using Black-Scholes\nGenerate paths with stochastic volatility and analyze pricing errors\nCreate scenarios where the model significantly misprices options\nPropose practical adjustments traders might make to account for these limitations\n\n\n\n\nAdvanced Applications\n\nExercise 9.17 Analyze the impact of discrete dividends on American call options:\n\nPrice a call option on a stock paying a discrete dividend before expiration\nShow when early exercise might be optimal (just before ex-dividend date)\nCompare American and European call values in this setting\nImplement the discrete dividend adjustment to the Black-Scholes formula\n\n\n\nExercise 9.18 Price an option on the maximum of two assets using change of numeraire:\n\nFor payoff \\(\\max(S_1(T), S_2(T), K)\\), set up the Monte Carlo pricing framework\nExperiment with different correlation levels between the assets\nCompare this “rainbow” option value to individual options on each asset\nAnalyze which asset should be used as numeraire for variance reduction",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_BlackScholes_updated.html#summary",
    "href": "Chapter_BlackScholes_updated.html#summary",
    "title": "9  The Black-Scholes Model",
    "section": "9.10 Summary",
    "text": "9.10 Summary\nThe Black-Scholes model combines the theoretical foundations of arbitrage pricing with practical implementation:\n\nChange of numeraire: Digital options under different measures give the formula\nReplication: Delta hedging shows how to replicate option payoffs\nFundamental PDE: All derivatives satisfy the same partial differential equation\nGreeks: Sensitivities guide risk management and hedging\nMarket practice: Implied volatilities reveal market expectations and model limitations\n\nThe model’s elegance lies in showing that, under its assumptions, options can be perfectly hedged through dynamic trading. While real markets violate these assumptions, the Black-Scholes framework remains the foundation for understanding option pricing and hedging.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>The Black-Scholes Model</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html",
    "href": "Chapter_MertonMargrabeBlack.html",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "10.1 Margrabe’s Formula\nIn this chapter, we will derive three important generalizations of the Black-Scholes formula. We will derive them from the Black-Scholes formula, which shows that all of the formulas are equivalent. We will start with Margrabe’s (Margrabe 1978) formula for an option to exchange one asset for another. Standard calls and puts are special cases, involving the exchange of cash for an asset or an asset for cash. From Margrabe’s formula, we will derive Black’s (Black 1976) formulas for options on forward and futures contracts. Then, from Black’s formulas, we will derive Merton’s (Merton 1973) formulas for calls and puts in the absence of a constant risk-free rate.\nUnless explicitly stated otherwise, we will not assume in this chapter the existence of a risk-free asset (or even an instantaneously risk-free asset as described in ?sec-c:arbitrage). This implies that the market is incomplete and there are many risk-neutral probabilitys. Nevertheless, we can price exchange options, forward and futures options, and stock options by arbitrage. Understanding this issue is not essential for deriving the formulas in this chapter—as mentioned, they will all be derived from the Black-Scholes formula—but the issue is nonetheless important. It is discussed in the final section of the chapter.\nNaturally, all of the option-pricing formulas discussed in this chapter are quite similar. The similarity can be seen from the Black-Scholes formula for a call option, which we can write as follows (replacing \\(d_1\\) by \\(x\\) and \\(d_2\\) by \\(y\\)): \\[\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(x) - \\mathrm{e}^{-rT}K\\mathrm{N}(y)\\;,\n\\qquad(10.1)\\]\nwhere\n\\[\nx=\\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\qquad(10.2)\\]\n\\[\ny = x -\\sigma\\sqrt{T}\\;.\n\\qquad(10.3)\\]\nNote that \\(\\mathrm{e}^{-qT}S_0\\) is the present value at date \\(0\\) of the stock that would be acquired if the option is exercised, because it is the cost that one must pay at date \\(0\\) to have one share of the stock at date \\(T\\) with no withdrawal of dividends in the interim. Obviously, \\(\\mathrm{e}^{-rT}K\\) is the present value of the cash that is paid if the option is exercised. Moreover, \\(x\\) is equal to \\[\\frac{\\log \\left(\\frac{\\mathrm{e}^{-qT}S_0}{\\mathrm{e}^{-rT}K} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\] and the logarithm in the numerator is of the ratio of present values. All of the option pricing formulas in this chapter have the same form: the present value of the asset to be acquired multiplied by \\(\\mathrm{N}(x)\\) minus the present value of the asset to be delivered multiplied by \\(\\mathrm{N}(y)\\). Moreover in each case \\(x\\) is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\) all divided by \\(\\sigma\\sqrt{T}\\), and in each case \\(y\\) is defined by Equation 10.3. Notice that the Black-Scholes put option formula has this structure also. The Black-Scholes put option formula is \\[\n\\mathrm{e}^{-rT}K\\mathrm{N}(x) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(y)\\;,\n\\qquad(10.4)\\]\nwhere\n\\[\nx =-d_2\n=  - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q-\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n\\] \\[\n=\\frac{\\log \\left(\\frac{\\mathrm{e}^{-rT}K}{\\mathrm{e}^{-qT}S_0} \\right)+ \\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.5)\\]\n\\[\ny=-d_1\n= - \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n=x - \\sigma\\sqrt{T}\\;.\n\\] This similarity is discussed further in later, where the pricing formulas are implemented in Python.\nConsider two assets with prices \\(S_1\\) and \\(S_2\\) and a European option to exchange asset 2 for asset 1 at date \\(T\\). The value of the option at maturity is \\[\\max(0,S_1(T)-S_2(T))\\; .\\] Note that there is no real difference between a put and a call: the exchange option can be viewed as a call on the first asset with random strike \\(S_2(T)\\) or as a put on the second asset with random strike \\(S_1(T)\\).\nAssume the assets pay constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\mathrm{d}  S_i}{S_i} = \\mu_i\\mathrm{d}   t+\\sigma_i\\mathrm{d}   B_i\\] where each \\(B_i\\) is a Brownian motion under the actual probability measure. As before, the drifts \\(\\mu_i\\) can be quite general random processes. We also allow the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the Brownian motions to be random processes; however, we make the assumption that \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\n\\qquad(10.6)\\]\nis a constant. As shown in ?eq-volatilityratio, \\(\\sigma\\) is the volatility of \\(S_1/S_2\\) (and also \\(S_2/S_1\\)). So, the assumption we are making is that the volatility of the ratio of the asset prices is constant. In Section 10.15, we will relax this assumption to allow \\(\\sigma\\) to be time-varying (though still non-random).\nThe following is the formula of Margrabe (Margrabe 1978):\nMargrabe’s derivation is a very simple argument based on the Black-Scholes formula. We noted in ?sec-c:foreignexchange that the Black-Scholes formula does not depend on the currency—if the underlying asset and risk-free asset are dollar denominated, the formula gives the dollar value of an option; if they are yen denominated, the formula gives the yen value of an option, etc. So we can take the currency to be units of the second asset; i.e., we will use the second asset as numeraire. With this numeraire, the value of the first asset is \\(S_1/S_2\\). The value of the exchange option at maturity is \\[\\max(0,S_1(T)-S_2(T)) = S_2(T)\\max\\left(0,\\frac{S_1(T)}{S_2(T)}-1\\right)\\; .\\] This is the value in the natural currency (e.g., dollars). The value using the second asset as numeraire is obtained by dividing by \\(S_2(T)\\), so it is \\[\\max\\left(0,\\frac{S_1(T)}{S_2(T)}-1\\right)\\; .\\] This is the value of a standard call option, the underlying being the first asset measured in units of the second. We can apply the Black-Scholes formula to obtain the value of the option (in units of the second asset) at date \\(0\\). Multiplying this value by \\(S_2(0)\\) will give the option value in the natural currency.\nThe risk-free rate when the second asset is the numeraire is the dividend yield on the second asset \\(q_2\\). To see this, note that the price of the second asset is always equal to one; moreover, an investment in the second asset will accumulate at the rate \\(q_2\\) via reinvestment of dividends. Therefore, \\(q_2\\) is a risk-free rate of return.\nThe dividend yield on the first asset remains \\(q_1\\). To see this, note that the dividend paid in the natural currency is \\(q_1S_1(t)\\mathrm{d}   t\\) in an instant \\(\\mathrm{d}  t\\) and the value of this dividend using the second asset as numeraire is \\([q_1S_1(T)/S_2(T)]\\mathrm{d}   t\\), which is the fraction \\(q_1\\mathrm{d}   t\\) of the value \\(S_1(T)/S_2(T)\\) of the first asset using the second asset as numeraire.\nThe volatility of the first asset using the second as numeraire is the volatility of the ratio \\(S_1(T)/S_2(T)\\), which is \\(\\sigma\\) defined in Equation 10.6. Applying the Black-Scholes formula with these inputs yields Margrabe’s formula directly.1.\nIn terms of programming, we could of course write entirely separate programs for the options discussed so far and those to be discussed in this chapter but it will become clear that they have common structure. As discussed in the introduction to this chapter, each is the present value of what is received upon exercise multiplied by \\(\\mathrm{N}(x)\\) minus the present value of what is delivered upon exercise multiplied by \\(\\mathrm{N}(y)\\) and \\(x\\) in each case is the logarithm of the ratio of present values plus one-half \\(\\sigma^2T\\), all divided by \\(\\sigma\\sqrt{T}\\). Thus, we first write a code for a generic option price. Later we use this generic option price function to price other options.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\n\n\n\n# Example usage\nP1 = 100\nP2 = 90\nsigma = 0.2\nT = 1\n\nprint(\"Generic Option:\", generic_option(P1, P2, sigma, T))\n\n\nGeneric Option: 13.589108116054796\nNow we can use the following one-line programs to value exchange options.\nCode\ndef margrabe(S1, S2, sigma, q1, q2, T):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    T = time to maturity\n    \"\"\"\n    P1 = np.exp(-q1 * T) * S1\n    P2 = np.exp(-q2 * T) * S2\n    return generic_option(P1, P2, sigma, T)\n\n# Example usage\nS1 = 100\nS2 = 90\nsigma = 0.2\nq1 = 0.01\nq2 = 0.02\n\nprint(\"Margrabe Option:\", margrabe(S1, S2, sigma, q1, q2, T))\n\n\nMargrabe Option: 14.05169829758782\nWe could also have calculated the Black-Scholes call formula as \\[\n\\text{Generic\\_Option}(Exp(-q*T)*S, Exp(-r*T)*K, sigma, T)\n\\]\nand the Black-Scholes put formula as\n\\[\n\\text{Generic\\_Option}(Exp(-r*T)*K, Exp(-q*T)*S, sigma, T).\n\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:margrabe",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:margrabe",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "10.2\n\n\n\nThe value of a European option to exchange two assets at date \\(T\\) is \\[\n\\mathrm{e}^{-q_1 T}S_1(0)\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T}S_2(0)\\mathrm{N}(d_2)\\;,\n\\qquad(10.7)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+\\left(q_2-q_1+\n\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.8)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(10.9)\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:black",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:black",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.3 Black’s Formula",
    "text": "10.3 Black’s Formula\nBlack (Black 1976) gives formulas for the values of options on futures contracts when interest rates are deterministic (i.e., non-random). It is well known (and we will establish this in Section 10.12) that, when interest rates are deterministic, futures prices should equal forward prices, so Black’s formulas also yield formulas for the values of options on forward contracts when interest rates are deterministic. However, the formulas for options on forwards are valid more generally (even when interest rates vary randomly) and now a mention of Black’s formulas is more likely to be referring to the formulas for options on forwards, instead of the formulas for options on futures. In any case, we will start with the formulas for options on forwards and then in Section 10.13 derive the formulas for options on futures when interest rates are deterministic.\nWe consider a forward contract that matures at some date \\(T^*\\) and a call or put option on the forward that matures at \\(T \\leq T^*\\). The meaning of a call option on a forward is that exercise of the call creates a long position in the forward contract with forward price equal to the strike price of the option. The long forward contract means that the investor will receive the underlying asset at \\(T^*\\) and pay the forward price (the strike of the option) at \\(T^*\\). Thus, the strike price is not paid at the date of exercise but instead is paid when the underlying asset is delivered. Symmetrically, the exercise of a put creates a short position in the forward contract with forward price equal to the strike of the put, which means that the exerciser must deliver the underlying at \\(T^*\\) and will receive the strike price at \\(T^*\\).\nWe will denote the market forward price by \\(F_t\\). We assume the forward price satisfies \\[\n\\frac{\\mathrm{d}  F}{F} = \\mu\\mathrm{d}   t + \\sigma\\mathrm{d}   B\\;,\n\\qquad(10.10)\\]\nwhere \\(B\\) is a Brownian motion. As before, \\(\\mu\\) can be a quite general random process. We will assume in this section that the volatility \\(\\sigma\\) is a constant and generalize to a time-varying (but non-random) volatility in Section 10.15. In Section 10.5, we will discuss the relations of the forward price and its volatility to the price and volatility of the underlying.\nBlack’s formulas are particularly useful when interest rates are assumed to be random, as we will see in Part~\\(\\ref{p_fixedincome}\\) of the book when we study fixed income derivatives. Therefore, we do not assume here that there is a constant risk-free rate. Instead we will assume that there is a discount bond that pays $1 at date \\(T^*\\). It is called a discount bond because its price is the appropriate discount factor for computing the present value of nonrandom cash flows at date \\(T^*\\). Such a bond is also called a zero coupon bond because it does not pay any cash flows until \\(T^*\\), when it pays its face value (which we take simply for convenience to be $1). We will let \\(P(t,T^*)\\) denote the price of the bond at date \\(t\\).^[In this section we could drop the \\(T^*\\) in \\(P(t,T^*)\\) and simply write \\(P_t\\), because we only consider one maturity date, but we will use the same notation when discussing multiple maturities in Part~\\(\\ref{p_fixedincome].}\\)\nBlack’s formulas are: \n\n\n\n\n\n\n10.4\n\n\n\nThe values at date \\(0\\) of European options with strike \\(K\\) and maturity \\(T\\) on a forward contract with maturity \\(T^*\\) are\n\\[\n\\text{Call Price} =P(0,T^*)F_0\\mathrm{N}(d_1)-P(0,T^*)K\\mathrm{N}(d_2)\\; ,\n\\qquad(10.11)\\]\n\\[\n\\text{Put Price} =P(0,T^*)K\\mathrm{N}(-d_2)-P(0,T^*)F_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(10.12)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.13)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.14)\\]\n\n\nBlack’s formulas are a simple consequence of Margrabe’s formula. To see this, we first need to describe the value of an option on a forward at the maturity date \\(T\\) of the option. Consider a call option. Exercise of the call results in a long forward position with forward price \\(K\\). The value of the long forward is given by its market price \\(F_T\\), but we must keep in mind that the forward price is not paid until the underlying is delivered at date \\(T^*\\). So suppose that you exercise the call and then sell a forward contract at the market forward price \\(F_T\\). The delivery/receipt obligations of the long and short forwards cancel, leaving you with the obligation to pay \\(K\\) dollars at date \\(T^*\\) and with an asset of \\(F_T\\) dollars to be received at date \\(T^*\\). The value of the net cash flow at date \\(T\\) is \\(P(T,T^*)[F_T-K]\\). This is the value if exercised, so the value of the call at date \\(T\\) is \\[\n\\max\\big(0, P(T,T^*)[F_T-K]\\big) = \\max\\big(0,P(T,T^*)F_T-P(T,T^*)K\\big)\\;.\n\\qquad(10.15)\\]\nWe can write this as \\[\n\\max(0,S_1(T)-S_2(T))\n\\qquad(10.16)\\]\nif we define \\[\nS_1(T) = P(t,T^*)F_t \\quad \\text{and} \\quad S_2(T) = P(t,T^*)K\n\\qquad(10.17)\\]\nfor \\(t=T\\) (and more generally for \\(t \\leq T\\)). Thus, the value at maturity of a call option on a forward is the value at maturity of an option to exchange the two assets with prices \\(S_1\\) and \\(S_2\\) (we will establish in a moment that \\(S_1\\) and \\(S_2\\) are actually asset prices). It follows that the value at date \\(0\\) of a call option on a forward is the value at date \\(0\\) of an option to exchange the two assets.\nNow consider a put option on a forward. Exercising the put and unwinding the short forward position by buying a forward at the market price \\(F_T\\) will leave one with a net cash flow of \\(K-F_T\\) to be received at the maturity date \\(T^*\\) of the forward. Therefore the value of the put at maturity is \\[\n\\max(0,P(T,T^*)[K-F_T]) = \\max(S_2(T)-S_1(T))\\;.\n\\qquad(10.18)\\]\nTherefore, the value at date \\(0\\) of the put option on a forward must be the value at date \\(0\\) of an exchange option, where asset one in Equation 10.17 is exchanged for asset two.\nThe key assumption in deriving Margrabe’s formula is that the volatility of the ratio of asset prices is a constant. For a call option on a forward, the relevant ratio is \\(S_1/S_2 = F/K\\). Because \\(K\\) is a constant, the volatility of the ratio is the volatility \\(\\sigma\\) of the forward price \\(F\\), which we have assumed to be constant. For a put option on a forward, the relevant ratio is \\(S_2/S_1 = K/F\\). Ito’s formula implies\n\\[\\begin{align*}\n\\frac{d(K/F)}{K/F} &= -\\frac{\\mathrm{d}  F}{F} + \\left(\\frac{\\mathrm{d}  F}{F}\\right)^2\\; ,\\\\\n&= (-\\mu +\\sigma^2)\\mathrm{d}   t - \\sigma\\mathrm{d}   B\\\\\n&= (-\\mu+\\sigma^2)\\mathrm{d}   t + \\sigma (-\\mathrm{d}  B),\n\\end{align*}\\] The purpose of the last equality displayed here is to emphasize that we should take the volatility of \\(K/F\\) to be the positive number \\(\\sigma\\). We can do this by using \\(-B\\) as the Brownian motion instead of \\(B\\).2 Thus, we can apply Margrabe’s formula to value calls and puts on forwards (once we verify that \\(S_1\\) and \\(S_2\\) are indeed asset prices).\nTo obtain Black’s Equation 10.11 for a call on a forward from Margrabe’s Equation 10.7, we simply substitute \\(S_1(0)=P(0,T^*)F_0\\), \\(S_2(0)=P(0,T^*)K\\), \\(q_1=0\\) and \\(q_2=0\\) in Margrabe’s formula. A put option is the reverse exchange, so Margrabe’s formula gives \\[\nP(0,T^*)K\\mathrm{N}(d^m_1) - P(0,T^*)F_0\\mathrm{N}(d^m_2)\\;,\n\\qquad(10.19)\\]\nwhere \\[\\begin{align*}\nd^m_1&= \\frac{\\log\\left(\\frac{P(0,T^*)K}{P(0,T^*)F_0}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\; ,\\\\\nd^m_2 &=d^m_1-\\sigma\\sqrt{T}.\n\\end{align*}\\] We introduce the superscript \\(m\\) here to distinguish these numbers in Margrabe’s formula from the \\(d_1\\) and \\(d_2\\) defined in Equation 10.13 and Equation 10.14. Notice that \\[\\begin{align*}\nd^m_1& = -\\frac{\\log\\left(\\frac{F_0}{K}\\right)-\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} = -d_2\\\\\nd^m_2 &= -\\frac{\\log\\left(\\frac{F_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}} =-d_1,\n\\end{align*}\\] so Margrabe’s Equation 10.19 is the same as Black’s Equation 10.12 for a put option on a forward.\nWe still need to explain why \\(S_1\\) and \\(S_2\\) defined in Equation 10.17 are asset prices, in fact the prices of dividend-reinvested assets since we have taken \\(q_1=q_2=0\\) in applying Margrabe’s formula. The case of \\(S_2\\) should be clear: it is the price of \\(K\\) units of the discount bond maturing at \\(T^*\\). The case of \\(S_1\\) is more subtle. It is the price of the following portfolio constructed at date \\(0\\) and held until date \\(T\\): go long one forward contract and buy \\(F_0\\) units of the discount bond maturing at \\(T^*\\). The value at date \\(t\\) of the bonds in the portfolio is \\(F_0P(t,T^*)\\). The value at date \\(t\\) of the long forward contract can be seen by considering unwinding it by selling a forward at date \\(t\\) at the market price \\(F_t\\). This cancels the delivery/receipt obligations on the underlying and results in a net cash flow of \\(F_t-F_0\\) to be received at date \\(T^*\\). The value at date \\(t\\) of this future cash flow is \\(P(t,T^*)[F_t-F_0]\\) and when we add this to the value of the bonds we obtain \\(P(t,T^*)F_t = S_1(T)\\).\nPut-call parity for options on forwards is \\[\\text{Call Price}  + P(0,T^*)K = \\text{Put Price}  + P(0,T^*)F_0\\; .\\] The left-hand side is the cost of the call and \\(K\\) units of the discount bond, which have value \\(\\max(F_T,K)P(T,T^*)\\) at time \\(T\\). The right-hand side is the cost of the put option and \\(F_0\\) units of the discount bond, which, together with a long forward contract initiated at date \\(0\\), also have value \\(\\max(F_T,K)P(T,T^*)\\) at time \\(T\\).\nAs in the case of exchange option, we can also write one-line programs for pricing options on futures and forwards.\n\n\nCode\ndef black_call(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * F, P * K, sigma, T)\n\ndef black_put(F, K, P, sigma, T):\n    \"\"\"\n    Inputs:\n    F = forward price\n    K = strike price\n    P = price of discount bond maturing when forward matures\n    sigma = volatility of forward price\n    T = time to maturity\n\n    To value a futures option, input F = futures price and P = price\n    of discount bond maturing when option matures.\n    \"\"\"\n    return generic_option(P * K, P * F, sigma, T)\n\n\nF = 100\nK = 90\nP = 0.95\nsigma = 0.2\n\nprint(\"Black Call:\", black_call(F, K, P, sigma, T))\nprint(\"Black Put:\", black_put(F, K, P, sigma, T))\n\n\nBlack Call: 12.909652710252054\nBlack Put: 3.409652710252054",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:merton",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:merton",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.5 Merton’s Formula",
    "text": "10.5 Merton’s Formula\nNow we reconsider the Black-Scholes model but without assuming there is a constant risk-free rate. We assume instead that there is a discount bond maturing at the same date as the option. Letting \\(T\\) denote the maturity date of the option and discount bond, we write the price of the discount bond at dates \\(t \\leq T\\) as \\(P(t,T)\\). We continue to assume that the stock has a constant dividend yield \\(q\\) but we make a different assumption about volatility—instead of assuming that the volatility of the stock is constant, we assume that the volatility of its forward price is constant. We relax this to allow time-varying but non-random volatility of the forward price in Section 10.15.\nThe forward contract we consider is a forward contract for the stock maturing at the date \\(T\\) that the option matures. Let \\(F_t\\) denote the forward price for this contract at dates \\(0 \\leq t\\leq T\\). Because the forward price must equal the spot price at the maturity of a forward contract, we have \\(F_T=S_T\\). Consider a call option on the forward, with the call maturing at \\(T\\) also. In the notation of the previous section, we have \\(T^*=T\\) and hence \\(P(T,T^*)=1\\) (the discount bond is worth $1 at maturity). Therefore the value Equation 10.15 of the call on the forward at its maturity \\(T\\) is \\[\\max(0,F_T-K) = \\max(0,S_T-K)\\; ,\\] which is the same as the value of the call on the stock. Therefore, the value at date \\(0\\) of the call on the stock must equal the value at date \\(0\\) of the call on the forward, and we can use Black’s Equation 10.11 for a call option on a forward to price a call option on the stock, assuming the forward price has a constant volatility.\nLikewise, the value at the maturity date \\(T\\) of a put option on the same forward contract is, from Equation 10.18, \\[\\max(0,K-F_T) = \\max(0,K-S_T)\\; .\\] Hence, we can use Black’s Equation 10.12 to price a put option on the stock, assuming the forward price has a constant volatility.\nIt is not necessary that the forward contract be traded, because we can create a synthetic forward using the stock. To create a synthetic forward at date \\(t\\) we buy \\(\\mathrm{e}^{-q(T-t)}\\) shares of the stock at cost \\(\\mathrm{e}^{-q(T-t)}S_t\\). With reinvestment of dividends, this will accumulate to one share at date \\(T\\). We finance the purchase of the stock by shorting \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) units of the discount bond. This results in a liability of \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at date \\(T\\), so the forward purchase is arranged by promising to pay \\(\\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) dollars at the delivery date; i.e., the forward price is^[If there is a constant risk-free rate \\(r\\), then it must be that \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), so Equation 10.20 becomes \\[F_t = \\mathrm{e}^{(r-q)(T-t)}S_t\\; ,\\] which is the same as the covered interest parity condition ?eq-forwardexchangerate—recall that we interpret the exchange rate as the price of an asset with dividend yield \\(q=r_f\\).} \\[\nF_t = \\frac{\\mathrm{e}^{-q(T-t)}S_t}{P(t,T)}\\;.\n\\qquad(10.20)\\]\nThe assumption we need to apply Black’s formulas is that \\[\n\\frac{\\mathrm{d}  F}{F} = \\mu\\mathrm{d}   t+\\sigma\\mathrm{d}   B\\;,\n\\qquad(10.21)\\]\nwhere \\(B\\) is a Brownian motion, \\(\\mu\\) can be a quite general random process, and \\(\\sigma\\) is a constant. At the end of this section, we will discuss the meaning of this assumption in terms of the volatilities of the stock and bond and their correlation.\nUnder this assumption, the following formulas originally due to Merton (Merton 1973) follow immediately from Black’s formulas Equation 10.11 - Equation 10.14 by substituting \\(F_0 = \\mathrm{e}^{-qT}S_0/P(0,T)\\).\n\n\n\n\n\n\n10.6\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price}  = \\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\;,\n\\qquad(10.22)\\]\n\\[\n\\text{Put Price} = P(0,T)K\\mathrm{N}(-d_2) - \\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\qquad(10.23)\\]\nwhere \\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{KP(0,T)}\\right)-qT+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.24)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.25)\\]\n\n\n\nThese formulas are clearly similar to the Black-Scholes formulas. The similarities are made more apparent by writing the discount bond price in terms of its yield. The yield \\(y\\) of the discount bond is defined as \\[y = \\frac{-\\log P(0,T)}{T} \\qquad\\Longleftrightarrow \\qquad P(0,T) = \\mathrm{e}^{-yT}\\; .\n\\] Substituting this into the expressions above, we have:\n\n\n\n\n\n\n10.7\n\n\n\nAssuming the forward price has a constant volatility \\(\\sigma\\), the values at date \\(0\\) of European calls and puts maturing at date \\(T\\) on a stock with a constant dividend yield \\(q\\) are\n\\[\n\\text{Call Price} =\\mathrm{e}^{-q T}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-yT}K\\mathrm{N}(d_2)\\;,\n\\qquad(10.26)\\]\n\\[\n\\text{Put Price} =\\mathrm{e}^{-yT}K\\mathrm{N}(-d_2)-\\mathrm{e}^{-q T}S_0\\mathrm{N}(-d_1),\n\\qquad(10.27)\\]\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(y-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.28)\\]\n\\[\nd_2 = d_1 - \\sigma\\sqrt{T}\\;.\n\\qquad(10.29)\\]\n\n\nThis shows that the Merton call and put formulas can be calculated from the Black-Scholes call and put functions given in ?sec-c:blackscholes by inputting the yield of the discount bond as the risk-free rate and by inputting the volatility of the forward price as \\(\\sigma\\).\nIf one wants to assume that there is a constant risk-free rate, then the discount bond price will have to be \\(\\mathrm{e}^{-rT}\\) and its yield will be the risk-free rate \\(r\\). In this case, the forward price is \\(\\mathrm{e}^{(r-q)T}S_0\\) and it has the same volatility as \\(S\\). Making these substitutions, the Merton formulas Equation 10.26 - Equation 10.29 are the same as the Black-Scholes formulas. However, the Merton formulas are an important generalization. It is common practice to use the yield of the discount bond as the risk-free rate that is input into the Black-Scholes formulas. The Merton formulas justify this practice. It is less common to attempt to estimate the volatility of the forward price and use this (as one should since the risk-free rate really is not constant) as the volatility in the Black-Scholes-Merton formulas. However, this does little damage for pricing short-term options, because the volatility of the forward price—see Equation 10.30 below—will be approximately the same as the volatility of the underlying for short-term options, due to the low volatility of short-term bond prices. Moreover, when one computes an implied volatility from the Black-Scholes formula (using the discount bond yield as the risk-free rate), it should be regarded as the market’s view of the forward price volatility, and it is perfectly appropriate to input it into the Black-Scholes-Merton formulas to price another option (assuming of course that the forward price volatility can be regarded as constant).\nThe volatility of the forward price can be computed in terms of the volatilities and correlation of the stock and discount bond as follows. Assume that \n\\[\\begin{align*}\n\\frac{\\mathrm{d}  S}{S}& = \\mu_s\\mathrm{d}   t + \\sigma_s\\mathrm{d}   B_s\\; ,\\\\\n\\frac{\\mathrm{d}  P}{P}& = \\mu_p\\mathrm{d}   t + \\sigma_p\\mathrm{d}   B_p,\n\\end{align*}\\] where \\(B_s\\) and \\(B_p\\) are Brownian motions with correlation \\(\\rho\\). Then ?eq-volatilityproduct and ?eq-volatilityratio show that the volatility of \\(F_t = \\mathrm{e}^{-q(T-t)}S_t/P(t,T)\\) is \\(\\sigma\\) defined as \\[\n\\sigma = \\sqrt{\\sigma_s^2+\\sigma_p^2 - 2\\rho\\sigma_s\\sigma_p}\\;.\n\\qquad(10.30)\\]\nAs mentioned before, we will consider in Section 10.15 that the the volatility Equation 10.30 may vary over time in a non-random way.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#deferred-exchange-options",
    "href": "Chapter_MertonMargrabeBlack.html#deferred-exchange-options",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.8 Deferred Exchange Options",
    "text": "10.8 Deferred Exchange Options\nA call option on a forward can be viewed as an option to exchange \\(K\\) dollars (or, equivalently, \\(K\\) units of the discount bond maturing at the maturity date of the forward) for the underlying asset, with the exchange taking place at the maturity date of the forward. Therefore, it is an exchange option in which the exchange takes place at a fixed date after the option matures. We can easily extend Margrabe’s formula to value options to exchange other assets when the option maturity precedes the date of the exchange. \nAs in Section 10.1, consider two assets with prices \\(S_i\\) and constant dividend yields \\(q_i\\) and assume the prices satisfy \\[\\frac{\\mathrm{d}  S_i}{S_i} = \\mu_i\\mathrm{d}   t + \\sigma_i\\mathrm{d}   B_i\\; ,\\] where the drifts \\(\\mu_i\\), the volatilities \\(\\sigma_i\\) and the correlation \\(\\rho\\) of the two Brownian motions can be general random processes. However, also as in Section 10.1, assume that the volatility \\[\\sigma = \\sqrt{\\sigma_1^2 + \\sigma_2^2 - 2\\rho\\sigma_1\\sigma_2}\\] of the ratio of asset prices is constant.\nConsider an option maturing at date \\(T\\) to exchange the second asset for the first asset at date \\(T^*\\geq T\\). To understand the value of the option at date \\(T\\), suppose it is exercised. To unwind the positions in the two assets, one can sell a forward contract on the asset to be received and buy a forward contract on the asset to be delivered, with the forward contracts maturing at the date of the exchange. Then the difference \\(F_1(T)-F_2(T)\\) in the forward prices is a cash flow to be received/paid at the exchange date \\(T^*\\) and its value at date \\(T\\) is \\(P(T,T^*)[F_1(T)-F_2(T)]\\). Therefore, the value of the option at its maturity \\(T\\) is \\[\\max(0,P(T,T^*)F_1(T) - P(T,T^*)F_2(T))\\; .\\] As in Section 10.3, this valuation does not require the existence of traded forward contracts, because synthetic forwards can be created. Also as in Section 10.3 we know that \\[S^*_1(t) = P(t,T^*)F_1(T) \\quad \\text{and} \\quad S^*_2(t) = P(t,T^*)F_2(T)\\] are the prices of dividend-reinvested assets. Therefore, the option to exchange the assets at date \\(T^*\\) must have the same value as an option to exchange at date \\(T\\) the assets with prices \\(S^*_i\\).\nWe recall here the arbitrage Equation 10.20 for the forward prices (making the change that here the forwards mature at \\(T^*\\)): \\[F_i(t) =  \\frac{\\mathrm{e}^{-q_i(T^*-t)}S_i(T)}{P(t,T^*)}\\; .\\] Thus, \\[S^*_i(t) = \\mathrm{e}^{-q_i(T^*-t)}S_i(T)\\; .\\] This implies that the volatility of the ratio \\(S_1^*/S_2^*\\) is the same as the volatility of the ratio \\(S_1/S_2\\). Therefore, we can price a deferred exchange option from Margrabe’s formula, inputting the prices \\(S^*_i(0) = \\mathrm{e}^{-q_iT^*}S_i(0)\\) as the initial asset prices and zero as their dividend yields. This formula is:\n\n\n\n\n\n\n10.9\n\n\n\nThe value of a European option maturing at date \\(T\\) to exchange two assets at date \\(T^*\\) is \\[\n\\mathrm{e}^{-q_1 T^*}S_1(0)\\mathrm{N}(d_1)-\\mathrm{e}^{-q_2 T^*}S_2(0)\\mathrm{N}(d_2)\\;,\n\\qquad(10.31)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+(q_2-q_1)T^*+\n\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.32)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;,\n\\qquad(10.33)\\]\n\n\n\n\nCode\ndef margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch):\n    \"\"\"\n    Inputs:\n    S1 = price of asset to be received\n    S2 = price of asset to be delivered\n    sigma = volatility of ratio of prices\n    q1 = dividend yield of asset to be received\n    q2 = dividend yield of asset to be delivered\n    Tmat = time to maturity of option\n    Texch = time until exchange &gt;= TOption\n    \"\"\"\n    P1 = np.exp(-q1 * Texch) * S1\n    P2 = np.exp(-q2 * Texch) * S2\n    return generic_option(P1, P2, sigma, Tmat)\n\n# Example usage\nS1 = 100\nS2 = 90\nq1 = 0.01\nq2 = 0.02\nsigma=0.2\nTmat = 1\nTexch = 2\n\nprint(\"Margrabe Deferred:\", margrabe_deferred(S1, S2, sigma, q1, q2, Tmat, Texch))\n\n\nMargrabe Deferred: 14.513318533107103",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:forwardhedging",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:forwardhedging",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.10 Greeks and Hedging",
    "text": "10.10 Greeks and Hedging\nThe Greeks for the Margrabe and Black formulas can be calculated in the same way that we calculated them in ?sec-c:blackscholes for the Black-Scholes formula. In analogy with ?eq-greeksimplify, it can be shown for the Margrabe formula that \\[\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1) = \\mathrm{e}^{-q_2T}S_2(0)\\mathrm{n}d(d_2)\\; ,\\] and again this simplifies the calculations. This equation applies to the Black call formula by taking \\(q_1=q_2=0\\), \\(S_1(0)=P(0,T^*)F_0\\), and \\(S_2(0)=P(0,T^*)K\\), leading to \\[F_0\\mathrm{n}d(d_1) = K\\mathrm{n}d(d_2)\\; .\\] The Greeks for the Black call formula and the Margrabe formula are: \n\n\n\n\n\n\n10.11\n\n\n\n\\[\\begin{align*}\n&**Black Call** && **Margrabe**\\\\\n& & & \\\\\n\\frac{\\partial}{\\partial F} &= P(0,T^*)\\mathrm{N}(d_1)  % Black delta1\n&\\frac{\\partial}{\\partial S_1}&= \\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\\\ % Margrabe delta1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial P} &= F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)% Black delta2\n&\\frac{\\partial}{\\partial S_2}&=-\\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\\\ % Margrabe delta2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F^2} &= \\frac{P(0,T^*)\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}F_0}  % Black gamma1\n&\\frac{\\partial^2}{\\partial S_1^2}&= \\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_1(0)}\\\\ % Margrabe gamma1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial P^2} &= 0 % Black gamma2\n&\\frac{\\partial^2}{\\partial S_2^2}&=\\frac{\\mathrm{e}^{-q_2T}\\mathrm{n}d(d_2)}{\\sigma\\sqrt{T}S_2(0)}\\\\ %Margrabe gamma2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial^2}{\\partial F \\partial P} &= \\mathrm{N}(d_1)&\\frac{\\partial^2}{\\partial S_1 \\partial S_2}% Black crossgamma\n&= -\\frac{\\mathrm{e}^{-q_1T}\\mathrm{n}d(d_1)}{\\sigma\\sqrt{T}S_2(0)}\\\\ % Margrabe crossgamma\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\\frac{\\partial}{\\partial T} &= -\\frac{\\sigma P(0,T^*)F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}%Black theta part1\n& -\\frac{\\partial}{\\partial T}&=q_1\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{N}(d_1)\\\\ %Margrabe theta part1\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n& &&-q_2\\mathrm{e}^{-q_2T}S_2(0)\\mathrm{N}(d_2)\\\\ % Margrabe theta part2\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n&&&-\\frac{\\sigma \\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\\\ % Margrabe theta part3\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\\frac{\\partial}{\\partial \\sigma} &= \\sqrt{T}P(0,T^*)F_0\\mathrm{n}d(d_1) % Black vega\n&\\frac{\\partial}{\\partial \\sigma}&=\\sqrt{T}\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{n}d(d_1) % Margrabe vega\n\\end{align*}\\]\n\n\nHedging for the Margrabe formula is much the same as for the Black-Scholes formula. We would delta-hedge a written exchange option by holding \\(\\delta_1=\\mathrm{e}^{-q_1T}\\mathrm{N}(d_1)\\) shares of the first asset and \\(\\delta_2 =- \\mathrm{e}^{-q_2T}\\mathrm{N}(d_2)\\) shares of the second asset (which means shorting the second asset). This position would be financed by borrowing at the risk-free rate (or shorting the discount bond). The same argument that we used in ?sec-s:deltahedging shows that this zero-cost portfolio will have a zero return if continuously rebalanced.\nBecause the Black formulas are a special case of the Margrabe formula, we can delta-hedge options on forwards in the same way. Putting \\(q_1=q_2=0\\), \\(S_1(0)=P(0,T^*)F_0\\) and \\(S_2(0)=P(0,T^*)K\\), we would delta-hedge a written call option by buying \\(\\mathrm{N}(d_1)\\) shares of the first asset and shorting \\(\\mathrm{N}(d_2)\\) shares of the second, where \\(d_1\\) and \\(d_2\\) are defined in the Margrabe formulas Equation 10.8 and Equation 10.9 and equivalently in the Black formulas Equation 10.13 and Equation 10.14. This position would be financed by shorting the discount bond to raise the difference between the cost of the portfolio and the option value so that the cost of the total portfolio (including the short discount bond) equals the option value. However, the first asset here consists of a long forward contract plus \\(F_0\\) units of the discount bond, and the second asset is \\(K\\) units of the discount bond. Furthermore, we are using the discount bond to finance the position (including the buying and shorting of the discount bond!). We can conclude that buying \\(\\mathrm{N}(d_1)\\) units of the first asset means that we should buy \\(\\mathrm{N}(d_1)\\) forward contracts. This has zero cost. Therefore, the portfolio value will equal the value of the discount bonds, and this must equal the option value. So, we actually invest the option value\n\\[P(0,T^*)F_0\\mathrm{N}(d_1) - P(0,T^*)K\\mathrm{N}(d_2)\\; ,\\] in the discount bond, which means buying \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the bond.\nA more direct analysis of hedging options on forwards is possible and instructive. We will consider that topic further in Section 10.16.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:futuresforwards",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:futuresforwards",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.12 The Relation of Futures Prices to Forward Prices",
    "text": "10.12 The Relation of Futures Prices to Forward Prices\nThe difference between futures and forward contracts is that futures are marked to market, which means that daily gains and losses are posted to the investor’s margin account. Thus, there are interim cash flows on a futures contract, whereas the only cash flows on a forward contract are at the maturity of the forward. We will establish three useful facts in this section, the last of which follows from the first two:\n\nFutures prices are martingales under the risk-neutral probability.\nForward prices are martingales when we use the discount bond with the same maturity as the forward as the numeraire.\nWhen interest rates are non-random, futures prices equal forward prices.\n\nWe consider the idealized case in which the futures contract is continuously marked to market. Assume there is an instantaneously risk-free asset with rate of return \\(r\\), which could vary randomly over time, and define, as in ?sec-c:arbitrage, \\[R_t = \\exp\\left(\\int_0^t r_s\\,ds\\right)\\; ,\\] which is the value at date \\(t\\) of a $1 investment in the asset at date \\(0\\), with interest continuously reinvested. Let \\(T^*\\) denote the maturity of the futures contract, and let \\(F^*_t\\) denote the futures price at dates \\(t \\leq T^*\\) (the \\(^*\\) notation is to distinguish the futures price from the forward price \\(F\\)). Consider the portfolio strategy that starts with zero dollars and one long futures contract at price \\(F^*_0\\) and which continuously invests and withdraws from the risk-free asset the gains and losses on the futures contract. Let \\(V_t\\) denote the value of this portfolio at date \\(t\\). The change in the value of the portfolio at any instant is the interest earned (or paid, if \\(V&lt;0\\)) on the risk-free asset plus the gain/loss on the futures. This means that \\[\\mathrm{d}  V = rV\\mathrm{d}   t + \\mathrm{d}  F^*\\; .\\] Because all gains and losses on this portfolio are reinvested, \\(V\\) is the price of a dividend-reinvested asset. Therefore, under the risk-neutral probability (i.e., using \\(R\\) as the numeraire), the ratio \\(V/R\\) must be a martingale and hence have zero drift. From Ito’s formula, \\[\\begin{align*}\n\\frac{\\mathrm{d}  (V/R)}{V/R} &= \\frac{\\mathrm{d}  V}{V} - \\frac{\\mathrm{d}  R}{R}\\\\\n&=\\frac{rV\\mathrm{d}   t + \\mathrm{d}  F^*}{V} - r\\mathrm{d}   t\\\\\n&= \\frac{\\mathrm{d}  F^*}{V}\\;.\n\\end{align*}\\] Thus, the drift of \\(V/R\\) being zero implies the drift of \\(F^*\\) is zero. We need to assume (and can assume) that \\(F^*\\) is an Ito process with finite expected quadratic variation—cf. condition Equation 6.9—in which case the absence of a drift implies that it is a martingale.\nNow we turn to fact (2). Consider a forward contract with maturity \\(T^*\\) and a discount bond also maturing at \\(T^*\\). Let \\(F_t\\) denote the forward price and let \\(P(t,T^*)\\) denote the price of the discount bond at dates \\(t \\leq T^*\\). We observed in Section 10.3 that there is a dividend-reinvested asset with price \\(P(t,T^*)F_t\\). When we use the discount bond as the numeraire, the ratio \\(P(t,T^*)F_t/P(t,T^*) = F_t\\) must be a martingale, which is fact (2). Because of this fact, a probability measure corresponding to a discount bond being the numeraire is called a forward measure. \nSuppose now that interest rates are deterministic, that is, even if \\(r\\) varies over time, it does so in a non-random way. Then the discount bond price at date \\(0\\) must be the discount factor \\[P(0,T^*) = \\exp\\left(-\\int_0^{T^*} r_t\\mathrm{d}   t\\right)\\; .\\] ?eq-probSnumeraire gives the probability of any event \\(A\\) when the discount bond is used as the numeraire as \\[\\text{prob}^P[A] = \\mathbb{E}\\left[1_A\\phi_{T^*}\\frac{P(T^*,T^*)}{P(0,T^*)}\\right] = \\exp\\left(-\\int_0^{T^*} r_t\\mathrm{d}   t\\right)\\mathbb{E}[1_A\\phi_{T^*}]\\; ,\\] where \\(\\phi\\) denotes the state prices. On the other hand, the same equation gives the probability of \\(A\\) when \\(R\\) is used as the numeraire as \\[\\text{prob}^R[A] = \\mathbb{E}\\left[1_A\\phi_{T^*}\\frac{R_{T^*}}{R_0}\\right] = \\exp\\left(-\\int_0^{T^*} r_t\\mathrm{d}   t\\right)\\mathbb{E}[1_A\\phi_{T^*}]\\; .\\] Therefore, the two probability measures are the same, and consequently the expectations \\(\\mathbb{E}^P\\) and \\(\\mathbb{E}^R\\) are the same. Now using the fact that both the futures price and the forward price must equal the spot price at maturity, we have \\(F^*_{T^*} = F_{T^*}\\), and, from the martingale properties, \\[F^*_t = \\mathbb{E}_t^P[F^*_{T^*}] = \\mathbb{E}_t^P[F_{T^*}] = \\mathbb{E}_t^R[F_{T^*}] = F_t\\; ,\\] which is fact (3).",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:futuresoptions",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:futuresoptions",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.13 Futures Options",
    "text": "10.13 Futures Options\nNow we consider options on futures contracts, assuming that interest rates are deterministic. We just showed that in this circumstance the futures price will equal the forward price for a contract of the same maturity. However, the values of options on a futures contract do not equal the values of options on the corresponding forward contract.\nThe difference is due to marking to market. Consider futures and forward contracts with maturity \\(T^*\\) and options maturing at \\(T \\leq T^*\\). Exercise of a call option on a futures contract will roll the investor into a long futures contract with futures price equal to the market futures price at that date. The difference \\(F^*_T-K\\) between the market futures price and the strike price of the option is immediately credited to the investor’s margin account. On the other hand, exercise of an option on a forward and sale of the forward results in a cash flow of \\(F_T - K\\) that is received at the maturity date \\(T^*\\) of the forward. Therefore, the value at maturity of a call option on a futures contract is \\(\\max(0,F^*_T-K)\\), whereas, as noted before, the value of a call option on a forward at the maturity of the option is \\(P(T,T^*)\\max(0,F_T-K)\\)\nAs in the analysis of options on forwards, an options on a futures contract can be viewed as an exchange option, where one exchanges the asset with price \\(S_2(T) = P(t,T)K\\) at date \\(t\\leq T\\) for the asset with price \\(S_1(T) = P(t,T)F^*_t\\). The asset with price \\(S_2\\) is of course \\(K\\) units of the discount bond maturing at \\(T\\). Assuming interest rates are deterministic, we have \\(F^*_t = F_t\\), and we noted in Section 10.3 that \\(P(t,T)F_t\\) is the price of a dividend-reinvested asset. Thus, we can apply Margrabe’s formula to price call (and put) options on futures when interest rates are deterministic. Compared to options on forwards, the difference is that the discount bonds defining the prices \\(S_1\\) and \\(S_2\\) mature at the maturity date of the option rather than at the maturity date of the futures or forward contract. The result is:\n\n\n\n\n\n\n10.14\n\n\n\nWhen interest rates are deterministic and the futures price \\(F^*\\) has a constant volatility \\(\\sigma\\), the values of European calls and puts on a futures contract are\n\\[\n\\text{Call Price} =P(0,T)F^*_0\\mathrm{N}(d_1)-P(0,T)K\\mathrm{N}(d_2)\\; ,\n\\qquad(10.34)\\]\n\\[\n\\text{Put Price} =P(0,T)K\\mathrm{N}(-d_2)-P(0,T)F^*_0\\mathrm{N}(-d_1)\\; ,\n\\qquad(10.35)\\]\n\\[\n\\] where \\[\nd_1= \\frac{\\log\\left(\\frac{F^*_0}{K}\\right)+\\frac{1}{2}\\sigma^2T}{\\sigma\\sqrt{T}}\\;,\n\\qquad(10.36)\\]\n\\[\nd_2=d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(10.37)\\]\n\n\nWe can calculate these values from the Black_Call and Black_Put functions by inputting the price of the discount bond maturing when the option matures rather than the price of the discount bond maturing when the forward/futures matures.\nWe will derive delta hedges for futures options in Section 10.16.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:volatility",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:volatility",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.15 Time-Varying Volatility",
    "text": "10.15 Time-Varying Volatility\nAll of the option pricing formulas in this chapter were derived from Margrabe’s formula, the main assumption of which is that the logarithm of the ratio of asset prices at date \\(T\\) is normally distributed with variance equal to \\(\\sigma^2T\\). The formulas in this chapter can easily be adapted to allow a time-varying but non-random volatility. This occurs in certain bond-option pricing models (which are outside the scope of this book). If the volatility is a non-random function \\(\\sigma_t\\) of time, then we define \\(\\sigma_{\\text{avg}}\\) to be the number such that \\[\n\\sigma_{\\text{avg}}^2 = \\frac{1}{T}\\int_0^T \\sigma^2_t\\mathrm{d}   t\\;.\n\\qquad(10.38)\\]\nWe should input \\(\\sigma_{\\text{avg}}\\) as (i) the volatility of the ratio of asset prices in Margrabe’s formula and the deferred exchange option formula if \\(\\sigma_t\\) is the volatility of the ratio at date \\(t\\) or as (ii) the volatility of the forward price in Black’s and Merton’s formulas if \\(\\sigma_t\\) is the volatility of the forward price at date \\(t\\).",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:hedgingforwards",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:hedgingforwards",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.16 Hedging with Forwards and Futures",
    "text": "10.16 Hedging with Forwards and Futures\nWe need to discuss the gains and losses that accrue from trading forwards. Consider dates \\(t&lt;u\\) and a forward contract with maturity \\(T\\). Suppose we purchase \\(x_t\\) forwards at date \\(t\\) and then change our position in forwards to \\(x(u)\\) at time \\(u\\). The purchase/sale of \\(x(u)-x_t\\) new contracts does not affect the portfolio value, so the change in the value of the portfolio is the change in the value of the \\(x_t\\) contracts purchased at date \\(t\\). These contracts were worth zero at date \\(t\\), because forward contracts have zero value at initiation. Selling them at date \\(u\\) cancels the obligation to deliver/receive the underlying, leaving one with a cash flow of \\(x_t[F(u)-F_t]\\) dollars to be received at date \\(T\\). The value of this cash flow at date \\(u\\) is \\(x_tP(u,T)[F(u)-F_t]\\). We can write this as \\[\\begin{align*}\nx_tP(u,T)[F(u)-F_t]  &= x_t\\big[P(t,T)[F(u)-F_t] + [P(u,T)-P(t,T)][F(u)-F_t]\\big]\\\\\n&= x_t\\big[P(t,T)\\,\\Delta F + (\\Delta P)(\\Delta F)\\big]\\;.\n\\end{align*}\\] This motivates the following definition:\n\n\n\n\n\n\n10.17\n\n\n\nThe change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\big[P(t,T)\\mathrm{d}   F_t + \\mathrm{d}  P(t,T)\\times \\mathrm{d}  F_t]\\;,\n\\qquad(10.39)\\]\nwhere \\(x_t\\) denotes the number of forward contracts held, \\(F_t\\) denotes the forward price, \\(P(t,T)\\) denotes the price of a discount bond maturing at \\(T\\), and \\(T\\) is the maturity of the forward contract.\n\n\nHedging with futures is a bit simpler, because the gains and losses are received instantaneously (daily, at least) rather than being deferred to the contract maturity. Letting \\(x_t\\) denote the number of futures contracts held at date \\(t\\) and \\(F^*_t\\) the futures price, the cash flow from the contracts is \\(x_t\\mathrm{d}   F^*_t\\). This is also the change in the value of the portfolio, because marking to market means that the contracts always have zero value.\nTo compare hedging with futures and forwards, assume there is a constant risk-free rate \\(r\\). Let \\(T\\) denote the maturity of the futures and forward contracts. Because there is a constant risk-free rate, we have \\(P(t,T) = \\mathrm{e}^{-r(T-t)}\\), which implies \\((\\mathrm{d}  P)(\\mathrm{d}  F) =0\\). Moreover, futures prices equal forward prices. Thus,\n\n\n\n\n\n\n10.18\n\n\n\nIf there is a constant risk-free rate \\(r\\), the change in the value of a portfolio of forward contracts at date \\(t\\) is \\[\nx_t\\mathrm{e}^{-r(T-t)}\\mathrm{d}   F_t\n\\qquad(10.40)\\]\nand the change in the value of a portfolio of futures contracts is \\[\nx_t\\mathrm{d}   F_t\\;,\n\\qquad(10.41)\\]\nwhere \\(x_t\\) denotes the number of futures/forward contracts held at date \\(t\\), \\(T\\) is the maturity of the futures and forward contracts and \\(F_t\\) is the futures (= forward) price at date \\(t\\).\n\n\nComparing Equation 10.40 and Equation 10.41, we see that if \\(x_t\\) is the number of forward contracts that should be held in a hedge, then \\[\ny_t = \\mathrm{e}^{-r(T-t)}x_t\n\\qquad(10.42)\\]\nis the number of futures contracts that should be held, because with this number of contracts we have \\[\\begin{align*}\n\\text{Change in Forward Portfolio} & = x_t\\mathrm{e}^{-r(T-t)}\\mathrm{d}   F_t\\\\\n& = y_t\\mathrm{d}   F_t\\\\\n& = \\text{Change in Futures Portfolio}\\;.\n\\end{align*}\\] In short, we don’t require as many futures contracts as forward contracts, and the scaling factor to convert from forwards to futures is just the present value factor \\(\\mathrm{e}^{-r(T-t)}\\).\nFor example, the result of ?sec-s:replicatingquantos on replicating the payoff \\(\\bar{X}S_T\\) with forward contracts leads to the following:\n\n\n\n\n\n\n10.19\n\n\n\nTo replicate the payoff \\(\\bar{X}S_T\\) at date \\(T\\), where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset, one should invest \\(V_t\\) units of domestic currency in the foreign asset and be short \\(\\mathrm{e}^{(r_f-r)(T-t)}V_t/X_t\\) currency futures at date \\(t\\), where \\(V_t\\) is defined in ?eq-quanto2 and \\(X_t\\) is the spot exchange rate.\n\n\nWe can use Equation 10.42 to determine how to delta hedge futures options. As explained in Section 10.13, assuming non-random interest rates, futures options are more valuable than options on forwards because futures are marked to market upon exercise of an option. Specifically, Black’s formulas Equation 10.11 - Equation 10.14 for options on forwards and Equation 10.34 - Equation 10.37 for options on futures show that the values are the same except for the maturity of the discount bond appearing in the equations. With a constant risk-free rate \\(r\\), options maturing at \\(T\\) and futures/forwards maturing at \\(T^*\\), the relation is \\[\\text{Value of Futures Option} = \\mathrm{e}^{r(T^*-T)} \\times \\text{Value of Forward Option}\\; .\\] Because the scaling factor \\(\\mathrm{e}^{r(T^*-T)}\\) does not change as time passes, this implies that as time passes we have\n\\[\n\\begin{multline}\n\\text{Change in Futures Option Value } \\\\= \\mathrm{e}^{r(T^*-T)} \\times \\text{Change in Forward Option Value}\\;.\n\\end{multline}\n\\qquad(10.43)\\]\nWe can combine Equation 10.42 and Equation 10.43 to convert from a hedge of a forward option using forward contracts, which we discussed in Section 10.10, to a hedge of a futures option using futures contracts. For example, we concluded in Section 10.10 that we should be long \\(\\mathrm{N}(d_1)\\) forwards to hedge a short call option on a forward contract. Consequently, Equation 10.42 shows that we can hedge a short call option on a forward by being long \\(\\mathrm{e}^{-r(T^*-t)}\\mathrm{N}(d_1)\\) futures, and then we see from Equation 10.43 that the hedge for a short call on a futures is being long \\[\\mathrm{e}^{r(T^*-T)}\\mathrm{e}^{-r(T^*-t)}\\mathrm{N}(d_1) = \\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\] futures contracts.\nIn Section 10.10, we derived the hedges for forward options by considering them as exchange options. We can use Equation 10.39 to confirm that our calculations were correct. Consider hedging a short call maturing at \\(T\\) on a forward contract maturing at \\(T^*\\). We can assume interest rates vary randomly and use discount bonds in the hedge. We stated in Section 10.10 that we should hold \\(F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\) units of the discount bond maturing at \\(T^*\\) and we should go long \\(\\mathrm{N}(d_1)\\) forwards to hedge the short call. This is a zero-cost portfolio when we include the proceeds from selling the call. Using Equation 10.39, we see that the change in the value of the portfolio will be \\[\n-\\mathrm{d}  C + [F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)]\\mathrm{d}  P + \\mathrm{N}(d_1)[P(0,T^*)\\mathrm{d}   F + (\\mathrm{d}  P)(\\mathrm{d}  F)]\\;.\n\\qquad(10.44)\\]\nThe value of the call at date \\(t\\) will be a function of \\(t\\), \\(P(t,T^*)\\) and \\(F_t\\), which we write as \\(C(t,P,F)\\). From Ito’s formula, \\[\\begin{align*}\n\\mathrm{d}  C &= \\frac{\\partial C}{\\partial t}\\mathrm{d}   t + \\frac{\\partial C}{\\partial P}\\mathrm{d}   P + \\frac{\\partial C}{\\partial F}\\mathrm{d}   F \\\\  &\\qquad + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial P^2}\\, (\\mathrm{d}  P)^2   + \\frac{1}{2}\\frac{\\partial^2 C}{\\partial F^2}\\, (\\mathrm{d}  F)^2 + \\frac{\\partial^2 C}{\\partial F \\partial P} (\\mathrm{d}  P)(\\mathrm{d}  F)\\;.\\\\\n&=\\Theta\\mathrm{d}   t + \\delta_P\\mathrm{d}   P + \\delta_F\\mathrm{d}   F  + \\frac{1}{2}\\Gamma_{PP} (\\mathrm{d}  P)^2 + \\frac{1}{2}\\Gamma_{FF} (\\mathrm{d}  F)^2  + \\Gamma_{FP}\\,(\\mathrm{d}  P)(\\mathrm{d}  F)\\;,\n\\end{align*}\\] where the \\(\\delta\\)’s and \\(\\Gamma\\)’s denote the first and second partial derivatives indicated by the subscripts. Inserting this formula into Equation 10.44 and making use of the formulas in the table in Section 10.10, we see that the \\(\\mathrm{d}  P\\) terms cancel because \\(\\delta_P = F_0\\mathrm{N}(d_1)-K\\mathrm{N}(d_2)\\). Furthermore, the \\(\\mathrm{d}  F\\) terms cancel because \\(\\delta_F = \\mathrm{N}(d_1)P(0,T^*)\\). Thus, there is no exposure in the portfolio to the two risky asset prices \\(P\\) and \\(F\\). Furthermore, \\(\\Gamma_{PP} = 0\\) and the \\((\\mathrm{d}  P)(\\mathrm{d}  F)\\) terms cancel because \\(\\Gamma_{FP} = \\mathrm{N}(d_1)\\). These substitutions simplify the change Equation 10.44 in the value of the portfolio to \\[-\\Theta\\mathrm{d}   t - \\frac{1}{2}\\Gamma_{FF} (\\mathrm{d}  F)^2  = \\frac{\\sigma P(0,T^*)F_0\\mathrm{n}d(d_1)}{2\\sqrt{T}}\\mathrm{d}   t  -  \\frac{P(0,T^*)\\mathrm{n}d(d_1)}{2\\sigma\\sqrt{T}F_0}\\,(\\mathrm{d}  F)^2\\; ,\\] which we can see to be zero because \\((\\mathrm{d}  F)^2 = \\sigma^2F^2\\mathrm{d}   t\\). Thus, the hedge is perfect when continuously rebalanced.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#sec-s:margrabecomplete",
    "href": "Chapter_MertonMargrabeBlack.html#sec-s:margrabecomplete",
    "title": "10  Merton, Black, and Margrabe",
    "section": "10.20 Market Completeness",
    "text": "10.20 Market Completeness\nA formal definition of market completeness must specify which state-contin-gent claims (random variables depending on the history of prices) can be replicated by trading the marketed assets—for example, one might want all of the claims with finite means to be replicable, or only all of the claims with finite variances, etc. A formal analysis of market completeness is not presented in this book, except for the binomial and trinomial models in ?sec-c:arbitrage. However, we have stated that stochastic volatility models are incomplete. This follows intuitively from the fact that a portfolio containing only one risky asset (the underlying) cannot be perfectly correlated with the two Brownian motions that determine the value of a derivative asset (the Brownian motions driving the price of the underlying and its volatility). In general, a market must include an instantaneously risk-free asset and as many risky assets as there are Brownian motions in order to be complete.\nThe exchange-option model of Margrabe—with two risky assets, two Brownian motions, and no risk-free asset—is obviously incomplete. For example, it is impossible to have exactly $100 at date \\(T\\). With no risk-free asset, there is simply no way to store money. This may seem far-fetched, but we might be interested in payoffs in real (i.e., inflation-adjusted) dollars, in which case the absence of a risk-free asset may be a normal situation. In any case, we have not assumed a risk-free asset exists, but we have priced options without appealing to equilibrium arguments. This deserves some clarification.\nAs mentioned above, a formal definition of market completeness must specify which contingent claims are to be replicable. The Margrabe model is complete for a certain set of contingent claims. Contingent claims of the form \\(S_2(T)X_T\\) where \\(X_T\\) is a random variable depending on the relative prices \\(S_1(T)/S_2(T)\\) for \\(0 \\leq t\\leq T\\) can be replicated. Likewise, contingent claims of the form \\(S_1(T)X_T\\) can be replicated. The payoffs of exchange options are of this form, so they can be priced by arbitrage, even though there are other contingent claims (for example, receiving exactly $100 at date \\(T\\)) that cannot be replicated and hence cannot be priced by arbitrage. Likewise, the Black and Merton models in which there is a zero-coupon bond but no instantaneously risk-free asset are examples of incomplete markets that are still sufficiently complete to price options by arbitrage (the options can be replicated). The proof that the Margrabe model is complete in the sense stated here follows from the change of numeraire argument used to derive Margrabe’s formula from the Black-Scholes formula (recall that the second asset is risk-free when we use it as the numeraire, so there is a risk-free asset under the new numeraire) and a proof that the Black-Scholes model is complete (which we have omitted, except to show that European options can be replicated).\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will conclude with a proof of the Margrabe formula that does not depend on the Black-Scholes formula. Let \\(x\\) denote the random variable taking the value 1 when \\(S_1(T)&gt;S_2(T)\\) and which is 0 otherwise. Then the value of the exchange option at maturity is \\(xS_1(T)-xS_2(T)\\). Let \\(V_i\\) denote the value of the portfolio beginning with \\(\\mathrm{e}^{-q_iT}\\) units of asset \\(i\\) at date \\(0\\) and reinvesting dividends, to accumulate to one share at date \\(T\\). Then \\(V_i(T)=S_i(T)\\) and from the fundamental pricing ?eq-formula the value at date \\(0\\) of receiving \\(xS_i(T)\\) at date \\(T\\) is \\[\\begin{align*}\nV_i(0)\\mathbb{E}^{V_i}\\left[x\\frac{S_i(T)}{V_i(T)}\\right] &= \\mathrm{e}^{-q_iT}S_i(0)\\mathbb{E}^{V_i}[x] \\\\\n&= \\mathrm{e}^{-q_iT}S_i(0)\\times\\text{prob}^{V_i}\\big(V_1(T)&gt;V_2(T)\\big)\\; .\n\\end{align*}\\] We can write the value of receiving \\(xS_1(T)\\) as \\[\\mathrm{e}^{-q_1T}S_1(0)\\times\\text{prob}^{V_1}\\left(\\frac{V_2(T)}{V_1(T)} &lt; 1\\right)\\] and the value of receiving \\(xS_2(T)\\) as \\[\\mathrm{e}^{-q_2T}S_2(0)\\times\\text{prob}^{V_2}\\left(\\frac{V_1(T)}{V_2(T)} &gt; 1\\right)\\;.\\] Note that \\(V_2/V_1\\) is a martingale when we use \\(V_1\\) as the numeraire and \\(V_1/V_2\\) is a martingale when we use \\(V_2\\) as the numeraire. Because they are martingales, they have no drifts. The volatility of the ratios is given in Equation 10.6. Therefore, we have \\[\\begin{align*}\n\\frac{\\mathrm{d}  (V_2/V_1)}{V_2/V_1} &= \\sigma \\mathrm{d}   B^*_1,\\\\\n\\frac{\\mathrm{d}  (V_1/V_2)}{V_1/V_2} &= \\sigma \\mathrm{d}   B^*_2,\n\\end{align*}\\] where \\(B^*_i\\) is a Brownian motion when \\(V_i\\) is used as the numeraire. Margrabe’s formula now follows from the tail probability formulas Equation 7.9–Equation 7.11.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#section-10",
    "href": "Chapter_MertonMargrabeBlack.html#section-10",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "Derive the Greeks of a call option on a futures contract.\n\n\nUsing the results of the previous exercise, show that the delta hedge of a written call on a futures contract that consists of \\(\\mathrm{e}^{-r(T-t)}\\mathrm{N}(d_1)\\) long futures contracts and the value of the call invested in the risk-free asset is a riskless hedge.\n\n\nDerive a formula (like put-call parity) for the value of an option to exchange asset~1 for asset~2 in terms of the value of an option to do the reverse exchange.\n\n\nCreate a Python function Black_Call_Implied_Vol that uses bisection to compute an implied forward price volatility from Black’s formula and the market price of a call option on a forward.\n\n\nUsing a synthetic forward argument, derive the forward price for a forward contract on a stock, where the forward matures at \\(T^*\\) and the stock pays a single known cash dividend \\(D\\) at date \\(T&lt;T^*\\).\n\n\nUsing the result of the previous exercise and Black’s formula, derive a formula for the value of a European call option on a stock that pays a single known cash dividend before the option matures.\n\n\nModify the function Simulated_Delta_Hedge_Profits to compute the percentiles of gains and losses for an investor who writes a call option on a forward contract and uses a discretely-rebalanced delta hedge. As in ?exr-e_forwardhedging, you will need to create a variable to keep track of the net asset/liability from trading forwards and include it in the valuation at date \\(T\\).\n\n\nConsider the portfolio that promises to pay \\(\\bar{X}S_T\\) at date \\(T\\) and replicates the payoff using currency forwards described in ?sec-s:replicatingquantos, where \\(\\bar{X}\\) is a fixed exchange rate and \\(S\\) is the foreign currency price of an asset. Using Equation 10.39 of gains and losses from trading forwards, verify that the portfolio is riskless.\n\n\nRepeat the previous exercise using the futures hedge described in Section 10.16.\n\n\nIt has been observed empirically that implied volatilities of stocks are upward biased estimates of future volatility. Given that there is not really a constant risk-free rate, implied volatilities should be interpreted as implied forward-price volatilities, whereas the empirical literature has measured future volatility as the subsequent volatility of the stock. What assumptions about bond volatilities and the correlation of bonds and stocks could explain the empirical finding; i.e., what assumptions imply that the volatility of the forward price exceeds the volatility of the stock?\n\n\nIn the continuous-time Ho-Lee model described in ?sec-c:vasicek, the volatility of a discount bond with time \\(\\tau\\) to maturity is \\(\\sigma_r\\tau\\) for a constant \\(\\sigma_r\\). Under this assumption, calculate the average volatility of the forward price of a stock from date \\(0\\) to date \\(T\\), where \\(T\\) is the maturity of the forward contract. Assume the stock has a constant volatility \\(\\sigma_s\\) and the correlation between the stock and bond is a constant \\(\\rho\\).\n\n\nMaking the same assumptions as in the previous exercise, and using the result of that exercise and Merton’s formula, write a Python function to calculate the value of a call option on a stock. The inputs should be \\(S\\), \\(K\\), \\(P\\), \\(\\sigma_s\\), \\(\\sigma_r\\), \\(\\rho\\), \\(q\\), and \\(T\\).\n\n\n\n\n\nBlack, F. 1976. “The Pricing of Commodity Contracts.” Journal of Financial Economics 3: 167–79.\n\n\nMargrabe, W. 1978. “The Value of an Option to Exchange One Asset for Another.” Journal of Finance 33: 177–86.\n\n\nMerton, R. 1973. “Theory of Rational Option Pricing.” Bell Journal of Economics and Management Science 4: 141–83.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_MertonMargrabeBlack.html#footnotes",
    "href": "Chapter_MertonMargrabeBlack.html#footnotes",
    "title": "10  Merton, Black, and Margrabe",
    "section": "",
    "text": "Of course, it is possible to give a direct proof, without relying on the Black-Scholes formula. A sketch is given in Section 10.20↩︎\nThis is really nothing more than the usual convention of defining the standard deviation of a random variable to be the positive square root of the variance.↩︎",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Merton, Black, and Margrabe</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html",
    "href": "Chapter_Asians.html",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "11.1 Asian Options\nThis chapter addresses some non-vanilla options that are very important for hedging: Asian options, basket options, and spread options. More exotic options are studied in the following chapter.\nAn Asian option is an option whose value depends on the average underlying asset price during the lifetime of the option. Average-price calls and puts are defined like standard calls and puts but with the final asset price replaced by the average price. Average-strike calls and puts are defined like standard calls and puts but with the exercise price replaced by the average asset price. A firm that must purchase an input at frequent intervals or will sell a product in a foreign currency at frequent intervals can use an average price option as an alternative to buying multiple options with different maturity dates. The average-price option will generally be both less expensive and a better hedge than purchasing multiple options.\nIn practice, the average price is computed by averaging over the prices sampled at a finite number of discrete dates. First, we consider the case of continuous sampling. With continuous sampling, the average price at date \\(T\\) for an option written at date \\(0\\) will be denoted by \\(A_T\\) and is defined as \\[\nA_T = \\frac{1}{T}\\int_0^T S_t\\mathrm{d}   t\\; .\n\\] A sum of lognormally distributed variables is not itself lognormally distributed. Likeise, the integral above, which is essentially a continuous sum of the prices at different dates, is not lognormally distributed.\nAn alternative contract would replace the average price with the geometric average. This is defined as the exponential of the average logarithm. We denote this by \\(A^g\\). The average logarithm is \\[\n\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\; ,\n\\] and the geometric average is \\[\nA^g_T = \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\right)\\; .\n\\] The concavity of the logarithm function guarantees that \\[\n\\log \\frac{1}{T}\\int_0^T S_t &gt; \\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t \\; .\n\\] Therefore, \\[\\begin{align*}\nA_T &= \\exp\\left(\\log \\frac{1}{T}\\int_0^T S_t\\right)\\\\\n&&gt; \\exp\\left(\\frac{1}{T}\\int_0^T \\log S_t\\mathrm{d}   t\\right) \\\\\n&= A^g_T\\; .\n\\end{align*}\\] Consequently, approximating the value of an average-price or average-strike option by substituting \\(A^g_T\\) for \\(A_T\\) produces a biased estimate of the value. Nevertheless, the geometric average\\(A^g_T\\) and the arithmetic average \\(A_T\\) are highly correlated, so \\(A^g_T\\) forms a very useful for Monte-Carlo valuation of average-price and average-strike options, as will be discussed later. To implement the idea, we need a valuation formula for options written on \\(A^g_T\\). We derive this for an average-price call, in which \\(A^g_T\\) substitutes for \\(A_T\\).\nSpecifically, consider a contract that pays \\(\\max(0,A^g_T-K)\\) at its maturity \\(T\\). This is a geometric-average-price call. Let \\(V_t\\) denote the value at date \\(t\\) of receiving \\(A^g_T\\) at date \\(T\\). This can be calculated, and the result is given below. \\(V_t\\) is the value of a dividend-reinvested portfolio, and, by definition, \\(V_T=A^g_T\\), so the geometric-average-price call is equivalent to a standard call with \\(V\\) being the price of the underlying. We will show that \\(V\\) has a time-varying but non-random volatility. This allows us to apply the Black-Scholes formula. We could attempt the same route to price average-price options, but we would find that the volatility of the corresponding value \\(V\\) varies randomly, making the Black-Scholes formula inapplicable.\nThe value \\(V_t\\) can be calculated as \\[\nV_t= \\mathrm{e}^{-r(T-t)}\\mathbb{E}^R_t\\big[A^g_T\\big]\\; .\n\\] Define \\[\nA^g_t = \\exp\\left(\\frac{1}{t}\\int_0^t \\log S_u\\,du\\right)\\;.\n\\]\nWe will verify at the end of this section that \\[\nV_t = \\mathrm{e}^{-r(T-t)}(A^g_t)^{\\frac{t}{T}}S_t^{\\frac{T-t}{T}}\\exp\\left(\\frac{(r-q-\\sigma^2/2)(T-t)^2}{2T} + \\frac{\\sigma^2(T-t)^3}{6T^2}\\right)\\;.\n\\qquad(11.1)\\]\nTwo points are noteworthy. First, the value at date \\(0\\) is\n\\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left(\\frac{(r-q-\\sigma^2/2)T}{2} + \\frac{\\sigma^2T}{6}\\right)\n\\] \\[\n=\\exp\\left(-\\frac{6r+6q + \\sigma^2}{12}T\\right)S_0\\;.\n\\qquad(11.2)\\]\nSecond, the volatility comes from the factor \\(S_t^{(T-t)/T}\\), and, by Ito’s formula, \\[\n\\mathrm{d}  \\log S_t^{(T-t)/T} = \\text{something}\\mathrm{d}    t + \\left(\\frac{T-t}{T}\\right)\\sigma\\mathrm{d}   B\\;.\n\\] We can compute the average volatility in the sense of \\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{T}\\int_0^T \\left(\\frac{T-t}{T}\\right)^2\\sigma^2\\mathrm{d}   t}\n=\\frac{\\sigma}{\\sqrt{3}}\\;.\n\\] and insert that into the Black-Scholes formula as \\(\\sigma\\).1 This yields:\nWe can also value a discretely-sampled geometric-average-price call by the same arguments. Consider dates \\(0&lt;t_0&lt; t_1 &lt; \\cdots t_N=T\\), where \\(t_i-t_{i-1}=\\Delta t\\) for each \\(i\\) and suppose the price is to be sampled at the dates \\(t_1,\\ldots,t_N\\). Now let \\(V_t\\) denote the value at date \\(t\\) of the contract that pays \\[\n\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right) = \\left(\\prod_{i=1}^N S_{t_i}\\right)^{1/N}\n\\qquad(11.3)\\]\nat date \\(T\\). The call option will pay \\(\\max(0,V_T-K)\\) at date \\(T\\). Let \\(k\\) denote the integer such that \\(t_{N-k-1} \\leq t &lt; t_{N-k}\\). This means that we have already observed the prices \\(S(t_1), \\ldots, S(t_{N-k-1})\\) and we have yet to observe the \\(k+1\\) prices \\(S(t_{N-k}), \\ldots ,S(t_N)\\). Define \\(\\varepsilon = (t_{N\\!-k}-t)/\\Delta t\\), which is fraction of the interval \\(\\Delta t\\) that must pass before we reach the next sampling date \\(t_{N\\!-k}\\). We will show at the end of this section that\n\\[\n\\begin{multline}\nV_t = \\mathrm{e}^{-r(T-t)}S_t^{\\frac{k+1}{N}}\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\\\\n\\times\\,\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}\\!+\\! \\frac{k(k+1)\\nu}{2N}\\! +\\! \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}\\!+\\!\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\;,\n\\end{multline}\n\\qquad(11.4)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\)\nAgain, two points are noteworthy. Assume the call was written at date \\(0\\) and the first observation date \\(t_1\\) is \\(\\Delta t\\) years away. Then, we have \\(k+1=N\\) and \\(\\varepsilon=1\\) so \\[\nV_0 = \\mathrm{e}^{-rT}S_0\\exp\\left( \\frac{(N+1)\\nu\\Delta t}{2} + \\frac{(N+1)(2N+1)\\sigma^2\\Delta t}{12N} \\right)\\;.\n\\qquad(11.5)\\]\nSecond, the volatility of \\(V_t\\) comes from the factor \\(S_t^{(k+1)/N}\\), and \\[\n\\frac{ \\mathrm{d}  S^{\\frac{k+1}{N}}}{S^{\\frac{k+1}{N}}} = \\text{something}\\mathrm{d}    t + \\left(\\frac{k+1}{N}\\right)\\sigma\\mathrm{d}   B\\;.\n\\] This implies that the average volatility, in the sense of ?sec-s:timevaryingvolatility, is\n\\[\n\\sigma_{\\text{avg}} = \\sqrt{\\frac{1}{N}\\sum_{k=0}^{N-1} \\left(\\frac{k+1}{N}\\right)^2\\sigma^2\\mathrm{d}   t}\n\\] \\[\n=\\frac{\\sigma}{N^{3/2}}\\sqrt{\\frac{N(N+1)(2N+1)}{6}}\\;,\n\\qquad(11.6)\\]\nwhere we have used the fact that \\(\\sum_{i=1}^N i^2 = N(N+1)(2N+1)/6\\) to obtain the second equality. Thus, the Black-Scholes formula implies:\nThis formula will be used in Section 13.3 as a control variate for pricing discretely-sampled average-price calls (even average-price calls that were written before the date of valuation).\nThe following code computes the price of a geometric-average-price call.\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma &lt;= 0 or T &lt;= 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    \n    d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\nS=60\nK=50\nr=0.05\nsigma=0.2\nq=0\nT=1\nN=100\n\nprint(\"Discrete Geometric Average Price Call:\", discrete_geom_average_price_call(S, K, r, sigma, q, T, N))\n\n\nDiscrete Geometric Average Price Call: 10.87461058434939",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#asian-options",
    "href": "Chapter_Asians.html#asian-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "11.2\n\n\n\nThe value at date \\(0\\) of a continuously-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 11.2, and \\(\\sigma_{\\text{avg}}=\\sigma/\\sqrt{3}\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n11.3\n\n\n\nThe value at date \\(0\\) of a discretely-sampled geometric-average-price call written at date \\(0\\) and having \\(T\\) years to maturity is \\[\nV_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\;,\n\\qquad(11.7)\\]\nwhere \\[\nd_1 = \\frac{\\log\\left(\\frac{V_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma_{\\text{avg}}^2\\right)T}{\\sigma_{\\text{avg}}\\sqrt{T}}, \\qquad d_2 = d_1 - \\sigma_{\\text{avg}}\\sqrt{T}\\; ,\n\\] \\(V_0\\) is defined in Equation 11.5, and \\(\\sigma_{\\text{avg}}\\) is defined in Equation 11.6.\n\n\n\n\n\n\n\n\n\nTheory Extra\n\n\n\n\n\n##\nWe will now derive Equation 11.1 and Equation 11.4. We will begin with Equation 11.1. The random variable \\(A^g_T\\) is normally distributed under the risk-neutral probability given information at time \\(t\\). To establish this, and to calculate the mean and variance of \\(A^g_T\\), the key is to change the order of integration in the integral in the second line below to obtain the third line: \\[\\begin{align*}\n\\int_t^T \\log S_u\\,du &= \\int_t^T \\left\\{\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(u-t) + \\sigma [B(u)-B_t]\\right\\}\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_t^u \\mathrm{d}  B_s\\,du\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T \\int_s^T du\\mathrm{d}   B_s\\\\\n&= (T-t)\\log S_t + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\frac{(T-t)^2}{2} + \\sigma\\int_t^T (T-s)\\mathrm{d}   B_s\n\\end{align*}\\] and then to note that \\(\\int_t^T (T-s)\\mathrm{d}   B_s\\) is normally distributed with mean zero and variance equal to \\[\n\\int_t^T (T-s)^2\\,ds =\\frac{(T-t)^3}{3}\\;.\n\\] Therefore \\(\\mathbb{E}^R_t\\left[A^g_T\\right]\\) is the expectation of the exponential of a normally distributed random variable. Equation~Equation 11.1 now follows from the fact that if \\(x\\) is normally distributed with mean \\(\\mu\\) and variance \\(\\sigma^2\\) then \\(\\mathbb{E}\\left[\\mathrm{e}^x\\right] = \\mathrm{e}^{\\mu+\\sigma^2/2}\\).\nTo establish Equation 11.4, note that the discounted risk-neutral expectation of Equation 11.3, conditional on having observed \\(S(t_1), \\ldots, S(t_{N-k-1})\\), is\n\\[\nV_t = \\mathrm{e}^{-r(T-t)}\\mathbb{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=1}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n= \\mathrm{e}^{-r(T-t)}\\exp\\left(\\frac{1}{N}\\sum_{i=1}^{N-k-1} \\log S_{t_i}\\right)\\times \\mathbb{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\n\\] \\[\n=\\left(\\prod_{i=1}^{N-k-1}S_{t_i}^{\\frac{1}{N}}\\right)\\times \\mathrm{e}^{-r(T-t)}\\mathbb{E}^R_t \\left[\\exp\\left(\\frac{1}{N} \\sum_{i=N-k}^N \\log S_{t_i}\\right)\\right]\\;.\n\\qquad(11.8)\\]\nLet \\(\\Delta_0B = B(t_{N-k})-B_t\\) and \\(\\Delta_iB = B(t_{N\\!-k+i})-B(t_{N\\!-k+i-1})\\) for \\(i \\geq 1\\). We can write the sum of logarithms inside the expectation above as \\[\\begin{multline*}\n\\sum_{i=0}^{k}\\big\\{[\\log S_t + (t_{N-k+i}-t)\\nu + \\sigma [B(t_{N-k+i})-B_t]\\big\\}\\\\\n=(k+1)\\log S_t + \\sum_{i=0}^{k} (\\varepsilon + i)\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} [\\Delta_0B + \\Delta_1B + \\cdots + \\Delta_iB] \\\\\n=(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t + \\sigma\\sum_{i=0}^{k} (k+1-i)\\Delta_iB\\;,\n\\end{multline*}\\] where to obtain the last equality we used the fact that \\(\\sum_{i=0}^k i = k(k+1)/2\\). The random variables \\(\\Delta_iB\\) are normally distributed with mean zero and variance \\(\\Delta t\\) (the variance is \\(\\varepsilon \\Delta t\\) for \\(i=0\\)). Thus, the sum of logarithms is a normally distributed random variable with mean \\[\n(k+1)\\log S_t + (k+1)\\varepsilon\\nu\\Delta t + \\frac{k(k+1)}{2}\\nu\\Delta t\n\\] and variance \\[\n(k+1)^2\\sigma^2\\varepsilon\\Delta t + \\sigma^2\\sum_{i=1}^{k} (k+1-i)^2\\Delta t = (k+1)^2\\sigma^2\\varepsilon\\Delta t +\\frac{k(k+1)(2k+1)\\sigma^2}{6}\\; ,\n\\] using the fact that \\(\\sum_{i=1}^k i^2 = k(k+1)(2k+1)/6\\). The expectation of the exponential of a normally distributed random variable equals the exponential of its mean plus one-half of its variance, and the exponential of \\((k+1)\\log S_t/N\\) is \\(S_t^{(k+1)/N}\\). Therefore the conditional expectation in Equation 11.8 is \\[S_t^{\\frac{k+1}{N}}\\exp\\left(\\left[ \\frac{(k+1)\\varepsilon\\nu}{N}+ \\frac{k(k+1)\\nu}{2N} + \\frac{(k+1)^2\\sigma^2\\varepsilon}{2N^2}+\\frac{k(k+1)(2k+1)\\sigma^2}{12N^2} \\right]\\Delta t\\right)\\; ,\n\\] which implies Equation 11.4.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#basket-options",
    "href": "Chapter_Asians.html#basket-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.4 Basket Options",
    "text": "11.4 Basket Options\nA basket option is an option written on a portfolio of assets. For example, someone may want to hedge the change in the value of the dollar relative to a basket of currencies. A basket option is an alternative to purchasing separate options on each currency. Generally, the basket option would have a lower premium than the separate options, because an option on a portfolio is cheaper (and pays less at maturity) than a portfolio of options.\nLetting \\(S_1\\), , \\(S_n\\) denote the asset prices and \\(w_1\\), , \\(w_n\\) the weights specified by the contract, a basket call would pay \\[\\max\\left(0,\\;\\sum_{i=1}^n w_iS_{iT} - K\\right)\\] at maturity \\(T\\). A spread option is actually a special case of a basket option, with \\(n=2\\), \\(w_1=1\\), and \\(w_2=-1\\). The difficulty in valuing basket options is the same as that encountered in valuing spread options. The volatility of the basket price \\(\\sum_{i=1}^nw_iS_{it}\\) will vary over time, depending on the relative volatilities of the assets and the price changes in the assets. For example, consider the case \\(n=2\\) and write \\(S_t\\) for the basket price \\(w_1S_{1t}+w_2S_{2t}\\). Then \\[\\begin{align*}\n\\frac{\\mathrm{d}  S}{S} &= \\frac{w_1\\mathrm{d}   S_1}{S} + \\frac{w_2\\mathrm{d}   S_2}{S}\\\\\n&=\\frac{w_1S_1}{S}\\times \\frac{\\mathrm{d}  S_1}{S_1} + \\frac{w_2S_2}{S}\\times \\frac{\\mathrm{d}  S_2}{S_2}\\;.\n\\end{align*}\\] Let \\(x_{it}=w_iS_{it}/S_t\\). This is the fraction of the portfolio value that the \\(i\\)–th asset contributes. It will vary randomly over time as the prices change. Letting \\(\\sigma_i\\) denote the volatilities of the individual assets and \\(\\rho\\) their correlation, the formula just given for \\(\\mathrm{d}  S/S\\) shows that the instantaneous volatility of the basket price at any date \\(t\\) is \\[\n\\sqrt{x_{t}^2\\sigma_1^2 + 2x_{1t}x_{2t}\\rho\\sigma_1\\sigma_2 + x_{2t}^2S_{2t}\\sigma_2^2}\\; .\n\\]\nHence, the volatility will vary randomly over time as the \\(x_i\\) change. There is no simple closed-form solution for the value of a basket option.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#spread-options",
    "href": "Chapter_Asians.html#spread-options",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.5 Spread Options",
    "text": "11.5 Spread Options\nA spread option is a call or a put written on the difference of two asset prices. For example, a spread call will pay at maturity \\(T\\) the larger of zero and \\(S_{1T}-S_{2T}-K\\), where the \\(S_i\\) are the asset prices and \\(K\\) is the strike price of the call. Spread options can be used by producers to hedge the difference between an input price and an output price. They are also useful for hedging basis risk. For example, someone may want to hedge an asset by selling a futures contract on a closely related but not identical asset. This exposes the hedger to basis risk: the difference in value between the asset and the underlying asset on the futures contract. A spread call can hedge the basis risk: take \\(S_1\\) to be the value of the asset underlying the futures contract and \\(S_2\\) the value of the asset being hedged.\nA spread option is actually an exchange option. Assuming constant dividend yields \\(q_1\\) and \\(q_2\\), we can take the assets underlying the exchange option to be as follows\n\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_1T}\\) units of the asset with price \\(S_1\\) and reinvest dividends, leading to a value of \\(S_{1T}\\) at date \\(T\\),\nAt date \\(0\\), purchase \\(\\mathrm{e}^{-q_2T}\\) units of the asset with price \\(S_2\\) and invest \\(\\mathrm{e}^{-rT}K\\) in the risk-free asset. Reinvesting dividends and accumulating interest means that we will have \\(S_{2T}+K\\) dollars at date \\(T\\).\n\nHowever, we cannot apply Margrabe’s formula to price spread options, because the second portfolio described above will have a stochastic volatility. To see this, note that if the price \\(S_{2t}\\) falls to a low level, then the portfolio will consist primarily of the risk-free asset, so the portfolio volatility will be near the volatility of the risk-free asset, which is zero. On the other hand, if \\(S_{2t}\\) becomes very high, then the portfolio will be weighted very heavily on the stock investment, and its volatility will approach the volatility of \\(S_2\\).",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#exercises",
    "href": "Chapter_Asians.html#exercises",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "11.6 Exercises",
    "text": "11.6 Exercises\n\nExercise 11.1 Intuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T^*\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Compute and plot the value of the option for \\(T=0.1T^*\\), \\(T=0.2T^*\\), , \\(T=0.9T^*\\).\n\n\nExercise 11.2 Create a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K**=S\\) (i.e., the call is at the money) and maturity \\(T^*\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T^*\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\nExercise 11.3 Create a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T^*\\). Take the date of the dividend payment to be \\(T=0.5T^*\\) and take the strike price to be \\(K=S\\). The value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\nExercise 11.4 Create a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 12.6. Verify that the function gives the same result as the function Chooser.\n\n\nExercise 11.5 Write Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Take the time to maturity of the underlying call and put to be \\(T^*\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T^*\\). Compute the cost of the chooser and the cost of the straddle.\n\n\nExercise 11.6 A stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 12.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\nExercise 11.7 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 11.8 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 11.9 Modify Exercise 12.7 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 12.7 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 11.10 Modify Exercise 12.8 by including the hedge in Exercise 12.9. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 11.11 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 12.7.\n\n\nExercise 11.12 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\nExercise 11.13 Using the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\nExercise 11.14 Derive Equation 12.19 for the value of a call on a put.\n\n\nExercise 11.15 Complete the derivation of Equation 12.34 for the value of a chooser option.\n\n\nExercise 11.16 Derive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\nExercise 11.17 Using the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_{20} + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_Asians.html#footnotes",
    "href": "Chapter_Asians.html#footnotes",
    "title": "11  Asians, Baskets, and Spreads",
    "section": "",
    "text": "We assumed a constant volatility when deriving the Black-Scholes formula, but it is easy to check that the same logic works when the volatility is non-randomly time-varying if we substitute this average volatility.↩︎",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Asians, Baskets, and Spreads</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html",
    "href": "Chapter_OtherExotics.html",
    "title": "12  Other Exotics",
    "section": "",
    "text": "12.1 Barrier Options\nWe study six classes of exotic options:\nA down-and-out call pays the usual call value at maturity if and only if the stock price does not hit a specified lower bound during the lifetime of the option. If it does breach the lower barrier, then it is out. Conversely, a down-and-in call pays off only if the stock price does hit the lower bound. Up-and-out and up-and-in calls are defined similarly, and there are also put options of this sort. The out versions are called knock-outs and the in versions are called knock-ins.\nKnock-ins can be priced from knock-outs and vice-versa. For example, the combination of a down-and-out call and a down-and-in call creates a standard European call, so the value of a down-and-in can be obtained by subtracting the value of a down-and-out from the value of a standard European call. Likewise, up-and-in calls can be valued by subtracting the value of an up-and-out from the value of a standard European call. Both knock-outs and knock-ins are of course less expensive than comparable standard options.\nWe will describe the pricing of a down-and-out call. The pricing of up-and-out calls and knock-out puts is similar. Often there are rebates associated with the knocking-out of a barrier option, but we will not include that feature here.\nA down-and-out call provides a hedge against an increase in an asset price, just as does a standard call, for someone who is short the asset. The difference is that the down-and-out is knocked out when the asset price falls sufficiently. Presumably this is acceptable to the buyer because the need to hedge against high prices diminishes when the price falls. In fact, in this circumstance the buyer may want to establish a new hedge at a lower strike. However, absent re-hedging at a lower strike, the buyer of a knock-out call obviously faces the risk that the price may reverse course after falling to the knock-out boundary, leading to regret that the option was knocked out. The rationale for accepting this risk is that the knock-out is cheaper than a standard call. Thus, compared to a standard call, a down-and-out call provides cheaper but incomplete insurance.\nThe combination of a knock-out call and a knock-in call (or knock-out puts) with the same barrier and different strikes creates an option with a strike that is reset when the barrier is hit. This is a hedge that adjusts automatically to the market. An example is given in Probs.~\\(\\ref{e_standardknockout3}\\) and~\\(\\ref{e_standardknockout4}\\).",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#sec-s:barriers",
    "href": "Chapter_OtherExotics.html#sec-s:barriers",
    "title": "12  Other Exotics",
    "section": "",
    "text": "Down-and-Out Call Payoff\nLet \\(L\\) denote the lower barrier for the down-and-out call and assume it has not yet been breached at the valuation date, which we are calling date \\(0\\). Denote the minimum stock price realized during the remaining life of the contract by \\(z = \\min_{0\\leq t\\leq T} S_t\\). In practice, this minimum is calculated at discrete dates (for example, based on daily closing prices), but we will assume here that the stock price is monitored continuously for the purpose of calculating the minimum.\nThe down-and-out call will pay \\(\\max(0,S_T-K)\\) if \\(z &gt; L\\) and 0 otherwise, at its maturity T.\nLet \\[\nx = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z &gt; L$;,}\\\\\n0 & \\text{otherwise;.} \\end{cases}\n\\] Then the value of the down-and-out call at maturity is \\[\nxS_T - xK\\; .\n\\]\n\n\nNumeraires\nAs in other cases, the value at date \\(0\\) can be written as \\[\n\\mathrm{e}^{-qT}S_0\\times\\text{prob}^{V}(x=1) - \\mathrm{e}^{-rT}K\\times\\text{prob}^{R}(x=1)\\; ,\n\\]\nwhere \\(V_t = \\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nTo calculate \\(\\text{prob}^{V}(x=1)\\) and \\(\\text{prob}^{R}(x=1)\\), we consider two cases.\n\nSuppose \\(K&gt;L\\). Define \\[\ny = \\begin{cases} 1 & \\text{if $S_T&gt;K$ and $z \\leq L$}\\\\\n0 & \\text{otherwise\\;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;K\\) is equal to the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!K) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!K) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\]\nAs in the derivation of the Black-Scholes formula, we have \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!K) = \\mathrm{N}(d_2)\\;,\n\\qquad(12.1)\\]\nwhere\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{K}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.2)\\]\nFurthermore , defining \\[\nd_1** = \\frac{\\log\\left(\\frac{L^2}{KS_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2** = d_1**-\\sigma\\sqrt{T}\\;,\n\\qquad(12.3)\\]\nit can be shown that\n\\[\n\\text{prob}^{V}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1**)\\;,\n\\qquad(12.4)\\]\n\\[\n\\text{prob}^{R}(y=1) = \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2**)\\;.\n\\qquad(12.5)\\]\n\nSuppose \\(K \\leq L\\). Then the condition \\(S_T&gt;K\\) in the definition of the event \\(x=1\\) is redundant: if \\(z &gt; L \\geq K\\), then it is necessarily true that \\(S_T&gt;K\\). Therefore, the probability (under either numeraire) of the event \\(x=1\\) is the probability that \\(z &gt; L\\). Define \\[y = \\begin{cases} 1 & \\text{if $S_T&gt;L$ and $z \\leq L$;,}\\\\\n0 & \\text{otherwise;.} \\end{cases}\n\\]\n\nThe event \\(S_T&gt;L\\) is the union of the disjoint events \\(x=1\\) and \\(y=1\\). Therefore, as in the previous case (but now with \\(K\\) replaced by \\(L\\)), \\[\\begin{align*}\n\\text{prob}^{V}(x=1) &= \\text{prob}^{V}(S_T\\!&gt;\\!L) - \\text{prob}^{V}(y=1)\\; ,\\\\\n\\text{prob}^{R}(x=1) &= \\text{prob}^{R}(S_T\\!&gt;\\!L) - \\text{prob}^{R}(y=1)\\;.\n\\end{align*}\\] Also as before, we know that \\[\n\\text{prob}^{V}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_1) \\quad \\text{and} \\quad \\text{prob}^{R}(S_T\\!&gt;\\!L) = \\mathrm{N}(d_2)\\;,\n\\qquad(12.6)\\]\nwhere now\n\\[\nd_1= \\frac{\\log\\left(\\frac{S_0}{L}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\\qquad  d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.7)\\]\nMoreover, \\(\\text{prob}^{V}(y=1)\\) and \\(\\text{prob}^{R}(y=1)\\) are given by Equation 12.4 - Equation 12.5 but with \\(K\\) replaced by \\(L\\), which means that \\[\nd_1** = \\frac{\\log\\left(\\frac{L}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2**= d_1** - \\sigma\\sqrt{T}\\;.\n\\qquad(12.8)\\]\n\n\nDown-and-Out Call Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a continuously-sampled down-and-out call option with barrier \\(L\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\left[\\mathrm{N}(d_1)-\\left(\\frac{L}{S_0}\\right)^{2\\left(r-q+\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_1**)\\right]\\\\ - \\mathrm{e}^{-rT}K\\left[\\mathrm{N}(d_2) - \\left(\\frac{L}{S_0}\\right)^{2\\left(r-q-\\frac{1}{2}\\sigma^2\\right)/\\sigma^2}\\mathrm{N}(d_2**)\\right]\\;,\n\\end{multline}\n\\qquad(12.9)\\]\nwhere\n\nif \\(K&gt;L\\), \\(d_1\\), \\(d_2\\) , \\(d_1**\\) and \\(d_2**\\) are defined in Equation 12.2 - Equation 12.3,\nif \\(K\\leq L\\), \\(d_1\\), \\(d_2\\), \\(d_1**\\) and \\(d_2**\\) are defined in Equation 12.7 - Equation 12.8.\n\n\n\nThe following code computes the price of a down and out call option.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef down_and_out_call(S, K, r, sigma, q, T, Barrier):\n    if K &gt; Barrier:\n        a = S / K\n        b = Barrier * Barrier / (K * S)\n    else:\n        a = S / Barrier\n        b = Barrier / S\n\n    d1 = (np.log(a) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1prime = (np.log(b) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2prime = d1prime - sigma * np.sqrt(T)\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N1prime = norm.cdf(d1prime)\n    N2prime = norm.cdf(d2prime)\n    x = 1 + 2 * (r - q) / (sigma ** 2)\n    y = x - 2\n    q1 = N1 - (Barrier / S) ** x * N1prime\n    q2 = N2 - (Barrier / S) ** y * N2prime\n\n    return np.exp(-q * T) * S * q1 - np.exp(-r * T) * K * q2\n\nS=100\nK=120\nr=0.05\nsigma=0.2\nq=0\nT=1\nprint(\"Down and Out Call:\", down_and_out_call(S, K, r, sigma, q, T, 80))\n\n\nDown and Out Call: 3.2407203551989525",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#sec-s:lookbacks",
    "href": "Chapter_OtherExotics.html#sec-s:lookbacks",
    "title": "12  Other Exotics",
    "section": "12.2 Lookbacks",
    "text": "12.2 Lookbacks\n A floating-strike lookback call pays the difference between the asset price at maturity and the minimum price realized during the life of the contract. A floating-strike lookback put pays the difference between the maximum price over the life of the contract and the price at maturity. Thus, the floating-strike lookback call allows one to buy the asset at its minimum price, and the floating-strike lookback put allows one to sell the asset at its maximum price. Of course, one pays upfront for this opportunity to time the market. These options were first discussed by Goldman, Sosin and Gatto (Goldman, Sosin, and Gatto 1979).\nA fixed-strike lookback put pays the difference between a fixed strike price and the minimum price during the lifetime of the contract. Thus, a fixed-strike lookback put and a floating-strike lookback call are similar in one respect: both enable one to buy the asset at its minimum price. However, the put allows one to sell the asset at a fixed price whereas the call allows one to sell it at the terminal asset price. A fixed-strike lookback call pays the difference between the maximum price and a fixed strike price and is similar to a floating-strike lookback put in the sense that both enable one to sell the asset at its maximum price. Fixed-strike lookback options were first discussed by Conze and Viswanathan (Conze and Viswanathan 1991). We will discuss the valuation of floating-strike lookback calls. As in the discussion of barrier options, we will assume that the price is continuously sampled for the purpose of computing the minimum.\n\nFloating-Strike Lookback Call Payoff\nAs in the previous section, let \\(z\\) denote the minimum stock price realized over the remaining lifetime of the contract. This is not necessarily the minimum stock price realized during the entire lifetime of the contract. Let \\(S_{\\min}\\) denote the minimum stock price realized during the lifetime of the contract up to and including date \\(0\\), which is the date at which we are valuing the contract. The minimum stock price during the entire lifetime of the contract will be the smaller of \\(z\\) and \\(S_{\\text{min}}\\). The payoff of the floating strike lookback call is \\(S_T - \\min\\left(z, S_{\\text{min}}\\right)\\).\n\n\nCalculations\nThe value at date \\(0\\) of the piece \\(S_T\\) is simply \\(\\mathrm{e}^{-qT}S_0\\). It can be shown (see, e.g., Musiela and Rutkowski (Musiela and Rutkowski 1997) for the details) that the value at date \\(0\\) of receiving \\[\n\\min(z, S_{\\text{min}})\n\\] at date \\(T\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) -\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2**) \\\\\n+\\left(1+ \\frac{\\sigma^2}{2(r-q)}\\right)\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;.\n\\end{multline*}\\] where\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S_{\\text{min}}}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; , \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(12.10)\\]\n\\[\nd_1** = \\frac{\\log\\left(\\frac{S_{\\text{min}}}{S_0}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2**=d_1** - \\sigma\\sqrt{T} \\;.\n\\qquad(12.11)\\]\nUsing the fact that \\([1-\\mathrm{N}(-d_1)]\\mathrm{e}^{-qT}S_0=\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)\\), this implies:\n\n\nFloating-Strike Lookback Call Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value at date \\(0\\) of a continuously-sampled floating-strike lookback call, given that the minimum price during the lifetime of the contract through date \\(0\\) is \\(S_{\\text{min}}\\) and the remaining time to maturity is \\(T\\), is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-qT}S_0\\mathrm{N}(d_1)-\\mathrm{e}^{-rT}S_{\\text{min}}\\mathrm{N}(d_2) \\\\+\\frac{\\sigma^2}{2(r-q)}\\left(\\frac{S_{\\text{min}}}{S_0}\\right)^{2(r-q)/\\sigma^2}\\mathrm{e}^{-rT}S_0\\mathrm{N}(d_2**) \\\\\n-\\frac{\\sigma^2}{2(r-q)}\\mathrm{e}^{-qT}S_0\\mathrm{N}(-d_1)\\;,\n\\end{multline}\n\\qquad(12.12)\\]\nwhere \\(d_1\\), \\(d_2\\), and \\(d_2**\\) are defined in Equation 12.10 - Equation 12.11.\n\n\nThe following program calculates the price of a floating strike lookback option.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\n# Example usage\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\n\nprint(\"Floating Strike Call:\", floating_strike_call(S, r, sigma, q, T, 90))\n\n\nFloating Strike Call: 16.27191861732918",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#compound-options",
    "href": "Chapter_OtherExotics.html#compound-options",
    "title": "12  Other Exotics",
    "section": "12.3 Compound Options",
    "text": "12.3 Compound Options\nA compound option is an option on an option, for example a call option on a call option or a call on a put. These options are useful for hedging when there is some uncertainty about the need for hedging which may be resolved by the exercise date of the compound option. As speculative trades, they have the benefit of higher leverage than ordinary options. These options were first discussed by Geske (Geske 1979).\n\nCall-on-a-Call Payoff\nLet the underlying call option have exercise price \\(K**\\) and maturity \\(T^*\\). Consider an option maturing at \\(T&lt;T^*\\) to purchase the underlying call at price \\(K\\).\nLet \\(C(t,S)\\) denote the value at date \\(t\\) of the underlying call when the stock price is \\(S\\) (i.e., \\(C\\) is the Black-Scholes formula). It is of course rational to exercise the compound call at date \\(T\\) if the value of the underlying call exceeds \\(K\\); i.e., if \\(C(T,S_T)&gt;K\\). Let \\(S^*\\) denote the critical price such that \\(C(T,S^*)=K\\). To calculate \\(S^*\\), we need to solve\nBlack_Scholes_Call(S*,Kprime,r,sigma,q,Tprime-T) = K\nfor \\(S^*\\). We can do this by bisection or one of the other methods mentioned in ?sec-s:impliedvolatility. It is rational to exercise the compound option when \\(S_T &gt; S^*\\).\nWhen \\(S_T &gt; S^*\\), exercise of the compound option generates a cash flow of \\(-K\\) at date \\(T\\). There is a cash flow (of \\(S_{T^*}-K**\\)) at date \\(T^*\\) only if the compound call is exercised and the underlying call finishes in the money. This is equivalent to: \\[\nS_T &gt; S^* \\quad\\text{and}\\quad S_{T^*}&gt;K**\\;.\n\\qquad(12.13)\\]\nLet \\[\n\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$;,}\\\\\n                               0 & \\text{otherwise;,}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&gt;S^*$ and $S_{T^*}&gt;K**$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\end{align*}\n\\] The cash flows of the compound option are \\(-xK\\) at date \\(T\\) and \\(yS_{T^*}-yK**\\) at date \\(T^*\\). We can value the compound option at date \\(0\\) by valuing these separate cash flows.\nThe cash flow \\(-xK\\) is the cash flow from being short \\(K\\) digital options on the underlying asset with strike price \\(S^*\\) and maturity \\(T\\). Therefore the value at date \\(0\\) of this cash flow is \\(-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2)\\), where \\[\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},  \\qquad d_2 = d_1-\\sigma\\sqrt{T}\\;.\n\\qquad(12.14)\\]\n\n\nNumeraires\nThe payoffs \\(yS_T\\) and \\(yK**\\) are similar to share digitals and digitals, respectively, except that the event \\(y=1\\) is more complex than we have previously encountered. However, we know from the analysis of share digitals and digitals that the values at date \\(0\\) of these payoffs are \\[\n\\mathrm{e}^{-q T^*}S_0\\times\\text{prob}^V\\!(y=1) \\quad \\text{and}\\quad \\mathrm{e}^{-rT^*}K**\\times\\text{prob}^R(y=1)\\; ,\n\\] where \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\).\n\n\nCalculating Probabilities\nWe will calculate the two probabilities in terms of the bivariate normal distribution function.\n\nThe event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T^*+\\sigma B^*_{T^*} &gt; \\log K**\\; ,\n\\] where \\(B^*\\) is a Brownian motion when the underlying asset (\\(V\\)) is used as the numeraire. These conditions can be rearranged as\n\n\\[-\\frac{B^*_T}{\\sqrt{T}}&lt;d_1 \\quad \\text{and} \\quad - \\frac{B^*_{T^*}}{\\sqrt{T^*}}&lt;d_1**\\;,\n\\qquad(12.15)\\]\nwhere \\(d_1\\) is defined in Equation 12.14, and \\[\nd_1** = \\frac{\\log\\left(\\frac{S_0}{K**}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T^*}{\\sigma\\sqrt{T^*}}\\;,\n\\qquad d_2**=d_1**-\\sigma\\sqrt{T^*}\\;.\n\\qquad(12.16)\\]\nThe two standard normal variables on the left-hand sides in Equation 12.15 have a covariance equal to \\[\n\\frac{1}{\\sqrt{TT^*}}\\mathrm{cov}(B_T,B_{T^*}) = \\frac{1}{\\sqrt{TT^*}}\\mathrm{cov}(B_T,B_T) = \\sqrt{\\frac{T}{T^*}}\\; ,\n\\]\nthe first equality following from the fact that \\(B_T\\) is independent of \\(B_{T^*}-B_T\\) and the second from the fact that the covariance of a random variable with itself is its variance. Hence, \\(\\text{prob}^V\\!(y=1)\\) is the probability that \\(a\\leq d_1\\) and \\(b\\leq d_1**\\), where \\(a\\) and \\(b\\) are standard normal random variables with covariance (= correlation coefficient) of \\(\\sqrt{T/T^*}\\). We will write this probability as \\(\\mathrm{M}\\!\\left(d_1,d_1**,\\sqrt{T/T^*}\\right)\\). A program to approximate the bivariate normal distribution function \\(\\mathrm{M}\\) is provided later.\n\nThe calculation for \\(\\text{prob}^R(y=1)\\) is similar. The event \\(y=1\\) is equivalent to \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T+\\sigma B^*_T &gt; \\log S^*\\;,\n\\] and \\[\n\\log S_0 + \\left(r-q+\\frac{1}{2}\\sigma^2\\right)T^*+\\sigma B^*_{T^*} &gt; \\log K**\\; ,\n\\] where \\(B^*\\) now denotes a Brownian motion under the risk-neutral probability. These are equivalent to \\[\n-\\frac{B^*_T}{\\sqrt{T}}&lt;d_2 \\quad \\text{and} \\quad - \\frac{B^*_{T^*}}{\\sqrt{T^*}} &lt; d_2**\\;.\n\\qquad(12.17)\\]\n\nHence, \\(\\text{prob}^R(y=1)=\\mathrm{M}\\!\\left(d_2,d_2**,\\sqrt{T/T^*}\\right)\\).\n\n\nCall-on-a-Call Pricing Formula\nWe conclude:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call on a call is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(d_2) + \\mathrm{e}^{-q T^*}S_0\\mathrm{M}\\!\\left(d_1,d_1**,\\sqrt{T/T^*}\\right)\n\\\\- \\mathrm{e}^{-rT^*}K**\\mathrm{M}\\!\\left(d_2,d_2**,\\sqrt{T/T^*}\\right)\\;,\n\\end{multline}\n\\qquad(12.18)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.14 and \\(d_1**\\) and \\(d_2**\\) are defined in Equation 12.16.\n\n\n\n\nPut-Call Parity\nEuropean compound options with the same underlyings and strikes satisfy put-call parity in the usual way: \\[\n\\text{Cash} + \\text{Call} = \\text{Underlying} + \\text{Put}\\; .\n\\]\nThe portfolio on each side of this equation gives the owner the maximum of the strike and the value of the underlying at the option maturity. In the case of options on calls, put-call parity is specifically \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on call} \\\\= \\text{Value of underlying call} + \\text{Value of put on call}\\; ,\n\\end{multline*}\\] where \\(K\\) is the strike price of the compound options and \\(T\\) is their maturity date. Likewise, for options on puts, we have \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on put} \\\\= \\text{Value of underlying put} + \\text{Value of put on put}\\; .\n\\end{multline*}\\] Thus, the value of a put on a call can be derived from the value of a call on a call. The value of a put on a put can be derived from the value of a call on a put, which we will now consider.\n\n\nCall-on-a-Put Pricing Formula\nConsider a call option maturing at \\(T\\) with strike \\(K\\) with the underlying being a put option with strike \\(K**\\) and maturity \\(T^*&gt;T\\). The underlying of the put is the asset with price \\(S\\) and constant volatility \\(\\sigma\\). The call on the put will never be in the money at \\(T\\) and hence is worthless if \\(K&gt; \\mathrm{e}^{-r(T^*-T)}K**\\), because the maximum possible value of the put option at date \\(T\\) is \\(\\mathrm{e}^{-r(T^*-T)}K**\\). So assume \\(K&lt; \\mathrm{e}^{-r(T^*-T)}K**\\).\nLet \\(S^*\\) again denote the critical value of the stock price such that the call is at the money at date \\(T\\) when \\(S_T=S^*\\). This means that \\(S^*\\) solves\nBlack_Scholes_Put(S*,Kprime,r,sigma,q,Tprime-T) = K.\nWe leave it as an exercise to confirm the following.\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call on a put is\n\\[\n\\begin{multline}\n-\\mathrm{e}^{-rT}K\\mathrm{N}(-d_2) + \\mathrm{e}^{-rT^*}K**\\mathrm{M}\\!\\left(-d_2,-d_2**,\\sqrt{T/T^*}\\right) \\\\- \\mathrm{e}^{-q T^*}S_0\\mathrm{M}\\!\\left(-d_1,-d_1**,\\sqrt{T/T^*}\\right) \\;,\n\\end{multline}\n\\qquad(12.19)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.14 and \\(d_1**\\) and \\(d_2**\\) are defined in Equation 12.16.\n\n\nWe will use bisection to find the critical price \\(S^*\\). We can use \\(e^{q(T^*-T)}(K+K**)\\) as an upper bound for \\(S^*\\) and 0 as a lower bound.^[We set the value of the call to be zero when the stock price is zero. The upper bound works because (by put-call parity and the fact that the put value is nonnegative) \\(C(T,S) \\geq e^{-q(T^*-T)}S-e^{-r(T^*-T)}K**\\). Therefore, when \\(S = e^{q(T^*-T)}(K+K**)\\), we have \\(C(T,S) \\geq K + K** - e^{-r(T^*-T)}K** &gt; K\\). }\nThe following uses \\(10^{-6}\\) as the error tolerance in the bisection.\n\n\nCode\nimport numpy as np\n\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\n\ndef call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * (Tu - Tc)) * (Kc + Ku)\n    guess = 0.5 * lower + 0.5 * upper\n    flower = -Kc\n    fupper = black_scholes_call(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(d2)\n    M1 = binormal_prob(d1, d1prime, rho)\n    M2 = binormal_prob(d2, d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-q * Tu) * S * M1 - np.exp(-r * Tu) * Ku * M2\n\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n\n# print(\"Call on Call:\", call_on_call(S, Kc, Ku, r, sigma, q, Tc, Tu))\n\n\nThe implementation of the call-on-a-put formula is of course very similar to that of a call-on-a-call. One difference is that there is no obvious upper bound for \\(S^*\\), so we start with \\(2K**\\) (= 2*K2) and double this until the value of the put is below \\(K\\). We can take 0 again to be the lower bound. Recall that we assume \\(K&lt;\\mathrm{e}^{-r(T^*-T)}K**\\) and the right-hand side of this is the value of the put at date \\(T\\) when \\(S_T=0\\).\n\n\nCode\ndef black_scholes_put(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-r * T) * K - np.exp(-q * T) * S)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(-d1)\n        N2 = norm.cdf(-d2)\n        return np.exp(-r * T) * K * N2 - np.exp(-q * T) * S * N1\n\ndef call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu):\n    tol = 1e-6\n    lower = 0\n    flower = np.exp(-r * (Tu - Tc)) * Ku - Kc\n    upper = 2 * Ku\n    fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n    while fupper &gt; 0:\n        upper *= 2\n        fupper = black_scholes_put(upper, Ku, r, sigma, q, Tu - Tc) - Kc\n\n    guess = 0.5 * lower + 0.5 * upper\n    fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_put(guess, Ku, r, sigma, q, Tu - Tc) - Kc\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2 = d1 - sigma * np.sqrt(Tc)\n    d1prime = (np.log(S / Ku) + (r - q + sigma ** 2 / 2) * Tu) / (sigma * np.sqrt(Tu))\n    d2prime = d1prime - sigma * np.sqrt(Tu)\n    rho = np.sqrt(Tc / Tu)\n    N2 = norm.cdf(-d2)\n    M1 = binormal_prob(-d1, -d1prime, rho)\n    M2 = binormal_prob(-d2, -d2prime, rho)\n\n    return -np.exp(-r * Tc) * Kc * N2 + np.exp(-r * Tu) * Ku * M2 - np.exp(-q * Tu) * S * M1\n# Example usage\nS = 100\nKc = 10\nKu = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 0.5\nTu = 1\n\n# print(\"Call on Put:\", call_on_put(S, Kc, Ku, r, sigma, q, Tc, Tu))",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#options-on-the-max-or-min",
    "href": "Chapter_OtherExotics.html#options-on-the-max-or-min",
    "title": "12  Other Exotics",
    "section": "12.4 Options on the Max or Min",
    "text": "12.4 Options on the Max or Min\nWe will consider here an option written on the maximum or minimum of two asset prices; for example, a call on the maximum pays \\[\n\\max(0,\\max(S_1(T), S_2(T))-K) = \\max(0,S_1(T)-K,S_2(T)-K)\n\\] at maturity \\(T\\). There are also call options on \\(\\min(S_1(T), S_2(T))\\) and put options on the maximum and minimum of two (or more) asset prices. Pricing formulas for these options are due to Stulz (Stulz 1982), who also discusses applications. We will assume the two assets have constant dividend yields \\(q_i\\), constant volatilities \\(\\sigma_i\\), and a constant correlation \\(\\rho\\).\n\nCall-on-the-Max Payoff\nTo value the above option, define the random variables: \\[\\begin{align*}\nx&= \\begin{cases} 1 & \\text{if $S_1(T)&gt;S_2(T)$ and $S_1(T)&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\ny&= \\begin{cases} 1 & \\text{if $S_2(T)&gt; S_1(T)$ and $S_2(T)&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;, \\end{cases}\\\\\nz&= \\begin{cases} 1 & \\text{if $S_1(T) &gt; K$ or $S_2(T)&gt; K$}\\; ,\\\\\n0 & \\text{otherwise}\\;. \\end{cases}\n\\end{align*}\\] Then the value of the option at maturity is \\[\nxS_1(T) + yS_2(T) - zK\\; .\n\\]\n\n\nNumeraires\nConsider numeraires \\(V_1(t) = \\mathrm{e}^{q_1t}S_1(T)\\), \\(V_2(t)=\\mathrm{e}^{q_2t}S_2(T)\\), and \\(R_t=\\mathrm{e}^{rt}\\). By familiar arguments, the value of the option at date \\(0\\) is \\[\\begin{multline*}\n\\mathrm{e}^{-q_1T}S_1(0)\\times\\text{prob}^{V_1}(x=1) + \\mathrm{e}^{-q_2T}S_2(0)\\times\\text{prob}^{V_2}(y=1) \\\\- \\mathrm{e}^{-rT}K\\times\\text{prob}^R(z=1)\\; .\n\\end{multline*}\\]\n\n\nCalculating Probabilities\n\nWe will begin by calculating \\(\\text{prob}^{V_1}(x=1)\\). From the second and third examples in ?sec-s:girsanov, the asset prices satisfy \\[\\begin{align*}\n\\frac{\\mathrm{d}  S_1}{S_1} &= (r-q_1+\\sigma^2_1)\\mathrm{d}   t + \\sigma_1\\mathrm{d}   B^*_{1}\\; ,\\\\\n\\frac{\\mathrm{d}  S_2}{S_2} &= (r-q_2+\\rho\\sigma_1\\sigma_2)\\mathrm{d}   t + \\sigma_2\\mathrm{d}   B^*_{2}\\;,\n\\end{align*}\\] where \\(B^*_{1}\\) and \\(B^*_{2}\\) are Brownian motions when we use \\(V_1\\) as the numeraire. Thus, \\[\n\\begin{align*}\n\\log S_1(T) &= \\log S_1(0) + \\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}(T)\\; ,\\\\\n\\log S_2(T) &= \\log S_2(0) + \\left(r-q_2+\\rho\\sigma_1\\sigma_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}(T)\\;.\n\\end{align*}\n\\] The condition \\(\\log S_1(T) &gt; \\log K\\) is therefore equivalent to\n\n\\[\n  -\\frac{1}{\\sqrt{T}}B^*_{1}(T) &lt; d_{11}\\;,\n\\qquad(12.20)\\]\nand the condition \\(\\log S_1(T)&gt;\\log S_2(T)\\) is equivalent to \\[\n\\frac{\\sigma_2B^*_{2}(T)-\\sigma_1B^*_{1}(T)}{\\sigma\\sqrt{T}} &lt; d_1\\;,\n\\qquad(12.21)\\]\nwhere \\[\n\\sigma =\\sqrt{\\sigma_1^2-2\\rho\\sigma_1\\sigma_2+\\sigma_2^2}\\;,\n\\qquad(12.22)\\]\nand\n\\[\nd_1 = \\frac{\\log\\left(\\frac{S_1(0)}{S_2(0)}\\right)+\\left(q_2-q_1+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;, \\qquad d_2 = d_1 - \\sigma\\sqrt{T}\\;,\n\\qquad(12.23)\\]\n\\[\nd_{11}=\\frac{\\log\\left(\\frac{S_1(0)}{K}\\right)+\\left(r-q_1+\\frac{1}{2}\\sigma_1^2\\right)T}{\\sigma_1\\sqrt{T}}\\;, \\qquad d_{12} = d_{11} - \\sigma_1\\sqrt{T}\\;.\n\\qquad(12.24)\\]\nThe random variables on the left-hand sides of Equation 12.20 - Equation 12.21 have standard normal distributions and their correlation is \\[\n\\rho_1 = \\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\; .\n\\] Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_1}(x=1) = \\mathrm{M}(d_{11},d_1,\\rho_1)\\;,\n\\end{equation*}\\] where \\(\\mathrm{M}\\) again denotes the bivariate normal distribution function.\n\nThe probability \\(\\text{prob}^{V_2}(y=1)\\) is exactly symmetric to \\(\\text{prob}^{V_1}(x=1)\\), with the roles of \\(S_1\\) and \\(S_2\\) interchanged. Note that the mirror image of \\(d_1\\) defined in Equation 12.23 is \\[\n\\frac{\\log\\left(\\frac{S_2(0)}{S_1(0)}\\right)+\\left(q_1-q_2+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\; ,\n\\] which equals \\(-d_2\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{V_2}(y=1) = \\mathrm{M}(d_{21},-d_2,\\rho_2)\\;,\n\\end{equation*}\\] where \\[\nd_{21}=\\frac{\\log\\left(\\frac{S_2(0)}{K}\\right)+\\left(r-q_2+\\frac{1}{2}\\sigma_2^2\\right)T}{\\sigma_2\\sqrt{T}},\\qquad d_{22} = d_{21}-\\sigma_2\\sqrt{T}\\;,\n\\qquad(12.25)\\]\n\nand \\[\n\\rho_2 = \\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\; .\n\\] 3. As usual, we have\n\\[\n\\begin{align*}\n\\log S_1(T) &= \\log S_1(0) + \\left(r-q_1-\\frac{1}{2}\\sigma_1^2\\right)T +\\sigma_1B^*_{1}(T)\\; ,\\\\\n\\log S_2(T) &= \\log S_2(0) + \\left(r-q_2-\\frac{1}{2}\\sigma_2^2\\right)T +\\sigma_2B^*_{2}(T)\\;,\n\\end{align*}\n\\]\nwhere \\(B^*_{1}\\) and \\(B^*_{2}\\) now denote Brownian motions under the risk-neutral probability. The event \\(z=1\\) is the complement of the event \\[\nS_1(T)\\leq K \\quad \\text{and} \\quad S_2(T)\\leq K\\; ,\n\\] which is equivalent to\n\\[\n\\frac{1}{\\sqrt{T}}B^*_{1}(T) &lt; -d_{12}\\;,\n\\qquad(12.26)\\]\nand \\[\n\\frac{1}{\\sqrt{T}}B^*_{2}(T) &lt; -d_{22}\\;.\n\\qquad(12.27)\\]\nThe random variables on the left-hand sides of Equation 12.26 and Equation 12.27 are standard normals and have correlation \\(\\rho\\). Therefore, \\[\\begin{equation*}\n\\text{prob}^{R}(z=1) = 1- \\mathrm{M}(-d_{12},-d_{22},\\rho)\\;.\n\\end{equation*}\\]\n\n\nCall-on-the-Max Pricing Formula\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a call option on the maximum of two risky asset prices with volatilities \\(\\sigma_1\\) and \\(\\sigma_2\\) and correlation \\(\\rho\\) is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q_1T}S_1(0)\\mathrm{M}\\!\\left(d_{11},d_1,\\frac{\\sigma_1-\\rho\\sigma_2}{\\sigma}\\right) + \\mathrm{e}^{-q_2T}S_2(0)\\mathrm{M}\\!\\left(d_{21},-d_2,\\frac{\\sigma_2-\\rho\\sigma_1}{\\sigma}\\right)\\\\+ \\mathrm{e}^{-rT}K\\mathrm{M}(-d_{12},-d_{22},\\rho) - \\mathrm{e}^{-rT}K\\;,\n\\end{multline}\n\\qquad(12.28)\\]\nwhere \\(\\sigma\\) is defined in Equation 12.22 and \\(d_1\\), \\(d_2\\), \\(d_{11}\\), \\(d_{12}\\), \\(d_{21}\\) and \\(d_{22}\\) are defined in Equation 12.23 - Equation 12.24.\n\n\nThe following code shows how to compute the price of a Call on the Max.\n\n\nCode\ndef call_on_max(S1, S2, K, r, sig1, sig2, rho, q1, q2, T):\n    sigma = np.sqrt(sig2 ** 2 - 2 * rho * sig1 * sig2 + sig1 ** 2)\n    d1 = (np.log(S1 / S2) + (q2 - q1 + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d11 = (np.log(S1 / K) + (r - q1 + sig1 ** 2 / 2) * T) / (sig1 * np.sqrt(T))\n    d12 = d11 - sig1 * np.sqrt(T)\n    d21 = (np.log(S2 / K) + (r - q2 + sig2 ** 2 / 2) * T) / (sig2 * np.sqrt(T))\n    d22 = d21 - sig2 * np.sqrt(T)\n    rho1 = (sig1 - rho * sig2) / sigma\n    rho2 = (sig2 - rho * sig1) / sigma\n    M1 = binormal_prob(d11, d1, rho1)\n    M2 = binormal_prob(d21, -d2, rho2)\n    M3 = binormal_prob(-d12, -d22, rho)\n\n    return np.exp(-q1 * T) * S1 * M1 + np.exp(-q2 * T) * S2 * M2 + np.exp(-r * T) * K * M3 - np.exp(-r * T) * K\n# Example usage\n\nS1 = 100\nS2= 100\nK = 100\nr = 0.05\nsigma1 = 0.2\nsigma2 = 0.2\nq1 = 0.02\nq2= 0.01\nT=1\nrho= 0.1\n\n# print(\"Call on Max:\", call_on_max(S1, S2, K, r, sigma1, sigma2, rho, q1, q2, T))",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#forward-start-options",
    "href": "Chapter_OtherExotics.html#forward-start-options",
    "title": "12  Other Exotics",
    "section": "12.5 Forward-Start Options",
    "text": "12.5 Forward-Start Options\nA forward-start option is an option for which the strike price is set equal to the stock price at some later date. In essence, it is issued at the later date, with the strike price set at the money. For example, an executive may know that he is to be given an option grant at some later date with the strike price set equal to the stock price at that date.\n\nForward-Start Call Payoff\nA forward-start call is defined by its maturity date \\(T^*\\) and the date \\(T&lt;T^*\\) at which the strike price is set. The value of a forward-start call at maturity is \\[\\max(0,S_{T^*}-S_T)\\; .\\] Let \\[x= \\begin{cases} 1 &\\text{if $S_{T^*}&gt;S_T$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\] Then, the value of the call at maturity can be written as \\[\nxS_{T^*}-xS_T\\; .\n\\]\n\n\nNumeraires\n\nUse \\(V_t=\\mathrm{e}^{qt}S_t\\) as numeraire to price the payoff \\(xS_{T^*}\\). From the fundamental pricing ?eq-formula, the value at date \\(0\\) is \\[\\mathrm{e}^{-qT^*}S_0\\mathbb{E}^V[x] = \\mathrm{e}^{-qT^*}S_0\\times \\text{prob}^V\\!(S_{T^*}&gt;S_T)\\; .\\]\nTo price the payoff \\(xS_T\\), use the following portfolio as numeraire:1purchase \\(\\mathrm{e}^{-qT}\\) shares of the stock at date \\(0\\) and reinvest dividends until date \\(T\\). This will result in the ownership of one share at date \\(T\\), worth \\(S_T\\) dollars. At date \\(T\\), sell the share and invest the proceeds in the risk-free asset and hold this position until date \\(T^*\\). At date \\(T^*\\), the portfolio will be worth \\(\\mathrm{e}^{r(T^*-T)}S_T\\). Let \\(Z_t\\) denote the value of this portfolio for each \\(0\\leq t\\leq T^*\\). The fundamental pricing ?eq-formula implies that the value of receiving \\(xS_T\\) at date \\(T^*\\) is \\[\\begin{align*}\nZ_0\\mathbb{E}^Z\\left[ \\frac{xS_T}{Z_{T^*}}\\right] &=\n\\mathrm{e}^{-qT}S_0\\mathbb{E}^Z\\left[ \\frac{xS_T}{\\mathrm{e}^{r(T^*-T)}S_T}\\right]\\\\&= \\mathrm{e}^{-qT-r(T^*-T)}S_0\\mathbb{E}^Z[x] \\\\&= \\mathrm{e}^{-qT-r(T^*-T)}S_0 \\times\\text{prob}^Z(S_{T^*}&gt;S_T)\\;.\n\\end{align*}\\]\n\n\n\nCalculating Probabilities\n\nAs in the case of a share digital, we know that \\[\n\\log S_t = \\log S_0 + \\left(r-q +\\frac{1}{2}\\sigma^2\\right)t + \\sigma B^*_t\n\\] for all \\(t&gt;0\\), where \\(B^*\\) is a Brownian motion when \\(V\\) is used as the numeraire. Taking \\(t=T^*\\) and \\(t=T\\) and subtracting yields \\[\\log S_{T^*}-\\log S_T = \\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T^*-T) + \\sigma \\left[B^*_{T^*}-B^*_T\\right]\\; .\\] Hence, \\(S_{T^*}&gt;S_T\\) if and only if \\[-\\frac{B^*_{T^*}-B^*_T}{\\sqrt{T^*-T}} &lt; \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T^*-T)}{\\sigma\\sqrt{T^*-T}}\\; .\\] The random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^V\\!(S_{T^*}&gt;S_T) = \\mathrm{N}(d_1)\\; ,\n\\] where\n\n\\[\nd_1 = \\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)(T^*-T)}{\\sigma\\sqrt{T^*-T}} =\\frac{\\left(r-q +\\frac{1}{2}\\sigma^2\\right)\\sqrt{T^*-T}}{\\sigma}\\;.\n\\qquad(12.29)\\]\n\nTo calculate the probability \\(\\text{prob}^Z(S_{T^*}&gt;S_T)\\), note that between \\(T\\) and \\(T^*\\), the portfolio with price \\(Z\\) earns the risk-free rate \\(r\\). The same argument presented in ?sec-s:girsanov shows that between \\(T\\) and \\(T^*\\) we have \\[\n\\frac{\\mathrm{d}  S}{S} = (r-q)\\mathrm{d}   t + \\sigma\\mathrm{d}   B^*\\; ,\n\\] where now \\(B^*\\) denotes a Brownian motion when \\(Z\\) is used as the numeraire. This implies as usual that \\[\n\\mathrm{d} \\log S = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)\\mathrm{d}   t + \\sigma\\mathrm{d}   B^*\\; ,\n\\] which means that \\[\n\\log S_{T^*} - \\log S_T = \\left(r-q-\\frac{1}{2}\\sigma^2\\right)(T^*-T) + \\sigma(B^*_{T^*}-B^*_T)\\; .\n\\] Hence, \\(S_{T^*}&gt;S_T\\) if and only if \\[\n-\\frac{B^*_{T^*}-B^*_T}{\\sqrt{T^*-T}} &lt; \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)(T^*-T)}{\\sigma\\sqrt{T^*-T}}\\; .\n\\] As before, the random variable on the left hand side is a standard normal, so \\[\n\\text{prob}^Z(S_{T^*}&gt;S_T) = \\mathrm{N}(d_2)\\; ,\n\\] where \\[\nd_2 = \\frac{\\left(r-q -\\frac{1}{2}\\sigma^2\\right)\\sqrt{T^*-T}}{\\sigma}=d_1-\\sigma\\sqrt{T^*-T}\\;.\n\\qquad(12.30)\\]\n\n\n\nForward-Start Call Pricing Formula\nCombining these results, we have:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a forward-start call at date \\(0\\) is \\[\n\\mathrm{e}^{-qT^*}S_0\\mathrm{N}(d_1) - \\mathrm{e}^{-qT-r(T^*-T)}S_0\\mathrm{N}(d_2)\\;,\n\\qquad(12.31)\\]\nwhere \\(d_1\\) and \\(d_2\\) are defined in Equation 12.29 - Equation 12.30.\n\n\n\n\nPut-Call Parity\nForward-strike calls and puts satisfy a somewhat unusual form of put-call parity. The usual put-call parity is of the form: \\[\n\\text{Call} \\;+\\; \\text{Cash} \\quad = \\quad \\text{Put} \\;+ \\;\\text{Underlying}\\; .\n\\]\nThe amount of cash is the amount that will accumulate to the exercise price at maturity; i.e., it is \\(\\mathrm{e}^{-rT^*}K\\). For forward-start calls and puts, the effective exercise price is \\(S_T\\), which is not known at date \\(0\\). However, the portfolio used as numeraire to value the second part of the payoff will be worth \\(\\mathrm{e}^{r(T^*-T)}S_T\\) at date \\(T^*\\), and by following the same strategy but starting with \\(\\mathrm{e}^{-r(T^*-T)-qT}\\) instead of \\(\\mathrm{e}^{-qT}\\) shares, we will have \\(S_T\\) dollars at date \\(T^*\\). The date–0 value of this portfolio should replace Cash in the above. Thus:\n\n\n\n\n\n\nKey Result\n\n\n\nPut-call parity for forward-start calls and puts is \\[\n\\text{Call Price} \\;+\\; \\mathrm{e}^{-r(T^*-T)-qT}S_0 = \\text{Put Price} \\;+\\; \\mathrm{e}^{-qT^*}S_0\\;.\n\\qquad(12.32)\\]\nThe new features in the option pricing formulas in this chapter are the use of the bivariate normal distribution function and sometimes the need to compute a critical (at-the-money) value of the underlying asset price. We will compute the critical values by bisection, in the same way that we computed implied volatilities for the Black-Scholes formula in ?sec-c:blackscholes.\nThe following is a fast approximation of the bivariate cumulative normal distribution function, accurate to six decimal places, due to Drezner (Drezner 1978)). For given numbers \\(a\\) and \\(b\\), this function gives the probability that \\(\\xi_1&lt;a\\) and \\(\\xi_2&lt;b\\) where \\(\\xi_1\\) and \\(\\xi_2\\) are standard normal random variables with a given correlation \\(\\rho\\), which we must input.\n\n\nCode\nimport numpy as np\nfrom scipy.stats import norm\n\ndef binormal_prob(a, b, rho):\n    x = np.array([0.24840615, 0.39233107, 0.21141819, 0.03324666, 0.00082485334])\n    y = np.array([0.10024215, 0.48281397, 1.0609498, 1.7797294, 2.6697604])\n    a1 = a / np.sqrt(2 * (1 - rho ** 2))\n    b1 = b / np.sqrt(2 * (1 - rho ** 2))\n    if a &lt;= 0 and b &lt;= 0 and rho &lt;= 0:\n        total_sum = 0\n        for i in range(5):\n            for j in range(5):\n                z1 = a1 * (2 * y[i] - a1)\n                Z2 = b1 * (2 * y[j] - b1)\n                z3 = 2 * rho * (y[i] - a1) * (y[j] - b1)\n                total_sum += x[i] * x[j] * np.exp(z1 + Z2 + z3)\n        return total_sum * np.sqrt(1 - rho ** 2) / np.pi\n    elif a &lt;= 0 and b &gt;= 0 and rho &gt;= 0:\n        return norm.cdf(a) - binormal_prob(a, -b, -rho)\n    elif a &gt;= 0 and b &lt;= 0 and rho &gt;= 0:\n        return norm.cdf(b) - binormal_prob(-a, b, -rho)\n    elif a &gt;= 0 and b &gt;= 0 and rho &lt;= 0:\n        total_sum = norm.cdf(a) + norm.cdf(b)\n        return total_sum - 1 + binormal_prob(-a, -b, rho)\n    elif a * b * rho &gt; 0:\n        rho1 = (rho * a - b) * np.sign(a) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        rho2 = (rho * b - a) * np.sign(b) / np.sqrt(a ** 2 - 2 * rho * a * b + b ** 2)\n        Delta = (1 - np.sign(a) * np.sign(b)) / 4\n        return binormal_prob(a, 0, rho1) + binormal_prob(b, 0, rho2) - Delta\n# print(\"BiNormalProb:\", binormal_prob(0.1, 0.2, 0.3))\n\n\nNotice that this function calls itself. This is an example of recursion.\nThe forward-start call pricing formula is of the same form as the Black-Scholes, Margrabe, Black, and Merton formulas. We can compute it with our Generic_Option pricing function.\n\n\nCode\ndef generic_option(P1, P2, sigma, T):\n    \"\"\"\n    Inputs:\n    P1 = present value of asset to be received\n    P2 = present value of asset to be delivered\n    sigma = volatility\n    T = time to maturity\n    \"\"\"\n    x = (np.log(P1 / P2) + 0.5 * sigma ** 2 * T) / (sigma * np.sqrt(T))\n    y = x - sigma * np.sqrt(T)\n    N1 = norm.cdf(x)\n    N2 = norm.cdf(y)\n    return P1 * N1 - P2 * N2\n\ndef forward_start_call(S, r, sigma, q, Tset, TCall):\n    P1 = np.exp(-q * TCall) * S\n    P2 = np.exp(-q * Tset - r * (TCall - Tset)) * S\n    return generic_option(P1, P2, sigma, TCall - Tset)\n\n# Example usage\nS = 100\nK = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT = 1\nDiv = 5\nTDiv = 0.5\nTCall = 1\nN = 10\n\n# print(\"Forward Start Call:\", forward_start_call(S, r, sigma, q, 0.5, TCall))",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#sec-s:choosers",
    "href": "Chapter_OtherExotics.html#sec-s:choosers",
    "title": "12  Other Exotics",
    "section": "12.6 Choosers",
    "text": "12.6 Choosers\nA chooser option allows the holder to choose whether the option will be a put or call at some fixed date before the option maturity. Let \\(T\\) denote the date at which the choice is made, \\(T_c\\) the date at which the call expires, \\(T_p\\) the date at which the put expires, \\(K_c\\) the exercise price of the call, and \\(K_p\\) the exercise price of the put, where \\(0&lt;T&lt;T_c\\) and \\(0&lt;T&lt;T_p\\). A simple chooser has \\(T_c=T_p\\) and \\(K_c=K_p\\). A chooser is similar in spirit to a straddle: it is a bet on volatility without making a bet on direction. A simple chooser must be cheaper than a straddle with the same exercise price and maturity \\(T^*=T_c=T_p\\), because a straddle is always in the money at maturity, whereas a simple chooser has the same value as the straddle if it is in the money but is only in the money at \\(T^*\\) when the choice made at \\(T\\) turns out to have been the best one.\n\nChooser Payoff\nThe value of the chooser at date \\(T\\) will be the larger of the call and put prices. Let \\(S^*\\) denote the stock price at which the call and put have the same value. We can find \\(S^*\\) by solving\nBlack_Scholes_Call(S*,Kc,r,sigma,q,Tc-T) = Black_Scholes_Put(S*,Kp,r,sigma,q,Tp-T).\nFor a simple chooser with \\(K_c=K_p=K\\) and \\(T_c=T_p=T^*\\), we can find \\(S^*\\) from the put-call parity relation at \\(T\\), leading to \\(S^*=\\mathrm{e}^{(q-r)(T^*-T)}K.\\)\nThe call will be chosen when \\(S_T&gt;S^*\\) and it finishes in the money if \\(S(T_c)&gt;K_c\\) at date \\(T_c\\), so the payoff of the chooser is \\(S(T_c)-K_c\\) when \\[S_T&gt;S^* \\quad \\text{and}\\quad S(T_c)&gt;K_c\\;.\n\\] The payoff is \\(K_p-S(T_p)\\) at date \\(T_p\\) when \\[\nS_T&lt;S^* \\quad \\text{and}\\quad S(T_p)&lt;K_p\\;.\n\\] Let \\[\n\\begin{align*}\nx&= \\begin{cases} 1 &\\text{if $S_T&gt;S^* $ and $S(T_c)&gt;K_c$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\\\\\ny&= \\begin{cases} 1 &\\text{if $S_T&lt;S^*$ and $S(T_p)&lt;K_p$;,}\\\\\n                               0 & \\text{otherwise;.}\n        \\end{cases}\n\\end{align*}\n\\] Then the payoff of the chooser is \\(xS(T_c)-xK_c\\) at date \\(T_c\\) and \\(yK_p-yS(T_p)\\) at date \\(T_p\\).\n\n\nNumeraires\nAs in the analysis of compound options, the value of the chooser at date \\(0\\) must be\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\times\\text{prob}^V\\!(x=1) \\;- \\;\\mathrm{e}^{-rT_c}K_c\\times\\text{prob}^R(x=1)\n\\\\+\\; \\mathrm{e}^{-rT_p}K_p\\times\\text{prob}^R(y=1) \\;- \\;\\mathrm{e}^{-q T_p}S_0\\times\\text{prob}^V\\!(y=1)\\;,\n\\end{multline}\n\\qquad(12.33)\\]\nwhere we use \\(V_t=\\mathrm{e}^{qt}S_t\\) and \\(R_t=\\mathrm{e}^{rt}\\) as numeraires.\n\n\nChooser Pricing Formula\nEquation 12.33 and calculations similar to those of the previous two sections lead us to:\n\n\n\n\n\n\nKey Result\n\n\n\nThe value of a chooser option is\n\\[\n\\begin{multline}\n\\mathrm{e}^{-q T_c}S_0\\mathrm{M}\\!\\left(d_1,d_{1c},\\sqrt{T/T_c}\\right) - \\mathrm{e}^{-rT_c}K_c\\mathrm{M}\\!\\left(d_2,d_{2c},\\sqrt{T/T_c}\\right)\\\\ +\\mathrm{e}^{-rT_p}K_p\\mathrm{M}\\!\\left(-d_2,-d_{2p} , \\sqrt{T/T_p}\\right) \\\\- \\mathrm{e}^{-q T_p}S_0\\mathrm{M}\\!\\left(-d_1 ,-d_{1p} ,\\sqrt{T/T_p}\\right)\\;,\n\\end{multline}\n\\qquad(12.34)\\]\nwhere \\[\\begin{equation*}\n\\begin{array}{ll}\nd_1 = \\frac{\\log\\left(\\frac{S_0}{S^*}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\;,\n& \\qquad d_2=d_1-\\sigma\\sqrt{T}\\;,\\\\\n&\\\\\nd_{1c} = \\frac{\\log\\left(\\frac{S_0}{K_c}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_c}{\\sigma\\sqrt{T_c}}\\;,\n& \\qquad d_{2c}=d_{1c}-\\sigma\\sqrt{T_c}\\;,\\\\\n&\\mathrm{d}_{1p} = \\frac{\\log\\left(\\frac{S_0}{K_p}\\right)+\\left(r-q+\\frac{1}{2}\\sigma^2\\right)T_p}{\\sigma\\sqrt{T_p}}\\;,\n& \\qquad d_{2p}=d_{1p}-\\sigma\\sqrt{T_p}\\;.\n\\end{array}\n\\end{equation*}\\]\n\n\nTo implement the bisection to compute \\(S^*\\), we can take zero as a lower bound and \\(K_c+K_p\\) as an upper bound.^[We take the call value to be zero and the put value to be \\(\\mathrm{e}^{-r(T_p-T)}K_p\\) at date \\(T\\) when the stock price is zero. To see why the upper bound works, note that when the stock price is \\(S\\) at date \\(T\\), the call is worth at least \\(S^*-K_c\\) and the put is worth no more than \\(K_p\\); i.e, \\(C \\geq S-K_c\\) and \\(P \\leq K_p\\). Therefore, \\(C-P \\geq S-K_c-K_p\\). Hence when \\(S=K_c+K_p\\), we have \\(C-P\\geq 0\\). }\n\n\nCode\ndef chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp):\n    tol = 1e-6\n    lower = 0\n    upper = np.exp(q * Tc) * (Kc + Kp)\n    guess = 0.5 * Kc + 0.5 * Kp\n    flower = -np.exp(-r * (Tp - T)) * Kp\n    fupper = black_scholes_call(upper, Kc, r, sigma, q, Tc - T) - black_scholes_put(upper, Kp, r, sigma, q, Tp - T)\n    fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    while upper - lower &gt; tol:\n        if fupper * fguess &lt; 0:\n            lower = guess\n            flower = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n        else:\n            upper = guess\n            fupper = fguess\n            guess = 0.5 * lower + 0.5 * upper\n            fguess = black_scholes_call(guess, Kc, r, sigma, q, Tc - T) - black_scholes_put(guess, Kp, r, sigma, q, Tp - T)\n    Sstar = guess\n\n    d1 = (np.log(S / Sstar) + (r - q + sigma ** 2 / 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d1c = (np.log(S / Kc) + (r - q + sigma ** 2 / 2) * Tc) / (sigma * np.sqrt(Tc))\n    d2c = d1c - sigma * np.sqrt(Tc)\n    d1p = (np.log(S / Kp) + (r - q + sigma ** 2 / 2) * Tp) / (sigma * np.sqrt(Tp))\n    d2p = d1p - sigma * np.sqrt(Tp)\n    rhoc = np.sqrt(T / Tc)\n    rhop = np.sqrt(T / Tp)\n    M1c = binormal_prob(d1, d1c, rhoc)\n    M2c = binormal_prob(d2, d2c, rhoc)\n    M1p = binormal_prob(-d1, -d1p, rhop)\n    M2p = binormal_prob(-d2, -d2p, rhop)\n\n    return np.exp(-q * Tc) * S * M1c - np.exp(-r * Tc) * Kc * M2c + np.exp(-r * Tp) * Kp * M2p - np.exp(-q * Tp) * S * M1p\n\n# Example usage\nS = 100\nKc = 80\nKp = 80\nr = 0.05\nsigma = 0.2\nq = 0.02\nTc = 1.5\nTp = 1.5\nT=1\n\n# print(\"Chooser Option:\", chooser(S, Kc, Kp, r, sigma, q, T, Tc, Tp))",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#exercises",
    "href": "Chapter_OtherExotics.html#exercises",
    "title": "12  Other Exotics",
    "section": "12.7 Exercises",
    "text": "12.7 Exercises\n\nExercise 12.1 Intuitively, the value of a forward-start call option should be lower the closer is the date \\(T\\) at which the strike is set to the date \\(T^*\\) at which the option matures, because then the option has less time to maturity after being created at \\(T\\). Create a Python program to confirm this. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Compute and plot the value of the option for \\(T=0.1T^*\\), \\(T=0.2T^*\\), , \\(T=0.9T^*\\).\n\n\nExercise 12.2 Create a Python program to demonstrate the additional leverage of a call-on-a-call relative to a standard call. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Use the Black-Scholes_Call function to compute and output the value \\(C\\) of a European call with strike \\(K**=S\\) (i.e., the call is at the money) and maturity \\(T^*\\). Use the Call_on_Call function to compute and output the value of a call option on the call with strike \\(K=C\\) (i.e., the call-on-a-call is at the money) and maturity \\(T=0.5T^*\\). Compute the percentage returns the standard European call and the call-on-a-call would experience if the stock price \\(S\\) instantaneously increased by 10%.\n\n\nExercise 12.3 Create a Python program to illustrate the early exercise premium for an American call on a stock paying a discrete dividend. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), and \\(T^*\\). Take the date of the dividend payment to be \\(T=0.5T^*\\) and take the strike price to be \\(K=S\\). The value of a European call is given by the Black-Scholes formula with \\(S-\\mathrm{e}^{-rT}D\\) being the initial asset price and \\(q=0\\) being the constant dividend yield. Use the function American_Call_Dividend to compute the value of an American call for dividends \\(D=.1S\\), \\(D=.9S\\). Subtract the value of the European call with the same dividend to obtain the early exercise premium. Plot the early exercise premium against the dividend \\(D\\).\n\n\nExercise 12.4 Create a Python function to value a simple chooser (a chooser option in which \\(K_c=K_p\\) and \\(T_c=T_p\\)) using put-call parity to compute \\(S^*\\) as mentioned in Section 12.6. Verify that the function gives the same result as the function Chooser.\n\n\nExercise 12.5 Create a Python code to compare the cost of a simple chooser to that of a straddle (straddle = call + put with same strike and maturity). Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\), \\(q\\), and \\(T^*\\). Take the time to maturity of the underlying call and put to be \\(T^*\\) for both the chooser and the straddle. Take the strike prices to be \\(K=S\\). Take the time the choice must be made for the chooser to be \\(T=0.5T^*\\). Compute the cost of the chooser and the cost of the straddle.\n\n\nExercise 12.6 A stock has fallen in price and you are attempting to persuade a client that it is now a good buy. The client believes it may fall further before bouncing back and hence is inclined to postpone a decision. To convince the client to buy now, you offer to deliver the stock to him at the end of two months at which time he will pay you the lowest price it trades during the two months plus a fee for your costs. The stock is not expected to pay a dividend during the next two months. Assuming the stock actually satisfies the Black-Scholes assumptions, find a formula for the minimum fee that you would require. (Hint: It is almost in Section 12.2.) Create a Python program allowing the user to input \\(S\\), \\(r\\), and \\(\\sigma\\) and computing the minimum fee.\n\n\nExercise 12.7 Suppose you must purchase 100 units of an asset at the end of a year. Create a Python program simulating the asset price and comparing the quality of the following hedges (assuming 100 contracts of each):\n\na standard European call,\na down-and-out call in which the knock-out barrier is 10% below the current price of the asset.\n\nTake both options to be at the money at the beginning of the year. Allow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Generate 500 simulated end-of-year costs (net of the option values at maturity) for each hedging strategy and create histogram charts to visually compare the hedges. Note: to create histograms, you will need the Data Analysis add-in, which may be need to be loaded (click Tools/Add Ins).\n\n\nExercise 12.8 Compute the prices of the options in the previous exercise. Modify the simulations to compare the end-of-year costs including the costs of the options, adding interest on the option prices to put everything on an end-of-year basis.\n\n\nExercise 12.9 Modify Exercise 12.7 by including a third hedge: a combination of a down-and-out call as in part (b) of Exercise 12.7 and a down-and-in call with knockout barrier and strike 10% below the current price of the asset. Note that this combination forms a call option with strike that is reset when the underlying asset price hits a barrier.\n\n\nExercise 12.10 Modify Exercise 12.8 by including the hedge in Exercise 12.9. Value the down-and-in call using the function Down_And_Out_Call and the fact that a down-and-out and down-and-in with the same strikes and barriers form a standard option.\n\n\nExercise 12.11 Each week you purchase 100 units of an asset, and you want to hedge your total quarterly (13-week) cost. Create a Python program simulating the asset price and comparing the quality of the following hedges:\n\na standard European call maturing at the end of the quarter (\\(T=0.25\\)) on 1300 units of the asset,\n13 call options maturing at the end of each week of the quarter, each written on 100 units of the asset, and\na discretely sampled average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\na discretely sampled geometric-average-price call with maturity \\(T=0.25\\) written on 1300 units of the asset, where the sampling is at the end of each week.\n\nAllow the user to input \\(S\\), \\(r\\), \\(\\sigma\\) and \\(q\\). Assume all of the options are at the money at the beginning of the quarter (\\(K=S\\)). Compare the hedges as in Exercise 12.7.\n\n\nExercise 12.12 In the setting of the previous problem, compute the prices of the options in parts (a), (b) and (d). Modify the simulations in the previous problem to compare the end-of-quarter costs including the costs of the options (adding interest on the option prices to put everything on an end-of-quarter basis).\n\n\nExercise 12.13 Using the put-call parity relation, derive a formula for the value of a forward-start put.\n\n\nExercise 12.14 Derive Equation 12.19 for the value of a call on a put.\n\n\nExercise 12.15 Complete the derivation of Equation 12.34 for the value of a chooser option.\n\n\nExercise 12.16 Derive a formula for the value of a put option on the maximum of two risky asset prices.\n\n\nExercise 12.17 Using the result of the preceding exercise and Margrabe’s formula, verify that calls and puts (having the same strike \\(K\\) and maturity \\(T\\)) on the maximum of two risky asset prices satisfy the following put-call parity relation: \\[\\begin{multline*}\n\\mathrm{e}^{-rT}K + \\text{Value of call on max} \\\\\n= \\mathrm{e}^{-q_2T}S_2(0) + \\text{Value of option to exchange asset 2 for asset 1} \\\\+ \\text{Value of put on max}\\;.\n\\end{multline*}\\]\n\n\n\n\n\nConze, A., and Viswanathan. 1991. “Path Dependent Options: The Case of Lookback Options.” Journal of Finance 46: 1893–1907.\n\n\nDrezner, Z. 1978. “Computation of the Bivariate Normal Integral.” Mathematics of Computation 32: 277–79.\n\n\nGeske, R. 1979. “The Valuation of Compound Options.” Journal of Financial Economics 7: 63–81.\n\n\nGoldman, M., H. Sosin, and M. Gatto. 1979. “Path Dependent Options: ‘Buy at the Low, Sell at the High.” ’ Journal of Finance 34: 1111–27.\n\n\nMusiela, M., and M. Rutkowski. 1997. Martingale Methods in Financial Modeling. Springer, Berlin Heidelberg New York.\n\n\nStulz, R. 1982. “Options on the Minimum or Maximum of Two Risky Assets: Analysis and Applications.” Journal of Financial Economics 10: 161–85.",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_OtherExotics.html#footnotes",
    "href": "Chapter_OtherExotics.html#footnotes",
    "title": "12  Other Exotics",
    "section": "",
    "text": "We are going to use equation~?eq-probSnumeraire at date \\(T^*\\) to define the probabilities, because it will not be known until date \\(T^*\\) whether the event \\(S_{T^*}&gt;S_T\\) is true. Thus, we need the price of a numeraire asset at date \\(T^*\\). We would like this price to be a constant times \\(S_T\\), which is what we will obtain. An equivalent numeraire is to make a smaller investment in the same portfolio: start with \\(\\mathrm{e}^{-r(T^*-T)-qT}\\) shares. This results in a final value of \\(S_T\\) at date \\(T^*\\). As will be seen, this is useful for deriving the put-call parity relation for forward-start options.↩︎",
    "crumbs": [
      "Part 3: Option Pricing",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Other Exotics</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html",
    "href": "Chapter_MonteCarlo.html",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "13.1 Introduction to Monte Carlo\nIn this chapter, we will introduce a principal numerical method for valuing derivative securities: Monte Carlo. Throughout the chapter, we will assume there is a constant risk-free rate. The last section, while quite important, could be skimmed on first reading—the rest of the book does not build upon it.\nAccording to our risk-neutral pricing ?eq-riskneutralformula, the value of a security paying an amount \\(x\\) at date \\(T\\) is \\[\n\\mathrm{e}^{-rT}\\mathbb{E}^R[x]\\;.\n\\qquad(13.1)\\]\nTo estimate this by Monte-Carlo means to simulate a sample of values for the random variable \\(x\\) and to estimate the expectation by averaging the sample values.1. Of course, for this to work, the sample must be generated from a population having a distribution consistent with the risk-neutral probabilities.\nThe simplest example is valuing a European option under the Black-Scholes assumptions. Of course, for calls and puts, this is redundant, because we already have the Black-Scholes formulas. Nevertheless, we will describe how to do this for the sake of introducing the Monte Carlo method. In the case of a call option, the random variable \\(x\\) in Equation 13.1 is \\(\\max(0,S_T-K)\\). To simulate a sample of values for this random variable, we need to simulate the terminal stock price \\(S_T\\). This is easy to do, because, under the Black-Scholes assumptions, the logarithm of \\(S_T\\) is normally distributed under the risk-neutral probability with mean \\(\\log S_0+\\nu T\\) and variance \\(\\sigma^2T\\), where \\(\\nu=r-q-\\sigma^2/2\\). Thus, we can simulate values for \\(\\log S_T\\) as \\(\\log S_0+\\nu T + \\sigma\\sqrt{T}z\\), where \\(z\\) is a standard normal. We can average the simulated values of \\(\\max(0,S_T-K)\\), or whatever the payoff of the derivative is, and then discount at the risk-free rate to compute the date–0 value of the derivative. This means that we generate some number \\(M\\) of standard normals \\(z_i\\) and estimate the option value as \\(\\mathrm{e}^{-rT}\\bar{x}\\), where \\(\\bar{x}\\) is the mean of \\[x_i = \\max\\left(0,\\mathrm{e}^{\\log S_0+\\nu T + \\sigma\\sqrt{T}z_i}-K\\right)\\; .\\] To value options that are path-dependent we need to simulate the path of the underlying asset price.\nThere are two main drawbacks to Monte-Carlo methods. First, it is difficult (though not impossible) to value early-exercise features.2 To value early exercise, we need to know the value at each date if not exercised, to compare to the intrinsic value. One could consider performing a simulation at each date to calculate the value if not exercised, but this value depends on the option to exercise early at later dates, which cannot be calculated without knowing the value of being able to exercise early at even later dates, etc. In contrast, the binomial model can easily handle early exercise but cannot easily handle path dependencies.\nThe second drawback of Monte Carlo methods is that they can be quite inefficient in terms of computation time (though, as will be explained later, they may be faster than alternative methods for derivatives written on multiple assets). As in statistics, the standard error of the estimate depends on the sample size. Specifically, given a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of size \\(M\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\), the best estimate of \\(\\mu\\) is the sample mean \\(\\bar{x}\\), and the standard error of \\(\\bar{x}\\) (which means the standard deviation of \\(\\bar{x}\\) in repeated samples) is best estimated by \\[\n\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^{M} x_i^2-M\\bar{x}^2\\right)}\\;.\n\\qquad(13.2)\\] Recall that \\(\\bar{x}\\) plus or minus 1.96 standard errors is a 95% confidence interval for \\(\\mu\\) when the \\(x_i\\) are normally distributed. In the context of European option valuation, the expression Equation 13.2 gives the standard error of the estimated option value at maturity, and multiplication of Equation 13.2 by \\(\\mathrm{e}^{-rT}\\) gives the standard error of the estimated date–0 option value.\nTo obtain an estimate with an acceptably small standard error may require a large sample size and hence a relatively large amount of computation time. The complexities of Monte Carlo methods arise from trying to reduce the required sample size. Later, we will describe two such methods (antithetic variates and control variates). For those who want to engage in a more detailed study of Monte Carlo methods, the book of Glasserman (Glasserman 2004) is highly recommended. J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002) is useful for more advanced readers, and Clewlow and Strickland (Clewlow and Strickland 1998) and Brandimarte (Brandimarte 2002) are useful references that include computer code.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "href": "Chapter_MonteCarlo.html#sec-s:mc_europeans",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "Monte Carlo Valuation of a European Call\nWe will illustrate Monte Carlo by valuing a European call under the Black-Scholes assumptions. We will also estimate the delta by each of the methods described in Section 13.4 and Section 13.5. Of course, we know the call value and its delta from the Black-Scholes formulas, and they can be used to evaluate the accuracy of the Monte Carlo estimates. In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process. Therefore we set \\(m=1\\). However, we use a large number of paths, \\(n=10,000\\) to get a large sample of terminal stock prices.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 10000\n#number of divisions\nm = 1\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Dividend Yield\nq=0.0\n# Delta t\ndt = T/m\n# Drift (nu)\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2020\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before, this code generates two samples \\(St\\), which adds the simulated standard (zero mean) normal random variable, and \\(St1\\) which subtracts the simulated (zero mean) standard normal random variable. Each sample produces and estimate for the Black-Scholes European call option.\n\n\nCode\ncc=np.maximum(St[m,:]-K,0)\ncp = np.mean(cc) * np.exp(-r * T)\ncc1=np.maximum(St1[m,:]-K,0)*np.exp(-r * T)\ncp1= np.mean(np.maximum(St1[m,:]-K,0)) * np.exp(-r * T)\n\nprint('The first sample gives an estimated call price=',cp)\nprint('The second sample gives an estimated call price=',cp1)\nbsc = (cp+cp1)/2\nprint('The average of the two estimates=',bsc)\n\n\nThe first sample gives an estimated call price= 4.791646287615179\nThe second sample gives an estimated call price= 4.687624646438364\nThe average of the two estimates= 4.739635467026771\n\n\nThe true call price is given by\n\n\nCode\nfrom scipy.stats import norm\nimport numpy as np\nfrom scipy.optimize import minimize, minimize_scalar\n\ndef blackscholes(S0, K, r, q, sig, T, call = True):\n    '''Calculate option price using B-S formula.\n    \n    Args:\n        S0 (num): initial price of underlying asset.\n        K (num): strick price.\n        r (num): risk free rate\n        q (num): dividend yield\n        sig (num): Black-Scholes volatility.\n        T (num): maturity.\n        call (bool): True returns call price, False returns put price.\n        \n    Returns:\n        num\n    '''\n    d1 = (np.log(S0/K) + (r -q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n    if call:\n        return np.exp(- q *T) * S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1) \n    else:\n        return -np.exp(-q * T) * S0 * norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ntruebsc=blackscholes(S0, K, r, q, sig, T, call = True)\nprint('The black scholes fromula=',truebsc)\n\n\nThe black scholes fromula= 4.759422392871532\n\n\nNotice that even with 10,000 data points for each sample the individual estimates are not very accurate compared to the exact Black Scoles price. This is a well known problem that is difficult to estimate the mean, even with a lot of data and is a drawback to Monte Carlo as discussed earlier. However, the average of the two prices is sgnificantly more accurate. This is an example of an antithetic variable which is discussed later. One simple intution is the two samples yield negatively correlated errors; if the plus sample is two high, then the minus sample will be too low. Combined, the simulation error will cancel out. Another intution is that each individual sample has a wrong estimate of the mean. However, the combined sample has zero mean by construction. Therefore combining the samples give the right mean of the simulated standard normal random variable. Nevertheless, there is still sampling error since we are estimating the mean of the discounted call payoffs, not the mean of the standard normal. This method and other methods to reduce sampling error are discussed next.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#antithetic-variates-in-monte-carlo",
    "href": "Chapter_MonteCarlo.html#antithetic-variates-in-monte-carlo",
    "title": "13  Monte Carlo Methods",
    "section": "13.2 Antithetic Variates in Monte Carlo",
    "text": "13.2 Antithetic Variates in Monte Carlo\nIn this and the following section, we will discuss two methods to increase the efficiency of the Monte Carlo method. These are two of the simplest methods. They are used extensively, but there are other important methods that are also widely used. J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002) and Glasserman (Glasserman 2004) provide a wealth of information on this topic.\nThe Monte Carlo method estimates the mean \\(\\mu\\) of a random variable \\(x\\) as the sample average of randomly generated values of \\(x\\). An antithetic variate is a random variable \\(y\\) with the same mean as \\(x\\) and a negative correlation with \\(x\\). It follows that the random variable \\(z=(x+y)/2\\) will have the same mean as \\(x\\) and a lower variance. Therefore the sample mean of \\(M\\) simulations of \\(z\\) will be an unbiased estimate of \\(\\mu\\) and will have a lower standard error than the sample mean of \\(M\\) simulations of \\(x\\). Thus, we should obtain a more efficient estimator of \\(\\mu\\) by simulating \\(z\\) instead of \\(x\\).3\nIn the context of derivative valuation, the standard application of this idea is to generate two negatively correlated underlying asset prices (or price paths, if the derivative is path dependent). The terminal value of the derivative written on the first asset serves as \\(x\\) and the terminal value of the derivative written on the second serves as \\(y\\). Because both asset prices have the same distribution, the means of \\(x\\) and \\(y\\) will be the same, and the discounted mean is the date–0 value of the derivative.\nConsider for example a non-path-dependent option in a world with constant volatility. In each simulation \\(i\\) (\\(i=1,\\ldots,M\\)), we would generate a standard normal \\(Z_i\\) and compute \\[\n\\begin{align*}\n\\log S_i(T) &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z_i\\; ,\\\\\n\\log S_i'(T) &= \\log S_0 + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T - \\sigma\\sqrt{T}Z_i\\;.\n\\end{align*}\n\\] Given the first terminal price, the value of the derivative will be some number \\(x_i\\) and given the second it will be some number \\(y_i\\). The date–0 value of the derivative is estimated as \\[\n\\mathrm{e}^{-rT}\\frac{1}{M}\\sum_{i=1}^M\\frac{x_i+y_i}{2}\\; .\n\\]",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "href": "Chapter_MonteCarlo.html#sec-s:controlvariates",
    "title": "13  Monte Carlo Methods",
    "section": "13.3 Control Variates in Monte Carlo",
    "text": "13.3 Control Variates in Monte Carlo\n Another approach to increasing the efficiency of the Monte Carlo method is to adjust the estimated mean (option value) based on the known mean of another related variable. We can explain this in terms of linear regression in statistics. Suppose we have a random sample \\(\\{x_1,\\ldots,x_M\\}\\) of a variable \\(x\\) with unknown mean \\(\\mu\\), and suppose we have a corresponding sample \\(\\{y_1,\\ldots,y_M\\}\\) of another variable \\(y\\) with known mean \\(\\phi\\). Then an efficient estimate of \\(\\mu\\) is \\(\\hat{\\mu} = \\bar{x} + \\hat{\\beta} (\\phi-\\bar{y})\\), where \\(\\bar{x}\\) and \\(\\bar{y}\\) denote the sample means of \\(x\\) and \\(y\\), and where \\(\\hat{\\beta}\\) is the coefficient of \\(y\\) in the linear regression of \\(x\\) on \\(y\\) (i.e., the estimate of \\(\\beta\\) in the linear model \\(x = \\alpha +\\beta y + \\varepsilon\\)). The standard Monte Carlo method, which we have described thus far, simply estimates the mean of \\(x\\) as \\(\\bar{x}\\). The control variate method adjusts the estimate by adding \\(\\hat{\\beta} (\\phi-\\bar{y})\\). To understand this correction, assume for example that the true \\(\\beta\\) is positive. If the random sample is such that \\(\\bar{y}&lt;\\phi\\), then it must be that small values of \\(y\\) were over-represented in the sample. Since \\(x\\) and \\(y\\) tend to move up and down together (this is the meaning of a positive \\(\\beta\\)) it is likely that small values of \\(x\\) were also over-represented in the sample. Therefore, one should adjust the sample mean of \\(x\\) upwards in order to estimate \\(\\mu\\). The best adjustment will take into account the extent to which small values of \\(y\\) were over-represented (i.e., the difference between \\(\\bar{y}\\) and \\(\\phi\\)) and the strength of the relation between \\(x\\) and \\(y\\) (which the estimate \\(\\hat{\\beta}\\) represents). The efficient correction of this sort is also the simplest: just add \\(\\hat{\\beta}(\\phi-\\bar{y})\\) to \\(\\bar{x}\\). In practice, the estimation of \\(\\hat{\\beta}\\) may be omitted and one may simply take \\(\\hat{\\beta}=1\\), if the relationship between \\(x\\) and \\(y\\) can be assumed to be one-for-one. If \\(\\beta\\) is to be estimated, the estimate (by ordinary least squares) is \\[\\hat{\\beta} = \\frac{\\sum_{i=1}^M x_iy_i - M\\bar{x}\\bar{y}}{\\sum_{i=1}^M y_i^2 - M\\bar{y}^2}\\; .\\] In general, the correction term \\(\\hat{\\beta}(\\phi-\\bar{y})\\) will have a nonzero mean, which introduces a bias in the estimate of \\(\\mu\\). To eliminate the bias, one can compute \\(\\hat{\\beta}\\) from a pre-sample of \\(\\{x,y\\}\\) values.\nAs an example of a control variate, in our simulation code to estimate the Black Scholes price for a call option we can use the stock price itself. The known stock price is the input price \\(S_0\\). The simulation also produces an estimate for the stock price as the dicsounted expected value of the terminal stock price \\(\\hat{S}=\\sum_{i=1}^{n} e^{- r T } S_t(m,i)\\) where \\(S_t(m,i)\\) is the \\(i\\)th simulated stock price at time \\(T\\). Theoretically these should be the same umber, but due to error they typically wil not be the same.\n\n\nCode\nSS=np.mean(St[m,:])*np.exp(-r*T)\nprint('The Estimated Stock Price for the first sample is =', SS)\nprint('The actual stock price should be=', S0)\nprint('The error is =', S0-SS)\n\n\nThe Estimated Stock Price for the first sample is = 42.05899999577932\nThe actual stock price should be= 42\nThe error is = -0.058999995779316805\n\n\nThe error is \\(S_0-\\hat{S}\\) which corresponds to \\(\\phi-y\\) above. We then compute \\(\\hat{\\beta}\\) and comute the improved estimate \\[ \\text{new estimate}= \\text{original estimate} +\\hat{\\beta}(S0-\\hat{S}) \\] In the code below we do this procedure for both samples and average the updates.\n\n\nCode\nhatbeta= np.cov(St[m,:],cc)[0,1]/np.cov(St[m,],cc)[1,1]\nhatbeta1=np.cov(St1[m,:],cc1)[0,1]/np.cov(St1[m,],cc1)[1,1]\ncorrection =hatbeta*(S0-SS)\nupdate=cp + correction\nprint('hatbeta=',hatbeta)\nprint('The original estimate for the call price from the first sample=',cp)\nprint('The original estimate for the call price from the second sample=',cp1)\nprint('The updated estimate from the first sample is=',update)\nSS1=np.mean(St1[m,:])*np.exp(-r*T)\nupdate1=cp1+hatbeta1*(S0-SS1)\nprint('The updated estimate from the second sample is=',update1)\nprint('The average of the updated estimates =',(update+update1)/2)\n\n\nhatbeta= 1.1541186403411716\nThe original estimate for the call price from the first sample= 4.791646287615179\nThe original estimate for the call price from the second sample= 4.687624646438364\nThe updated estimate from the first sample is= 4.723553292706219\nThe updated estimate from the second sample is= 4.780385012196883\nThe average of the updated estimates = 4.751969152451551\n\n\nWe can compare this to the exact Black Scholes formula from before.\n\n\nCode\nprint('The exact Black Scholes Price is=', truebsc)\n\n\nThe exact Black Scholes Price is= 4.759422392871532\n\n\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[A_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\; .\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[K^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\; .\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\mathbb{E}^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\; .\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[x = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\; .\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[y =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\; .\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 11.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks1",
    "title": "13  Monte Carlo Methods",
    "section": "13.4 Monte Carlo Greeks I: Difference Ratios",
    "text": "13.4 Monte Carlo Greeks I: Difference Ratios\nGreeks can be calculated by Monte Carlo by running the valuation program twice and computing a difference ratio, for example \\((C_u-C_d)/(S_u-S_d)\\) to estimate a delta. However, to minimize the error, and minimize the number of computations required, one should use the same set of random draws to estimate the derivative value for different values of the parameter. For path-independent options (e.g., European puts and calls) under the Black-Scholes assumptions, we only need to generate \\(S_T\\) and then we can compute \\(S_u(T)\\) as \\([S_u(0)/S_0] \\times S_T\\) and \\(S_d(T)\\) as \\([S_u(0)/S_0] \\times S_T\\). We can estimate standard errors for the Greeks in the same way that we estimate the standard error of the derivative value.\nActually, there is often a better method available that is just as simple. This is called pathwise calculation. We will explain this in the next section. Here we will describe how to estimate the delta and gamma of a derivative as sample means of difference ratios.\nConsider initial prices for the underlying \\(S_u&gt;S&gt;S_d\\). Denote the underlying price at the option maturity in a given simulation by \\(S_u(T)\\) when the initial underlying price is \\(S_u\\), by \\(S_T\\) when the initial underlying price is \\(S\\), and by \\(S_d(T)\\) when the initial underlying price is \\(S_d\\). Under the Black-Scholes assumptions, the logarithm of the stock price at date \\(T\\) starting from the three initial prices \\(S_d\\), \\(S\\) and \\(S_u\\) is\n\\[\n\\begin{align*}\n\\log S_d(T) &= \\log S_d + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_T &= \\log S + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\; ,\\\\\n\\log S_u(T) &= \\log S_u + \\left(r-q-\\frac{1}{2}\\sigma^2\\right)T + \\sigma B_T\\;,\n\\end{align*}\n\\] so \\[\\log S_d(T) = \\log S_T + \\log S_d - \\log S\\Longrightarrow S_d(T) = \\left(\\frac{S_d}{S}\\right) S_T\\; ,\\] and \\[\\log S_u(T) = \\log S_T + \\log S_u - \\log S \\Longrightarrow S_u(T) = \\left(\\frac{S_u}{S}\\right) S_T\\; .\\] Therefore, under the Black-Scholes assumptions, we only need to simulate \\(S_T\\) and then perform the multiplications indicated above to obtain \\(S_d(T)\\) and \\(S_u(T)\\).\nConsider a particular simulation and let \\(C_d(T)\\) denote the value of the derivative at maturity when the initial asset price is \\(S_d\\), let \\(C_T\\) denote the value of the derivative at maturity when the initial asset price is \\(S\\), and let \\(C_u(T)\\) denote the value of the derivative at maturity when the initial asset price is \\(S_u\\). For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of \\(S_T\\) as just described. However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).\nThe estimates \\(C_d\\), \\(C\\) and \\(C_u\\) of the date–0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the \\(C_d(T)\\), \\(C_T\\) and \\(C_u(T)\\). One way to estimate the delta is \\((C_u-C_d)/(S_u-S_d)\\). This is a difference of discounted sample means, multiplied by the reciprocal of \\(S_u-S_d\\). Equivalently, it is the sample mean of the differences \\(C_u(T)-C_d(T)\\), multiplied by \\(\\mathrm{e}^{-rT}/(S_u-S_d)\\). The standard error is \\[\n\\frac{\\mathrm{e}^{-rT}}{S_u-S_d}\\sqrt{\\frac{1}{M(M-1)}\\left(\\sum_{i=1}^M \\left[C_{ui}(T)-C_{di}(T)\\right]^2 - M\\left[\\overline{C_{u}(T)}-\\overline{C_{d}(T)}\\right]^2\\right)}\\; ,\n\\] where the overline denotes the sample mean and where \\(C_{ui}(T)\\) [respectively, \\(C_{di}(T)\\)] denotes the value of the derivative at maturity in simulation \\(i\\) when the initial asset price is \\(S_u\\) [respectively, \\(S_d\\)].\nThe corresponding Monte Carlo estimate of the gamma is also a sample mean. Simple algebra shows that Equation 14.4 is equivalent to \\[\n\\Gamma = \\frac{2}{(S_u-S)(S_u-S_d)}C_u - \\frac{2}{(S_u-S)(S-S_d)}C +\\frac{2}{(S-S_d)(S_u-S_d)}C_d\\;.\n\\qquad(13.3)\\]\nNormally one would take \\(S_u=(1+\\alpha)S\\) and \\(S_d = (1-\\alpha)S\\) for some \\(\\alpha\\) (e.g., \\(\\alpha=0.01\\)). In this case Equation 13.3 simplifies to \\[\n\\Gamma = \\frac{C_u - 2C + C_d}{\\alpha^2S^2}\\;,\n\\qquad(13.4)\\]\nand the standard error of the gamma is\n\\[\n\\begin{multline*}\\frac{\\mathrm{e}^{-rT}}{\\alpha^2S^2}\\sqrt{\\frac{1}{M(M-1)}}\\\\\n\\times \\sqrt{\\sum_{i=1}^M \\left[C_{ui}(T)-2C_i(T)+C_{di}(T)\\right]^2 -M\\left[\\overline{C_{u}(T)}-2\\overline{C_T}+\\overline{C_{d}(T)}\\right]^2}\\; .\n\\end{multline*}\n\\]",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "href": "Chapter_MonteCarlo.html#sec-s:montecarlogreeks2",
    "title": "13  Monte Carlo Methods",
    "section": "13.5 Monte Carlo Greeks II: Pathwise Estimates",
    "text": "13.5 Monte Carlo Greeks II: Pathwise Estimates\nWe will examine the bias in the Monte Carlo delta estimate discussed in the preceding section and explain pathwise estimation of Greeks. By biased, we mean that the expected value of an estimate is different from the true value. It is important to recognize that if a Monte Carlo estimate is biased, then, even if a large number of simulations is used and the standard error is nearly zero, the answer provided by the Monte Carlo method will be incorrect. For simplicity, consider a European call under the Black-Scholes assumptions.\nThe delta estimate we have considered is the discounted sample mean of \\[\n\\frac{C_u(T) - C_d(T)}{S_u-S_d}\\;.\n\\qquad(13.5)\\]\nThis ratio takes on one of three values, depending on \\(S_T\\):\n\nIf \\(S_u(T) \\leq K\\) then the option is out of the money in both the up and down cases; i.e., \\[C_u(T) = C_d(T) = 0\\; ,\\] so the ratio Equation 13.5 is zero.\nIf \\(S_d(T) \\geq K\\) then the option is in the money in both the up and down cases; i.e.,\n\n\\[\n\\begin{align*} C_u(T) &= S_u(T) - K =\\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d(T) &= S_d(T) - K = \\left(\\frac{S_d}{S}\\right)S_T - K\\;,\n\\end{align*}\n\\]\nso the ratio Equation 13.5 equals \\(S_T/S\\). - If \\(S_u(T) &gt; K &gt; S_d(T)\\), then the option is in the money in only the up case; i.e., \\[\n\\begin{align*}\nC_u(T) &= S_u(T) - K = \\left(\\frac{S_u}{S}\\right)S_T - K\\; ,\\\\\nC_d(T) &= 0\\;,\n\\end{align*}\n\\] so the ratio Equation 13.5 equals \\[\n\\frac{\\left(\\frac{S_u}{S}\\right)S_T - K}{S_u-S_d} &lt; \\frac{S_T}{S}\\; .\n\\]\nThe bias is induced by the third case above. We can see this as follows. We are trying to estimate \\[\n\\frac{\\partial }{\\partial S} \\mathrm{e}^{-rT}\\mathbb{E}^R \\big[\\max(0,S_T-K)\\big] = \\mathrm{e}^{-rT}\\mathbb{E}^R  \\left[ \\frac{\\partial }{\\partial S} \\max(0,S_T-K)\\right]\\;.\n\\qquad(13.6)\\]\nThe delta estimate \\((C_u-C_d)/(S_u-S_d)\\) replaces the mean \\(\\mathbb{E}^R\\) with the sample mean and replaces \\[\n\\frac{\\partial }{\\partial S} \\max(0,S_T-K)\n\\qquad(13.7)\\]\nwith the ratio Equation 13.5. The derivative Equation 13.7 takes on two possible values, depending on \\(S_T\\)—we can ignore the case \\(S_T=K\\) because it occurs with zero probability:\n\nIf \\(S_T &lt; K\\), then \\(\\max(0,S_T-K) = 0\\) and the derivative is zero.\nIf \\(S_T&gt;K\\), then \\(\\max(0,S_T-K) = S_T-K\\) and the derivative equals \\[\\frac{\\partial S_T}{\\partial S}=\\mathrm{e}^{(r-q-\\sigma^2/2)T + \\sigma B_T} = \\frac{S_T}{S}\\; .\\]\n\nTherefore, the true delta—the expectation Equation 13.6—equals4 \\[\n\\mathrm{e}^{-rT}\\mathbb{E}^R\\left[\\frac{S_T}{S} x\\right]\\;,\n\\qquad(13.8)\\]\nwhere \\(x\\) is the random variable defined as \\[\\begin{equation*}\nx =  \\begin{cases} 1 & \\text{if $S_T&gt;K$}\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{equation*}\\] On the other hand, our analysis of the ratio Equation 13.5 shows that the expected value of the delta estimate \\((C_u-C_d)/(S_u-S_d)\\) is \\[\n\\mathrm{e}^{-rT}\\mathbb{E}^R\\left[\\frac{S_T}{S} y\\right] + \\mathrm{e}^{-rT}\\mathbb{E}^R\\left[\\frac{S_uS_T-SK}{S(S_u-S_d)}z\\right]\\;,\n\\qquad(13.9)\\]\nwhere \\[\n\\begin{align*}\ny &=  \\begin{cases} 1 & \\text{if} S_d(T)&gt;K\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\n\\] and \\[\n\\begin{align*}\nz &=  \\begin{cases} 1 & \\text{if} S_u(T)&gt;K&gt;S_d(T)\\; ,\\\\\n0 & \\text{otherwise}\\;.\n\\end{cases}\n\\end{align*}\n\\] To contrast Equation 13.8 and Equation 13.9, note that if \\(y=1\\) then \\(x=1\\), so the term \\(\\mathbb{E}^R\\left[\\frac{S_T}{S} y\\right]\\) in Equation 13.9 is part of Equation 13.8. However, there are two partially offsetting errors in Equation 13.9: \\(z\\) sometimes equals one when \\(x\\) is zero, and when both \\(z\\) and \\(x\\) are one, then the factor multiplying \\(z\\) is smaller than the factor multiplying \\(x\\). In any case, the expected value Equation 13.9 is not the same as the true delta Equation 13.8. As noted before, this implies that the delta estimate will be incorrect even if its standard error is zero. The bias can be made as small as one wishes by taking the magnitude \\(S_u-S_d\\) of the perturbation to be small, but taking the perturbation to be very small will introduce unacceptable roundoff error.\nThe obvious way to estimate the delta in this situation is simply to compute the discounted sample average of \\([S_T/S]x\\). This is called a pathwise estimate of the delta, because it only uses the sample paths of \\(S_t\\) rather than considering up and down perturbations. This method is due to Broadie and Glasserman (Broadie and Glasserman 1996). Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.\nTo compute pathwise estimates in other models and for other Greeks, we need the Greek to be an expectation as on the right-hand side of Equation 13.6. Additional examples can be found in Glasserman (Glasserman 2004) and J\\(\\ddot{\\text{a}}\\)ckel (Jäckel 2002).",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "href": "Chapter_MonteCarlo.html#monte-carlo-models-for-path-dependent-options",
    "title": "13  Monte Carlo Methods",
    "section": "13.6 Monte Carlo Models for Path-Dependent Options",
    "text": "13.6 Monte Carlo Models for Path-Dependent Options\nA derivative is said to be path dependent if its value depends on the path of the underlying asset price rather than just on the price at the time of exercise. Examples of path-dependent options are lookbacks, barrier options, and Asians. To value a path-dependent option by Monte Carlo, we need to simulate an approximate path of the stock price. We do this by considering time periods of length \\(\\Delta t = T/N\\) for some integer \\(N\\). Under the risk-neutral probability, the logarithm of the stock price changes over such a time period by \\[\n\\Delta \\log S = \\nu\\,\\Delta t + \\sigma\\sqrt{\\Delta t}\\,z\\;,\n\\qquad(13.10)\\]\nwhere \\(\\nu = r-q-\\sigma^2/2\\) and \\(z\\) is a standard normal. Given that there are \\(N\\) time periods of length \\(\\Delta t\\), we need to generate \\(N\\) standard normals to generate a stock price path. If we generate \\(M\\) paths to obtain a sample of \\(M\\) option values, then we will need to generate \\(MN\\) standard normals.\nConsider for example a floating-strike lookback call. The formula for this option given in Section 12.2 assumes the minimum stock price is computed over the entire path of the stock price, i.e., with continuous sampling of the stock price. In practice, the minimum will be computed by recording the price at a discrete number of dates. We can value the discretely sampled lookback using Monte-Carlo by choosing \\(\\Delta t\\) to be the interval of time (e.g., a day or week) at which the price is recorded. For example, if the contract calls for weekly observation, we will attain maximum precision by setting \\(N\\) to be the number of weeks before the option matures.\nFor most path dependent options, a possible starting point is to generate an array of \\(n\\) paths but since we want the entire path we choose the number of time steps that is appropriate for our application. We can use the same code as in @#sec-s:mc_europeans if we are working in a Black Scholes setting.\n\n\nCode\n# Simulate Geometric Brownian Motion\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq=0.0\n# Volatility\nsig = 0.2\n# Initial Stock Price\nS0 = 42\n# Maturity\nT = 0.5\n#Strike Price\nK=40\n# Delta t\ndt = T/m\n# Drift\ndrift = (r-q-0.5*sig**2)\n# Volatility\nvol = sig * np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nSt = np.zeros(shape = (m + 1, n))\nSt = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1 = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\n\nAs before this code generates two samples the original and the antithetic. The output is an array of \\(n\\) sample paths with \\(m\\) time steps. The sample can also be used to find the value of a floating strike lookback call.\n\n\nCode\ndef floating_strike_call(S, r, sigma, q, T, SMin):\n    d1 = (np.log(S / SMin) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    d2prime = (np.log(SMin / S) + (r - q - 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n    N1 = norm.cdf(d1)\n    N2 = norm.cdf(d2)\n    N2prime = norm.cdf(d2prime)\n    x = 2 * (r - q) / (sigma ** 2)\n    return np.exp(-q * T) * S * N1 - np.exp(-r * T) * SMin * N2 + (1 / x) * (SMin / S) ** x * np.exp(-r * T) * SMin * N2prime - (1 / x) * np.exp(-q * T) * S * (1 - N1)\n\nS = 100\nr = 0.05\nsigma = 0.2\nq = 0.02\nT=1\n\nStmin=St[m:]-np.minimum(np.min(St,axis=0),S0)\nSt1min=St1[m:]-np.minimum(np.min(St1,axis=0),S0)\nfloatlkbk=np.exp(-r*T)*np.mean(Stmin)\nfloatlkbk1=np.exp(-r*T)*np.mean(St1min)\n\nprint('The first estimate is=',floatlkbk)\nprint('The second estimate is=',floatlkbk1)\nprint('The average estimate is=',(floatlkbk+floatlkbk1)/2)\nprint('The exact formula is=',floating_strike_call(S0, r, sigma, 0, T, S0))\n\n\nThe first estimate is= 5.45244209168367\nThe second estimate is= 5.468030697490039\nThe average estimate is= 5.460236394586854\nThe exact formula is= 7.231056939691567\n\n\nTo value the fixed strike lookback call option with time \\(T\\) payoff \\(\\max(\\max_{0\\le t \\le T} S_t.0)\\), we simply add the following\n\n\nCode\nStmax=np.maximum(np.max(St,axis=0)-K,0)\nSt1max=np.maximum(np.max(St1,axis=0)-K,0)\nlookbck = np.exp(-r*T) *np.mean(Stmax)\nlookbck1=np.exp(-r * T)*np.mean(St1max)\nprint('The first estimate is=',lookbck)\nprint('The second estimate is=',lookbck1)\nprint('The average estimate is=', (lookbck + lookbck1)/2)\n\n\nThe first estimate is= 7.716467940991822\nThe second estimate is= 7.769558237964809\nThe average estimate is= 7.743013089478316\n\n\nAsian and barrier options are also subject to discrete rather than continuous sampling and can be valued by Monte-Carlo in the same way as lookbacks.\nAs another example, consider the classic case of estimating the value of a discretely-sampled average-price call, using a discretely-sampled geometric-average-price call as a control variate. Let \\(\\tau\\) denote the amount of time that has elapsed since the call was issued and \\(T\\) the amount of time remaining before maturity, so the total maturity of the call is \\(T+\\tau\\). To simplify somewhat, assume date \\(0\\) is the beginning of a period between observations. Let \\(t_1, \\ldots, t_N\\) denote the remaining sampling dates, with \\(t_1 = \\Delta t\\), \\(t_i-t_{i-1}=\\Delta t = T/N\\) for each \\(i\\), and \\(t_N=T\\). We will input the average price \\(A_0\\) computed up to date \\(0\\), assuming this average includes the price \\(S_0\\) at date \\(0\\). The average price at date \\(T\\) will be \\[\nA_T = \\frac{\\tau}{T+\\tau}A_0 + \\frac{T}{T+\\tau}\\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right)\\;.\n\\] The average-price call pays \\(\\max(0,A_T-K)\\) at its maturity \\(T\\), and we can write this as \\[\\begin{align*}\n\\max(A_T-K,0) &= \\max\\left(\\frac{T}{T+\\tau}\\left( \\frac{\\sum_{i=1}^N S_{t_i}}{N}\\right) - \\left(K - \\frac{\\tau}{T+\\tau}A_0\\right), 0\\right)\\\\\n&= \\frac{T}{T+\\tau} \\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;,\n\\end{align*}\\] where \\[\nK^* = \\frac{T+\\tau}{T}K - \\frac{\\tau}{T}A_0\\;.\n\\] Therefore, the value at date \\(0\\) of the discretely-sampled average-price call is \\[\n\\frac{T}{T+\\tau} \\,\\mathrm{e}^{-rT} \\mathbb{E}^R\\left[\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\right]\\;.\n\\] In terms of the discussion above, the random variable the mean of which we want to estimate is \\[\nx = \\mathrm{e}^{-rT}\\max \\left(\\frac{\\sum_{i=1}^N S_{t_i}}{N} - K^*,0\\right)\\;.\n\\] A random variable \\(y\\) that will be closely correlated to \\(x\\) is \\[\ny =\\mathrm{e}^{-rT}\\max \\left(\\mathrm{e}^{\\sum_{i=1}^N \\log S_{t_i}/N} - K^*,0\\right)\\;.\n\\] The mean \\(\\phi\\) of \\(y\\) under the risk-neutral probability is given in the pricing Equation 11.7. We can use the sample mean of \\(y\\) and its known mean \\(\\phi\\) to adjust the sample mean of \\(x\\) as an estimator of the value of the average-price call. Generally, the estimated adjustment coefficient \\(\\hat{\\beta}\\) will be quite close to 1.\nAgain we can get a sample of payoffs using our stock price samples.\n\n\nCode\naverage = np.mean(St,axis=0)\naverage1 = np.mean(St1,axis=0)\ndpayoff=np.exp(-r*T)*np.mean(np.maximum(average-K,0))\ndpayoff1=np.exp(-r*T)*np.mean(np.maximum(average1-K,0))\nprint('The first estimate is=',dpayoff)\nprint('The second estimate is=',dpayoff1)\nprint('The average of the estimates=',(dpayoff+dpayoff1)/2)\n\n\nThe first estimate is= 3.231154315344899\nThe second estimate is= 3.296876297130776\nThe average of the estimates= 3.2640153062378374\n\n\nWe now construct a control variate, the geometric asian option which has a known formula for its value.\n\n\nCode\ndef black_scholes_call(S, K, r, sigma, q, T):\n    \"\"\"\n    Inputs:\n    S = initial stock price\n    K = strike price\n    r = risk-free rate\n    sigma = volatility\n    q = dividend yield\n    T = time to maturity\n    \"\"\"\n    if sigma == 0:\n        return max(0, np.exp(-q * T) * S - np.exp(-r * T) * K)\n    else:\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        N1 = norm.cdf(d1)\n        N2 = norm.cdf(d2)\n        return np.exp(-q * T) * S * N1 - np.exp(-r * T) * K * N2\n\ndef discrete_geom_average_price_call(S, K, r, sigma, q, T, N):\n    dt = T / N\n    nu = r - q - 0.5 * sigma ** 2\n    a = N * (N + 1) * (2 * N + 1) / 6\n    V = np.exp(-r * T) * S * np.exp(((N + 1) * nu / 2 + sigma ** 2 * a / (2 * N ** 2)) * dt)\n    sigavg = sigma * np.sqrt(a) / (N ** 1.5)\n    return black_scholes_call(V, K, r, sigavg, q, T)\n\ngeom=np.exp((np.mean(np.log(St),axis=0)))\ngeom1=np.exp((np.mean(np.log(St1),axis=0)))\ngeomavgpo=np.maximum(geom-K,0)\ngeomavg1po=np.maximum(geom1-K,0)\nvalue=np.mean(geomavgpo)*np.exp(-r*T)\nvalue1=np.mean(geomavg1po)*np.exp(-r*T)\ntga=discrete_geom_average_price_call(S0, K, r, sigma, q, T, m)\nerror =tga-value\nerror1=tga-value1\nprint('The estimate from the first sample=',value)\nprint('The estimate from the second sample=',value1)\nprint('The average of the two estimates is=',(value+value1)/2)\nprint('The value from the exact formula=',tga)\nprint('The error in the first estimate=',error)\nprint('The error in the second estimate=',error1)\n\n\nThe estimate from the first sample= 3.172076049997697\nThe estimate from the second sample= 3.236566795172543\nThe average of the two estimates is= 3.20432142258512\nThe value from the exact formula= 2.6835589764289125\nThe error in the first estimate= -0.4885170735687847\nThe error in the second estimate= -0.5530078187436307\n\n\nNext we estimate the beta. As discussed before, we could simply set beta=1. Alternatively, if we estimate beta from the simulated sample, then our update could be biased. Instead we compute an independent sample from which we estimate beta. We then estimate the updated estimate for both samples from the formula \\[\n\\text{new estimate} = \\text{original estimate} + \\beta * \\text{error}\n\\]\n\n\nCode\nincpre = np.zeros(shape = (m + 1, n))\nincpre[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nStpre = np.zeros(shape = (m + 1, n))\nSt1pre=np.zeros(shape = (m + 1, n))\nStpre = S0 * np.exp(np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\nSt1pre = S0 * np.exp(-np.cumsum(inc,axis=0) + (drift * t[0:m + 1])[:,None])\n\namean=np.mean(Stpre,axis=0)\namean1=np.mean(St1pre,axis=0)\napo = np.maximum(amean-K,0)\na1po=np.maximum(amean1-K,0)\ngmean=np.exp(np.mean(np.log(St),axis=0))\ng1mean=np.exp(np.mean(np.log(St1),axis=0))\ngpo=np.maximum(gmean-K,0)\ng1po=np.maximum(g1mean-K,0)\nbeta=np.cov(gpo,apo)[0,1]/np.cov(gpo,apo)[1,1]\nbeta1=np.cov(g1po,a1po)[0,1]/np.cov(g1po,a1po)[1,1]\nupdate=dpayoff +beta*error\nupdate1=dpayoff1+beta1*error1\n\nprint('The updated estimate for the first sample=',update)\nprint('The updated value for the second sample=',update1)\nprint('The average of the updated values is=',(update +update1)/2)\n\n\nThe updated estimate for the first sample= 2.7518403446698483\nThe updated value for the second sample= 2.7538925235582683\nThe average of the updated values is= 2.7528664341140585",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "href": "Chapter_MonteCarlo.html#sec-montecarlomultiple",
    "title": "13  Monte Carlo Methods",
    "section": "13.7 Monte Carlo Valuation of Basket and Spread Options",
    "text": "13.7 Monte Carlo Valuation of Basket and Spread Options\n In this section, we will consider the valuation of European spread and basket options by the Monte Carlo method. There are no simple formulas for these options. In each simulation, we will generate a terminal price for each of the underlying assets and compute the value of the option at its maturity. Discounting the average terminal value gives the estimate of the option value as usual.\nThe difference between binomial and Monte Carlo methods for options written on multiple assets can be understood as follows. Both methods attempt to estimate the discounted expected value of the option (under the risk-neutral probability). In an \\(N\\)–period model, the binomial model produces \\(N+1\\) values for the terminal price of each underlying asset. Letting \\(k\\) denote the number of underlying assets, this produces \\((N+1)^k\\) combinations of asset prices. Of course, each combination has an associated probability. In contrast, the Monte Carlo method produces \\(M\\) combinations of terminal prices, where \\(M\\) is the number of simulations. Each combination is given the same weight (\\(1/M\\)) when estimating the expected value.\nWith a single underlying asset, the binomial model is more efficient, as discussed in ?sec-s:introbinomial, because the specifically chosen terminal prices in the binomial model sample the set of possible terminal prices more efficiently than randomly generated terminal prices. However, this advantage disappears, and the ranking of the methods can be reversed, when there are several underlying assets. The reason is that many of the \\((N+1)^k\\) combinations of prices in the binomial model will have very low probabilities. For example, with two assets that are positively correlated, it is very unlikely that one asset will be at its highest value in the binomial model and the other asset simultaneously at its lowest. It is computationally wasteful to evaluate the option for such a combination, because the probability-weighted value will be very small and hence contribute little to the estimate of the expected value. On the other hand, each set of terminal prices generated by the Monte Carlo method will be generated from a distribution having the assumed correlation. Thus, only relatively likely combinations will typically be generated, and time is not wasted on evaluating unlikely combinations. However, it should not be concluded that Monte Carlo valuation of a derivative on multiple assets will be quick and easy—even though the computation time required for more underlying assets does not increase as much with Monte Carlo as for binomial models, it can nevertheless be substantial.\nTo implement Monte Carlo valuation of options on multiple assets, we must first explain how to simulate correlated asset prices. We can simulate the changes in two Brownian motions \\(B_1\\) and \\(B_2\\) that have correlation \\(\\rho\\) by generating two independent standard normals \\(Z_1\\) and \\(Z_2\\) and defining \\[\n\\Delta B_1 = \\sqrt{\\Delta t}\\,Z_1\\;, \\qquad \\text{and} \\qquad \\Delta B_2 = \\sqrt{\\Delta t}\\,Z\\; ,\n\\] where \\(Z\\) is defined as \\[\nZ = \\rho Z_1 + \\sqrt{1-\\rho^2}\\,Z_2\\;.\n\\] The random variable \\(Z\\) is also a standard normal, and the correlation between \\(Z_1\\) and \\(Z\\) is \\(\\rho\\).\n\n\nCode\n# Simulate 2 Geometric Brownian Motions\nimport numpy as np\nimport matplotlib.pyplot as plt\n# number of paths\nn = 1000\n#number of divisions\nm = 1000\n# Interest rate (We set the drift equal to the interest rate for the risk-neutral probability)\nr = 0.1\n# Dividend yield\nq1=0.0\nq2=0\n# Volatility\nsig1 = 0.2\nsig2=.3\n# correlation\nrho=0.5\n# Initial Stock Price\nS0 = 42\nV0 = 50\n# Maturity\nT = 0.5\n\n# Delta t\ndt = T/m\n# Drift\ndrift1 = (r-q1-0.5*sig1**2)\ndrift2 = (r-q2-0.5*sig2**2)\n# Volatility\nvol = np.sqrt(dt)\n\nt = np.array(range(0,m + 1,1)) * dt\n\n# seed for random generator\nseed= 2024\n# define a random generator\nnp.random.seed(seed)\ninc = np.zeros(shape = (m + 1, n))\ninc[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\ninc1 = np.zeros(shape = (m + 1, n))\ninc1[1:] = np.transpose(np.random.normal(loc = 0, scale = vol,size = (n,m)))\nincr = np.zeros(shape = (m + 1, n))\nincr = rho*inc + np.sqrt(1-rho**2)*inc1\n\n\nThus, we can simulate the changes in the logarithms of two correlated asset prices as \\[\\begin{align*}\n\\Delta \\log S_1 &= \\nu_1\\Delta t + \\sigma_1\\sqrt{\\Delta t}Z_1 \\; ,\\\\\n\\Delta \\log S_2 &= \\nu_2\\Delta t + \\sigma_2\\rho\\sqrt{\\Delta t}Z_1 + \\sigma_2\\sqrt{1-\\rho^2}\\sqrt{\\Delta t}Z_2\\;,\n\\end{align*}\\] where \\(\\nu_i = r-q_1-\\sigma_i^2/2\\) and the \\(Z_i\\) are independent standard normals.\n\n\nCode\nSt1 = np.zeros(shape = (m + 1, n))\nSt2 = np.zeros(shape = (m + 1, n))\nSt1 = S0 * np.exp(sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2 = V0 * np.exp(sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nWe can also construct antithetic variables.\n\n\nCode\nSt1a = np.zeros(shape = (m + 1, n))\nSt2a = np.zeros(shape = (m + 1, n))\nSt1a = S0 * np.exp(-sig1*np.cumsum(inc,axis=0) + (drift1 * t[0:m + 1])[:,None])\nSt2a = V0 * np.exp(-sig2*np.cumsum(incr,axis=0) + (drift2 * t[0:m + 1])[:,None])\n\n\nGiven this sample, we can estimate the value of a best of 2 option with payoff \\(\\max(S_{1T},S_{2T})\\).\n\n\nCode\npayoff = np.maximum(St1[m,:],St2[m,:])\npayoffa = np.maximum(St1a[m,:],St2a[m,:])\nvalue= np.exp(-r*T)*np.mean(payoff)\nvaluea= np.exp(-r*T)*np.mean(payoffa)\n\nprint('The first estmate is =',value)\nprint('The second estimate is =',valuea)\nprint('The avergae of the estimates is=',(value+valuea)/2)\n\n\nThe first estmate is = 50.11374784508302\nThe second estimate is = 51.46596027225067\nThe avergae of the estimates is= 50.78985405866685\n\n\nTo generalize this idea to more than two assets, we introduce some additional notation. The simulation for the case of two assets can be written as\n\\[\n\\Delta \\log S_1 = \\nu_1\\Delta t + a_{11}\\sqrt{\\Delta t}Z_1 + a_{12}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(13.11)\\]\n\\[\n\\Delta \\log S_2 = \\nu_2\\Delta t + a_{21}\\sqrt{\\Delta t}Z_1 + a_{22}\\sqrt{\\Delta t}Z_2\\;,\n\\qquad(13.12)\\]\nwhere \\[\\begin{array}{rclcrcl}\na_{11}&=&\\sigma_1\\;, &\\qquad & a_{12}&=&0\\; ,\\\\\na_{21}&=&\\sigma_2\\rho\\;, &\\qquad & a_{22} &= &\\sigma_2\\sqrt{1-\\rho^2}\\;.\n\\end{array}\n\\]\nThese are not the only possible choices for the constants \\(a_{ij}\\). Given that \\(Z_1\\) and \\(Z_2\\) are independent standard normals, the conditions the \\(a_{ij}\\) must satisfy in order to match the variances \\(\\sigma_i^2\\Delta t\\) and correlation \\(\\rho\\) of the changes in the logarithms are\n\\[\na_{11}^2+a_{12}^2 =\\sigma_1^2\\;,\n\\qquad(13.13)\\]\n\\[\na_{21}^2+a_{22}^2 =\\sigma_2^2\\;,\n\\qquad(13.14)\\]\n\\[\na_{11}a_{21}+a_{12}a_{22} = \\sigma_1\\sigma_2\\rho\\;.\n\\qquad(13.15)\\]\nThese three equations in the four coefficients \\(a_{ij}\\) leave one degree of freedom. We choose to take \\(a_{12}=0\\) and then solve for the other three.\nIn matrix notation, the system Equation 13.13 - Equation 13.15 plus the condition \\(a_{12}=0\\) can be written as the equation \\[\n\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}^\\top = \\begin{pmatrix}\\sigma_1^2 & \\rho\\sigma_1\\sigma_2 \\\\\\rho\\sigma_1\\sigma_2 & \\sigma_2^2\\end{pmatrix}\\; ,\n\\] where \\(^\\top\\) denotes the matrix transpose. The matrix on the right hand side is the covariance matrix of the continuously-compounded annual returns (changes in log asset prices). Choosing the \\(a_{ij}\\) so that the lower triangular matrix \\[\nA \\equiv \\begin{pmatrix}a_{11} & 0 \\\\a_{21} & a_{22}\\end{pmatrix}\n\\] satisfies \\[\nAA^\\top = \\text{covariance matrix}\n\\] is called the the Cholesky decomposition of the covariance matrix. Given any number \\(L\\) of assets, provided none of the assets is redundant (perfectly correlated with a portfolio of the others), the Cholesky decomposition of the \\(L\\times L\\) covariance matrix always exists. An algorithm for computing the Cholesky decomposition in numpy is np.linalg.cholesky.\nWe can use the Cholesky decomposition to perform Monte-Carlo valuation of a basket or spread option.5 If there were some path dependency in the option value, we would simulate the paths of the asset prices as in Equation 13.11 - Equation 13.12. However a standard basket option is not path dependent, so we only need to simulate the asset prices at the option maturity date \\(T\\), as in Section 13.1. The value of a basket call option at its maturity \\(T\\) is \\[\n\\max\\left(0,\\;\\sum_{i=1}^L w_iS_i(T)-K\\right)\\; ,\n\\] where \\(L\\) is the number of assets in the basket (portfolio) and \\(w_i\\) is the weight of the \\(i\\)–th asset in the basket. The logarithm of the \\(i\\)–th asset price at maturity is simulated as \\[\n\\log S_i(T) = \\log S_i(0) +\\nu_iT + \\sqrt{T} \\sum_{j=1}^L a_{ij}Z_j\\; ,\n\\] where the \\(Z_j\\) are independent standard normals. Given the simulated values of the \\(\\log S_i(T)\\), the value at maturity of the basket option is readily computed. The estimate of the date–0 value is then computed as the discounted average of the simulated values at maturity.\nFor our two asset example we compute the value of a call opttion on an equally weighted porfotlio.\n\n\nCode\nw=0.5\nK=45\nbasketpo=np.maximum(w*St1[m,:]+(1-w)*St2[m,:]-K,0)\nbasketpoa=np.maximum(w*St1a[m,:]+(1-w)*St2a[m,:]-K,0)\nestimate=np.exp(-r*T)*np.mean(basketpo)\nestimatea=np.exp(-r*T)*np.mean(basketpoa)\nprint('The first estimate is =',estimate)\nprint('The second estimate is =',estimatea)\nprint('The average of the estimates=',(estimate+estimatea)/2)\n\n\nThe first estimate is = 4.4030641748675095\nThe second estimate is = 4.945665333101932\nThe average of the estimates= 4.674364753984721\n\n\nBelow is a three asset basket option whihc uses the numpy cholesky decomposition. In contrast to the above routine, this routine is does not have the option to generate the entire path, although this can be easily modeified.\n\n\nCode\nimport numpy as np\n#risk free rate\nr=0.1\n# number of assets\nk=3\n\n# number of paths\nn=100000\n# Horizon\nT=0.5\n\n# Initial price\n\nS0=[42,50,45]\n\n# Basket Weights\nw=[.25,.5,.25]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n# drift of log returns\n\ndrift= r*np.ones(k) -0.5*np.dot(S@S,np.ones(k))\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n# covariance matrix\n\nV = S@rho@S\n\n# generate uniform n*k normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc1=np.transpose(np.random.normal(loc = 0, scale = np.sqrt(T),size = (n,k)))\n \n\n\n# create correlated random variables\nZ=np.linalg.cholesky(V)\nincr=np.dot(Z,inc1)\n\nprint('The sample correlation matrix =',np.corrcoef(incr))\nprint('The input correlation matrix =',rho)\n\n\n\n\nSt = S0 * np.exp(drift *T + np.transpose(incr))\n#antithetic sample\nSt1 = S0 * np.exp( drift * T - np.transpose(incr))\n\nestimate=np.mean(St,axis=0)*np.exp(-r*T)\nestimate1=np.mean(St1,axis=0)*np.exp(-r*T)\nprint('The average discounted stock price averaged over both samples=',(estimate+estimate1)/2)\nprint('The initial Srock Price input =',S0)\n\nbasketpo=np.maximum(w@np.transpose(St)-K,0)\nbasketpo1=np.maximum(w@np.transpose(St1)-K,0)\nvalue=np.mean(basketpo)*np.exp(-r*T)\nvalue1=np.mean(basketpo1)*np.exp(-r*T)\nprint('The first sample estimate of the basket option value=',value)\nprint('The second sample estimate of the basket option value=',value1)\nprint('The average estimate of the basket option value=',(value+value1)/2)\n\n\nThe sample correlation matrix = [[1.         0.50356746 0.30497838]\n [0.50356746 1.         0.20383175]\n [0.30497838 0.20383175 1.        ]]\nThe input correlation matrix = [[1.  0.5 0.3]\n [0.5 1.  0.2]\n [0.3 0.2 1. ]]\nThe average discounted stock price averaged over both samples= [42.00560021 50.00484037 45.01680115]\nThe initial Srock Price input = [42, 50, 45]\nThe first sample estimate of the basket option value= 5.335894164783821\nThe second sample estimate of the basket option value= 5.289353051200051\nThe average estimate of the basket option value= 5.312623607991936\n\n\nWe can generate the entire path of multiple assets to value, for example, lookback options on a basket. The code below values the same European basket option as above only it calculates \\(m=2\\) time steps; a lookback can be created by changing the payoffs and increasing \\(m\\).\n\n\nCode\nimport numpy as np\n#number of time steps\nm=2\n# number of assets\nk=3\n# number of sample paths\nn=100000\n\n#risk free rate\nr=0.1\n\n\n\n# Horizon\nT=0.5\n# delta t\ndt=T/m\n# Initial price\n\nS0=[42,50,45]\n\n#Strike Price\n\nK=45\n\n#  put in volatilities\nsig1=.2\nsig2=.3\nsig3=.4\n\n#create diagonal\nsig=[sig1,sig2,sig3]\n\nS=np.diag(sig)\n\n\n# correlation matrix\n\nrho=np.array([[1.0, 0.5, 0.3],\n                  [0.5, 1.0, 0.2],\n                  [0.3, 0.2, 1.0]])\n\n# covariance matrix\n\nV = S@rho@S\n\n# drift of log returns\ndrift= np.array(r*np.ones(k) -0.5*np.dot(S@S,np.ones(k)))*dt\n\n# times vector\nt=np.array(range(1,m + 1,1))\n\n\ndriftv = np.transpose(np.kron(drift,t).reshape(3,m))\n\n# generate uniform n(paths)*k(assets)*m(time steps) normal uncorrelated random variables\n\nseed=2024\nnp.random.seed(seed)\n\ninc=np.random.normal(loc = 0, scale = np.sqrt(dt),size = (n,k,m))\n\n#create correlated random increments\nZ=np.linalg.cholesky(V)\n# numpy matmul assumes last two define matrix multiplication\nincr=np.matmul(Z,inc)\n\n\n\nSSt=S0*np.exp(driftv)\n\n# generate returns along path and antithetic path\n# first e^{cumsum(increments)} gives e^sigma B_t for different t\n\nStb = np.exp(np.cumsum(incr[:,:,],axis=2))\nStb1 = np.exp(-np.cumsum(incr[:,:,],axis=2))\n\n\n#Multiply by S0 e^drift for each t\nSt=np.multiply(Stb,np.transpose(SSt))\nSt1=np.multiply(Stb1,np.transpose(SSt))\n\n#Last date returns\nStm=St[:,:,m-1]\nStm1=St1[:,:,m-1]\n\n#define payoff\n# Basket Weights\nw=[.25,.5,.25]\n\n\npayoff= np.maximum(np.matmul(Stm,np.transpose(w))-K,0)\npayoff1= np.maximum(np.matmul(Stm1,np.transpose(w))-K,0)\n\n\nvalue= np.exp(-r*T)*np.mean(payoff)\nvalue1= np.exp(-r*T)*np.mean(payoff1)\nprint('The estimate for the first sample value=',value)\nprint('The estimate for the second sample value=',value1)\nprint('The average estimate for the value=',(value+value1)/2)\n\n\nThe estimate for the first sample value= 5.310173600480473\nThe estimate for the second sample value= 5.287928240443306\nThe average estimate for the value= 5.299050920461889\n\n\n\n\n\n\nBoyle, P. 1977. “Options: A Monte Carlo Approach.” Journal of Financial Economics 4: 323–38.\n\n\nBrandimarte, P. 2002. Numerical Methods in Finance: A MATLAB-Based Introduction. Wiley, New York.\n\n\nBroadie, M., and P. Glasserman. 1996. “Estimating Security Price Derivatives Using Simulation.” Management Science 42: 269–85.\n\n\n———. 1997. “Pricing American-Style Securities Using Simulation.” Journal of Economic Dynamics and Control 21: 1323–52.\n\n\nClewlow, L., and C. Strickland. 1998. Implementing Derivatives Models. Wiley, New York.\n\n\nGlasserman, P. 2004. Monte Carlo Methods in Financial Engineering. Springer, New York Berlin Heidelberg.\n\n\nJäckel, P. 2002. Monte Carlo Methods in Finance. Wiley, New York.\n\n\nLongstaff, F., and E. Schwartz. 2001. “Valuing American Options by Simulation: A Simple Least-Squares Approach.” Review of Financial Studies 14: 113–47.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_MonteCarlo.html#footnotes",
    "href": "Chapter_MonteCarlo.html#footnotes",
    "title": "13  Monte Carlo Methods",
    "section": "",
    "text": "Boyle~(Boyle 1977) introduced Monte-Carlo methods for derivative valuation, including the variance-reduction methods of control variates and antithetic variates to be discussed later↩︎\nMonte-Carlo methods for valuing early exercise include the stochastic mesh method of Broadie and Glasserman (Broadie and Glasserman 1997) and the regression method of Longstaff and Schwartz (Longstaff and Schwartz 2001). Glasserman (Glasserman 2004) provides a good discussion of these methods and the relation between them.↩︎\n The negative correlation between \\(x\\) and \\(y\\) is essential for this method to generate a real gain in efficiency. To generate \\(M\\) simulations of \\(z\\), one must generate \\(M\\) simulations of \\(x\\) and \\(M\\) of \\(y\\), which will generally require about as much computation time as generating \\(2M\\) simulations of \\(x\\). If \\(x\\) and \\(y\\) were independent, the standard error from \\(M\\) simulations of \\(z\\) would be the same as the standard error from \\(2M\\) simulations of \\(x\\), so using the antithetic variate would be no better than just doubling the sample size for \\(x\\).↩︎\nBy changing numeraires, we can show that Equation 13.8 equals \\(\\mathrm{e}^{-qT}\\mathbb{E}^V[x] = \\mathrm{e}^{-qT}\\mathrm{N}(d_1)\\), as we know from ?sec-c:blackscholes is the delta of a European call in the Black-Scholes model (here, as in ?sec-c:blackscholes, \\(V_t=\\mathrm{e}^{qt}S_t\\) denotes the value of the dividend-reinvested portfolio created from the stock).↩︎\nFor a spread option, take \\(L=2\\), \\(w_1=1\\) and \\(w_2=-1\\).↩︎",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Monte Carlo Methods</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html",
    "href": "Chapter_BinomialModel.html",
    "title": "14  Binomial and Trinomial Models",
    "section": "",
    "text": "14.1 Advanced Binomial Applications\nThis chapter builds on the binomial tree foundations from Chapter 4 to explore advanced applications and techniques. We focus on specialized implementations, performance optimizations, and extensions to multiple asset problems. The fundamental concepts of backward induction and parameter calibration are covered in the earlier chapter on binomial trees.\nHaving covered the basic binomial tree framework in Chapter 4, we now turn to specialized applications where binomial models excel. The key advantage of binomial models over Monte Carlo methods lies in their efficiency for early exercise features and their ability to provide precise exercise boundaries.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#alternative-parameter-sets",
    "href": "Chapter_BinomialModel.html#alternative-parameter-sets",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.2 Alternative Parameter Sets",
    "text": "14.2 Alternative Parameter Sets\nWhile Chapter 4 covered the popular Cox-Ross-Rubinstein parameters and other standard parameter choices, we focus here on specialized parameter sets that offer advantages for multi-asset applications.\n\nTrigeorgis Parameters for Multi-Asset Models\nWhen we consider binomial models for multiple assets, we will use the tree proposed by Trigeorgis (Trigeorgis 1991), because it is the simplest to explain in that context. Trigeorgis proposes choosing \\(p\\), \\(u\\) and \\(d\\) so that the mean and variance of \\(\\Delta \\log S\\) in the binomial model match those in the continuous-time model exactly, where \\(\\mathrm{n}u = r - q - \\sigma^2/2\\) is the drift of the log price process. This means that\n\\[\\begin{align*}\n\\frac{p\\log u+(1-p)\\log d}{\\Delta t} &= \\mathrm{n}u\\; ,\\\\\n\\frac{p(1-p)(\\log u-\\log d)^2}{\\Delta t} &= \\sigma^2\\;.\n\\end{align*}\\]\nThese are two equations in the three unknowns, leaving one degree of freedom, so Trigeorgis takes \\(d=1/u\\), as do Cox, Ross and Rubinstein. As we will show in the next section, taking \\(d=1/u\\) simplifies the calculations of deltas and gammas. Solving these two equations yields1\n\\[\n\\log u=\\sqrt{\\sigma^2\\Delta t + \\mathrm{n}u^2(\\Delta t)^2}\\;,\n\\qquad(14.1)\\]\n\\[\np = \\frac{1}{2}+\\frac{\\mathrm{n}u\\Delta t}{2\\log u}\\;.\n\\qquad(14.2)\\]\nThese Trigeorgis parameters prove particularly useful in multi-asset applications as we will demonstrate later in the chapter. The choice of \\(d = 1/u\\) not only ensures tree recombination but also simplifies the calculation of option sensitivities, as we explore in the next section.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#sec-s:binomial_greeks",
    "href": "Chapter_BinomialModel.html#sec-s:binomial_greeks",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.3 Binomial Greeks",
    "text": "14.3 Binomial Greeks\nTo estimate Greeks in any valuation model, one can run the valuation program twice, for two different parameter values, and then estimate the Greek as the difference in value divided by the difference in parameters. For example, to estimate vega when the volatility of the underlying is \\(\\sigma\\), we could estimate the derivative value for a volatility of \\(0.99\\sigma\\) and for a volatility of \\(1.01\\sigma\\). Denoting the former derivative value by \\(C_d\\) and the latter by \\(C_u\\), the vega can be estimated by \\[\\frac{C_u-C_d}{1.01\\sigma-0.99\\sigma} = \\frac{C_u-C_d}{0.02\\sigma}\\; .\\] We can in principle obtain a more precise estimate of the derivative by making a smaller change in the parameter (e.g., using \\(0.999\\sigma\\) and \\(1.001\\sigma\\)) but computer round-off errors limit how small a parameter change one should take in practice.\nTo estimate the gamma when the price of the underlying is \\(S\\), we need to estimate the derivative value at two other prices for the underlying, which we will call \\(S_u\\) and \\(S_d\\), with \\(S_u&gt;S&gt;S_d\\). As just explained, the estimate of the delta (which we continue to denote by \\(\\delta\\)) would be \\[\n\\delta = \\frac{C_u-C_d}{S_u-S_d}\\;,\n\\qquad(14.3)\\]\nwhere \\(C_u\\) denotes the derivative value when the underlying is equal to \\(S_u\\) and \\(C_d\\) denotes the derivative value when the underlying is equal to \\(S_d\\). Letting \\(C\\) denote the derivative value when the underlying is equal to \\(S\\), two other obvious estimates of the delta are \\[\\delta_u = \\frac{C_u-C}{S_u-S} \\qquad \\text{and} \\qquad \\delta_d = \\frac{C-C_d}{S-S_d}\\; .\\] The first of these should be understood as an estimate of the delta when the price of the underlying is at the midpoint of \\(S_u\\) and \\(S\\), and the second is an estimate of the delta when the price of the underlying is at the midpoint of \\(S_d\\) and \\(S\\). The distance between these midpoints is \\[\\frac{S_u+S}{2} - \\frac{S_d+S}{2} = \\frac{S_u-S_d}{2}\\; ,\\] so we obtain an estimate of \\(\\Gamma\\) (the derivative of \\(\\delta\\)) as \\[\n\\Gamma = \\frac{\\delta_u-\\delta_d}{(S_u-S_d)/2}\\;.\n\\qquad(14.4)\\]\nIn a binomial model, it is possible to compute the most important Greeks, delta and gamma, more efficiently than by simply running the valuation program several times. Assume we have taken \\(d=1/u\\), so after an up and a down move (or a down and an up move) the stock price returns to its initial value \\(S\\). After fixing the length \\(\\Delta t = T/N\\) of each time period, we redefine \\(N=N+2\\). This results in an \\(N+2\\) period tree covering a time period of length \\(T+2\\Delta t\\). Now consider the tree starting two periods from the initial date. At the middle node shown below, the stock price is \\(udS=S\\). Ignoring the top and bottom nodes and the branches that follow them, the result of adding two periods is that the tree starting from \\(udS\\) is an \\(N\\)–period tree for a time period of length \\(T\\).\n\nHence, the derivative price calculated at the middle node will be the price we are trying to estimate. The derivative price at the top node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(u^2S\\). Similarly, the derivative price at the bottom node will be the value of a derivative of maturity \\(T\\) when the initial price of the underlying is \\(d^2S\\). Thus, when we back up in the tree to this date, we will have all of the information we need to return an estimate of the derivative value and to return estimates of the delta and gamma, taking \\(S_u=u^2S\\) and \\(S_d = d^2S\\) in Equation 14.3 and Equation 14.4. We are not interested in the tree to the left of what is shown above.\n\nTrinomial Valuation of American Options\nThe trinomial model is a special case of an explicit finite difference method for solving partial differnetial equations; however, it requires no knowledge of partial differential equations. It is similar to a binomial model in that it is a tree. As the name suggests, the trinomial model has three branches up, down, and middle. The middle branch eliminates the up down behavior and can lead to smoother exercise boundaries. We will use the following parameterization: at each node the stock price grows by a factor \\(u=e^{\\sigma \\sqrt{3 \\Delta t}}\\), stays the same, or declines by a factor of \\(d=1/u\\). In this sense, it inherits some of the tractabilty of the Cox, Ross, and Rubenstein model in the sense that the stock price at all nodes can be expressed as the initial stock price times \\(u\\) to a power. The probabilities are given by\n\\[\np_u = \\frac{1}{6} + \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)~~~p_m =2/3~~p_d= \\frac{1}{6} - \\sqrt{\\frac{\\Delta t}{12 \\sigma^2}} \\left(r - \\frac{\\sigma^2}{2}\\right)\n\\]\nWhile there are many choices for the parameterization they are not completely arbitrary. The probability \\(p_m =2/3\\) roughly corresponds to plus or minus one standard devation of a normal distribution and the up and down probabilities capture the tails. There are other parameterizations which can work ust as well.\nConceptually, although there are three states and only two assets and the market is incomplete, the model converges to the Black Scholes model but there is no direct replication strategy. Nevertheless, we are modelling the price in a risk-neutral probability. More importantly it does potentially give a better estimate of derivative prices.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nvec = np.arange(2*n+1)\nvec1 = np.ones(2*n+1)\nS = S0 * u**(vec-n*vec1)\nAP = np.maximum(K-S,0)\nex = S[AP&gt;0]\n# eb is an array to save the boundary price\neb = np.zeros(n+1)\neb[n] = ex.max()\n# Backward recursion in the loop\nfor i in range(n):\n    vec = np.arange(2*(n-i-1)+1)\n    vec1 = np.ones(2*(n-i-1)+1)\n    # Possible Stock prices at times-i period\n    S = S0 * u**(vec-(n-i-1)*vec1)\n    # P calculates the value of early exercise\n    P = np.maximum(K - S, 0)\n    # PP calculates value of waiting using payoffs from next period\n    PP = (pu*AP[2:(2*(n-i)+1)] + pm*AP[1:(2*(n-i))] + pd*AP[0:(2*(n-i)-1)])/a\n    # AP is the max of ealry exercise and waiting\n    AP = np.maximum(P,PP)\n    # ex is prices where early exercise is optimal\n    ex = S[(AP-PP)&gt;0]\n    # eb calculates the highest price\n    # where exercise is optimal to plot boundary\n    if ex.shape[0]&gt;0:\n        eb[n-i] = ex.max()\n    else:\n        eb[n-i] = np.nan\nprint('The American put price is=', AP[0])\n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),eb)\n\n\nThe American put price is= 1.6396310315369165\n\n\n\n\n\n\n\n\n\nWe again provide a program which does the same calculation using loops. It is much slower. We use the same parametrs and preamble as before and just outline the steps. As in the binomial model, we start at the last date and build \\(2n+1\\) terminal stock prices. We also keep track of the highest stock price which we exercise.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n# parameters\n# number of steps\nn = 100\n# interest rate\nr = .1\n# volatility\nsig = .2\n# Initial Stock Price\nS0 = 42\n# Strike Price\nK = 42\n# Maturity\nT = 0.5\n\n# calculate parameters for trinomial model\ndt = T/n\na = np.exp(r*dt)\nu = np.exp(sig*np.sqrt(3*dt))\nd = 1/u\npu = 1/6 + np.sqrt(dt/(12*sig**2))*(r - sig**2/2)\npm = 2/3\npd = 1 - pu - pm\n# Build vector of ending values\n# and prices for which put is exercised\nex = np.zeros(n+1)\nS = np.zeros(2*n+1)\nAP = np.zeros(2*n+1)\n\nfor j in range(2*n+1):\n    S[j] = S0*u**(j-n)\n    AP[j] = max(K-S[j],0)\n    if AP[j]&gt;0:\n        ex[n] = S[j]\n\n\nWe then move backwards. There are two loops. The inner loop builds the stock price, the value, and exercise boundary at each time and the outer loop moves backwards in time.\n\n\nCode\nfor i in range(n):\n    S = np.zeros(2*(n-i-1)+1)\n    P = np.zeros(2*(n-i-1)+1)\n    PP = np.zeros(2*(n-i-1)+1)\n    for j in range(2*(n-i-1)+1):\n        S[j] = S0*u**(j-(n-i-1))\n        #\n        # P calculates the value of early exercise\n        P[j] = max(K-S[j],0)\n        #\n        # PP calculates value of waiting using payoffs\n        # from next period\n        PP[j] = (pu*AP[j+2] + pm*AP[j+1] + pd*AP[j])/a\n        #\n        # AP is the max of ealry exercise and waiting\n        AP[j] = max(P[j],PP[j])\n        #\n        # ex is price where early exercise is optimal\n        if P[j] &gt; PP[j]:\n            ex[n-i] = S[j]\n\nprint('The American put price is =', AP[0])            \n# plot the exercise boundary\nplt.figure(figsize=(10,7))\nplt.scatter(dt*np.arange(n+1),ex)            \n\n\nThe American put price is = 1.6396310315369165",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#accelerating-binomial-convergence",
    "href": "Chapter_BinomialModel.html#accelerating-binomial-convergence",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.4 Accelerating Binomial Convergence",
    "text": "14.4 Accelerating Binomial Convergence\nBroadie and Detemple (Broadie and Detemple 1997) show that a modified binomial model is a quite efficient way to value American put options. They modify the binomial model as follows: (i) the Black-Scholes formula is used to value the option at the penultimate date, and (ii) Richardson extrapolation is used to estimate what the option value would be with an infinite number of periods.\nIf an option is not exercised at date \\(N-1\\) in an \\(N\\)–period binomial model (i.e., one date from the end), then, because in the binomial model there are no further opportunities for early exercise, the American option at date \\(N-1\\) is equivalent to a European option at that date. The value of a European option is given by the Black-Scholes formula. Therefore, the estimate of the option value can be improved by replacing\nwith\nat date \\(N-1\\) (of course this also means that we do not need to compute the intrinsic value at date \\(N\\)). This idea can be effectively used in binomial valuation of any option for which there is a closed-form solution (like the Black-Scholes formula) for the value of the corresponding European option in a continuous-time model.\nBroadie and Detemple combine the use of the Black-Scholes formula at date \\(N-1\\) with Richardson extrapolation. Richardson extrapolation is a method that may improve the efficiency of any algorithm by extrapolating to the limit. In the case of a binomial model, the idea is to extrapolate the values calculated for different numbers of periods (different \\(N\\)**s) to try to estimate the value for \\(N=\\infty\\).\nIt is easier to work with convergence to zero than convergence to infinity, so define \\(x=1/N\\). For any value of \\(N\\), the binomial model will return a value, which is an estimate of the option value and which we denote as \\(y=f(x)\\). We would like to know the value at \\(N=\\infty\\), which in this notation is \\(f_0\\). Of course, we cannot calculate \\(f_0\\), because we do not know the function \\(f\\), but we can approximate \\(f\\) by a known function \\(g\\) and then estimate \\(f_0\\) by \\(g_0\\).\nA linear approximation is the simplest and is shown by Broadie and Detemple to be quite effective. For a linear approximation, we would take \\[g(x) = a + bx\\] for parameters \\(a\\) and \\(b\\) to be determined. We can input values \\(N_1\\) and \\(N_2 = 2N_1\\) for the number of periods, run the binomial model for each, set \\(x_i=1/N_i\\), and define \\(y_i=f(x_i)\\) to be the value of the option returned by the binomial model when the number of periods is \\(N_i\\). Then we force \\(g(x_i)=f(x_i)\\) for \\(i=1,2\\) by solving the equations \\[y_i=a + bx_i\\] for \\(a\\) and \\(b\\). Of course, \\(g_0 = a\\), so we will return the constant \\(a\\) as our estimate of \\(f_0\\). This is simpler than it may appear—we put \\[\\begin{equation*}\\begin{array}{rclcl}\ny_1 &= &a + bx_1 &= &a+2bx_2\\;,\\\\\ny_2 &= & &  & a + bx_2 \\;,\n\\end{array}\\end{equation*}\\] and subtracting gives us \\(y_1-y_2 = bx_2\\), which implies from the bottom equation that \\(a = 2y_2-y_1\\). We can think of \\(N_2\\) as being the number of periods we want to use in the binomial model, in which case \\(y_2\\) would be our estimate of the option value. Richardson extrapolation here means also running the binomial model for half as many periods (\\(N_1 = N_2/2\\)) and adding the difference of the estimates \\(y_2-y_1\\) to the estimate \\(y_2\\).\nRichardson extrapolation can be viewed as cancelling the first-order term in the Taylor series expansion of \\(f\\). We have \\[\\begin{align*}\ny_1 = f(x_1) &= f_0 + f**_0x_1 + \\text{higher order terms} \\\\\n& = f_0 + 2f**_0x_2 + \\text{higher order terms}\\;,\\\\\ny_2 = f(x_2) &= f_0 + f**_0x_2 + \\text{higher order terms}\\;.\n\\end{align*}\\] This implies \\[2y_2-y_1 = f_0 + \\text{difference of higher order terms}\\;.\\] Having eliminated the first-order term, one can hope to obtain a closer approximation to \\(f_0\\).\nWe now show hot to implement this in Pyhton.\nFirst we create a binomial valuation program that replaces (i) calculation of the intrinsic value at maturity and (ii) calculation of the value at the penultimate date as the larger of intrinsic value and the discounted value at maturity with (iii) calculation of the value at the penultimate date as the larger of intrinsic value and the Black-Scholes value of a European option with one period to maturity.\n\n\nCode\n# First define the Black-Scholes function needed for the acceleration method\ndef blackscholes(S0, K, r, q, sig, T, call=True):\n    \"\"\"Calculate option price using B-S formula.\"\"\"\n    from scipy import stats\n    import numpy as np\n    \n    d1 = (np.log(S0/K) + (r - q + sig**2/2) * T)/(sig*np.sqrt(T))\n    d2 = d1 - sig*np.sqrt(T)\n    norm = stats.norm\n    if call:\n        return np.exp(-q*T)*S0 * norm.cdf(d1,0,1) - K * np.exp(-r * T) * norm.cdf(d2,0, 1)\n    else:\n        return -np.exp(-q*T)*S0 * norm.cdf(-d1,0,1) + K * np.exp(-r * T) * norm.cdf(-d2,0, 1)\n\ndef binomialbd(n,r,sig,S0,y,K,T):\n\n    # parameters\n    # number of steps\n    #n \n    # interest rate\n    #r \n    # volatility\n    #sig \n    # Initial Stock Price\n    #S0\n    # Strike Price\n        #K \n    # Maturity\n    #T \n    # dividend yield\n    # y\n\n    # calculate parameters for binomial model\n    dt = T/n\n    delt = np.exp(-y*dt)\n    a = np.exp(r*dt) * delt\n    u = np.exp(sig*np.sqrt(dt))\n    d = 1/u\n    pu = (a-d)/(u-d)\n    pd = 1-pu\n    # Build vector of ending values\n    # \n    \n    S = np.zeros(n)\n    AP = np.zeros(n)\n    \n    # Build vector of ending values\n    # at the next to last date (penultimate date)\n    vec = np.arange(n)\n    vec1 = np.ones(n)\n\n    S = S0 * u**(2*vec - (n-1)*vec1)\n\n    AP = np.maximum(K-S,blackscholes(S, K, r, y, sig, dt, call = False))\n    \n    \n    # Backward recursion in the loop\n    for i in range(n-1):\n        vec = np.arange(n-i-1)\n        vec1 = np.ones(n-i-1)\n        # Possible Stock prices at times-i period\n        S = S0 * u**(2*vec-(n-i-1)*vec1+1)\n    \n    #     S = S0 * u**(2*vec-(n-i))\n        # P calculates the value of early exercise\n        P = np.maximum(K*vec1 - S, 0)\n        # PP calculates value of waiting using payoffs from next period\n        PP = (pu*AP[1:(n-i)] + pd*AP[0:(n-i-1)])/a\n        # AP is the max of ealry exercise and waiting\n        AP = np.maximum(P,PP)\n        \n\n    \n    \n    \n    return AP[0]          \n\n\nNow we create a program that uses Richardson extrapolation from a binomial model with N periods and a binomial model with N/2 periods to estimate the value from a binomial model with an infinite number of periods. We use the previous program as our binomial model. The number of time steps \\(n\\) must be even so \\(n/2\\) is an integer. In the following we initally use \\(n=20\\), which is smaller than the the number of steps in the previous binomial american option routines.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nfrom math import pow, exp, sqrt\n\n\n#inputs\n#number of steps= n; must be an even number\nn=20\n# interest rate\nr=.1\n# volatility\nsig=.2\n# initial stock price\nS0=42\n# dividend yield\ny=0\n# Strike price \nK=42\n# expiration\nT=0.5\n\nif 2*int(n/2) == n:\n\n    y2=binomialbd(n,r,sig,S0,y,K,T)\n    y1=binomialbd(int(n/2),r,sig,S0,y,K,T)\n    \n    extrapolate= 2*y2-y1\n    print('The extrapolated value=',extrapolate)\n\nelse:\n    print('n must be even you big dummy!!')   \n\n\nThe extrapolated value= 1.6495917266169138",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#sec-s:curse",
    "href": "Chapter_BinomialModel.html#sec-s:curse",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.5 Binomial Valuation of Basket and Spread Options",
    "text": "14.5 Binomial Valuation of Basket and Spread Options\n By combining binomial models, we can value options or other derivatives on multiple assets. We will illustrate for an option on two assets. This is the most important case, and the extension to more than two assets is straightforward.\nConsider two stocks with constant dividend yields \\(q_i\\) and constant volatilities \\(\\sigma_i\\). Suppose the two Brownian motions driving the two stocks have a constant correlation coefficient \\(\\rho\\). We will denote the price of stock \\(i\\) (\\(i=1,2\\)) in the up state in each period by \\(u_iS_i\\) and the price in the down state by \\(d_iS_i\\), where \\(S_i\\) is the price at the beginning of the period, and \\(u_i\\) and \\(d_i\\) are parameters to be specified. In each period, there are four possible combinations of returns on the two stocks: up for both stocks, up for stock 1 and down for stock~2, down for stock 1 and up for stock 2, and down for both stocks. Denote the probabilities of these four combinations by \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\) respectively. Thus, there are eight parameters in the binomial model: the number \\(N\\) of periods (which defines the length of each period as \\(\\Delta t=T/N\\) where \\(T\\) is the option maturity), the up and down parameters \\(u_i\\) and \\(d_i\\) for each stock, and three probabilities (the fourth probability being determined by the condition that the probabilities sum to one).\nGiven the period length \\(\\Delta t\\), we want to choose the up and down parameters and the probabilities to match (or approximately match in an appropriate sense) the means, variances and covariances of the returns \\(\\Delta S_i/S_i\\) or the continuously-compounded returns \\(\\Delta \\log S_i\\). There are two means, two variances and one covariance, so there are five restrictions to be satisfied and seven parameters. It is convenient to take \\(d_i = 1/u_i\\), leaving five restrictions and five free parameters.\nAs discussed in ?sec-s:binomialparameters, there are multiple ways to define the binomial model so that it converges to the continuous-time model as the number of periods is increased. As an example, we will describe here the suggestion of Trigeorgis (Trigeorgis 1991), which matches the means, variances and covariance of the continuously-compounded returns. Letting \\(p_i\\) denote the probability of the up state for stock \\(i\\), matching the means and variances implies, as in ?sec-s:binomialparameters, \\[\\begin{align*}\n\\log u_i&=\\sqrt{\\sigma_i^2\\Delta t + \\nu_i^2(\\Delta t)^2}\\; ,\\\\\np_i &= \\frac{1}{2}+\\frac{\\nu_i\\Delta t}{2\\log u_i}\\;.\n\\end{align*}\\] where \\(\\nu_i=r-q_i-\\sigma_i^2/2\\). In terms of the notation \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\), the probability of the up state for stock 1 is \\(p_1=p_{uu}+p_{ud}\\) and the probability of the up state for stock 2 is \\(p_2=p_{uu}+p_{du}\\). Therefore,\n\\[\np_{uu}+p_{ud} = \\frac{1}{2}+\\frac{\\nu_1\\Delta t}{2\\log u_1}\\;,\n\\qquad(14.5)\\]\n\\[\np_{uu}+p_{du} = \\frac{1}{2}+\\frac{\\nu_2\\Delta t}{2\\log u_2}\\;.\n\\qquad(14.6)\\]\nIn the continuous time model, over a discrete time period \\(\\Delta t\\), the covariance of \\(\\Delta \\log S_1\\) and \\(\\Delta \\log S_2\\) is \\(\\rho\\sigma_1\\sigma_2\\Delta t\\). In the binomial model, with \\(d_i=1/u_i\\), we have \\[\n\\mathbb{E} \\big[\\Delta \\log S_1 \\times \\Delta \\log S_2\\big] = (p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2\\;.\n\\] Given that \\(\\mathbb{E}[\\Delta\\log S_i] =\\nu_i\\Delta t\\), this implies a covariance of \\[\n(p_{uu}-p_{ud}-p_{du}+p_{dd})\\log u_1\\log u_2 - \\nu_1\\nu_2(\\Delta t)^2\\;.\n\\] Matching the covariance in the binomial model to the covariance in the continuous-time model therefore implies \\[\np_{uu}-p_{ud}-p_{du}+p_{dd} =\\frac{\\rho\\sigma_1\\sigma_2\\Delta t + \\nu_1\\nu_2(\\Delta t)^2}{\\log u_1\\log u_2}\\;.\n\\qquad(14.7)\\]\nWe can solve the system Equation 14.5 - Equation 14.7, together with the condition that the probabilities sum to one, to obtain the probabilities \\(p_{uu}\\), \\(p_{ud}\\), \\(p_{du}\\), and \\(p_{dd}\\). This solution and a Python function for valuing an American spread call option are given later. This function operates much like the binomial valuation of American options described earlier. The primary difference is that the value of the option at maturity depends on both stock prices, so we have to consider each possible combination of stock prices. In an \\(N\\)–period model, there are \\(N+1\\) nodes at the final date for each of the two stocks, and hence \\((N+1)^2\\) possible combinations of nodes. In fact, at each date \\(n\\) (\\(n=0,\\ldots,N\\)) there are \\((n+1)^2\\) combinations of nodes to be considered.\nThe computation time required for a spread call option is therefore roughly the square of the time required for a standard call.\nLikewise, in an \\(N\\)–period model for a basket option written on three assets, there are \\((n+1)^3\\) combinations of nodes to be considered at date \\(n\\); if there are five assets, there are \\((n+1)^5\\) combinations, etc. Thus, the computation time required increases exponentially with the number of assets. This can be a serious problem. For example, with five assets and \\(N=99\\), we would have \\(100^5\\) (10 billion) combinations. As this suggests, problems with multiple assets quickly become intractable in a binomial framework. This is called the curse of dimensionality.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#exercises",
    "href": "Chapter_BinomialModel.html#exercises",
    "title": "14  Binomial and Trinomial Models",
    "section": "14.6 Exercises",
    "text": "14.6 Exercises\n\nExercise 14.1 Consider an at-the-money European call option on a dividend-reinvested stock with six months to maturity. Take the initial stock price to be $50, the interest rate to be 5% and $=$30%. Compute the value in a binomial model with \\(N=10, 11, \\ldots, 20\\) and plot the values against \\(N\\). Plot your results. Is convergence monotone?\n\n\nExercise 14.2 Consider the same option as in the previous problem. Roughly what value of \\(N\\) is needed to get penny accuracy? (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)\n\n\nExercise 14.3 Repeat the two previous problems only instead of the Cox, Ross Rubenstein model, use the Jarrow Rudd model.\n\n\nExercise 14.4 The early exercise premium is the difference between the value of an American option and the value of a European option with the same parameters. Compute the early exercise premium for an American put and various values for the interest rate, exercise price, and stock parameters. Under what circumstances is the early exercise premium relatively large?\n\n\nExercise 14.5 A shout option is an option where the holder is entitled to shout at any time before the expiration of the option. Upon shouting, the holder receives the immediate exercise value paid at expiration, plus an at the money option with the same expiration as the original option. The payoff to this option if the holder shouts at time \\(\\tau\\) is thus given as \\(\\max(0, S(\\tau)-K, S_T-K )\\) where \\(K\\) is the original strike price.\n1) Show that it is better to shout at some time where \\(S(\\tau)&gt;K\\) than to never shout at all. 2) Modify the code for an American put to find the optimal exercise boundary for a shout option. Hint: The payoffs on the last nodes of the tree are simply \\((S_T - K)^+\\). Then work backwards. The `immediate exercise value’ which is the present value of \\(S_t-K\\), (\\(e^{-r(T-t)} (S_t -K)\\)) plus the Black Scholes value (use a python function) of an at the money option with expiration \\(T-t\\). Choose the maximum of these values at each node. For each time store the highest price at which you exersize. The first node (time 0) then gives the price. Plot the exercise boundary.\n\n\n\n\n\n\nBroadie, M., and J. Detemple. 1997. “American Option Valuation: New Bounds, Approximations, and a Comparison of Existing Methods.” Review of Financial Studies 9: 1211–50.\n\n\nTrigeorgis, A. 1991. “A Log-Transformed Binomial Analysis Method for Valuing Complex Multi-Option Investments.” Journal of Financial and Quantitative Analysis 26: 309–26.",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_BinomialModel.html#footnotes",
    "href": "Chapter_BinomialModel.html#footnotes",
    "title": "14  Binomial and Trinomial Models",
    "section": "",
    "text": "Notice that if we were to drop the \\((\\Delta t)^2\\) term in Equation 14.1 (which we could do because it becomes increasingly negligible as \\(\\Delta t \\rightarrow 0)\\), then Equation 14.1 would be the same as the Cox-Ross-Rubinstein up parameter \\(u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}\\). The different choices of \\(p\\) in the Cox-Ross-Rubinstein approach and Equation 14.2 can be understood as follows. The Cox-Ross-Rubinstein approach implies that the expected stock price \\(pS_u + (1-p)S_d\\) equals \\(\\mathrm{e}^{(r-q)\\Delta t}S\\), focusing on the expected return. The Trigeorgis method (Equation 14.2) implies that the expected log stock price \\(p \\,\\log S_u + (1-p) \\log S_d\\) equals \\(\\log S + \\mathrm{n}u \\Delta t\\), focusing on the expected continuously-compounded return.↩︎",
    "crumbs": [
      "Part 5: Numerical Methods",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Binomial and Trinomial Models</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixBinomial.html",
    "href": "Chapter_AppendixBinomial.html",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "",
    "text": "15.1 Basics of the Binomial Tree Model\nThe binomial tree model is a discrete-time framework used to price derivative securities. It is widely used in financial engineering for valuing options and other contingent claims. This model is particularly useful because it provides an intuitive approach to pricing and allows for easy incorporation of various features such as early exercise in American options.\nThe binomial tree model is based on the assumption that, over a small time step, the price of an underlying asset can move up or down by a certain factor. The model is constructed iteratively to estimate the fair value of derivatives such as options.\nAn \\(n\\) period binomial tree model can be described as follows:\n\\[\nS_{t+\\Delta t} = S_t \\times u_t \\quad \\text{(up move)}\n\\] or \\[\nS_{t+\\Delta t} = S_t \\times d_t \\quad \\text{(down move)}\n\\]\n\\[\np_t = \\frac{e^{r_t \\Delta t} - d_t}{u_t - d_t}\n\\]\nwhere $ r_t $ is the risk-free rate from \\(t\\) to \\(t+\\Delta t\\).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixBinomial.html#basics-of-the-binomial-tree-model",
    "href": "Chapter_AppendixBinomial.html#basics-of-the-binomial-tree-model",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "",
    "text": "There are \\(n+1\\) time points with \\(t=0, \\Delta t, 2 \\Delta t, ..., n\\Delta t\\), where \\(\\Delta t\\) is the time step.\nAt each time point \\(t\\), the price of the underlying asset either goes up by a factor \\(u_t&gt;1\\) with probability \\(p_t\\in(0,1)\\) or goes down by a factor \\(d_t&lt;1\\) with probability \\(1-p_t\\).\nGiven an initial stock price \\(S_0\\), the price of the underlying asset evolves as:\n\n\n\nThe absence of arbitrage ensures the model can be solved using risk-neutral valuation, where the risk-neutral probability of an up move is:\n\n\n\n\nExample: Three-Period Recombining Binomial Tree\nThis is an example of a three-period recombining binomial tree: \\(n=3\\), \\(u=1.1\\), \\(d=1/u\\), \\(\\Delta t=1\\):\n\n\nCode\nimport plotly.graph_objects as go\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1):\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t  # Time step on x-axis\n            y = 2 * j - t  # Centered y-axis positioning for symmetry\n            nodes[(x, y)] = round(S0 * (u ** j) * (d ** (t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = 2 * j - t\n            edges.append(((x, y), (x + 1, y + 1)))  # Up move\n            edges.append(((x, y), (x + 1, y - 1)))  # Down move\n\n    fig = go.Figure()\n\n    # Add edges to the plot\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        fig.add_trace(go.Scatter(x=x_coords, y=y_coords, mode='lines', line=dict(color='black'), showlegend=False))\n\n    # Add nodes to the plot\n    x_vals = [key[0] for key in nodes.keys()]\n    y_vals = [key[1] for key in nodes.keys()]\n    labels = [str(nodes[key]) for key in nodes.keys()]\n\n    fig.add_trace(go.Scatter(\n        x=x_vals, y=y_vals, mode='markers+text',\n        marker=dict(size=20, color='lightblue'),\n        text=labels, textposition=\"top center\",\n        showlegend=False\n    ))\n\n    fig.update_layout(\n        title=\"3-Period Symmetric Binomial Tree (u=1.1, d=1/u)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        plot_bgcolor='white',\n        width=700,\n        height=500\n    )\n\n    fig.show()\n\nplot_symmetric_binomial_tree()\n\n\n                                                \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\n\ndef plot_symmetric_binomial_tree(S0=100, u=1.1, vertical_scale=0.5, title_pad=20):\n    \"\"\"\n    Plots a 3-period symmetric binomial tree using Matplotlib,\n    with options to compress the vertical spacing and add space between the title and the plot.\n\n    :param S0: initial stock price\n    :param u: up factor\n    :param vertical_scale: compresses or expands the vertical spacing\n    :param title_pad: extra spacing between the title and the tree (in points)\n    \"\"\"\n    d = 1 / u  # Down factor\n    periods = 3  # Number of periods\n\n    # Define nodes with symmetric positioning\n    nodes = {}\n    for t in range(periods + 1):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)  # scale the vertical distance\n            nodes[(x, y)] = round(S0 * (u**j) * (d**(t - j)), 2)\n\n    # Define edges\n    edges = []\n    for t in range(periods):\n        for j in range(t + 1):\n            x = t\n            y = vertical_scale * (2 * j - t)\n            # Up move\n            edges.append(((x, y), (x + 1, y + vertical_scale)))\n            # Down move\n            edges.append(((x, y), (x + 1, y - vertical_scale)))\n\n    # Create a Matplotlib figure\n    fig, ax = plt.subplots(figsize=(7, 5))\n\n    # Plot edges\n    for edge in edges:\n        x_coords = [edge[0][0], edge[1][0]]\n        y_coords = [edge[0][1], edge[1][1]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes\n    x_vals = [k[0] for k in nodes.keys()]\n    y_vals = [k[1] for k in nodes.keys()]\n    labels = [str(nodes[k]) for k in nodes.keys()]\n    ax.scatter(x_vals, y_vals, s=300, color='lightblue')\n\n    # Add text labels above each node\n    for x, y, label in zip(x_vals, y_vals, labels):\n        ax.text(x, y + 0.3 * vertical_scale, label, ha='center', va='bottom')\n\n    # Title with extra spacing set by 'pad'\n    ax.set_title(\n        f\"3-Period Symmetric Binomial Tree (u={u}, d={round(d,2)})\",\n        pad=title_pad\n    )\n\n    # Style the plot\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n\n    plt.show()\n\n# Example usage: extra spacing of 20 points between the caption and the tree\nplot_symmetric_binomial_tree(vertical_scale=0.5, title_pad=20)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixBinomial.html#approximation-of-continuous-stochastic-processes",
    "href": "Chapter_AppendixBinomial.html#approximation-of-continuous-stochastic-processes",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "15.2 Approximation of Continuous Stochastic Processes",
    "text": "15.2 Approximation of Continuous Stochastic Processes\nA binomial tree is a discrete-time stochastic process with two possible outcomes at each time step. In its simplest form, at every step the process moves either up or down by a fixed factor or amount, with specified probabilities. This construction can be used to approximate almost any continuous stochastic processes. The main idea is as follows:\n\nDiscrete Steps:\nIn a binomial tree, time is divided into small increments (say, \\(\\Delta t\\)). At each time step, the process moves up by a factor \\(u\\) or down by a factor \\(d\\). This is analogous to a random walk where at each step you move one unit to the right or left.\nProbabilities and Expected Change:\nBy choosing the probabilities (say \\(p\\) for an up move and \\(1-p\\) for a down move) appropriately, you can control the drift and variance of the process. For a symmetric random walk, you might set \\(p = 0.5\\). More generally, one can adjust these parameters so that, over many steps, the binomial model matches the first two moments (mean and variance) of the random walk you want to approximate.\nConvergence to a Continuous Process:\nAs you make the time steps smaller (i.e., \\(\\Delta t \\to 0\\)) and choose \\(u\\) and \\(d\\) appropriately (for example, \\(u = e^{\\sigma\\sqrt{\\Delta t}}\\) and \\(d = e^{-\\sigma\\sqrt{\\Delta t}}\\) for volatility \\(\\sigma\\)), the binomial process converges in distribution to a continuous-time process, such as Brownian motion (or a geometric Brownian motion if you’re modeling stock prices).\nExample:\nSuppose you have a simple random walk starting at 0. At each time step:\n\nWith probability \\(0.5\\), add 1 (up move).\nWith probability \\(0.5\\), subtract 1 (down move).\n\nThis is a binomial tree where the position after \\(n\\) steps is given by: \\[\nX_n = X_0 + (\\text{number of up moves}) - (\\text{number of down moves}).\n\\] As \\(n\\) grows, by the Central Limit Theorem, the distribution of \\(X_n\\) becomes approximately normal, just like a random walk with Gaussian increments.\nApplication in Finance:\nIn financial modeling, the binomial tree is used to approximate the price evolution of an asset. The tree method provides a simple numerical technique to value options and other derivatives by stepping through the possible future asset prices and then discounting back to the present.\n\nIn summary, the binomial tree model can approximate a continuous stochastic process by discretizing time into small intervals with two possible outcomes at each step. With the right choice of parameters and as the step size decreases, the binomial process can approximate well the behavior of the continuous stochastic process, while keeping the numerical valuation of simple.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixBinomial.html#a-generalized-n-period-tree",
    "href": "Chapter_AppendixBinomial.html#a-generalized-n-period-tree",
    "title": "15  Introduction to Binomial Tree Model",
    "section": "15.3 A Generalized \\(n\\)-Period Tree",
    "text": "15.3 A Generalized \\(n\\)-Period Tree\nWe can generalize the above basic binomial tree to a more general one where each node at any time \\(t\\) can have a variable number of branches and the branching pattern can vary across both time steps and nodes. This flexible structure can be useful for pricing more complex derivative securities.\n\nDefinition of a Generalized \\(n\\)-period tree\n\n\n1. Tree Structure\nWe define the tree as a directed graph \\(T = (N, E)\\), where:\n\n\\(N\\) is the set of nodes.\n\\(E \\subseteq N \\times N\\) is the set of edges, representing transitions between nodes across periods.\n\nEach node is indexed by:\n\\[\nN_{t,i}, \\quad t = 0, 1, \\dots, n, \\quad i = 1, \\dots, |N_t|\n\\]\nwhere:\n\n\\(t\\) represents the time point,\n\\(i\\) represents the node index at time \\(t\\),\n\\(|N_t|\\) denotes the number of nodes at time \\(t\\).\n\n\n\n\n2. Variable Branching\nEach node \\(N_{t,i}\\) has \\(B_{t,i}\\) branches, which represents the number of children (next-period nodes) it connects to. The total number of nodes at time \\(t+1\\) is then:\n\\[\n|N_{t+1}| = \\sum_{i=1}^{|N_t|} B_{t,i}\n\\]\nEach edge represents a transition probability \\(P_{t,i,j}\\) from node \\(N_{t,i}\\) at time \\(t\\) to node \\(N_{t+1, j}\\) at time \\(t+1\\), satisfying:\n\\[\n\\sum_{j=1}^{B_{t,i}} P_{t,i,j} = 1, \\quad \\forall i, t\n\\]\nwhere \\(P_{t,i,j}\\) is the probability of transitioning from \\(N_{t,i}\\) to \\(N_{t+1,j}\\).\n\n\n\n3. Node Values and Transition Rule\nEach node has a value \\(S_{t,i}\\), which can represent an evolving variable (e.g., stock price, state variable). The value transition function is defined as:\n\\[\nS_{t+1,j} = f(S_{t,i}, a_{t,i,j})\n\\]\nwhere:\n\n\\(S_{t,i}\\) is the value at node \\(N_{t,i}\\),\n\\(a_{t,i,j}\\) is a transition factor specific to the branch from \\(N_{t,i}\\) to \\(N_{t+1,j}\\),\n\\(f\\) is a value update function, often modeled as: \\[\nS_{t+1,j} = S_{t,i} \\times a_{t,i,j}\n\\]\n\nExample: Consider a 3-period tree with variable branching:\n\nPeriod 0: 1 node (\\(B_{0,1} = 2\\))\nPeriod 1: 2 nodes, each with different branching (\\(B_{1,1} = 3, B_{1,2} = 2\\))\nPeriod 2: 5 nodes, each branching further (\\(B_{2,1} = 2, B_{2,2} = 2, B_{2,3} = 1, B_{2,4} = 3, B_{2,5} = 2\\)).\n\nThe node count evolves as:\n\\[\n|N_1| = B_{0,1} = 2, \\quad\n|N_2| = B_{1,1} + B_{1,2} = 3 + 2 = 5, \\quad\n|N_3| = 2 + 2 + 1 + 3 + 2 = 10\n\\]\nThus, a generalized tree dynamically adjusts the branching structure.\nSpecial Cases\n\nBinomial Tree (\\(B_{t,i} = 2\\)): Each node has exactly two branches, leading to an up/down model.\nTrinomial Tree (\\(B_{t,i} = 3\\)): Each node has three possible transitions (e.g., up, middle, down).\nAdaptive Trees: \\(B_{t,i}\\) can depend on volatility or other dynamic parameters.\n\n\n\nA Graphical Illustration of a Generalized 3-Period Tree\nHere is a 3-period example with variable branching:\n\n\nCode\nimport plotly.graph_objects as go\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_symmetric():\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # next_index[t] tracks how many nodes have been created at period t so far\n    next_index = defaultdict(int)\n    next_index[0] = 1  # We have 1 node at t=0\n\n    # transitions[(t, i)] = list of factors for each branch out of node (t, i)\n    transitions = {\n        (0, 0): [1.1, 0.9],       # At t=0, i=0 =&gt; 2 branches\n        (1, 0): [1.2, 1.0, 0.8],  # At t=1, i=0 =&gt; 3 branches\n        (1, 1): [1.1, 0.85],      # At t=1, i=1 =&gt; 2 branches\n        (2, 0): [1.3, 0.9],       # At t=2, i=0 =&gt; 2 branches\n        (2, 1): [1.2, 1.0],       # At t=2, i=1 =&gt; 2 branches\n        (2, 2): [1.1],            # At t=2, i=2 =&gt; 1 branch\n        (2, 3): [1.15, 0.95, 0.85], # t=2, i=3 =&gt; 3 branches\n        (2, 4): [1.1, 0.9]        # t=2, i=4 =&gt; 2 branches\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_value = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_value = round(base_value * factor, 2)\n            nodes[(child_t, child_i)] = child_value\n\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Count how many nodes per period =&gt; assign symmetrical y-coordinates\n    nodes_in_period = defaultdict(list)\n    for (t, i), val in nodes.items():\n        nodes_in_period[t].append(i)\n\n    # For each period t, sort node indexes, then map them to symmetrical positions around 0\n    coords = {}  # coords[(t, i)] = y_position\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n\n        # We'll assign positions from 0..(count-1), then shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            # E.g., if count=5, positions -&gt; 0,1,2,3,4 =&gt; shift by -2 =&gt; -2,-1,0,1,2\n            shift = -(count - 1) / 2\n            y = idx + shift\n            coords[(t, node_i)] = y\n\n    # 3. Build the plot\n    fig = go.Figure()\n\n    # Add edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1, t2]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        fig.add_trace(go.Scatter(\n            x=x_coords,\n            y=y_coords,\n            mode='lines',\n            line=dict(color='black'),\n            showlegend=False\n        ))\n\n    # Add nodes (markers+text)\n    for (t, i), val in nodes.items():\n        fig.add_trace(go.Scatter(\n            x=[t],\n            y=[coords[(t, i)]],\n            mode='markers+text',\n            marker=dict(size=10, color='blue'),\n            text=[str(val)],\n            textposition='top center',\n            showlegend=False\n        ))\n\n    fig.update_layout(\n        title=\"3-Period Variable Branching Tree (Symmetric Layout)\",\n        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n        width=900,\n        height=600,\n        plot_bgcolor='white'\n    )\n\n    fig.show()\n\n# Call the plotting function\nplot_variable_branching_tree_symmetric()\n\n\n                                                \n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom collections import defaultdict\n\ndef plot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0):\n    \"\"\"\n    Plots a 3-period variable branching tree in a narrower vertical \n    layout and a longer horizontal layout.\n\n    :param vertical_scale: Factor (&lt;1 = narrower, &gt;1 = taller) for vertical spacing\n    :param horizontal_scale: Factor (&gt;1 = longer, &lt;1 = shorter) for horizontal spacing\n    \"\"\"\n    # 1. Build tree nodes/edges\n    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 =&gt; value=100\n    edges = []\n\n    # Track how many nodes created at each period t\n    next_index = defaultdict(int)\n    next_index[0] = 1\n\n    # transitions: dict[(t, i)] -&gt; list of factors from node (t,i)\n    transitions = {\n        (0, 0): [1.1, 0.9],\n        (1, 0): [1.2, 1.0, 0.8],\n        (1, 1): [1.1, 0.85],\n        (2, 0): [1.3, 0.9],\n        (2, 1): [1.2, 1.0],\n        (2, 2): [1.1],\n        (2, 3): [1.15, 0.95, 0.85],\n        (2, 4): [1.1, 0.9]\n    }\n\n    # Create nodes/edges\n    for (t, i), factors in transitions.items():\n        base_val = nodes[(t, i)]\n        for factor in factors:\n            child_t = t + 1\n            child_i = next_index[child_t]\n            next_index[child_t] += 1\n\n            child_val = round(base_val * factor, 2)\n            nodes[(child_t, child_i)] = child_val\n            edges.append(((t, i), (child_t, child_i)))\n\n    # 2. Assign symmetrical y-coords for each period\n    nodes_in_period = defaultdict(list)\n    for (t, i) in nodes.keys():\n        nodes_in_period[t].append(i)\n\n    coords = {}\n    for t in sorted(nodes_in_period.keys()):\n        node_list = sorted(nodes_in_period[t])\n        count = len(node_list)\n        # positions =&gt; 0..(count-1), shift so center is 0\n        for idx, node_i in enumerate(node_list):\n            shift = -(count - 1) / 2\n            y = (idx + shift) * vertical_scale\n            coords[(t, node_i)] = y\n\n    # 3. Build the Matplotlib figure\n    fig, ax = plt.subplots(figsize=(12, 4))  # Wider figure\n\n    # Plot edges\n    for ((t1, i1), (t2, i2)) in edges:\n        x_coords = [t1 * horizontal_scale, t2 * horizontal_scale]\n        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n        ax.plot(x_coords, y_coords, color='black')\n\n    # Plot nodes + text\n    for (t, i), val in nodes.items():\n        x_ = t * horizontal_scale\n        y_ = coords[(t, i)]\n        ax.scatter(x_, y_, s=100, color='blue')\n        ax.text(x_, y_ + 0.2 * vertical_scale, str(val),\n                ha='center', va='bottom')\n\n    ax.set_title(\"3-Period Variable Branching Tree (Scaled)\")\n    ax.axis(\"equal\")\n    ax.axis(\"off\")\n    plt.show()\n\n# Example usage: narrower by vertical_scale=0.5, longer by horizontal_scale=2.0\nplot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introduction to Binomial Tree Model</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixMonteCarlo.html",
    "href": "Chapter_AppendixMonteCarlo.html",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "",
    "text": "16.1 History and Applications of Monte Carlo Simulations\nMonte Carlo simulations are a class of computational algorithms that use repeated random sampling to obtain numerical results. Random number generation by a computer typically relies on deterministic algorithms, known as pseudo-random number generators (PRNGs), which produce a sequence of values that only appear random. These algorithms start from an initial seed and repeatedly transform it with a mathematical function to produce a new number each time. Although true randomness cannot be achieved purely with deterministic code, PRNGs are sufficient for many applications such as simulations and gaming. In cases where a higher degree of randomness is required—for example, in cryptography—computers gather real-world data (e.g., from hardware noise) to generate true random numbers, which do not follow a purely deterministic pattern.\nMonte Carlo methods are widely used in fields such as finance, engineering, physics, and risk management to solve complex problems that involve stochastic elements and are too difficult or inefficient to solve analytically or by other numrical methods. They are particularly useful when solving problems that involve: - High-dimensional spaces. - Uncertainty and randomness. - Complex integrations or optimizations that are difficult to solve analytically.\nBy simulating a large number of possible outcomes, Monte Carlo methods provide an approximation to a solution that is often more practical than attempting to derive an exact answer.\nMonte Carlo methods were first developed during the 1940s by scientists working on nuclear weapons research, including John von Neumann and Stanislaw Ulam. The name “Monte Carlo” was inspired by the famous casino in Monaco, reflecting the method’s reliance on randomness and probability.\nMonte Carlo simulations have since been applied in various domains:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixMonteCarlo.html#history-and-applications-of-monte-carlo-simulations",
    "href": "Chapter_AppendixMonteCarlo.html#history-and-applications-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "",
    "text": "Finance: Option pricing, portfolio risk management, and credit risk modeling.\nPhysics and Engineering: Particle simulations, fluid dynamics, and reliability analysis.\nHealthcare and Epidemiology: Disease spread modeling and risk assessment.\nBusiness and Economics: Decision-making under uncertainty, supply chain risk management.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixMonteCarlo.html#principle-of-monte-carlo-simulations",
    "href": "Chapter_AppendixMonteCarlo.html#principle-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.2 Principle of Monte Carlo Simulations",
    "text": "16.2 Principle of Monte Carlo Simulations\nThe principle of Monte Carlo simulations is based on the concept of using randomness to approximate deterministic problems. The core idea is to use random sampling to generate a large number of possible scenarios, analyze the outcomes, and estimate probabilities or expected values. This method is particularly useful when dealing with systems that have inherent uncertainty or when an exact analytical solution is difficult to obtain.\nSteps Involved in a Monte Carlo Simulation:\n\nDefine the Problem: Identify the mathematical or physical system being modeled.\nGenerate Random Inputs: Use random number generators to create sample inputs that represent possible states of the system.\nPerform Simulations: Compute the outcome for each randomly generated input using a defined model.\nAggregate Results: Analyze the distribution of outcomes to derive probabilities, expected values, or other statistical measures.\nInterpret and Apply Findings: Use the insights obtained to make informed decisions or refine the model.\n\nExample Illustration:\nIf we want to estimate the probability of a financial portfolio achieving a certain return, we can: - Generate random market conditions (e.g., stock prices, interest rates). - Compute portfolio returns under each condition. - Analyze the distribution of simulated returns to assess risk and return characteristics.\nMonte Carlo methods leverage the Law of Large Numbers, which states that as the number of simulations increases, the estimate converges to the true expected value.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixMonteCarlo.html#implementing-monte-carlo-simulations-in-python",
    "href": "Chapter_AppendixMonteCarlo.html#implementing-monte-carlo-simulations-in-python",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.3 Implementing Monte Carlo Simulations in Python",
    "text": "16.3 Implementing Monte Carlo Simulations in Python\nPython provides several libraries to implement Monte Carlo simulations effectively, including numpy, scipy, and matplotlib. Below, we demonstrate multiple examples of Monte Carlo simulations.\nEstimating π using Monte Carlo Simulation\nA classic example of Monte Carlo methods is estimating the value of π by simulating random points inside a unit square and counting how many fall inside a quarter circle.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_pi(num_samples):\n    \"\"\"\n    Estimate the value of π using the Monte Carlo method.\n    \n    - Generates `num_samples` random points inside a square [-1,1] x [-1,1].\n    - Determines how many points fall inside the unit circle.\n    - Uses the ratio of points inside the circle to estimate π.\n    - Visualizes the simulation with a scatter plot.\n    \"\"\"\n    # Generate random points\n    x = np.random.uniform(-1, 1, num_samples)\n    y = np.random.uniform(-1, 1, num_samples)\n\n    # Check if points are inside the unit circle\n    inside_circle = x**2 + y**2 &lt;= 1\n\n    # Estimate π\n    pi_estimate = (inside_circle.sum() / num_samples) * 4\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=(6,6))\n\n    # Plot points\n    ax.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label=\"Inside Circle\")\n    ax.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label=\"Outside Circle\")\n\n    # Draw square boundary\n    square_x = [-1, 1, 1, -1, -1]\n    square_y = [-1, -1, 1, 1, -1]\n    ax.plot(square_x, square_y, color='black', linewidth=2, label=\"Square Boundary\")\n\n    # Draw circle boundary\n    circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=2, label=\"Unit Circle\")\n    ax.add_patch(circle)\n\n    # Set limits and labels\n    ax.set_xlim(-1.1, 1.1)\n    ax.set_ylim(-1.1, 1.1)\n    ax.set_aspect('equal')\n    ax.legend()\n    ax.set_title(f\"Monte Carlo Estimation of π: {pi_estimate:.4f}\")\n\n    # Show plot\n    plt.show()\n\n    \n\n# Run simulation\nmonte_carlo_pi(10000)\n\n\n\n\n\n\n\n\n\nMonte Carlo Simulation for Portfolio Returns\nMonte Carlo simulations can be used to estimate the expected return of an investment portfolio over time.\nAssumptions in this simulation:\n\nLog-normal distribution of returns: Asset returns follow a normal distribution when compounded over time.\nIndependence of daily returns: Returns are randomly sampled from the normal distribution and do not exhibit autocorrelation.\nConstant mean and volatility: The expected return (mean) and volatility (standard deviation) are assumed to remain constant over the time horizon.\nNo external shocks: The model does not account for external factors like market crashes, policy changes, or economic shifts.\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_portfolio_returns(initial_investment=100000, num_simulations=10000, time_horizon=252, mu=0.07, sigma=0.2):\n    np.random.seed(42)  # For reproducibility\n    simulated_returns = np.random.normal(mu / time_horizon, sigma / np.sqrt(time_horizon), (num_simulations, time_horizon))\n    portfolio_values = initial_investment * np.cumprod(1 + simulated_returns, axis=1)\n    expected_return = np.mean(portfolio_values[:, -1])\n    \n    plt.figure(figsize=(10,6))\n    plt.plot(portfolio_values.T, alpha=0.1, color='blue')\n    plt.title('Monte Carlo Simulation of Portfolio Returns')\n    plt.xlabel('Trading Days')\n    plt.ylabel('Portfolio Value')\n    plt.show()\n    \n    return expected_return\n\nexpected_return = monte_carlo_portfolio_returns()\nprint(f'Expected Portfolio Value after One Year: ${expected_return:.2f}')\n\n\n\n\n\n\n\n\n\nExpected Portfolio Value after One Year: $107047.67",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  },
  {
    "objectID": "Chapter_AppendixMonteCarlo.html#advantages-and-limitations-of-monte-carlo-simulations",
    "href": "Chapter_AppendixMonteCarlo.html#advantages-and-limitations-of-monte-carlo-simulations",
    "title": "16  Introduction to Monte Carlo Simulations",
    "section": "16.4 Advantages and Limitations of Monte Carlo Simulations",
    "text": "16.4 Advantages and Limitations of Monte Carlo Simulations\nAdvantages - Versatility: Can be applied to a wide range of problems in different fields. - Scalability: Can handle complex and high-dimensional problems that are difficult to solve analytically. - Flexibility: Works well with stochastic processes and probabilistic modeling.\nLimitations - Computationally Expensive: Requires large numbers of simulations for accurate results. - Dependent on Randomness: The accuracy of results improves with more iterations, but random variability exists. - Model Sensitivity: Results can be sensitive to the assumptions and distributions used in the simulation.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Introduction to Monte Carlo Simulations</span>"
    ]
  }
]