{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Using Fourier Transforms to Price Options {#sec-c_fouriertrasform}\n",
        "\n",
        "## Introduction\n",
        "\n",
        "The Fourier Transform has become an essential tool in option pricing, particularly for complex models like those with stochastic volatility and Lévy processes including variance gamma and jump diffusion processes. In this chapter, we will explore how the Fourier Transform simplifies the pricing of derivative securities, examine its advantages, and provide analytical examples and Python code for practical illustration.\n",
        "\n",
        "\n",
        "The key reason for using Fourier Transforms in option pricing is that they allow us to solve pricing problems more efficiently in the frequency domain rather than the time domain. Specifically, Fourier methods:\n",
        "\n",
        "1. **Handle Non-Gaussian Processes**: Many real-world asset price models involve jumps or stochastic volatility, which may lead to non-Gaussian distributions of returns. Fourier Transforms allow us to handle these models efficiently.\n",
        "2. **Use Characteristic Functions**: The Fourier Transform is closely related to the characteristic function of the underlying asset price. Many stochastic processes have closed-form characteristic functions without explicit distribution functions. Using the closed-form characteristic functions simplifies the integration required in risk-neutral valuation.\n",
        "3. **Conduct Fast Numerical Computation**: By leveraging Fast Fourier Transform (FFT) algorithms, we can calculate option prices for a wide range of strikes and maturities quickly.\n",
        "4. **Simplify Complex Problems**: Many option pricing models lead to complex partial differential equations (PDEs). The Fourier Transform helps transform these PDEs into simpler algebraic equations.\n",
        "\n",
        "In this chapter, we'll focus on the first three and demonstrate these advantages through theory, examples, and Python code.\n",
        "\n",
        "## Section 1: Theoretical Foundation\n",
        "\n",
        "The Fourier transform of a function $f(x)$, denoted as $\\hat{f}(u)$, is given by:\n",
        "\n",
        "$$\n",
        "\\hat{f}(u) = \\int_{-\\infty}^{\\infty} e^{-iux} f(x) \\, dx,\n",
        "$$\n",
        "where $i=\\sqrt{-1}$ and $u$ is termed ``frequency.''\n",
        "\n",
        "\n",
        "In the context of option pricing using the **Fourier Transform**, our goal is to transform option payoff into the frequency domain (via the Fourier transform), which allows for efficient option pricing using techniques like the **Fast Fourier Transform (FFT)**.\n",
        "\n",
        "To apply the Fourier transform, we often work with the **logarithm of the asset price**, $X_T = \\ln(S_T)$, instead of the asset price $S_T$ directly. This is done because log-prices simplify the structure of the characteristic function (which is essential in the Fourier method). The payoff of a European call with strike price $K$ at maturity $T$ becomes:\n",
        "\n",
        "$$\n",
        "C(X_T) = \\max(e^{X_T} - K, 0)\n",
        "$$\n",
        "\n",
        "We now take the Fourier transform of this function with respect to $x = X_T$ (the log-price), leading to the formula for $\\hat{C}(u)$, which is:\n",
        "\n",
        "$$\n",
        "\\hat{C}(u) = \\int_{-\\infty}^{\\infty} e^{-iux} \\max(e^x - K, 0) \\, dx\n",
        "$$\n",
        "\n",
        "To compute this transform explicitly, we split the payoff function into two regions:\n",
        "- When $x < \\ln(K)$, the payoff is zero because $S_T < K$.\n",
        "- When $x \\geq \\ln(K)$, the payoff is $e^x - K$ because $S_T \\geq K$.\n",
        "\n",
        "Thus, the integral for $\\hat{C}(u)$ becomes:\n",
        "\n",
        "$$\n",
        "\\hat{C}(u) = \\int_{\\ln(K)}^{\\infty} e^{-iux} (e^x - K) \\, dx\n",
        "$$\n",
        "\n",
        "This integral can be computed analytically and results in a closed-form expression for $\\hat{C}(u)$. The final result is:\n",
        "\n",
        "$$\n",
        "\\hat{C}(u) = \\frac{K^{1 - iu}}{iu(1 + iu)}\n",
        "$$\n",
        "\n",
        "In essence, $\\hat{C}(u)$ is the representation of the call option’s payoff in the **frequency domain**. It captures how different frequencies (or Fourier modes) contribute to the option price. Once the Fourier transform is applied to the payoff function, this $\\hat{C}(u)$ can be combined with the **characteristic function** of the underlying asset's price process to calculate the option price.\n",
        "\n",
        "The characteristic function $\\phi_{X}(u)$ of a random variable $X$ is defined as:\n",
        "\n",
        "$$\n",
        "\\phi_{X}(u) = \\mathbb{E}[e^{i u X}].\n",
        "$$\n",
        "The characteristic function uniquely defines the probability distribution of $X$ and can be used to recover the density function via the inverse Fourier Transform.\n",
        "\n",
        "\n",
        "\n",
        "The final step in the pricing process involves integrating the product of $\\hat{C}(u)$ and the characteristic function of the log-returns of the asset (under the risk-neutral measure) to recover the option price in the original domain (time or price space).\n",
        "\n",
        "Once $\\hat{C}(u)$ is computed, the price of the option can be calculated using the **Fourier inversion formula**. The general formula for the call option price $C(K)$ at time $0$  is:\n",
        "\n",
        "$$\n",
        "C(K) = \\frac{e^{-rT}}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-iuk} \\hat{C}(u) \\phi_X(u) \\, du,\n",
        "$${#eq-FTpricing}\n",
        "where $\\phi_X(u)$ is the **characteristic function** of the log-price process at time $T$, $k = \\ln(K)$ is the log-strike, and $\\hat{C}(u)$ is the Fourier transform of the payoff function.\n",
        "\n",
        "By evaluating this integral (typically done numerically), we recover the option price. This illustrate the main idea behind the appilcation of Fourier transform in pricing options. \n",
        "\n",
        "\n",
        "Unfortunately, the Fast Fourier Transform  (FFT) cannot be used to evaluate the pricing integral @eq-FTpricing, since the integrand is singular at the required evaluation point $u = 0$. Given the considerable speed advantages of the FFT, we introduce the Carr-Madan method [@CarrMadan] that can leverage the efficiency of  the FFT.\n",
        "\n",
        "## The Carr-Madan Method\n",
        "\n",
        "The key idea behind the Carr-Madan Method is to express the option price as an integral in Fourier space and then discretize it for the FFT numerical evaluation.\n",
        "\n",
        "\n",
        "### Step 1: Modify the Payoff Function\n",
        "\n",
        "Let $k$ denote the log of the strike price $K$, and let $C(k)$ be the desired value of a $T$-maturity call option with strike exp(k). Let the risk-neutral density of the $s=\\ln(S)$ be $q(s)$. The initial call value $C(k)$ is related to the risk-neutral density $q(s)$ by \n",
        "\n",
        "$$\n",
        "C(k) = \\int_{k}^\\infty e^{-r T} (e^s-e^k) q(s)\\, ds.\n",
        "$$\n",
        "\n",
        "Because $C(k)$ approaches $S_0$ as $k$ tends to $-\\infty$, the call pricing function of $k$ is not square integrable. To ensure the square integrability of the Fourier Transform, we first modify the option's payoff function by introducing a dampening factor $\\alpha > 0$:\n",
        "\n",
        "$$\n",
        "\\tilde{C}(k) = e^{\\alpha k} C(k).\n",
        "$$\n",
        "This modification ensures that the transformed function decays sufficiently fast at infinity.\n",
        "\n",
        "### Step 2: Express the Modified Price as an Integral\n",
        "\n",
        "By the fourier inversion theorem, the modified call price can be written as:\n",
        "\n",
        "$$\n",
        "C(k) = \\frac{e^{-\\alpha k}}{2\\pi} \\int_{-\\infty}^\\infty e^{-i u k} \\phi_{C}(u)\\, du = \\frac{e^{-\\alpha k}}{\\pi} \\int_{0}^\\infty e^{-i u k} \\phi_{C}(u)\\, du,\n",
        "$$ {#eq-carrmadan}\n",
        "where $\\phi_{C}(u)$ is the Fourier Transform of the option $C(k)$ and the second equality follows because $\\phi_{C}(u)$ is odd in its imaginary part and even in its real part.\n",
        "\n",
        "### Step 3: Derive the Fourier Transform of the Payoff\n",
        "\n",
        "The Fourier Transform $\\phi_{C}(u)$ is given by:\n",
        "\n",
        "$$\n",
        "\\phi_{C}(u) = \\int_{-\\infty}^\\infty e^{i u k} e^{\\alpha k}e^{-r T} (e^{s} - e^{k})^+q(s) \\, ds.\n",
        "$$\n",
        "\n",
        "By simplifying and rearranging terms, we obtain:\n",
        "\n",
        "$$\n",
        "\\phi_{C}(u) = \\frac{e^{-rT}\\phi_{S}(u - i (\\alpha + 1))}{(\\alpha + i u)(\\alpha + i u + 1)},\n",
        "$$ \n",
        "where $\\phi_{S}(u)$ is the characteristic function of $\\ln S$.\n",
        "\n",
        "### Step 4: Discretize the Integral for FFT\n",
        "\n",
        "The FFT is an efficient algorithm for computing the sum\n",
        "$$\n",
        "g(m)=\\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N}(j-1) (m-1)\\right)y(j), m=1,...,N,\n",
        "$$\n",
        "where $N$ is typically a power of 2 and $y(\\cdot)$ is some given function. The algorithm reduces the number of\n",
        "multiplications in the required $N$ summations from an order of $N^2$ to that of\n",
        "$N \\log_2(N)$, a very significant reduction. We present in this section the details for writing the integration (5) as an application of the summation (16). To improve the accuracy of the approximation, we can combine it with the Simpson's rule. \n",
        "\n",
        "**Simpson's Rule:** We divide the integration interval $[a, b]$ into $N$ subintervals, where $N$ is an even number. Let $h = \\frac{b - a}{N}$ be the width of each subinterval. The function $f(x)$ is evaluated at equally spaced points $x_1, x_2, x_3, \\dots, x_{N+1}$, where $x_j = a+(j-1) h$.\n",
        "\n",
        "The Simpson's Rule formula is:\n",
        "$$\n",
        "\\int_a^b f(x) \\, dx \\approx \\frac{h}{3} \\left[ f(x_1) + 4 \\sum_{j=2,4,6,\\dots}^{N-1} f(x_j) + 2 \\sum_{j=1,3,5,\\dots}^{N-2} f(x_j) + f(x_{N+1}) \\right].\n",
        "$$\n",
        "Combinig the FFT with the Simpson's rule, we have \n",
        "$$\n",
        "g(m)=\\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N}(j-1) (m-1)\\right)y(j)w(j), m=1,...,N,\n",
        "$${#eq-FFTSimpson}\n",
        "where $w(j)=4$ if $j$ is even, $w(j)=2$ if $j$ is odd, and $w(1)=w(N+1)=1$.^[NOte that because for FFT to work efficiently, we need $N$ to be even, but for the Simpson's rule, we need even number of **subintervals**, i.e., $N$ to be odd. In practice, we choose $N$ to be even and ignore the last point evaluation for the Simpson's weight $w(N+1)$. When the spacing interval is small, the error from this omission is small.]\n",
        "\n",
        "\n",
        "To apply the FFT @eq-FFTSimpson, we discretize the integral @eq-carrmadan over $u$:\n",
        "\n",
        "- Define $u_j = \\eta (j-1)$, where $\\eta$ is the spacing between points and $j = 1, 2, \\dots, N $.\n",
        "- Similarly, define $k_m = -b + \\lambda \\, (m-1)$, where \n",
        "$$\n",
        "\\lambda = \\frac{2\\pi}{N \\eta}\n",
        "$$ \n",
        "is the spacing in log-strike space,\n",
        "$$\n",
        "b=\\frac{N \\lambda}{2} \n",
        "$$\n",
        "is the integration upper limit of $k$, and $m = 1, 2,  \\dots, N$.\n",
        "\n",
        "The integral @eq-carrmadan becomes a sum:\n",
        "\n",
        "$$\n",
        "\\tilde{C}(k_m) \\approx \\frac{e^{-\\alpha k_m}}{\\pi} \\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N} (j-1)\\, (m-1) \\right) e^{i u_j b} \\phi_{C}(u_j)  \\eta.\n",
        "$$\n",
        "To further improve the efficiency, we use Simpson's rule to choose the weights of each term to arrive at \n",
        "$$\n",
        "\\tilde{C}(k_m) \\approx \\frac{e^{-\\alpha k_m}}{\\pi} \\sum_{j=1}^{N} \\exp\\left(-i \\frac{2\\pi}{N} (j-1)\\, (m-1) \\right) e^{i u_j b} \\phi_{C}(u_j) \\frac{\\eta}{3}(3+(-1)^{j}-\\delta_{j-1}),\n",
        "$${#eq-carrmadanFFT}\n",
        "where $\\delta_n=1$ is equal to 1 if and only if $n=0$. @eq-carrmadanFFT can be efficiently computed using the FFT method.^[For options with very short maturities, the pricing errors \n",
        "for close-to-money options because the value approaches the non-analytic intrinsic value. Adjusting the Fourier transform parameter values (e.g., $N$ and $\\eta$) may be necessary.  \n",
        "An alternative method proposed by Carr and Madan (1999) may also be used. See Carr and Madan (1999) for details. ]\n",
        "\n",
        "### Implementation Steps\n",
        "\n",
        "#### 1. Set the Parameters\n",
        "\n",
        "- Choose $N$, the number of FFT points (preferably a power of 2 for computational efficiency).\n",
        "- Set the dampening factor $\\alpha$ to ensure convergence.\n",
        "- Determine $\\eta$ and $\\lambda$ based on $N$ and the desired range of strikes.\n",
        "\n",
        "#### 2. Compute the Characteristic Function\n",
        "\n",
        "For a given model (e.g., Black-Scholes, Heston), compute the characteristic function $\\phi_{S_T}(u)$ of $\\ln S_T$.\n",
        "\n",
        "#### 3. Calculate the Fourier Transform of the Call Payoff\n",
        "\n",
        "Compute $\\phi_{C}(u_j)$ using:\n",
        "\n",
        "$$\n",
        "\\phi_{C}(u_j) = \\frac{e^{-r T}\\phi_{S_T}(u_j - i (\\alpha + 1))}{(\\alpha + i u_j)(\\alpha + i u_j + 1)}.\n",
        "$$\n",
        "\n",
        "#### 4. Apply the FFT @eq-carrmadanFFT to get the option price. \n",
        "\n",
        "\n",
        "## Applications of the Carr-Madan Method\n",
        "\n",
        "###  Pricing a European Call Option under the Black-Scholes Model\n",
        "\n",
        "In the Black-Scholes model, the asset price follows a geometric Brownian motion, and the log-price $X_T = \\ln(S_T)$ is normally distributed with mean $(r - \\frac{\\sigma^2}{2})T$ and variance $\\sigma^2 T$. The characteristic function for the log-price $X_T$ is:\n",
        "\n",
        "$$\n",
        "\\phi_T(u) = \\exp\\left(iu \\left(\\ln(S_0) + \\left(r -q-\\frac{\\sigma^2}{2}\\right)T\\right) - \\frac{1}{2} \\sigma^2 T u^2 \\right),\n",
        "$$\n",
        "where $S_0$ is the initial asset price, $r$ is the risk-free rate,\n",
        "$\\sigma$ is the volatility of the asset, $T$ is the time to maturity, and $u$ is the complex Fourier variable.\n",
        "\n",
        "The following code implements the Carr-Madan method, which uses the FFT to price \n",
        "European call options by transforming the characteristic function of \n",
        "the Black-Scholes model into the frequency domain. The option prices are \n",
        "then obtained by applying Simpson's Rule for integration and \n",
        "FFT for efficient computation. These prices are compared to those \n",
        "obtained using the Black-Scholes formula. The code also visualizes \n",
        "the comparison and the differences between the two methods.\n",
        "The results suggest that the Carr-Madan method yields \n",
        "an accurate call price.  \n"
      ],
      "id": "98087d34"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from numpy.fft import fft\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.stats import norm\n",
        "\n",
        "# Market and option parameters\n",
        "S0 = 100       # Initial stock price\n",
        "K = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\n",
        "T = 0.1        # Time to maturity\n",
        "r = 0.05       # Risk-free rate\n",
        "q = 0.02       # Dividend yield\n",
        "sigma = 0.2    # Volatility\n",
        "\n",
        "# Carr-Madan method parameters\n",
        "alpha = 1.5    # Damping factor (> 0)\n",
        "N = 2**16      # Number of FFT points (must be even for Simpson's Rule)\n",
        "eta = 0.05     # Spacing in the frequency domain (smaller for higher accuracy)\n",
        "\n",
        "# Ensure N is even for Simpson's Rule\n",
        "if N % 2 != 0:\n",
        "    N += 1\n",
        "\n",
        "# Compute the grid in the frequency domain (v)\n",
        "v = np.arange(N) * eta  # v_j = j * eta\n",
        "\n",
        "# Compute the grid in the log-strike domain (k)\n",
        "lambda_ = (2 * np.pi) / (N * eta)\n",
        "b = N * lambda_ / 2     # Upper limit for k\n",
        "k = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n",
        "\n",
        "def phi(u):\n",
        "    \"\"\"Characteristic function of log(S_T) under the Black-Scholes model.\"\"\"\n",
        "    mu = np.log(S0) + (r -q- 0.5 * sigma**2) * T\n",
        "    variance = sigma**2 * T\n",
        "    return np.exp(1j * u * mu - 0.5 * variance * u**2)\n",
        "\n",
        "# Adjustment to the characteristic function for damping\n",
        "u = v - (alpha + 1) * 1j\n",
        "psi = np.exp(-r * T) * phi(u) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n",
        "\n",
        "#   Simpson's Rule weights\n",
        "w = np.ones(N)\n",
        "w[0] = w[-1] = 1\n",
        "w[1:-1:2] = 4  # Weights for odd indices\n",
        "w[2:-1:2] = 2  # Weights for even indices\n",
        "w = w * (eta / 3)\n",
        "\n",
        "# Function to be transformed with   weights\n",
        "fft_input = psi * np.exp(1j * v * b) * w\n",
        "\n",
        "# Apply the FFT\n",
        "fft_output = fft(fft_input)\n",
        "\n",
        "# Compute the option prices\n",
        "C_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n",
        "\n",
        "# Convert strikes to log-strikes\n",
        "log_K = np.log(K)\n",
        "\n",
        "# Interpolate the option prices at desired strikes\n",
        "call_prices_fft = np.interp(log_K, k, C_k)\n",
        "\n",
        "# Black-Scholes formula for European call options\n",
        "def black_scholes_call(S0, K, T, r, sigma, q):\n",
        "    \"\"\"Black-Scholes formula for European call options.\"\"\"\n",
        "    d1 = (np.log(S0 / K) + (r -q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n",
        "    d2 = d1 - sigma * np.sqrt(T)\n",
        "    return np.exp(-q * T)*S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n",
        "\n",
        "# Compute Black-Scholes prices\n",
        "call_prices_bs = black_scholes_call(S0, K, T, r, sigma, q)\n",
        "\n",
        "# Plot comparison\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, call_prices_fft, label='Carr-Madan FFT Price', linestyle='--')\n",
        "plt.plot(K, call_prices_bs, label='Black-Scholes Price', alpha=0.7)\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Option Price')\n",
        "plt.title('Comparison of Carr-Madan FFT and Black-Scholes Prices')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "# Optionally, plot the absolute difference\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, np.abs(call_prices_fft - call_prices_bs), label='Absolute Difference')\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Price Difference')\n",
        "plt.title('Absolute Difference between Carr-Madan FFT and Black-Scholes Prices')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n"
      ],
      "id": "79aadbaf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Pricing a European Call Option under the Heston (1993) Model \n",
        "\n",
        "In the Heston stochastic volatility model [@Heston], the dynamics of the asset price $S_t$ and its variance $v_t$ are given by the following stochastic differential equations (SDEs):\n",
        "\n",
        "$$\n",
        "dS_t = \\mu S_t dt + \\sqrt{v_t} S_t dW_t^S\n",
        "$$\n",
        "$$\n",
        "dv_t = \\kappa(\\theta - v_t)dt + \\sigma \\sqrt{v_t} dW_t^v\n",
        "$$\n",
        "\n",
        "Where $v_t$ is the stochastic variance, $\\kappa$ is the rate at which $v_t$ reverts to the long-term mean $\\theta$, $\\sigma$ is the volatility of volatility,\n",
        "$W_t^S$ and $W_t^v$ are two Wiener processes with correlation coefficient $\\rho$.\n",
        "\n",
        "The characteristic function is more complex and involves solving a system of differential equations. \n",
        "The characteristic function of $\\ln(S_t)$ for the Heston model is given by (for derivation details, see Heston (1993)):\n",
        "\n",
        "\n",
        "$$\n",
        "\\begin{multline}\n",
        "\\phi(u) = \\exp\\left\\{ i u \\left( \\ln(S_0) + (r-q) T \\right) + \\frac{\\kappa \\theta}{\\sigma^2} \\left[ (b - d) T - 2 \\ln\\left( \\frac{1 - g e^{-d T}}{1 - g} \\right) \\right]\\\\ + \\frac{b - d}{\\sigma^2} \\left( \\frac{1 - e^{-d T}}{1 - g e^{-d T}} \\right) v_0 \\right\\},\n",
        "\\end{multline}\n",
        "$$\n",
        "where \n",
        "$$\n",
        "\\begin{aligned}\n",
        "b &= \\kappa +\\lambda- \\rho \\sigma i u, \\\\\n",
        "d &= \\sqrt{( \\rho \\sigma i u - b )^2 + \\sigma^2 (i u + u^2)}, \\\\\n",
        "g &= \\frac{b - d}{b + d}, \\\\\n",
        "\\end{aligned}\n",
        "$$\n",
        "$v_0$ is the initial variance (volatility squared), $q$ is the dividend yield, $\\theta$ is the long-term mean of the variance, \n",
        "$\\kappa$ is the rate at which the variance reverts to $\\theta$, $\\rho$ is the correlation between the asset price \n",
        "and its volatility, $\\sigma$ is the volatility of volatility, and $\\lambda$ is the volatility risk premium.\n",
        "\n",
        "The following Python code implements the Carr-Madan method to price a European call option under the Heston Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation.   \n"
      ],
      "id": "d5474a8b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import time\n",
        "\n",
        "# -----------------------------\n",
        "# 1. Define Heston Model Parameters\n",
        "# -----------------------------\n",
        "\n",
        "# Market parameters\n",
        "S0 = 100        # Initial stock price\n",
        "r = 0.05        # Risk-free interest rate\n",
        "q = 0.02        # Dividend yield\n",
        "T = 1.0         # Time to maturity (in years)\n",
        "\n",
        "# Heston model parameters\n",
        "kappa = 1.5     # Speed of mean reversion of variance\n",
        "theta = 0.04    # Long-term variance\n",
        "sigma_v = 0.3   # Volatility of variance (vol of vol)\n",
        "rho = -0.7      # Correlation between asset and variance\n",
        "v0 = 0.04       # Initial variance\n",
        "\n",
        "# Carr-Madan parameters (Enhanced)\n",
        "alpha = 1.5             # Dampening factor (> 0)\n",
        "N = 2**16             # Number of FFT points (power of 2)\n",
        "eta = 0.25              # Spacing of the grid in Fourier space\n",
        "lambda_ = (2 * np.pi) / (N * eta)  # Spacing in log-strike space\n",
        "b = N * lambda_ / 2  # Upper bound of log-strike\n",
        "\n",
        "# Monte Carlo simulation parameters (Enhanced)\n",
        "num_paths = 100000     # Number of simulated paths\n",
        "num_steps = 500        # Number of time steps\n",
        "\n",
        "# -----------------------------\n",
        "# 2. Define the Heston Characteristic Function\n",
        "# -----------------------------\n",
        "\n",
        "def heston_char_func(u, T, kappa, theta, sigma_v, rho, v0, r, q, S0):\n",
        "    \"\"\"\n",
        "    Characteristic function of log(S_T) under the Heston model.\n",
        "    \"\"\"\n",
        "    i = 1j\n",
        "    sigma = sigma_v\n",
        "\n",
        "    d = np.sqrt((rho * sigma * i * u - kappa) ** 2 + sigma ** 2 * (i * u + u ** 2))\n",
        "    g = (kappa - rho * sigma * i * u - d) / (kappa - rho * sigma * i * u + d)\n",
        "\n",
        "    exp_dT = np.exp(-d * T)\n",
        "\n",
        "    C = (np.log(S0)+(r-q)*T) * i * u  + (kappa * theta / sigma ** 2) * ((kappa - rho * sigma * i * u - d) * T - 2 * np.log((1 - g * exp_dT) / (1 - g)))\n",
        "\n",
        "    D = ((kappa - rho * sigma * i * u - d) / sigma ** 2) * (\n",
        "        (1 - exp_dT) / (1 - g * exp_dT)\n",
        "    )\n",
        "\n",
        "    phi = np.exp(C + D * v0)\n",
        "    return phi\n",
        "\n",
        "# -----------------------------\n",
        "# 3. Carr-Madan Option Pricing Function (Enhanced)\n",
        "# -----------------------------\n",
        "\n",
        "def carr_madan_call_price(S0, r, q, T, kappa, theta, sigma_v, rho, v0, alpha, N, eta):\n",
        "    \"\"\"\n",
        "    Calculate the European call option prices using Carr-Madan method under Heston model.\n",
        "    \"\"\"\n",
        "    i = 1j\n",
        "    # Step 1: Compute the modified characteristic function\n",
        "    u = np.arange(N) * eta  # u values\n",
        "\n",
        "    # Avoid division by zero\n",
        "    u[0] = 1e-22\n",
        "\n",
        "    # Characteristic function with dampening factor\n",
        "    phi = np.exp(-r * T) * heston_char_func(u - (alpha + 1) * i, T, kappa, theta, sigma_v, rho, v0, r, q, S0) \\\n",
        "        / (alpha ** 2 + alpha - u ** 2 + i * (2 * alpha + 1) * u)\n",
        "\n",
        "    # Step 2: Apply Simpson's Rule weights\n",
        "    SimpsonW = np.ones(N)\n",
        "    SimpsonW[0] = 1\n",
        "    SimpsonW[1:N-1:2] = 4\n",
        "    SimpsonW[2:N-2:2] = 2\n",
        "    SimpsonW[-1] = 1\n",
        "    SimpsonW = SimpsonW * (eta / 3)\n",
        "\n",
        "    # Step 3: Compute the FFT\n",
        "    x = phi * np.exp(i * b * u) * SimpsonW\n",
        "    fft_x = np.fft.fft(x)\n",
        "    fft_x = np.real(fft_x)\n",
        "\n",
        "    # Step 4: Recover the call prices\n",
        "    k = -b + np.arange(N) * lambda_\n",
        "    K = np.exp(k)\n",
        "    call_prices = np.exp(-alpha * k) / np.pi * fft_x\n",
        "\n",
        "    return K, call_prices\n",
        "\n",
        "# -----------------------------\n",
        "# 4. Monte Carlo Simulation Function (Enhanced)\n",
        "# -----------------------------\n",
        "\n",
        "def heston_simulation(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps):\n",
        "    \"\"\"\n",
        "    Simulate asset price paths under the Heston model using antithetic variates.\n",
        "    \"\"\"\n",
        "    dt = T / num_steps\n",
        "    sqrt_dt = np.sqrt(dt)\n",
        "    np.random.seed(0)  # For reproducibility\n",
        "\n",
        "    num_paths_half = num_paths // 2\n",
        "\n",
        "    # Initialize arrays\n",
        "    S = np.zeros((num_paths, num_steps + 1))\n",
        "    v = np.zeros((num_paths, num_steps + 1))\n",
        "\n",
        "    # Set initial values\n",
        "    S[:, 0] = S0\n",
        "    v[:, 0] = v0\n",
        "\n",
        "    # Cholesky decomposition for correlated Brownian motions\n",
        "    cov_matrix = np.array([[1.0, rho], [rho, 1.0]])\n",
        "    L = np.linalg.cholesky(cov_matrix)\n",
        "\n",
        "    for t in range(1, num_steps + 1):\n",
        "        # Generate standard normal random variables\n",
        "        Z = np.random.randn(num_paths_half, 2)\n",
        "        Z_antithetic = -Z  # Antithetic variates\n",
        "        Z_full = np.vstack((Z, Z_antithetic))\n",
        "\n",
        "        # Correlated random variables\n",
        "        dW = np.dot(Z_full, L.T) * sqrt_dt\n",
        "\n",
        "        # Update variance process using full truncation Euler scheme\n",
        "        v_prev = v[:, t - 1]\n",
        "        sqrt_v_prev = np.sqrt(np.maximum(v_prev, 0))\n",
        "        dv = kappa * (theta - np.maximum(v_prev, 0)) * dt + sigma_v * sqrt_v_prev * dW[:, 1]\n",
        "        v[:, t] = np.maximum(v_prev + dv, 0)  # Ensure variance is non-negative\n",
        "\n",
        "        # Update asset price\n",
        "        S_prev = S[:, t - 1]\n",
        "        S[:, t] = S_prev * np.exp((r - q - 0.5 * np.maximum(v_prev, 0)) * dt + sqrt_v_prev * dW[:, 0])\n",
        "\n",
        "    # Return asset prices at maturity\n",
        "    return S[:, -1]\n",
        "\n",
        "def heston_option_pricing(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps, K_values):\n",
        "    \"\"\"\n",
        "    Price European call options using Monte Carlo simulation under the Heston model.\n",
        "    \"\"\"\n",
        "    # Simulate asset prices at maturity\n",
        "    S_T = heston_simulation(S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps)\n",
        "\n",
        "    # Initialize array for call prices\n",
        "    call_prices = np.zeros_like(K_values)\n",
        "\n",
        "    # Discount factor\n",
        "    discount_factor = np.exp(-r * T)\n",
        "\n",
        "    # Calculate option prices for each strike price\n",
        "    payoffs_matrix = np.maximum(S_T[:, np.newaxis] - K_values, 0)\n",
        "    call_prices = discount_factor * np.mean(payoffs_matrix, axis=0)\n",
        "\n",
        "    return call_prices\n",
        "\n",
        "# -----------------------------\n",
        "# 5. Calculate Option Prices Using Both Methods\n",
        "# -----------------------------\n",
        "\n",
        "# Carr-Madan method\n",
        "start_time_cm = time.time()\n",
        "K_cm, call_prices_cm = carr_madan_call_price(\n",
        "    S0, r, q, T, kappa, theta, sigma_v, rho, v0, alpha, N, eta\n",
        ")\n",
        "end_time_cm = time.time()\n",
        "time_cm = end_time_cm - start_time_cm\n",
        "\n",
        "# Select strike prices between 60 and 140\n",
        "K_indices = np.where((K_cm >= 60) & (K_cm <= 140))\n",
        "K_cm = K_cm[K_indices]\n",
        "call_prices_cm = call_prices_cm[K_indices]\n",
        "\n",
        "# Monte Carlo simulation\n",
        "K_mc = np.linspace(60, 140, 81)\n",
        "start_time_mc = time.time()\n",
        "call_prices_mc = heston_option_pricing(\n",
        "    S0, v0, r, q, T, kappa, theta, sigma_v, rho, num_paths, num_steps, K_mc\n",
        ")\n",
        "end_time_mc = time.time()\n",
        "time_mc = end_time_mc - start_time_mc\n",
        "\n",
        "# -----------------------------\n",
        "# 6. Compute Price Differences\n",
        "# -----------------------------\n",
        "\n",
        "# Interpolate Carr-Madan prices to match K_mc\n",
        "call_prices_cm_interp = np.interp(K_mc, K_cm, call_prices_cm)\n",
        "\n",
        "# Compute price differences\n",
        "price_differences = np.abs(call_prices_cm_interp - call_prices_mc)\n",
        "max_diff = np.max(price_differences)\n",
        "\n",
        "# -----------------------------\n",
        "# 7. Plot the Option Prices\n",
        "# -----------------------------\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K_mc, call_prices_cm_interp, label='Carr-Madan Method', color='blue', linewidth=2)\n",
        "plt.plot(K_mc, call_prices_mc, label='Monte Carlo Simulation', color='red', linestyle='--', linewidth=2)\n",
        "plt.xlabel('Strike Price K', fontsize=14)\n",
        "plt.ylabel('Option Price', fontsize=14)\n",
        "plt.title('European Call Option Prices under Heston Model', fontsize=16)\n",
        "plt.grid(True)\n",
        "plt.legend(fontsize=12)\n",
        "plt.show()\n",
        "\n",
        "\n",
        "# -----------------------------\n",
        "# 8. Plot Price Differences\n",
        "# -----------------------------\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K_mc, price_differences, label='Price Difference (Carr-Madan - MC)', color='green', linewidth=2)\n",
        "plt.xlabel('Strike Price K', fontsize=14)\n",
        "plt.ylabel('Price Difference', fontsize=14)\n",
        "plt.title('Price Differences between Carr-Madan and Monte Carlo Methods', fontsize=16)\n",
        "plt.grid(True)\n",
        "plt.legend(fontsize=12)\n",
        "plt.show()\n",
        "\n",
        "# -----------------------------\n",
        "# 9. Report Computation Times and Maximum Price Difference\n",
        "# -----------------------------\n",
        "\n",
        "print(f\"Computation Time (Carr-Madan Method): {time_cm:.2f} seconds\")\n",
        "print(f\"Computation Time (Monte Carlo Simulation): {time_mc:.2f} seconds\")\n",
        "print(f\"Maximum Price Difference: {max_diff:.6f}\")"
      ],
      "id": "11fc791b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Pricing Options When Stock Price Follows a Lévy Process\n",
        "\n",
        "A **Lévy process** is a type of stochastic process with stationary, independent increments, generalizing Brownian motion and Poisson processes. It is widely used in various fields like finance, physics, and stochastic modeling due to its ability to model random jumps and continuous changes over time.\n",
        "\n",
        "Key Properties of a Lévy Process:\n",
        "\n",
        "1. **Independent Increments**: The changes (increments) in the process over non-overlapping time intervals are independent. For example, the change in the process from time $t_1$ to $t_2$ is independent of the change from time $t_3$ to $t_4$ if $t_1 \\leq t_2 \\leq t_3 \\leq t_4$.\n",
        "\n",
        "2. **Stationary Increments**: The distribution of the increment of the process depends only on the length of the time interval, not the specific time at which the interval starts. That is, the increment between times $t$ and $t+s$ has the same distribution as the increment between times 0 and $s$.\n",
        "\n",
        "3. **Stochastic Continuity**: For every $\\epsilon > 0$ and $t \\geq 0$, the probability that the change in the process over a small interval $h$ becomes large tends to zero as $h \\to 0$. Formally, \n",
        "$$ \\lim_{h \\to 0} P(|X(t+h) - X(t)| \\geq \\epsilon) = 0.\n",
        "$$\n",
        "\n",
        "4. **Initial Condition**: Typically, a Lévy process starts at zero, $X(0) = 0$.\n",
        "\n",
        "Examples of Lévy Processes: \n",
        "\n",
        "- **Brownian Motion (Wiener Process)**: A Lévy process with continuous paths and normally distributed increments.\n",
        "- **Poisson Process**: A Lévy process where the increments represent the number of jumps (events) in a given time period, with the number of jumps following a Poisson distribution.\n",
        "- **Jump Diffusion Process**: A Lévy process where jumps occur at random times, with the size of each jump following a specified distribution.\n",
        "- **Variance Gamma**: A Lévy process characterized by heavy-tailed distributions, often used to model extreme events or large movements (jumps).\n",
        "\n",
        "The characteristic function of any Lévy process $X(t)$ can be expressed using the **Lévy-Khintchine formula**:\n",
        "$$\n",
        "\\mathbb{E}[e^{itX(t)}] = e^{t\\psi(t)},\n",
        "$$\n",
        "where $\\psi(t)$ is called the **Lévy exponent** and has the form:\n",
        "$$\n",
        "\\psi(t) = i\\gamma t - \\frac{1}{2} \\sigma^2 t^2 + \\int_{\\mathbb{R}} \\left( e^{itx} - 1 - itx \\mathbf{1}_{|x| < 1} \\right) \\nu(dx).\n",
        "$$\n",
        "\n",
        "In this formula, $\\gamma$ is the drift term (linear component), $\\sigma^2$ is the variance of the continuous Gaussian component, $\\nu$ is the **Lévy measure**, which controls the intensity and size of jumps.\n",
        "\n",
        "Lévy processes can thus combine continuous movements, such as Brownian motion, with jumps, providing a powerful framework for modeling both smooth and abrupt changes in time series.\n",
        "\n",
        "\n",
        "**Pricing Options in the Variance Gamma Model**\n",
        "\n",
        "\n",
        "Let $S(t)$ represent the stock price at time $t$. Under the risk-neutral measure $\\mathbb{Q}$, the stock price evolves as:\n",
        "\n",
        "$$\n",
        "S(t) = S(0) \\exp(X(t)),\n",
        "$$\n",
        "where $X(t)$ is a variance gamma process: \n",
        "$$\n",
        "X(t) = \\left( (r - q) - \\frac{1}{2} \\sigma^2 - \\frac{1}{\\nu} \\log\\left(1 - \\theta \\nu - \\frac{1}{2} \\sigma^2 \\nu \\right) \\right)t + \\sigma W(G(t))\n",
        "$$\n",
        "where $r$ is the risk-free rate, $q$ is the dividend yield, $\\sigma$ is the volatility parameter, $G(t)$ is a Gamma process with mean rate $t$ and variance rate $\\nu$, $\\theta$ controls the drift of the VG process, $\\nu$ is the variance rate of the Gamma process, and  $W(t)$ is a standard Brownian motion under the risk neutral measure $\\mathbb{Q}$.\n",
        "\n",
        "The characteristic function of $\\log(S(t))$ under the risk-neutral measure is:\n",
        "\n",
        "$$\n",
        "\\phi_{\\log(S(t))}^{\\mathbb{Q}}(u) = e^{iu \\log(S(0))} \\left( \\frac{1}{1 - iu \\theta_{\\mathbb{Q}} \\nu + \\frac{1}{2} \\sigma^2 u^2 \\nu} \\right)^{t/\\nu},\n",
        "$$\n",
        "where \n",
        "$$\n",
        "\\theta_{\\mathbb{Q}} = (r - q) - \\frac{1}{2} \\sigma^2 - \\frac{1}{\\nu} \\log\\left(1 - \\theta \\nu - \\frac{1}{2} \\sigma^2 \\nu \\right).\n",
        "$$\n",
        "\n",
        "The following Python code implements the Carr-Madan method to price a European call option under the Variance Gamma Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation. \n"
      ],
      "id": "f7977cd3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from numpy.fft import fft\n",
        "import matplotlib.pyplot as plt\n",
        "import time\n",
        "\n",
        "# Market and option parameters\n",
        "S0 = 100        # Initial stock price\n",
        "r = 0.05        # Risk-free rate\n",
        "q = 0.0         # Dividend yield\n",
        "T = 1.0         # Time to maturity\n",
        "\n",
        "# Variance Gamma parameters\n",
        "sigma = 0.12    # Volatility parameter\n",
        "nu = 0.2        # Variance rate of the Gamma process\n",
        "theta = -0.14   # Drift parameter\n",
        "\n",
        "# Strike prices\n",
        "K = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\n",
        "\n",
        "# Carr-Madan method parameters\n",
        "alpha = 5.0     # Damping factor (> 0), increased for better convergence\n",
        "N = 2**14       # Number of FFT points (must be even for Simpson's Rule)\n",
        "eta = 0.05      # Spacing in the frequency domain, decreased for better accuracy\n",
        "\n",
        "# Ensure N is even for Simpson's Rule\n",
        "if N % 2 != 0:\n",
        "    N += 1\n",
        "\n",
        "# Start timing the Carr-Madan method\n",
        "start_time_fft = time.time()\n",
        "\n",
        "# Compute the grid in the frequency domain (v)\n",
        "v = np.arange(N) * eta  # v_j = j * eta\n",
        "\n",
        "# Compute the grid in the log-strike domain (k)\n",
        "lambda_ = (2 * np.pi) / (N * eta)\n",
        "b = N * lambda_ / 2     # Upper limit for k\n",
        "k = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n",
        "\n",
        "def phi(u):\n",
        "    \"\"\"\n",
        "    characteristic function of log(S_T) under the Variance Gamma model.\n",
        "    \"\"\"\n",
        "    i = 1j\n",
        "    omega = (1 / nu) * np.log(1 - theta * nu - 0.5 * sigma**2 * nu)\n",
        "    drift = r - q - omega  \n",
        "    phi_u = np.exp(i * u * (np.log(S0) + drift * T)) * \\\n",
        "            (1 - i * theta * nu * u + 0.5 * sigma**2 * nu * u**2) ** (-T / nu)\n",
        "    return phi_u\n",
        "\n",
        "# Adjusted characteristic function\n",
        "u = v - (alpha + 1) * 1j\n",
        "psi = (np.exp(-r * T) * phi(u)) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n",
        "\n",
        "#   Simpson's Rule weights\n",
        "w = np.ones(N)\n",
        "w[0] = w[-1] = 1\n",
        "w[1:-1:2] = 4  # Weights for odd indices\n",
        "w[2:-1:2] = 2  # Weights for even indices\n",
        "w = w * (eta / 3)\n",
        "\n",
        "# Function to be transformed\n",
        "fft_input = psi * np.exp(-1j * v * b) * w  #   sign in exponential term\n",
        "\n",
        "# Apply the FFT\n",
        "fft_output = fft(fft_input)\n",
        "\n",
        "# Compute the option prices\n",
        "C_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n",
        "\n",
        "# Convert log-strike grid to strike prices\n",
        "K_fft = np.exp(k)\n",
        "\n",
        "# Interpolate the option prices at desired strikes\n",
        "call_prices_fft = np.interp(K, K_fft, C_k)\n",
        "\n",
        "# End timing the Carr-Madan method\n",
        "end_time_fft = time.time()\n",
        "time_fft = end_time_fft - start_time_fft\n",
        "\n",
        "# Monte Carlo simulation with variance reduction\n",
        "def vg_process_mc(S0, T, r, q, sigma, theta, nu, M):\n",
        "    \"\"\"\n",
        "    Monte Carlo simulation for the Variance Gamma process with antithetic variates.\n",
        "    \"\"\"\n",
        "    np.random.seed(0)  # For reproducibility\n",
        "\n",
        "    # Simulate Gamma process\n",
        "    N_sim = T / nu\n",
        "    G = np.random.gamma(N_sim, nu, M)\n",
        "\n",
        "    # Antithetic variates for Z\n",
        "    Z = np.random.randn(M)\n",
        "    Z_antithetic = -Z\n",
        "\n",
        "    # VG process for original Z\n",
        "    X = theta * G + sigma * np.sqrt(G) * Z\n",
        "    # VG process for antithetic Z\n",
        "    X_antithetic = theta * G + sigma * np.sqrt(G) * Z_antithetic\n",
        "\n",
        "    # Adjusted drift to ensure martingale\n",
        "    omega = (1 / nu) * np.log(1 - theta * nu - 0.5 * sigma**2 * nu)\n",
        "    drift = (r - q - omega) * T  #   drift\n",
        "\n",
        "    # Simulate stock prices at maturity\n",
        "    ST = S0 * np.exp(drift + X)\n",
        "    ST_antithetic = S0 * np.exp(drift + X_antithetic)\n",
        "\n",
        "    # Combine the two sets of simulated prices\n",
        "    ST_combined = np.concatenate((ST, ST_antithetic))\n",
        "\n",
        "    return ST_combined\n",
        "\n",
        "M = 500000  # Number of simulations (total simulations will be 1,000,000 with antithetic variates)\n",
        "\n",
        "# Start timing the Monte Carlo method\n",
        "start_time_mc = time.time()\n",
        "\n",
        "# Simulate stock prices\n",
        "ST_combined = vg_process_mc(S0, T, r, q, sigma, theta, nu, M)\n",
        "\n",
        "# Compute payoffs\n",
        "payoffs = np.maximum(ST_combined[:, np.newaxis] - K, 0)\n",
        "\n",
        "# Discounted option prices\n",
        "call_prices_mc = np.exp(-r * T) * np.mean(payoffs, axis=0)\n",
        "\n",
        "# End timing the Monte Carlo method\n",
        "end_time_mc = time.time()\n",
        "time_mc = end_time_mc - start_time_mc\n",
        "\n",
        "# Compute the price differences\n",
        "price_differences = call_prices_fft - call_prices_mc\n",
        "\n",
        "\n",
        "# Plot comparison\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, call_prices_fft, label='Carr-Madan FFT Price (VG)', linestyle='--')\n",
        "plt.plot(K, call_prices_mc, label='Monte Carlo Price (VG)', alpha=0.7)\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Option Price')\n",
        "plt.title('Comparison of Carr-Madan FFT and Monte Carlo Prices (VG)')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "# Plot the differences in prices\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, price_differences, label='Price Difference (FFT - MC)')\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Price Difference')\n",
        "plt.title('Difference in Option Prices between Carr-Madan FFT and Monte Carlo (VG)')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "# Calculate the maximum absolute difference\n",
        "max_difference = np.max(np.abs(price_differences))\n",
        "print(f\"Maximum Absolute Price Difference: {max_difference:.6f}\")\n",
        "\n",
        "# Print computational times\n",
        "print(f\"Computational Time (Carr-Madan FFT): {time_fft:.6f} seconds\")\n",
        "print(f\"Computational Time (Monte Carlo): {time_mc:.6f} seconds\")\n"
      ],
      "id": "ce1d3c9f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Pricing Options in a Jump Diffusion Model** \n",
        "\n",
        "A jump diffusion process is a type of stochastic process that extends a standard diffusion process, such as Brownian motion, by including random jumps. This model [e.g., @MertonJD] is widely used in financial mathematics to capture sudden, discontinuous changes in asset prices, interest rates, or other time series that are not explained by continuous diffusive processes alone.\n",
        "\n",
        "Let $S(t)$ represent the stock price at time $t$, and under the risk-neutral measure $\\mathbb{Q}$, the stock price follows a jump diffusion process. The stock price dynamics can be described by:\n",
        "\n",
        "$$\n",
        "dS(t) = (r - q) S(t) dt + \\sigma S(t) dW(t) + S(t) dJ(t)\n",
        "$$\n",
        "\n",
        "where $r$ is the risk-free rate, $q$ is the continuous dividend yield, $\\sigma$ is the volatility of the Brownian motion component, $W(t)$ is a standard Brownian motion under the risk-neutral measure, \n",
        "and the jump process $J(t)$ follows:\n",
        "$$\n",
        "J(t) = \\sum_{i=1}^{N(t)} (Y_i - 1),\n",
        "$$\n",
        "where $N(t)$ is a Poisson process with intensity $\\lambda$, representing the number of jumps up to time $t$, and $Y_i$ is the jump size, often modeled as a random variable from a log-normal distribution such that $\\log(Y_i) \\sim \\mathcal{N}(\\mu_J, \\sigma_J^2)$.\n",
        "\n",
        "Thus, the stock price is driven by both the diffusion term (due to the Brownian motion) and the jump term (due to the Poisson process).\n",
        "\n",
        "The solution to the stochastic differential equation (SDE) for $S(t)$ can be expressed as:\n",
        "\n",
        "$$\n",
        "S(t) = S(0) \\exp\\left( (r - q - \\frac{1}{2}\\sigma^2)t + \\sigma W(t) + \\sum_{i=1}^{N(t)} \\log(Y_i) \\right)\n",
        "$$\n",
        "\n",
        "This shows that the stock price incorporates both continuous changes (via the $W(t)$ term) and discrete jumps (via the $\\sum_{i=1}^{N(t)} \\log(Y_i)$ term).\n",
        "\n",
        "The characteristic function of $\\log(S(t))$ under the risk-neutral measure is:\n",
        "\n",
        "$$\n",
        "\\phi_{\\log(S(t))}^{\\mathbb{Q}}(u) = e^{iu \\log(S(0))} \\exp\\left( iu (r - q - \\frac{1}{2} \\sigma^2) t - \\frac{1}{2} u^2 \\sigma^2 t \\right)\n",
        "\\cdot \\exp\\left( \\lambda t \\left( \\exp\\left( iu \\mu_J - \\frac{1}{2} u^2 \\sigma_J^2 \\right) - 1 \\right) \\right)\n",
        "$$\n",
        "\n",
        "This formula captures both the diffusion (Brownian motion) and jump components, making it applicable for more accurate modeling of stock prices that experience sudden jumps in addition to continuous fluctuations.\n",
        "\n",
        "The following Python code implements the Carr-Madan method to price a European call option under the Jump Diffusion Model and compare it to the prices obtained from simulation. The results suggest that the Carr-Madan method yields almost the same prices as those from Monte Carlo simulation. In addition, the Carr-Madan method runs hundreds of times faster than simulation. \n"
      ],
      "id": "4b16e357"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from numpy.fft import fft\n",
        "from scipy.stats import norm\n",
        "import matplotlib.pyplot as plt\n",
        "import time\n",
        "\n",
        "# Market and option parameters\n",
        "S0 = 100       # Initial stock price\n",
        "r = 0.05       # Risk-free rate\n",
        "q = 0.0        # Dividend yield\n",
        "T = 0.1        # Time to maturity\n",
        "\n",
        "# Volatility\n",
        "sigma = 0.2    # Volatility of diffusion component\n",
        "\n",
        "# Jump parameters\n",
        "lam = 0.1      # Jump intensity (lambda)\n",
        "mu_j = -0.1    # Mean of jump size (mu_J)\n",
        "sigma_j = 0.3  # Standard deviation of jump size (sigma_J)\n",
        "\n",
        "# Calculated parameter kappa\n",
        "kappa = np.exp(mu_j + 0.5 * sigma_j**2) - 1\n",
        "\n",
        "# Strike prices\n",
        "K = np.linspace(60, 140, 81)  # Strike prices from 60 to 140\n",
        "\n",
        "# Carr-Madan method parameters\n",
        "alpha = 1.5    # Damping factor (> 0)\n",
        "N = 2**16      # Number of FFT points (must be even for Simpson's Rule)\n",
        "eta = 0.05     # Spacing in the frequency domain (smaller for higher accuracy)\n",
        "\n",
        "# Ensure N is even for Simpson's Rule\n",
        "if N % 2 != 0:\n",
        "    N += 1\n",
        "\n",
        "# Start timing the Carr-Madan method\n",
        "start_time_fft = time.time()\n",
        "\n",
        "# Compute the grid in the frequency domain (v)\n",
        "v = np.arange(N) * eta  # v_j = j * eta\n",
        "\n",
        "# Compute the grid in the log-strike domain (k)\n",
        "lambda_ = (2 * np.pi) / (N * eta)\n",
        "b = N * lambda_ / 2     # Upper limit for k\n",
        "k = -b + lambda_ * np.arange(N)  # k_i = -b + i * lambda\n",
        "\n",
        "def phi(u):\n",
        "    \"\"\"\n",
        "    Characteristic function of log(S_T) under the Merton Jump-Diffusion model.\n",
        "    \"\"\"\n",
        "    i = 1j\n",
        "    mu = np.log(S0) + (r - q - lam * kappa - 0.5 * sigma**2) * T\n",
        "    variance = sigma**2 * T\n",
        "    phi_jump = lam * T * (np.exp(i * u * mu_j - 0.5 * sigma_j**2 * u**2) - 1)\n",
        "    cf = np.exp(i * u * mu - 0.5 * variance * u**2 + phi_jump)\n",
        "    return cf\n",
        "\n",
        "# Adjusted characteristic function\n",
        "u = v - (alpha + 1) * 1j\n",
        "psi = np.exp(-r * T) * phi(u) / (alpha**2 + alpha - v**2 + 1j * (2 * alpha + 1) * v)\n",
        "\n",
        "#   Simpson's Rule weights\n",
        "w = np.ones(N)\n",
        "w[0] = w[-1] = 1\n",
        "w[1:-1:2] = 4  # Weights for odd indices\n",
        "w[2:-1:2] = 2  # Weights for even indices\n",
        "w = w * (eta / 3)\n",
        "\n",
        "# Function to be transformed\n",
        "fft_input = psi * np.exp(-1j * v * b) * w\n",
        "\n",
        "# Apply the FFT\n",
        "fft_output = fft(fft_input)\n",
        "\n",
        "# Compute the option prices\n",
        "C_k = np.exp(-alpha * k) / np.pi * np.real(fft_output)\n",
        "\n",
        "# Convert log-strike grid to strike prices\n",
        "K_fft = np.exp(k)\n",
        "\n",
        "# Interpolate the option prices at desired strikes\n",
        "call_prices_fft = np.interp(K, K_fft, C_k)\n",
        "\n",
        "# End timing the Carr-Madan method\n",
        "end_time_fft = time.time()\n",
        "time_fft = end_time_fft - start_time_fft\n",
        "\n",
        "# Monte Carlo simulation\n",
        "def merton_jump_diffusion_mc(S0, K, T, r, q, sigma, lam, mu_j, sigma_j, M):\n",
        "    \"\"\"\n",
        "    Monte Carlo simulation for European call option under Merton jump-diffusion model.\n",
        "    \"\"\"\n",
        "    np.random.seed(0)  # For reproducibility\n",
        "    drift = (r - q - lam * kappa - 0.5 * sigma**2) * T\n",
        "    diffusion = sigma * np.sqrt(T) * np.random.randn(M)\n",
        "\n",
        "    # Simulate number of jumps for each path\n",
        "    N_jumps = np.random.poisson(lam * T, M)\n",
        "\n",
        "    # Simulate jump sizes\n",
        "    sum_Y = np.zeros(M)\n",
        "    idx = np.where(N_jumps > 0)[0]\n",
        "    for i in idx:\n",
        "        Y_i = np.random.normal(mu_j, sigma_j, N_jumps[i])\n",
        "        sum_Y[i] = np.sum(Y_i)\n",
        "\n",
        "    # Compute log stock price at maturity\n",
        "    ln_ST = np.log(S0) + drift + diffusion + sum_Y\n",
        "\n",
        "    ST = np.exp(ln_ST)\n",
        "\n",
        "    # Compute payoff for each simulation\n",
        "    payoffs = np.maximum(ST[:, np.newaxis] - K, 0)\n",
        "\n",
        "    # Discount back\n",
        "    C_MC = np.exp(-r * T) * np.mean(payoffs, axis=0)\n",
        "\n",
        "    return C_MC\n",
        "\n",
        "M = 100000  # Number of simulations\n",
        "\n",
        "# Start timing the Monte Carlo method\n",
        "start_time_mc = time.time()\n",
        "call_prices_mc = merton_jump_diffusion_mc(S0, K, T, r, q, sigma, lam, mu_j, sigma_j, M)\n",
        "end_time_mc = time.time()\n",
        "time_mc = end_time_mc - start_time_mc\n",
        "\n",
        "# Compute the price differences\n",
        "price_differences = call_prices_fft - call_prices_mc\n",
        "\n",
        "\n",
        "# Plot comparison\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, call_prices_fft, label='Carr-Madan FFT Price ', linestyle='--')\n",
        "plt.plot(K, call_prices_mc, label='Monte Carlo Price (JD)', alpha=0.7)\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Option Price')\n",
        "plt.title('Comparison of Carr-Madan FFT and Monte Carlo Prices (JD)')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "# Plot the differences in prices\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(K, price_differences, label='Price Difference (FFT - MC)')\n",
        "plt.xlabel('Strike Price K')\n",
        "plt.ylabel('Price Difference')\n",
        "plt.title('Difference in Option Prices between Carr-Madan FFT and Monte Carlo (JD)')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()\n",
        "\n",
        "\n",
        "# Print computational times\n",
        "print(f\"Computational Time (Carr-Madan FFT): {time_fft:.6f} seconds\")\n",
        "print(f\"Computational Time (Monte Carlo): {time_mc:.6f} seconds\")"
      ],
      "id": "492d57df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exercises\n",
        "\n",
        "\n",
        "::: {#exr-nolabel}\n",
        " Create a Python code to compare the Carr-Madan method with the direct Fourier Transform method using @eq-FTpricing for pricing in-the-money, at-the-money, and out-of-the-money  European call options in terms of speed and accuracy in the Black-Scholes model. \n",
        ":::\n",
        "\n",
        "\n",
        "::: {#exr-nolabel}\n",
        " Create a Python code to let users input all the parameter values in the jump diffusion model and use the Carr-Madan method to price European put options in this model.\n",
        ":::\n",
        "::: {#exr-nolabel}\n",
        " Create a Python code to let users input all the parameter values in the Heston model and use the Carr-Madan method to price European put options in this model.  \n",
        ":::\n",
        "\n",
        "::: {#exr-nolabel}\n",
        " Create a Python code to show how the speed and accuracy change as one varies the damping factor $\\alpha$ and the strike price spacing $\\eta$ in the jump diffusion model. \n",
        ":::\n",
        "\n",
        "\n",
        "## References\n",
        "\n",
        "1. Carr, P., & Madan, D. B. (1999). *Option valuation using the fast Fourier transform*. Journal of Computational Finance, 2(4), 61-73.\n",
        "2. Black, F., & Scholes, M. (1973). *The pricing of options and corporate liabilities*. Journal of Political Economy, 81(3), 637-654.\n"
      ],
      "id": "434fd8e1"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\kerry\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}