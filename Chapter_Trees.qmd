{{< include macros.qmd >}}

# Binomial Tree Models {#sec-c:trees}

```{python}
#| eval: true
#| echo: false

import plotly
from IPython.display import display, HTML

plotly.offline.init_notebook_mode(connected=True)
display(
    HTML(
        '<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG"></script>'
    )
)
```

This chapter introduces binomial tree models for valuing derivative securities. We begin with the fundamental concepts of arbitrage pricing in a one-period model, extend to multi-period trees, and then discuss practical implementation and parameter calibration.

## One-Period Binomial Model

We start with the simplest possible model. A stock has price $S$ today (date 0) and will have one of two possible values at date $t$: either $S_u$ (up state) or $S_d$ (down state), where $S_u > S_d$. There is also a risk-free asset earning a continuously compounded rate $r$.

### Delta Hedging and Replication

Consider a European call option with strike $K$ and maturity $t$. Its payoff will be $C_u = \max(0, S_u - K)$ in the up state and $C_d = \max(0, S_d - K)$ in the down state.

The key insight is that we can replicate the option payoff using a portfolio of the stock and risk-free asset. Let $\delta$ be the number of shares we hold. This delta is chosen so that the portfolio has the same payoff as the option in both states:

$$\delta = \frac{C_u - C_d}{S_u - S_d}$$

To see why this works, consider a portfolio that holds $\delta$ shares of stock and borrows an amount $B$ at the risk-free rate. The portfolio value at maturity will be:
- Up state: $\delta S_u - B e^{rt}$
- Down state: $\delta S_d - B e^{rt}$

For replication, we need these to equal the option payoffs:
$$\delta S_u - B e^{rt} = C_u$$
$$\delta S_d - B e^{rt} = C_d$$

Subtracting the second equation from the first:
$$\delta(S_u - S_d) = C_u - C_d$$

This gives us our delta formula. We can solve for the borrowing amount:
$$B = e^{-rt}(\delta S_u - C_u) = e^{-rt}(\delta S_d - C_d)$$

The initial cost of this replicating portfolio is:
$$\text{Portfolio Cost} = \delta S - B = \delta S - e^{-rt}(\delta S_u - C_u)$$

By no-arbitrage, this must equal the option price.

::: Example
Suppose $S = 100$, $S_u = 110$, $S_d = 90$, $K = 105$, $r = 0.05$, $t = 1$. Then:
- $C_u = \max(0, 110 - 105) = 5$
- $C_d = \max(0, 90 - 105) = 0$
- $\delta = \frac{5 - 0}{110 - 90} = 0.25$
- $B = e^{-0.05}(0.25 \times 110 - 5) = e^{-0.05} \times 22.5 \approx 21.43$
- Option price $= 0.25 \times 100 - 21.43 = 3.57$

**Verification:** In the up state, the portfolio is worth $0.25 \times 110 - 22.5 = 5$, matching $C_u$. In the down state, it's worth $0.25 \times 90 - 22.5 = 0$, matching $C_d$.

This delta hedging shows that by holding 0.25 shares and borrowing $21.43, we can perfectly replicate the option payoff.
:::

### Risk-Neutral Valuation

We can rearrange the replication formula to express the option value as:

$$C = \pi_u C_u + \pi_d C_d$$

where the state prices are:

$$\pi_u = \frac{S - \mathrm{e}^{-rt}S_d}{S_u - S_d}, \quad \pi_d = \frac{\mathrm{e}^{-rt}S_u - S}{S_u - S_d}$$

These state prices satisfy:
- $\pi_u, \pi_d > 0$ (under no-arbitrage condition $S_u/S > \mathrm{e}^{rt} > S_d/S$)
- $\pi_u \mathrm{e}^{rt} + \pi_d \mathrm{e}^{rt} = 1$

This motivates defining risk-neutral probabilities:

$$p_u = \pi_u \mathrm{e}^{rt}, \quad p_d = \pi_d \mathrm{e}^{rt}$$

Then:

$$C = \mathrm{e}^{-rt}[p_u C_u + p_d C_d]$$

The option value is the discounted expected payoff under the risk-neutral probability measure. Note that:

$$p_u = \frac{\mathrm{e}^{rt} - S_d/S}{S_u/S - S_d/S}$$

## Two-Period Model

Now consider a two-period model where the stock price evolves over two time steps of length $\Delta t = t/2$. To simplify notation and ensure the tree recombines, we parameterize the price movements using multiplicative factors $u > 1$ and $d = 1/u < 1$.

Starting from $S$, after one period the stock price is either $uS$ or $dS$. After two periods, the possible prices are:
- $u^2S$ (two up moves)
- $udS = S$ (one up, one down)  
- $d^2S$ (two down moves)

The tree recombines because $ud = du = 1$, so the middle node has price $S$ regardless of the path taken.

::: {#fig-binomial-trees}

<iframe width="720" height="800" src="https://binomial-trees.koyeb.app/"></iframe>

**Interactive Binomial Trees.** 
The interest rate should be the rate per period. The **up move** parameter corresponds to $(u-1)$ where $u$ is our up factor. The model takes $d = 1/u$. You can explore how option values change with different parameters and see both European and American option pricing.

:::

### Backward Induction Process

The key to valuing options in multi-period trees is **backward induction**. We start at maturity and work backwards to find today's value.

**Step 1: Final Period (t = 2)**
Calculate option payoffs at each terminal node:
- Node (2,2): $C_{uu} = \max(0, u^2S - K)$ 
- Node (2,1): $C_{ud} = \max(0, udS - K) = \max(0, S - K)$
- Node (2,0): $C_{dd} = \max(0, d^2S - K)$

**Step 2: Intermediate Period (t = 1)**
At each node, calculate the option value as the discounted risk-neutral expectation of the next period's values. 

At the up node (1,1) with stock price $uS$:
$$C_u = e^{-r\Delta t}[p \cdot C_{uu} + (1-p) \cdot C_{ud}]$$

At the down node (1,0) with stock price $dS$:
$$C_d = e^{-r\Delta t}[p \cdot C_{ud} + (1-p) \cdot C_{dd}]$$

**Step 3: Initial Period (t = 0)**
Finally, calculate today's option value:
$$C_0 = e^{-r\Delta t}[p \cdot C_u + (1-p) \cdot C_d]$$

**For American Options:**
At each intermediate node, compare continuation value with immediate exercise:
- Up node: $C_u = \max(\text{continuation value}, \max(0, uS - K))$
- Down node: $C_d = \max(\text{continuation value}, \max(0, dS - K))$

This backward induction process automatically finds the optimal exercise strategy by comparing holding vs. exercising at each node.

## N-Period Model

The extension to N periods is straightforward. With parameters $u$ and $d = 1/u$, after $n$ periods we have $n+1$ nodes with stock prices:

$$S_j = u^j d^{n-j} S = u^{2j-n} S, \quad j = 0, 1, \ldots, n$$

The critical insight for efficient implementation is backward induction rather than computing all possible paths.

### Backward Induction Implementation

For American options especially, we must use backward induction. Here's how the algorithm works:

```{python}
#| echo: true
#| eval: true

def binomial_american_detailed(S0, K, r, sigma, T, N, option_type='put'):
    """
    Price American option using binomial tree with detailed backward induction
    
    This function shows exactly how backward induction works step by step
    """
    # Step 1: Set up tree parameters
    dt = T / N                          # Time per step
    u = np.exp(sigma * np.sqrt(dt))     # Up factor
    d = 1 / u                           # Down factor (ensures recombining tree)
    p = (np.exp(r * dt) - d) / (u - d)  # Risk-neutral probability
    disc = np.exp(-r * dt)              # Discount factor
    
    print(f"Tree parameters: u={u:.4f}, d={d:.4f}, p={p:.4f}")
    
    # Step 2: Initialize option values at maturity (time N)
    # At maturity, we have N+1 possible stock prices
    V = np.zeros(N+1)  # Option values
    S = np.zeros(N+1)  # Stock prices
    
    for j in range(N+1):
        S[j] = S0 * (u**j) * (d**(N-j))  # Stock price at node j
        if option_type == 'call':
            V[j] = max(0, S[j] - K)      # Call payoff
        else:
            V[j] = max(0, K - S[j])      # Put payoff
    
    print(f"\nAt maturity (time {N}):")
    print(f"Stock prices: {[f'{s:.2f}' for s in S]}")
    print(f"Option values: {[f'{v:.4f}' for v in V]}")
    
    # Step 3: Backward induction through the tree
    for i in range(N-1, -1, -1):  # Work backwards from time N-1 to 0
        print(f"\nTime step {i}:")
        
        # At time i, we have i+1 nodes
        new_V = np.zeros(i+1)
        new_S = np.zeros(i+1)
        
        for j in range(i+1):
            # Stock price at this node
            new_S[j] = S0 * (u**j) * (d**(i-j))
            
            # Continuation value (discounted expected value)
            continuation = disc * (p * V[j+1] + (1-p) * V[j])
            
            # Immediate exercise value
            if option_type == 'call':
                exercise = max(0, new_S[j] - K)
            else:
                exercise = max(0, K - new_S[j])
            
            # American option: take maximum of continuation and exercise
            new_V[j] = max(continuation, exercise)
            
            print(f"  Node {j}: S={new_S[j]:.2f}, Cont={continuation:.4f}, "
                  f"Exercise={exercise:.4f}, Value={new_V[j]:.4f}")
        
        # Update for next iteration
        V = new_V.copy()
        S = new_S.copy()
    
    return V[0]

# Example with small tree to see the process
print("Detailed backward induction for 3-step American put:")
S0, K, r, sigma, T, N = 50, 50, 0.05, 0.3, 0.25, 3
put_value = binomial_american_detailed(S0, K, r, sigma, T, N, 'put')
print(f"\nFinal American put value: {put_value:.4f}")
```

Now here's the streamlined version for practical use:

```{python}
#| echo: true
#| eval: true

def binomial_american_fast(S0, K, r, sigma, T, N, option_type='put'):
    """
    Efficient American option pricing using backward induction
    
    This version uses vectorized operations for speed
    """
    dt = T / N
    u = np.exp(sigma * np.sqrt(dt))
    d = 1 / u
    p = (np.exp(r * dt) - d) / (u - d)
    disc = np.exp(-r * dt)
    
    # Initialize option values at maturity
    # Use vectorized operations for efficiency
    j_values = np.arange(N+1)
    S_final = S0 * (u**j_values) * (d**(N-j_values))
    
    if option_type == 'call':
        V = np.maximum(S_final - K, 0)
    else:
        V = np.maximum(K - S_final, 0)
    
    # Backward induction
    for i in range(N-1, -1, -1):
        j_values = np.arange(i+1)
        S_current = S0 * (u**j_values) * (d**(i-j_values))
        
        # Continuation values (vectorized)
        V_new = disc * (p * V[1:i+2] + (1-p) * V[0:i+1])
        
        # Exercise values
        if option_type == 'call':
            exercise = np.maximum(S_current - K, 0)
        else:
            exercise = np.maximum(K - S_current, 0)
        
        # Take maximum (American feature)
        V = np.maximum(V_new, exercise)
    
    return V[0]

# Examples
print("\nAmerican option values:")
put_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'put')
call_american = binomial_american_fast(100, 105, 0.05, 0.2, 1, 100, 'call')
print(f"American put (K=105): {put_american:.4f}")
print(f"American call (K=105): {call_american:.4f}")
```

### How the Code Works

**Key algorithmic insights:**

1. **Vectorization**: Instead of nested loops, we use NumPy arrays to compute all nodes at each time step simultaneously

2. **Memory efficiency**: We only store option values for the current time step, not the entire tree

3. **Backward induction logic**:
   - Start with payoffs at maturity
   - At each prior time step, compute continuation value as discounted expectation
   - For American options, compare with immediate exercise value
   - Take the maximum (American feature)

4. **Risk-neutral probability**: The tree converges to the Black-Scholes model when $p = \frac{e^{r\Delta t} - d}{u - d}$ and we use the Cox-Ross-Rubinstein parameters.

**Computational complexity**: 
- Time: $O(N^2)$ for American options (must visit all nodes)  
- Space: $O(N)$ (only current time step stored)
- This is much better than the $O(2^N)$ complexity of path enumeration

## Parameter Calibration

The key question is how to choose the parameters $u$, $d$, and $p$ so that the binomial model approximates the continuous-time Black-Scholes model as $N \to \infty$.

### Cox-Ross-Rubinstein Parameters

The most popular choice, proposed by Cox, Ross, and Rubinstein, sets:

$$u = \mathrm{e}^{\sigma\sqrt{\Delta t}}, \quad d = \frac{1}{u}, \quad p = \frac{\mathrm{e}^{(r-q)\Delta t} - d}{u - d}$$

where $q$ is the dividend yield. This choice ensures:
- The tree recombines ($ud = 1$)
- The discrete model converges to geometric Brownian motion
- The risk-neutral probability is well-defined when $d < \mathrm{e}^{(r-q)\Delta t} < u$

### Matching Moments

For the binomial model to converge properly to the continuous-time model, we need:

$$\frac{\mathbb{E}[\Delta \log S]}{\Delta t} \to r - q - \frac{\sigma^2}{2}$$

$$\frac{\mathrm{Var}[\Delta \log S]}{\Delta t} \to \sigma^2$$

The Cox-Ross-Rubinstein parameters satisfy these conditions. With $u = \mathrm{e}^{\sigma\sqrt{\Delta t}}$ and $d = 1/u$:

- $\log u = \sigma\sqrt{\Delta t}$ and $\log d = -\sigma\sqrt{\Delta t}$
- The variance of $\log(S_{t+\Delta t}/S_t)$ is approximately $\sigma^2 \Delta t$ for small $\Delta t$

### Alternative Parameters

Other popular choices include:

**Jarrow-Rudd**: Set $p = 1/2$ and adjust $u$ and $d$ to match the mean and variance:
$$u = \exp\left((r - q - \frac{\sigma^2}{2})\Delta t + \sigma\sqrt{\Delta t}\right)$$
$$d = \exp\left((r - q - \frac{\sigma^2}{2})\Delta t - \sigma\sqrt{\Delta t}\right)$$

**Equal Probabilities**: This choice simplifies calculations but requires different up and down factors.

### Convergence and Accuracy

The binomial model converges to the Black-Scholes model as $N \to \infty$, but convergence is not monotonic. For European options:
- Accuracy improves roughly as $O(1/N)$
- Oscillations occur due to the discrete nature of the tree
- Using $N \approx 100$ typically gives prices accurate to a few cents

For American options:
- The binomial model provides one of the most efficient numerical methods
- Early exercise boundaries can be extracted from the tree
- Smooth convergence requires larger $N$ than for European options

## Summary

The binomial tree model provides an intuitive and flexible framework for option pricing:

1. **One-period model**: Introduces replication and risk-neutral valuation
2. **Multi-period extension**: Uses backward induction for path-independent claims
3. **Parameter choice**: Cox-Ross-Rubinstein parameters with $u = \mathrm{e}^{\sigma\sqrt{\Delta t}}$ and $d = 1/u$ ensure convergence
4. **Implementation**: Efficient for American options and provides exercise boundaries

The model's strength lies in its simplicity and ability to handle early exercise features. However, for path-dependent options or multiple underlying assets, the computational requirements grow exponentially, making Monte Carlo methods more attractive in those cases.

## Exercises

::: {#exr-trees1}
In a one-period binomial model with $S = 50$, $S_u = 60$, $S_d = 40$, and $r = 0.05$:
a) Calculate the risk-neutral probabilities
b) Price a call option with strike $K = 55$
c) Verify your answer using delta hedging
:::

::: {#exr-trees2}
Show that in the Cox-Ross-Rubinstein model, the expected return on the stock under the risk-neutral measure equals the risk-free rate: $\mathbb{E}^p[S_{t+\Delta t}/S_t] = \mathrm{e}^{r\Delta t}$
:::

::: {#exr-trees3}
Implement a function to compute the early exercise boundary for an American put option. Plot the boundary as a function of time to maturity.
:::

::: {#exr-trees4}
Compare the convergence of European option prices using:
a) Cox-Ross-Rubinstein parameters
b) Jarrow-Rudd parameters
Plot the option values against the number of time steps $N$.
:::