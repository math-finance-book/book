{
  "hash": "c6c959debc312eb5696eb631bfa66537",
  "result": {
    "engine": "jupyter",
    "markdown": "\\newcommand{\\d}{\\,\\mathrm{d}}\n\\newcommand{\\e}{\\mathrm{e}}\n\\newcommand{\\E}{\\mathbb{E}}\n\n\n# Binomial Tree Models {#sec-c:trees}\n\n::: {#112493de .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"></script>\n```\n:::\n:::\n\n\nThis chapter introduces binomial tree models for valuing derivative securities. We begin with the fundamental concepts of arbitrage pricing in a one-period model, extend to multi-period trees, and then discuss practical implementation and parameter calibration.\n\n## One-Period Binomial Model\n\nWe start with the simplest possible model. A stock has price $S$ today (date 0) and will have one of two possible values at date $t$: either $S_u$ (up state) or $S_d$ (down state), where $S_u > S_d$. There is also a risk-free asset earning a continuously compounded rate $r$.\n\n### Delta Hedging and Replication\n\nConsider a European call option with strike $K$ and maturity $t$. Its payoff will be $C_u = \\max(0, S_u - K)$ in the up state and $C_d = \\max(0, S_d - K)$ in the down state.\n\nThe key insight is that we can replicate the option payoff using a portfolio of the stock and risk-free asset. Let $\\delta$ be the number of shares we hold. This delta is chosen so that the portfolio has the same payoff as the option in both states:\n\n$$\\delta = \\frac{C_u - C_d}{S_u - S_d}$$\n\nThe portfolio consists of:\n- $\\delta$ shares of stock\n- A position in the risk-free asset worth $B = \\mathrm{e}^{-rt}(\\delta S_u - C_u) = \\mathrm{e}^{-rt}(\\delta S_d - C_d)$\n\nBy no-arbitrage, the option value must equal the cost of the replicating portfolio:\n\n$$C = \\delta S - B = \\delta S - \\mathrm{e}^{-rt}(\\delta S_u - C_u)$$\n\n::: Example\nSuppose $S = 100$, $S_u = 110$, $S_d = 90$, $K = 105$, $r = 0.05t$. Then:\n- $C_u = \\max(0, 110 - 105) = 5$\n- $C_d = \\max(0, 90 - 105) = 0$\n- $\\delta = \\frac{5 - 0}{110 - 90} = \\frac{1}{4}$\n\nThe replicating portfolio requires buying 0.25 shares and borrowing money. The option value equals the cost of this portfolio.\n:::\n\n### Risk-Neutral Valuation\n\nWe can rearrange the replication formula to express the option value as:\n\n$$C = \\pi_u C_u + \\pi_d C_d$$\n\nwhere the state prices are:\n\n$$\\pi_u = \\frac{S - \\mathrm{e}^{-rt}S_d}{S_u - S_d}, \\quad \\pi_d = \\frac{\\mathrm{e}^{-rt}S_u - S}{S_u - S_d}$$\n\nThese state prices satisfy:\n- $\\pi_u, \\pi_d > 0$ (under no-arbitrage condition $S_u/S > \\mathrm{e}^{rt} > S_d/S$)\n- $\\pi_u \\mathrm{e}^{rt} + \\pi_d \\mathrm{e}^{rt} = 1$\n\nThis motivates defining risk-neutral probabilities:\n\n$$p_u = \\pi_u \\mathrm{e}^{rt}, \\quad p_d = \\pi_d \\mathrm{e}^{rt}$$\n\nThen:\n\n$$C = \\mathrm{e}^{-rt}[p_u C_u + p_d C_d]$$\n\nThe option value is the discounted expected payoff under the risk-neutral probability measure. Note that:\n\n$$p_u = \\frac{\\mathrm{e}^{rt} - S_d/S}{S_u/S - S_d/S}$$\n\n## Two-Period Model\n\nNow consider a two-period model where the stock price evolves over two time steps of length $\\Delta t = t/2$. To simplify notation and ensure the tree recombines, we parameterize the price movements using multiplicative factors $u > 1$ and $d = 1/u < 1$.\n\nStarting from $S$, after one period the stock price is either $uS$ or $dS$. After two periods, the possible prices are:\n- $u^2S$ (two up moves)\n- $udS = S$ (one up, one down)\n- $d^2S$ (two down moves)\n\nThe tree recombines because $ud = du = 1$, so the middle node has price $S$ regardless of the path taken.\n\n### Backward Induction\n\nTo value a European option, we work backwards through the tree:\n\n1. At maturity (period 2), calculate option payoffs at each node\n2. At period 1, calculate option values as discounted expected values:\n   $$C_{period 1} = \\mathrm{e}^{-r\\Delta t}[p C_{up} + (1-p) C_{down}]$$\n3. At period 0, repeat to get the initial option value\n\nFor American options, at each node we compare the continuation value (from holding) with the intrinsic value (from exercising) and take the maximum.\n\n## N-Period Model\n\nThe extension to N periods is straightforward. With parameters $u$ and $d = 1/u$, after $n$ periods we have $n+1$ nodes with stock prices:\n\n$$S_j = u^j d^{n-j} S = u^{2j-n} S, \\quad j = 0, 1, \\ldots, n$$\n\n### European Option Valuation\n\nFor a European option, the value is:\n\n$$C = \\mathrm{e}^{-rT} \\sum_{j=0}^N \\binom{N}{j} p^j (1-p)^{N-j} \\max(u^{2j-N}S - K, 0)$$\n\nwhere $\\binom{N}{j} = \\frac{N!}{j!(N-j)!}$ is the binomial coefficient giving the number of paths to node $j$.\n\n### Implementation for European Options\n\n::: {#9491f5a5 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.special import comb\n\ndef binomial_european(S0, K, r, sigma, T, N, option_type='call'):\n    \"\"\"\n    Price European option using binomial tree\n    \n    Parameters:\n    S0: initial stock price\n    K: strike price\n    r: risk-free rate\n    sigma: volatility\n    T: time to maturity\n    N: number of time steps\n    option_type: 'call' or 'put'\n    \"\"\"\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    \n    # Stock prices at maturity\n    S = S0 * u**(2*np.arange(N+1) - N)\n    \n    # Option payoffs at maturity\n    if option_type == 'call':\n        payoffs = np.maximum(S - K, 0)\n    else:\n        payoffs = np.maximum(K - S, 0)\n    \n    # Expected value under risk-neutral measure\n    option_value = 0\n    for j in range(N+1):\n        option_value += comb(N, j, exact=True) * p**j * (1-p)**(N-j) * payoffs[j]\n    \n    return np.exp(-r * T) * option_value\n\n# Example\nS0 = 100\nK = 100\nr = 0.05\nsigma = 0.2\nT = 1\nN = 100\n\ncall_value = binomial_european(S0, K, r, sigma, T, N, 'call')\nprint(f\"European call value: {call_value:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEuropean call value: 10.4306\n```\n:::\n:::\n\n\n### Implementation for American Options\n\nFor American options, we must use backward induction and check for early exercise at each node:\n\n::: {#a8cfe72e .cell execution_count=3}\n``` {.python .cell-code}\ndef binomial_american(S0, K, r, sigma, T, N, option_type='put'):\n    \"\"\"\n    Price American option using binomial tree with backward induction\n    \n    Parameters as before\n    \"\"\"\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    p = (np.exp(r * dt) - d) / (u - d)\n    disc = np.exp(-r * dt)\n    \n    # Stock prices at maturity\n    S = S0 * u**(2*np.arange(N+1) - N)\n    \n    # Option values at maturity\n    if option_type == 'call':\n        V = np.maximum(S - K, 0)\n    else:\n        V = np.maximum(K - S, 0)\n    \n    # Backward induction\n    for i in range(N-1, -1, -1):\n        # Stock prices at time i\n        S = S0 * u**(2*np.arange(i+1) - i)\n        \n        # Continuation values\n        V = disc * (p * V[1:i+2] + (1-p) * V[0:i+1])\n        \n        # Compare with immediate exercise\n        if option_type == 'call':\n            V = np.maximum(V, S - K)\n        else:\n            V = np.maximum(V, K - S)\n    \n    return V[0]\n\n# Example\nput_value = binomial_american(S0, K, r, sigma, T, N, 'put')\nprint(f\"American put value: {put_value:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAmerican put value: 6.0824\n```\n:::\n:::\n\n\n## Parameter Calibration\n\nThe key question is how to choose the parameters $u$, $d$, and $p$ so that the binomial model approximates the continuous-time Black-Scholes model as $N \\to \\infty$.\n\n### Cox-Ross-Rubinstein Parameters\n\nThe most popular choice, proposed by Cox, Ross, and Rubinstein, sets:\n\n$$u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u}, \\quad p = \\frac{\\mathrm{e}^{(r-q)\\Delta t} - d}{u - d}$$\n\nwhere $q$ is the dividend yield. This choice ensures:\n- The tree recombines ($ud = 1$)\n- The discrete model converges to geometric Brownian motion\n- The risk-neutral probability is well-defined when $d < \\mathrm{e}^{(r-q)\\Delta t} < u$\n\n### Matching Moments\n\nFor the binomial model to converge properly to the continuous-time model, we need:\n\n$$\\frac{\\mathbb{E}[\\Delta \\log S]}{\\Delta t} \\to r - q - \\frac{\\sigma^2}{2}$$\n\n$$\\frac{\\mathrm{Var}[\\Delta \\log S]}{\\Delta t} \\to \\sigma^2$$\n\nThe Cox-Ross-Rubinstein parameters satisfy these conditions. With $u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}$ and $d = 1/u$:\n\n- $\\log u = \\sigma\\sqrt{\\Delta t}$ and $\\log d = -\\sigma\\sqrt{\\Delta t}$\n- The variance of $\\log(S_{t+\\Delta t}/S_t)$ is approximately $\\sigma^2 \\Delta t$ for small $\\Delta t$\n\n### Alternative Parameters\n\nOther popular choices include:\n\n**Jarrow-Rudd**: Set $p = 1/2$ and adjust $u$ and $d$ to match the mean and variance:\n$$u = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t + \\sigma\\sqrt{\\Delta t}\\right)$$\n$$d = \\exp\\left((r - q - \\frac{\\sigma^2}{2})\\Delta t - \\sigma\\sqrt{\\Delta t}\\right)$$\n\n**Equal Probabilities**: This choice simplifies calculations but requires different up and down factors.\n\n### Convergence and Accuracy\n\nThe binomial model converges to the Black-Scholes model as $N \\to \\infty$, but convergence is not monotonic. For European options:\n- Accuracy improves roughly as $O(1/N)$\n- Oscillations occur due to the discrete nature of the tree\n- Using $N \\approx 100$ typically gives prices accurate to a few cents\n\nFor American options:\n- The binomial model provides one of the most efficient numerical methods\n- Early exercise boundaries can be extracted from the tree\n- Smooth convergence requires larger $N$ than for European options\n\n## Summary\n\nThe binomial tree model provides an intuitive and flexible framework for option pricing:\n\n1. **One-period model**: Introduces replication and risk-neutral valuation\n2. **Multi-period extension**: Uses backward induction for path-independent claims\n3. **Parameter choice**: Cox-Ross-Rubinstein parameters with $u = \\mathrm{e}^{\\sigma\\sqrt{\\Delta t}}$ and $d = 1/u$ ensure convergence\n4. **Implementation**: Efficient for American options and provides exercise boundaries\n\nThe model's strength lies in its simplicity and ability to handle early exercise features. However, for path-dependent options or multiple underlying assets, the computational requirements grow exponentially, making Monte Carlo methods more attractive in those cases.\n\n## Exercises\n\n::: {#exr-trees1}\nIn a one-period binomial model with $S = 50$, $S_u = 60$, $S_d = 40$, and $r = 0.05$:\na) Calculate the risk-neutral probabilities\nb) Price a call option with strike $K = 55$\nc) Verify your answer using delta hedging\n:::\n\n::: {#exr-trees2}\nShow that in the Cox-Ross-Rubinstein model, the expected return on the stock under the risk-neutral measure equals the risk-free rate: $\\mathbb{E}^p[S_{t+\\Delta t}/S_t] = \\mathrm{e}^{r\\Delta t}$\n:::\n\n::: {#exr-trees3}\nImplement a function to compute the early exercise boundary for an American put option. Plot the boundary as a function of time to maturity.\n:::\n\n::: {#exr-trees4}\nCompare the convergence of European option prices using:\na) Cox-Ross-Rubinstein parameters\nb) Jarrow-Rudd parameters\nPlot the option values against the number of time steps $N$.\n:::\n\n",
    "supporting": [
      "Chapter_Trees_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\nif (typeof require !== 'undefined') {\nrequire.undef(\"plotly\");\nrequirejs.config({\n    paths: {\n        'plotly': ['https://cdn.plot.ly/plotly-2.35.2.min']\n    }\n});\nrequire(['plotly'], function(Plotly) {\n    window._Plotly = Plotly;\n});\n}\n</script>\n\n"
      ]
    }
  }
}