\addcontentsline{toc}{part}{Appendices}
\chapter{Programming in VBA}\label{c_matlab}

The purpose of this appendix is to provide an introduction to the features of Excel VBA that are used in the book.   To learn more about VBA in a finance setting, Jackson and Staunton \cite{JS} is a good source.

\section{VBA Editor and Modules}



Subroutines and functions are created in the VBA editor, which is reached through Tools/ Macros/Visual Basic Editor.    When the editor opens, click Insert/Module to open an editing screen in which subroutines and functions can be typed.   If you have opened a new workbook and  inserted a module, you should see on the left a small pane with the heading Project-VBA Project that lists the elements of the workbook, including Module 1, which is the default name for the collection of things you might type in the editing screen (if the pane is not present, click View/Project Window).  You should also see on the left a pane with the heading Properties-Module 1 (if it is not there, click View/Properties).  You can rename Module 1 to something more useful by highlighting Module 1 in the Properties Window and typing the new name.  You can add another module by clicking Insert/Module again.  If you save the Excel workbook, all of the modules (and hence all of the subroutines and functions created in them) are saved with the workbook.  

If you open the workbook distributed with this book, you will see in the Project Window modules named Chapt2, Chapt3, \ldots, Chapter 13.  Each of these modules contains the VBA code in the corresponding book chapter.  To view the code in a particular module, right-click on its name in the Project Window and select View Code.  You will see a collection of programs separated by gray lines (which are added by the VBA editor to make things more readable).  Each subroutine starts with \verb!Sub! and ends with \verb!End Sub! and each function starts with \verb!Function! and ends with \verb!End Function!.  You will also see ``Option Explicit'' at the top of each module---this will be discussed below.

The organization of subroutines and functions into modules is not important (except for globally defined variables, which are not used in this book).  All of the subroutines and all of the functions in all of the modules in any open workbook are available to use in any open workbook.  However, you may find it convenient to organize your work into separate modules, for example Homework1, Homework2, etc. 

If you open multiple workbooks, and open the VBA editor with one of them, then the Project Window will list each workbook and the modules associated with each.  When the workbooks are saved, each set of modules will be saved with the associated workbook.  

If VBA catches an error (normally a syntax error or an undeclared variable if ``Option Explicit'' has been declared) when executing a subroutine or function, a message box will pop up to inform the user.  If the ``Debug'' option is chosen in this box, the offending VBA code will be highlighted in the VBA editor.  After correcting the error, you need to click Run/Reset in the editor (or the square button in the editor's toolbar).

VBA ignores everything written on a line following an apostrophe, so comments can be placed on any line by preceding them with an apostrophe.  Including comments in your subroutines and functions is very important to make them understandable.  

The underscore character indicates that a line is to be continued.  For example, 
\small\begin{verbatim}
y = x + 5
\end{verbatim}\normalsize
is the same as
\small\begin{verbatim}
y = x _
+ 5
\end{verbatim}\normalsize
This is useful for breaking long lines.
\section{Subroutines and Functions}

A subroutine is also called a macro.  It is a way of automating tasks, including mathematical calculations, cell formatting, and outputting results to cells.  The subroutines in  this book simulate a random process and output the results to the active worksheet.  The other programs in the book are user-defined functions.  

To execute a macro, click Tools/Macros.  Clicking the name of a macro  and then clicking Run will execute it. A macro or function created in one workbook can be used in another.  To execute a macro created in another workbook, simply open both workbooks at the same time, click Tools/Macros and choose the option ``All Open Workbooks'' for the macros to be displayed.\footnote{Since you will be running macros and using user-defined functions frequently, it is useful to add buttons to the toolbar to execute the keystrokes of clicking Tools/Macros and Insert/Function, if the buttons are not already there.  To add the macro button, click Tools/Customize/Commands/Tools, scroll to Macros, and  drag the ``Macros \ldots" button to the toolbar.  To add the function button, scroll to Insert and  drag the ``Insert Function" button to the toolbar.} 

\vfil\eject
To create a macro in the VBA editor, type 
\small\begin{verbatim}
Sub WhateverNameYouWant()
...
list of commands
...
End Sub
\end{verbatim}\normalsize
You will notice that the editor automatically adds the parentheses \verb!()! at the end of the subroutine name and adds the \verb!End Sub! statement when you type \verb!Sub WhateverNameYouWant!.

A user-defined function is executed just like any other Excel function---in a cell of the spreadsheet, type  \verb!=FunctionName(arguments)!.  The arguments supplied to the functions can be numbers or can be cell references, just as with any other Excel function.
To see the user-defined functions that have been created, click Insert/Function and select the category User Defined.  You may see a lot of functions created by Excel add-ins in addition to the functions that are in the modules.  You can also execute a function by double-clicking on its name here.

To create a function in the VBA editor, type
\small\begin{verbatim}
Function AnotherName(argument1, argument2, ..., lastargument)
...
list of commands
...
AnotherName = WhateverTheAnswerMightBe
End Function
\end{verbatim}\normalsize



\section{Message Box and Input Box}
One way for a subroutine or function to deliver information is through the \verb!MsgBox! function.  In Module 1, type
\small\begin{verbatim}
Sub WhateverNameYouWant()
MsgBox("Whatever you want to type.")
End Sub
\end{verbatim}\normalsize
When you execute this macro, a message box will pop up, displaying the message.  To close the message box, click OK.  
The message box function is useful primarily for displaying error messages.    However, the message box can also return the results of mathematical operations, as the next example shows.
\vfil\eject

One way for a subroutine or function to obtain information from the user is via the \verb!InputBox! function.   In Module 1, type
\small\begin{verbatim}
Sub AnotherSub()
x = InputBox("What is your favorite number?")
MsgBox("You said your favorite number was  " & x)
End Sub
\end{verbatim}\normalsize
When you execute this macro, a box will pop up displaying the text ``What is your favorite number?'' and providing a facility for inputting a number.  When you hit Enter or click OK, the input box will disappear and the message box will appear, displaying the message and the number you chose.



\section{Writing to and Reading from Cells}

You can write a number, text, or formula to any cell in any worksheet of any open workbook.  For example, executing the following macro
\small\begin{verbatim}
Sub WritingTest()
Workbooks("Book1.xls").Sheets("Sheet1").Range("B3").Value = 7
End Sub
\end{verbatim}\normalsize
will write the number 7 to cell B3 of Sheet1 of Book1.xls.  The statement can be shortened to
\small\begin{verbatim}
Sheets("Sheet1").Range("B3").Value = 7
\end{verbatim}\normalsize
if you want to write to the active workbook, 
and it can be shortened to
\small\begin{verbatim}
Range("B3").Value = 7
\end{verbatim}\normalsize
if you want to write to the active sheet in the active workbook.
To write text to the cell, enclose it in parentheses; for example, we could replace \verb!Value = 7! with \verb!Value = "some text"!.  It is also possible to write a formula to a cell by replacing  \verb!Value = 7! with, for example, \verb!Formula = "=A6"!.  Running any macro of this sort will over-write anything that may already be in cell B3.

In the macros in this book, rather than writing to a particular cell, we write to the active cell of the active sheet of the active workbook (i.e., the cell in which the cursor is) and to cells surrounding the active cell.  This is done as follows:
\small\begin{verbatim}
Sub WritingTest()
Workbooks("Book1.xls").Sheets("Sheet1").Range("B3").Value = 7
End Sub
\end{verbatim}\normalsize
This macro writes the number 7 to the active cell and the number 8 to the cell that is one row below and two columns to the right of the active cell. 

A subroutine or function can also read directly from a cell in a workbook, though we do not use that feature in this book.  The syntax is the same as for writing to a cell; for example, \verb!x = ActiveCell.Value! assigns the value in the active cell to the variable \verb!x!.

The formatting of cells (and ranges of cells) can also be changed in Excel macros.  Moreover, the active cell/sheet/workbook can also be selected within a macro, and charts can be generated within macros, etc.  We use VBA mainly as a computational engine in this book rather than as a means to create and modify worksheets, so we do not use many of the features of Excel VBA.

\section{Variables and Assignments}

Variable names must begin with a letter, be less than 256 characters long, and cannot include various special characters (in particular, they cannot contain blank spaces, hyphens or periods).  Variable names are not case sensitive: \verb!a! is the same variable as \verb!A! (in fact, you may find the VBA editor changing the capitalization of names to maintain consistency across a project).  It is of course a good idea to use names that mean something, so your programs are easier to read later.  You cannot use any name already reserved by VBA or Excel; for example, attempting to create a variable with the name \verb!Sub! will generate an error message.
 
An expression like \verb!y = x + 3! is an assignment statement (unless it is prefaced by an \verb!If!, \verb!ElseIf! or \verb!Do While!---see below).  The computer evaluates the right-hand side, by looking up the value already assigned to \verb!x!, adding~3, and storing this value in the memory space reserved for \verb!y!.  A statement like \verb!x = x + 3! is perfectly acceptable.  It simply adds 3 to the value of \verb!x!.  It doesn't matter whether you add spaces around the = and + signs; the VBA editor will automatically adjust the spacing.

It is optional whether you must specifically allocate memory space for a variable.  If you type ``Option Explicit'' in a VBA module, then all variables must be declared.  This is done with the keyword \verb!Dim! at the beginning of the program (more on this below).  If you do not type ``Option Explicit,'' then you can create a new variable in the middle of a program simply by assigning it a value.  For example, you can type \verb!y = x+3!.  If \verb!y! has not been previously defined, then it will be created and assigned the value \verb!x+3!.  If \verb!x! has not been defined, it will be created and given the value 0.  

The main virtue of selecting ``Option Explicit'' is that it helps to avoid typographical errors.  Suppose for example that you intend to assign a new value to a variable named \verb!HardToSpell!.  If you misspell the name in the assignment statement and have not declared ``Option Explicit,'' then VBA will create a new variable with the misspelled name.  The program will still execute, but it will not calculate what you intended it to calculate.  Likewise, if you intend to perform some operation with \verb!HardToSpell! and assign the result to another variable and you misspell \verb!HardToSpell!, then a new variable will be created with the misspelled name, given a value of zero, and the operation will be performed with the value zero rather than with the value of \verb!HardToSpell!.  In both cases, with ``Option Explicit'' declared, VBA will generate an error message alerting you to the misspelling.

\section{Mathematical Operations}

The basic mathematical operations are performed in VBA in the same way as in Excel: addition, subtraction, multiplication (the asterisk symbol), division (/), and exponentiation (the caret symbol---\verb!3^2! is 3 squared).  The natural exponential is also the same in VBA as in Excel: \verb!Exp(6)! is $\E^6$.  The square root and natural logarithm functions are also available in VBA but with different names than in Excel.  The name of the square root function is \verb!Sqr! in VBA (rather than \verb!Sqrt! as in Excel) and the name of the natural logarithm function is \verb!Log! in VBA (rather than \verb!Ln! as in Excel).  It does not matter whether or not  you capitalize the names; the VBA editor will automatically capitalize, converting for example \verb!exp! to \verb!Exp!.

Other mathematical functions are used in VBA by preceding their Excel names with \verb!Application.!  For example \verb!Application.Max(3,4)! returns the larger of 3 and 4.  Of course, VBA means ``Visual Basic for Applications'' and the application being used here is Excel, so the name \verb!Application.Max! indicates that the Excel \verb!Max! function is to be used.  A function that we use frequently is \verb!Application.NormSDist(d)!, which returns the probability that a standard normal random variable is less than or equal to \verb!d!.

\section{Random Numbers}

Computers do not behave in a random way (though of course it may seem like it when one crashes) but  they can generate sequences of numbers that pass statistical tests for randomness.  The basic construction is the generation of a random integer in some range $[0,N]$ with each integer in the range being ``equally likely.''  Dividing by $N$ gives a number between 0 and 1 that has the appearance of being uniformly distributed.  This number can then be transformed to give the appearance of a normal distribution or other standard distributions.  Random integers are generated sequentially by an algorithm of the type $I_j = aI_{j-1}+c$ mod $N$, for constants $a$ and $c$.  ``mod $N$'' means the remainder after dividing by $N$ (7 mod 5 is 2, 10 mod 3 is 1, etc.).  In this construction, $I_{j-1}$ is called the ``seed,'' and each integer becomes the seed for the next.  This is certainly not a random construction, but if the constants and~$N$ are suitable chosen ($N$ must be very large) then the integers will have the appearance of unpredictability, both to the human observer and according to formal statistical tests.  

VBA has a built-in function for generating random variables that are uniformly distributed between 0 and 1.  This function is called \verb!Rnd()!.  The same function is in Excel but  called \verb!Rand()!. Applying the inverse of the standard normal cumulative distribution function to a random variable that is uniformly distributed between 0 and 1 will generate a random variable with the standard normal distribution (i.e, the normal distribution with  mean 0 and variance 1).  The inverse of the standard normal cumulative distribution function is provided in Excel as the \verb!NormSInv! function, and hence it can be called in VBA as \verb!Application.NormsInv!.  Given the existence of the \verb!NormSInv! function, this is the simplest, though not the fastest, way to transform a uniformly distributed random variable into a normally distributed one.  To reduce typing, the following function is used throughout this book.

\addcontentsline{lof}{figure}{RandN}
\small\begin{verbatim}
Function RandN()
   RandN = Application.NormSInv(Rnd())
End Function
\end{verbatim}\normalsize

\section{For Loops}

A loop is a command or set of commands that executes repeatedly either for a fixed number of times or until some condition is violated.  To execute the commands for a fixed number of times, use a ``{for loop.''

To add the first 10 integers together we can create the following macro:
\small\begin{verbatim}
Sub AddIntegers()
x = 1
For i = 2 To 10
    x = x + i
Next i
ActiveCell.Value = x
End Sub
\end{verbatim}\normalsize
In the above, we first initialized the value of \verb!x! to be 1.  The statement(s) between the \verb!For! statement and the \verb!Next! statement are executed repeatedly.  In the first passage through the loop, the variable \verb!i! has the value 2 and the statement \verb!x = x + i! translates as \verb!x = 1 + 2!, so \verb!x! is given the value 3.  In the next passage, \verb!i! has the value 3 and \verb!x! has the value 3, so the statement \verb!x = x + i! translates as \verb!x = 3 + 3!, and \verb!x! is given the value 6, etc.  

Any variable name (not just \verb!i!) can be used as a counter.  The indentation of the line \verb!x = x + i! is optional and serves only to make the program easier to read.

The number of iterations need not be fixed when the program is written.  We can use variables in the \verb!For! statement like \verb!For i = y To z!.  The number of iterations will then be determined by the values of \verb!y! and \verb!z! when the for loop is encountered.  

In the statement \verb!For i = 2 To 10!, MATLAB increases \verb!i! by one each time it reaches the statement \verb!Next i!.  This is the default, but it can be changed.  If you want \verb!i! to increase by two each time, you can write 
\small\begin{verbatim}
For i = 2 To 10 Step 2.
\end{verbatim}\normalsize
Negative step sizes and non-integer step sizes are also acceptable.  For example, the statement \verb!For i = 10 To 1 Step -1! produces a loop that executes ``backwards,'' starting from \verb!i = 10! and counting down until \verb!i = 2!.  

\section{While Loops and Logical Expressions}

A ``while loop'' executes a block of statements repeatedly until some condition is violated.  For example a crude way to add the first 10 integers would be with the following macro:

\small\begin{verbatim}
Sub AddIntegers2()
x = 0
i = 1
Do While i <= 10
    x = x + i
    i = i + 1
Loop
ActiveCell.Value = x
End Sub
\end{verbatim}\normalsize

When the program first encounters the \verb!Do While! statement, it checks whether the condition $\verb!i! \leq 10$ is true.  If it is, then the statements preceding the \verb!Loop! statement are executed.  The condition $\verb!i!\leq 10$ is then checked again, and the statements are executed repeatedly in this way until the condition $\verb!i! \leq 10$ is false.  Be careful that the statements being executed will eventually cause the condition to be false.  

The comparison operators that can be used in the \verb!Do While! statement (and \verb!If! and \verb!ElseIf! described below) are less than (\verb!<!), less than or equal to (\verb!<=!), greater than (\verb!>!), greater than or equal to (\verb!>=!), and equal to (\verb!=!).  

The expression \verb!Not(i > 10)! is equivalent to \verb!(i <= 10)!.  Multiple conditions can be combined: the expression \verb! i <= 10 And  y > 6!
is true if (and only if) both $\verb!i!\leq 10$ and $\verb!y!>6$ are true, and the expression 
\verb!i <= 10 Or y > 6! is true if either or both of its component statements is true.  

\section{If, Else, and ElseIf Statements}

You can cause a statement to execute only when a certain condition is satisfied by prefacing it with an \verb!If! statement.  The format is
\small\begin{verbatim}
If y <= 10 Then
    x = 2 * x
End If
\end{verbatim}\normalsize
\noindent which doubles \verb!x! if $\verb!y!\leq 10$ and does nothing otherwise.  Rather than doing nothing otherwise, you can cause a different statement or block of statements to execute when the condition is violated by including an \verb!Else!.  For example,
\small\begin{verbatim}
If y <= 10 Then
    x = 2 * x
Else
    x = 3 * x
End If
\end{verbatim}\normalsize
In this case, if $\verb!y! > 10$, the statements following the \verb!Else! statement execute, tripling \verb!x!.  Finally, you can check multiple conditions sequentially with \verb!ElseIf!.  Consider the following:
\small\begin{verbatim}
If y <= 10 Then
    x = 2 * x
ElseIf y <= 20 Then
    x = 3 * x
ElseIf y <= 30 Then
    x = 4 * x
Else
    x = 5 * x
End If
\end{verbatim}\normalsize
\noindent The conditions are checked sequentially as follows.  If $\verb!y!\leq 10$, then \verb!x! is doubled and execution of of the \verb!If! block ends.  If $\verb!y! > 10$, the condition $\verb!y! \leq 20$ is checked.  If this is true, \verb!x! is tripled.  If it is not true, the next condition is checked, etc.  The result is that \verb!x! is doubled when $\verb!y!\leq 10$; it is tripled when $10<\verb!y!\leq 20$; it is quadrupled when  $20<\verb!y!\leq 30$; and it is quintupled when $\verb!y!>30$.

\section{Variable Declarations}
As mentioned before, if ``Option Explicit'' is declared, each variable must be declared at the beginning of a subroutine or function.  A variable can be declared to be of a specific type or the type can be left unspecified and VBA will choose what seems to be the appropriate type.  For numerical calculations, the important types are Integer, Long, Double, and Variant.  The Integer data type is for storage of integers between -32,768 and 32,769.  The Long data type can store integers between plus or minus 2 billion (actually a bit more than 2 billion).  The Double data type stores arbitrary (floating point) numbers, to sixteen digits of accuracy.  The Variant data type is the default  type for variables whose type is not specified, and it adjusts itself automatically to the data stored within it.  To declare a variable to be of a particular type, there are two equally acceptable syntaxes.  For example, the Double type can be declared either as \verb!Dim x As Double! or \verb!Dim x#!.  The Integer type can be declared either as \verb!Dim x As Integer! or \verb!Dim x%!.  Note that the syntax \verb!Dim i, j, k As Integer! is acceptable but it declares only \verb!k! as being of type Integer, with \verb!i! and \verb!j! still being of type Variant.  On the other hand, \verb!Dim i%, j%, k%! declares \verb!i!, \verb!j! and \verb!k! as being of type Integer.  

In this book, the data type is  left unspecified (hence as Variant), with the exception that the type of large arrays is declared.  The Variant data type requires more memory for storage, so this is a bit inefficient.  



Variables declared within a function or subroutine are ``local variables.''  They can only be accessed within the function or subroutine within which they are defined.  To understand this, consider the following  simple example  of a function (\verb!TestFunction!) calling another function (\verb!AddTwo!).
\small\begin{verbatim}
Function TestFunction(x)
TestFunction = x * AddTwo(x)
End Function
\end{verbatim}\normalsize

\small\begin{verbatim}
Function AddTwo(x)
Dim y
y = x + 2
AddTwo = y
End Function
\end{verbatim}\normalsize
The result of \verb!TestFunction(3)! is  $3 \times 5 = 15$.  
Consider now the following (strange) change to \verb!TestFunction!.
\small\begin{verbatim}
Function TestFunction(x)
Dim z
z = x * AddTwo(x)
TestFunction = y
End Function
\end{verbatim}\normalsize
The new feature is that \verb!TestFunction(x)! attempts to return \verb!y!, which is defined only in \verb!AddTwo!.   If  \verb!TestFunction(3)! is executed, then one of two things will happen: (i) if ``Option Explicit'' has been declared, an error message will appear with the information that the variable \verb!y! has not been declared within \verb!TestFunction!, or (ii) if ``Option Explicit'' has not been declared, the function will return a value of zero.  The reason in both cases is that the variable \verb!y! defined within \verb!AddTwo! is not available to  \verb!TestFunction!---it is local to \verb!AddTwo!.  In case (ii), a new variable \verb!y! is created within \verb!TestFunction! and, like all new variables, is given a default value of zero.  The error message is probably preferable in this circumstance, which points again to the value of the ``Option Explicit'' declaration.

It is possible to declare a variable so that it is available to (and can be modified by) all of the functions in a module, or all of the functions in a workbook, or even all of the functions in all open workbooks.  Such variables are called ``global variables.''  That facility is  useful in some situations, but it is not used in this book.

\section{Variable Passing}

As we have seen, functions and macros can call other functions or macros to perform part of their work.  For example, macros shown previously in this appendix call the \verb!MsgBox! function.  
The default arrangement in VBA is that variables are passed to functions (or to macros---though  variables are not passed to macros in this book) ``by reference'' rather than ``by value.''  This means that the actual memory location of the variable is given to the function, and any changes made to a variable by a function will affect the use of the variable in a calling function.  Consider, for example the following simple change to the function \verb!AddTwo!:
\small\begin{verbatim}
Function AddTwo(x)
x = x + 2
AddTwo = x
End Function
\end{verbatim}\normalsize
This function still adds the number 2 to its input.  Now when we execute 
\small\begin{verbatim}
TestFunction(3)
\end{verbatim}\normalsize and it reaches the line
\small\begin{verbatim}
TestFunction = x * AddTwo(x)
\end{verbatim}\normalsize
it will be multiplying \verb!x! by 5 as before.  However, now \verb!x! has been changed in \verb!AddTwo! from 3 to 5, so the result of \verb!TestFunction(3)! is $5 \times 5 = 25$.

This may sometimes be what one wants, but it is more likely that it will produce mistakes.  There are two possible solutions.  One is to change the function \verb!AddTwo! as follows:
\small\begin{verbatim}
Function AddTwo(ByVal x)
x = x + 2
AddTwo = x
End Function
\end{verbatim}\normalsize
This forces VBA to pass only the value of \verb!x! and not the memory location.  So when 2 is added to \verb!x! and returned to \verb!TestFunction(3)!, the value of \verb!x! in \verb!TestFunction! is still 3.

The second solution is more straightforward:  simply do not change input variables within a function.  That is, we can use our first version of \verb!AddTwo!, which created a new variable to store the sum of \verb!x! and 2, rather than changing the value of \verb!x! (or we could use the simpler one-line function \verb!AddTwo = x + 2!).  The functions in this book follow this second approach---\textbf{we avoid changing the values of input variables}.

\section{Arrays}

It is very useful to be able to use a single variable name to store multiple values.  For example, we can write loops such as
\small\begin{verbatim}
For i = 1 To 10
    x(i) = whatever
Next i
\end{verbatim}\normalsize
An array variable must be declared, regardless of whether ``Option Explicit'' is declared.  Normally, the declaration takes the form \verb!Dim x(10)! if the largest index number of \verb!x! is known (to equal 10) when the function or macro is written.  The default in VBA is that the first element is indexed by 0.\footnote{This can be changed so that the default is for the first element to be indexed by~1 with the statement ``Option Base 1.''} Therefore, \verb!Dim x(10)! creates a vector with 11 elements, which are accessed as \verb!x(0)!, \ldots, \verb!x(10)!.  The type of each element is Variant, unless it is declared otherwise---for example, \verb!Dim x(10) As Integer! reserves memory locations for 11 integers.
Multidimensional arrays can also be used.  For example, \verb!x(10, 6, 12)! creates a 3-dimensional array, with $11 \times 7 \times 13$ elements.  The first index does not have to be zero.  The declaration \verb!Dim x(1 To 10)! creates a vector with 10 elements, which are accessed as \verb!x(1)!, \ldots, \verb!x(10)!.  Likewise, one can use, for example \verb!Dim x(-6 To 3)!  to start the indexing at -6 and end at 3.

If the dimension of the array is not fixed, which is often the case, then normally it must be declared with empty parentheses---for example, \verb!Dim x()!.    The dimension will depend on the input arguments, or on calculations based on the input arguments.  Before the array is used, the program must include a statement specifying the dimension, of the form \verb!ReDim x(N)!, or \verb!ReDim x(1 To N)!, where the variable \verb!N! is either an input argument to the function or has been calculated prior to the statement \verb!ReDim x(N)!.

The exception to the above statements about declaring array variables, whether the number of elements is known in advance or not, is when an array is assigned to a variable by a call to a function.  The \verb!Array! function is one example of a function that creates an array.  For example
\small\begin{verbatim}
Dim x
x= Array(3, 6, 7)
\end{verbatim}\normalsize
will create an array with elements \verb!x(0)=3!, \verb!x(1)=6!, and \verb!x(2) = 7!.  Replacing \verb!Dim x! with  \verb!Dim x(2)! in this context will not work.


Functions can take arrays as inputs and return arrays as outputs. Arrays can be input by (i) typing the array as an argument of the function, (ii) inputting the worksheet cells in which the array resides, or (iii) passing the array as an output from another function.  An array created in one function is passed to another function in the same way that any other variable is passed.  To type an array as an input, enclose it curly braces, separate items in each row with a comma, and separate rows with a semicolon---for example $\{3,1,2; 4,6,2\}$ is an array with two rows and three columns, the first row being $\{3,1,2\}$ and the second row being $\{4,6,2\}$.  The same array might be input via cell references as \verb!B3:C5!.

Arrays can also be output to Excel worksheets.  Consider the following:
\small\begin{verbatim}
Function MyArray(x)
Dim y(3)
For i = 1 To 3
  y(i) = i * x
Next i
MyArray = y
End Function
\end{verbatim}\normalsize
Note that the array \verb!y! has four elements.  The program does not define element~0, so it is zero by default.  If we execute MyArray(2), the other elements will be \verb!y(1) = 2!, \verb!y(2) = 4!, and \verb!y(3) = 6!.   If we execute the function by typing \verb!=MyArray(2)! in a cell of a worksheet, the number 0 will appear. (To avoid this and have the output show up in three cells instead of four, we could have declared \verb!Dim y(1 To 3)!.)   To see the rest of the output, highlight the active cell and the three cells immediately to the right on the same row.  Click the function key F2 and then hold down the key combination CTRL-SHIFT-ENTER.  This is the standard Excel procedure for displaying arrays returned by functions.  For example, the output of Excel's matrix algebra functions, such as \verb!MMULT!, is revealed in the same way.\footnote{Once this is done, the individual cells in which the array was output cannot be changed.  Attempting to do so will generate an error message, and it may be necessary to hit the Escape key once or twice to allow any use of the worksheet after the error message appears.}
Two-dimensional arrays can be output to worksheets in the same way.  

 
 
 \section{Debugging}
Errors (bugs) are inevitable.  VBA will catch some types (for example, syntax errors) and inform you.  The more troublesome errors are those that do not prevent the program from running but lead to incorrect results.  It is essential therefore to debug each program carefully.  

To debug a subroutine, put the cursor on the subroutine name in the Visual Basic editor.  Click on Debug/Step Into (or the function key F8) to step through the subroutine one line at a time.  Putting the cursor over any variable will show the value of the variable at that stage of the program.  To observe the values of variables more systematically, you can include statements of the form \verb!Debug.Print x! or \verb!Debug.Print "The value of x is " & x! in the subroutine.  The subroutine will then print to the Immediate Window.  To view the Immediate Window, click View/Immediate Window.  Click on Run/Reset (or the square button on the toolbar) to discontinue debugging.  

To debug a function, one can rewrite it as a subroutine, defining values for the input variables in the beginning of the subroutine.  
The VBA debugger has many other features.  Debug/Step Over is particularly useful for stepping over a line that does not need to be checked and will be time consuming to check, for example, a call to another function.