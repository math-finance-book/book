{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "\\newcommand{\\d}{\\,\\mathrm{d}}\n",
        "\\newcommand{\\e}{\\mathrm{e}}\n",
        "\\newcommand{\\E}{\\mathbb{E}}\n",
        "\n",
        "\n",
        "\n",
        "# Introduction to Binomial Tree Model {#sec-c:introbinomial} \n",
        "\n",
        "The binomial tree model is a discrete-time framework used to price derivative securities. It is widely used in financial engineering for valuing options and other contingent claims. This model is particularly useful because it provides an intuitive approach to pricing and allows for easy incorporation of various features such as early exercise in American options.\n",
        "\n",
        "## Basics of the Binomial Tree Model\n",
        "The binomial tree model is based on the assumption that, over a small time step, the price of an underlying asset can move up or down by a certain factor. The model is constructed iteratively to estimate the fair value of derivatives such as options.\n",
        "\n",
        "An $n$ period binomial tree model can be described as follows:\n",
        "\n",
        "1. There are $n+1$ time points with $t=0, \\Delta t, 2 \\Delta t, ..., n\\Delta t$, where $\\Delta t$ is the time step.\n",
        "\n",
        "2. At each time point $t$, the price of the underlying asset either goes up by a factor $u_t>1$ with probability $p_t\\in(0,1)$ or goes down by a factor $d_t<1$ with probability $1-p_t$.\n",
        "\n",
        "3. Given an initial stock price $S_0$,  the price of the underlying asset evolves as:\n",
        "\n",
        "$$\n",
        "S_{t+\\Delta t} = S_t \\times u_t \\quad \\text{(up move)}\n",
        "$$\n",
        "or\n",
        "$$\n",
        "S_{t+\\Delta t} = S_t \\times d_t \\quad \\text{(down move)}\n",
        "$$\n",
        "\n",
        "4. The absence of arbitrage ensures the model can be solved using risk-neutral valuation, where the risk-neutral probability of an up move is:\n",
        "\n",
        "$$\n",
        "p_t = \\frac{e^{r_t \\Delta t} - d_t}{u_t - d_t}\n",
        "$$\n",
        "\n",
        "where $ r_t $ is the risk-free rate from $t$ to $t+\\Delta t$.\n",
        "\n",
        "### Example: Three-Period Recombining Binomial Tree\n",
        "This is an example of a three-period recombining binomial tree: $n=3$, $u=1.1$, $d=1/u$, $\\Delta t=1$:\n"
      ],
      "id": "536ca672"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| output: true\n",
        "import plotly.graph_objects as go\n",
        "\n",
        "def plot_symmetric_binomial_tree(S0=100, u=1.1):\n",
        "    d = 1 / u  # Down factor\n",
        "    periods = 3  # Number of periods\n",
        "\n",
        "    # Define nodes with symmetric positioning\n",
        "    nodes = {}\n",
        "    for t in range(periods + 1):\n",
        "        for j in range(t + 1):\n",
        "            x = t  # Time step on x-axis\n",
        "            y = 2 * j - t  # Centered y-axis positioning for symmetry\n",
        "            nodes[(x, y)] = round(S0 * (u ** j) * (d ** (t - j)), 2)\n",
        "\n",
        "    # Define edges\n",
        "    edges = []\n",
        "    for t in range(periods):\n",
        "        for j in range(t + 1):\n",
        "            x = t\n",
        "            y = 2 * j - t\n",
        "            edges.append(((x, y), (x + 1, y + 1)))  # Up move\n",
        "            edges.append(((x, y), (x + 1, y - 1)))  # Down move\n",
        "\n",
        "    fig = go.Figure()\n",
        "\n",
        "    # Add edges to the plot\n",
        "    for edge in edges:\n",
        "        x_coords = [edge[0][0], edge[1][0]]\n",
        "        y_coords = [edge[0][1], edge[1][1]]\n",
        "        fig.add_trace(go.Scatter(x=x_coords, y=y_coords, mode='lines', line=dict(color='black'), showlegend=False))\n",
        "\n",
        "    # Add nodes to the plot\n",
        "    x_vals = [key[0] for key in nodes.keys()]\n",
        "    y_vals = [key[1] for key in nodes.keys()]\n",
        "    labels = [str(nodes[key]) for key in nodes.keys()]\n",
        "\n",
        "    fig.add_trace(go.Scatter(\n",
        "        x=x_vals, y=y_vals, mode='markers+text',\n",
        "        marker=dict(size=20, color='lightblue'),\n",
        "        text=labels, textposition=\"top center\",\n",
        "        showlegend=False\n",
        "    ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"3-Period Symmetric Binomial Tree (u=1.1, d=1/u)\",\n",
        "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        plot_bgcolor='white',\n",
        "        width=700,\n",
        "        height=500\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "\n",
        "plot_symmetric_binomial_tree()"
      ],
      "id": "17d54f62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| eval: true\n",
        "#| output: true\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "def plot_symmetric_binomial_tree(S0=100, u=1.1, vertical_scale=0.5, title_pad=20):\n",
        "    \"\"\"\n",
        "    Plots a 3-period symmetric binomial tree using Matplotlib,\n",
        "    with options to compress the vertical spacing and add space between the title and the plot.\n",
        "\n",
        "    :param S0: initial stock price\n",
        "    :param u: up factor\n",
        "    :param vertical_scale: compresses or expands the vertical spacing\n",
        "    :param title_pad: extra spacing between the title and the tree (in points)\n",
        "    \"\"\"\n",
        "    d = 1 / u  # Down factor\n",
        "    periods = 3  # Number of periods\n",
        "\n",
        "    # Define nodes with symmetric positioning\n",
        "    nodes = {}\n",
        "    for t in range(periods + 1):\n",
        "        for j in range(t + 1):\n",
        "            x = t\n",
        "            y = vertical_scale * (2 * j - t)  # scale the vertical distance\n",
        "            nodes[(x, y)] = round(S0 * (u**j) * (d**(t - j)), 2)\n",
        "\n",
        "    # Define edges\n",
        "    edges = []\n",
        "    for t in range(periods):\n",
        "        for j in range(t + 1):\n",
        "            x = t\n",
        "            y = vertical_scale * (2 * j - t)\n",
        "            # Up move\n",
        "            edges.append(((x, y), (x + 1, y + vertical_scale)))\n",
        "            # Down move\n",
        "            edges.append(((x, y), (x + 1, y - vertical_scale)))\n",
        "\n",
        "    # Create a Matplotlib figure\n",
        "    fig, ax = plt.subplots(figsize=(7, 5))\n",
        "\n",
        "    # Plot edges\n",
        "    for edge in edges:\n",
        "        x_coords = [edge[0][0], edge[1][0]]\n",
        "        y_coords = [edge[0][1], edge[1][1]]\n",
        "        ax.plot(x_coords, y_coords, color='black')\n",
        "\n",
        "    # Plot nodes\n",
        "    x_vals = [k[0] for k in nodes.keys()]\n",
        "    y_vals = [k[1] for k in nodes.keys()]\n",
        "    labels = [str(nodes[k]) for k in nodes.keys()]\n",
        "    ax.scatter(x_vals, y_vals, s=300, color='lightblue')\n",
        "\n",
        "    # Add text labels above each node\n",
        "    for x, y, label in zip(x_vals, y_vals, labels):\n",
        "        ax.text(x, y + 0.3 * vertical_scale, label, ha='center', va='bottom')\n",
        "\n",
        "    # Title with extra spacing set by 'pad'\n",
        "    ax.set_title(\n",
        "        f\"3-Period Symmetric Binomial Tree (u={u}, d={round(d,2)})\",\n",
        "        pad=title_pad\n",
        "    )\n",
        "\n",
        "    # Style the plot\n",
        "    ax.axis(\"equal\")\n",
        "    ax.axis(\"off\")\n",
        "\n",
        "    plt.show()\n",
        "\n",
        "# Example usage: extra spacing of 20 points between the caption and the tree\n",
        "plot_symmetric_binomial_tree(vertical_scale=0.5, title_pad=20)\n"
      ],
      "id": "e8911d39",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Approximation of Continuous Stochastic Processes\n",
        "\n",
        "A binomial tree is a discrete-time stochastic process with two possible outcomes at each time step. In its simplest form, at every step the process moves either up or down by a fixed factor or amount, with specified probabilities. This construction can be used to approximate almost any continuous stochastic processes. The main idea is as follows:\n",
        "\n",
        "1. Discrete Steps:\n",
        "\n",
        "   In a binomial tree, time is divided into small increments (say, $\\Delta t$). At each time step, the process moves up by a factor $u$ or down by a factor $d$. This is analogous to a random walk where at each step you move one unit to the right or left.\n",
        "\n",
        "2. Probabilities and Expected Change:\n",
        "\n",
        "   By choosing the probabilities (say $p$ for an up move and $1-p$ for a down move) appropriately, you can control the drift and variance of the process. For a symmetric random walk, you might set $p = 0.5$. More generally, one can adjust these parameters so that, over many steps, the binomial model matches the first two moments (mean and variance) of the random walk you want to approximate.\n",
        "\n",
        "3. Convergence to a Continuous Process:\n",
        "\n",
        "   As you make the time steps smaller (i.e., $\\Delta t \\to 0$) and choose $u$ and $d$ appropriately (for example, $u = e^{\\sigma\\sqrt{\\Delta t}}$ and $d = e^{-\\sigma\\sqrt{\\Delta t}}$ for volatility $\\sigma$), the binomial process converges in distribution to a continuous-time process, such as Brownian motion (or a geometric Brownian motion if you’re modeling stock prices).\n",
        "\n",
        "4. Example: \n",
        "\n",
        "   Suppose you have a simple random walk starting at 0. At each time step:\n",
        "\n",
        "   - With probability $0.5$, add 1 (up move).\n",
        "   - With probability $0.5$, subtract 1 (down move).\n",
        "\n",
        "   This is a binomial tree where the position after $n$ steps is given by:\n",
        "   $$\n",
        "   X_n = X_0 + (\\text{number of up moves}) - (\\text{number of down moves}).\n",
        "   $$\n",
        "   As $n$ grows, by the Central Limit Theorem, the distribution of $X_n$ becomes approximately normal, just like a random walk with Gaussian increments.\n",
        "\n",
        "5. Application in Finance:\n",
        "\n",
        "   In financial modeling, the binomial tree is used to approximate the price evolution of an asset. The tree method provides a simple numerical technique to value options and other derivatives by stepping through the possible future asset prices and then discounting back to the present.\n",
        "\n",
        "In summary, the binomial tree model can approximate a continuous stochastic process by discretizing time into small intervals with two possible outcomes at each step. With the right choice of parameters and as the step size decreases, the binomial process can approximate well the behavior of the continuous stochastic process, while keeping the numerical valuation of simple. \n",
        "\n",
        "## A Generalized $n$-Period Tree\n",
        "\n",
        "We can generalize  the above basic binomial tree to a more general one where each node at any time $t$ can have a variable number of branches and the branching pattern can vary across both time steps and nodes. This flexible structure can be useful for pricing more complex derivative securities. \n",
        "\n",
        "### Definition of a Generalized $n$-period tree\n",
        "\n",
        "#### 1. Tree Structure\n",
        "\n",
        "We define the tree as a directed graph $T = (N, E)$, where:\n",
        "\n",
        "- $N$ is the set of nodes.\n",
        "- $E \\subseteq N \\times N$ is the set of edges, representing transitions between nodes across periods.\n",
        "\n",
        "Each node is indexed by:\n",
        "\n",
        "$$\n",
        "N_{t,i}, \\quad t = 0, 1, \\dots, n, \\quad i = 1, \\dots, |N_t|\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $t$ represents the time point,\n",
        "- $i$ represents the node index at time $t$,\n",
        "- $|N_t|$ denotes the number of nodes at time $t$.\n",
        "\n",
        "---\n",
        "\n",
        "#### 2. Variable Branching\n",
        "\n",
        "Each node $N_{t,i}$ has $B_{t,i}$ branches, which represents the number of children (next-period nodes) it connects to. The total number of nodes at time $t+1$ is then:\n",
        "\n",
        "$$\n",
        "|N_{t+1}| = \\sum_{i=1}^{|N_t|} B_{t,i}\n",
        "$$\n",
        "\n",
        "Each edge represents a transition probability $P_{t,i,j}$ from node $N_{t,i}$ at time $t$ to node $N_{t+1, j}$ at time $t+1$, satisfying:\n",
        "\n",
        "$$\n",
        "\\sum_{j=1}^{B_{t,i}} P_{t,i,j} = 1, \\quad \\forall i, t\n",
        "$$\n",
        "\n",
        "where $P_{t,i,j}$ is the probability of transitioning from $N_{t,i}$ to $N_{t+1,j}$.\n",
        "\n",
        "---\n",
        "\n",
        "#### 3. Node Values and Transition Rule\n",
        "\n",
        "Each node has a value $S_{t,i}$, which can represent an evolving variable (e.g., stock price, state variable). The value transition function is defined as:\n",
        "\n",
        "$$\n",
        "S_{t+1,j} = f(S_{t,i}, a_{t,i,j})\n",
        "$$\n",
        "\n",
        "where:\n",
        "\n",
        "- $S_{t,i}$ is the value at node $N_{t,i}$,\n",
        "- $a_{t,i,j}$ is a transition factor specific to the branch from $N_{t,i}$ to $N_{t+1,j}$,\n",
        "- $f$ is a value update function, often modeled as:\n",
        "  $$\n",
        "  S_{t+1,j} = S_{t,i} \\times a_{t,i,j}\n",
        "  $$\n",
        "\n",
        "\n",
        "Example: Consider a 3-period tree with variable branching:\n",
        "\n",
        "- Period 0: 1 node ($B_{0,1} = 2$)\n",
        "- Period 1: 2 nodes, each with different branching ($B_{1,1} = 3, B_{1,2} = 2$)\n",
        "- Period 2: 5 nodes, each branching further ($B_{2,1} = 2, B_{2,2} = 2, B_{2,3} = 1, B_{2,4} = 3, B_{2,5} = 2$).\n",
        "\n",
        "The node count evolves as:\n",
        "\n",
        "$$\n",
        "|N_1| = B_{0,1} = 2, \\quad\n",
        "|N_2| = B_{1,1} + B_{1,2} = 3 + 2 = 5, \\quad\n",
        "|N_3| = 2 + 2 + 1 + 3 + 2 = 10\n",
        "$$\n",
        "\n",
        "Thus, a generalized tree dynamically adjusts the branching structure.\n",
        "\n",
        "\n",
        "**Special Cases**\n",
        "\n",
        "- Binomial Tree ($B_{t,i} = 2$): Each node has exactly two branches, leading to an up/down model.\n",
        "- Trinomial Tree ($B_{t,i} = 3$): Each node has three possible transitions (e.g., up, middle, down).\n",
        "- Adaptive Trees: $B_{t,i}$ can depend on volatility or other dynamic parameters.\n",
        "\n",
        "\n",
        "### A Graphical Illustration of a Generalized 3-Period Tree\n",
        "\n",
        "Here is a 3-period example with variable branching:\n"
      ],
      "id": "b2cba9c9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import plotly.graph_objects as go\n",
        "from collections import defaultdict\n",
        "\n",
        "def plot_variable_branching_tree_symmetric():\n",
        "    # 1. Build tree nodes/edges\n",
        "    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 => value=100\n",
        "    edges = []\n",
        "\n",
        "    # next_index[t] tracks how many nodes have been created at period t so far\n",
        "    next_index = defaultdict(int)\n",
        "    next_index[0] = 1  # We have 1 node at t=0\n",
        "\n",
        "    # transitions[(t, i)] = list of factors for each branch out of node (t, i)\n",
        "    transitions = {\n",
        "        (0, 0): [1.1, 0.9],       # At t=0, i=0 => 2 branches\n",
        "        (1, 0): [1.2, 1.0, 0.8],  # At t=1, i=0 => 3 branches\n",
        "        (1, 1): [1.1, 0.85],      # At t=1, i=1 => 2 branches\n",
        "        (2, 0): [1.3, 0.9],       # At t=2, i=0 => 2 branches\n",
        "        (2, 1): [1.2, 1.0],       # At t=2, i=1 => 2 branches\n",
        "        (2, 2): [1.1],            # At t=2, i=2 => 1 branch\n",
        "        (2, 3): [1.15, 0.95, 0.85], # t=2, i=3 => 3 branches\n",
        "        (2, 4): [1.1, 0.9]        # t=2, i=4 => 2 branches\n",
        "    }\n",
        "\n",
        "    # Create nodes/edges\n",
        "    for (t, i), factors in transitions.items():\n",
        "        base_value = nodes[(t, i)]\n",
        "        for factor in factors:\n",
        "            child_t = t + 1\n",
        "            child_i = next_index[child_t]\n",
        "            next_index[child_t] += 1\n",
        "\n",
        "            child_value = round(base_value * factor, 2)\n",
        "            nodes[(child_t, child_i)] = child_value\n",
        "\n",
        "            edges.append(((t, i), (child_t, child_i)))\n",
        "\n",
        "    # 2. Count how many nodes per period => assign symmetrical y-coordinates\n",
        "    nodes_in_period = defaultdict(list)\n",
        "    for (t, i), val in nodes.items():\n",
        "        nodes_in_period[t].append(i)\n",
        "\n",
        "    # For each period t, sort node indexes, then map them to symmetrical positions around 0\n",
        "    coords = {}  # coords[(t, i)] = y_position\n",
        "    for t in sorted(nodes_in_period.keys()):\n",
        "        node_list = sorted(nodes_in_period[t])\n",
        "        count = len(node_list)\n",
        "\n",
        "        # We'll assign positions from 0..(count-1), then shift so center is 0\n",
        "        for idx, node_i in enumerate(node_list):\n",
        "            # E.g., if count=5, positions -> 0,1,2,3,4 => shift by -2 => -2,-1,0,1,2\n",
        "            shift = -(count - 1) / 2\n",
        "            y = idx + shift\n",
        "            coords[(t, node_i)] = y\n",
        "\n",
        "    # 3. Build the plot\n",
        "    fig = go.Figure()\n",
        "\n",
        "    # Add edges\n",
        "    for ((t1, i1), (t2, i2)) in edges:\n",
        "        x_coords = [t1, t2]\n",
        "        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n",
        "        fig.add_trace(go.Scatter(\n",
        "            x=x_coords,\n",
        "            y=y_coords,\n",
        "            mode='lines',\n",
        "            line=dict(color='black'),\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    # Add nodes (markers+text)\n",
        "    for (t, i), val in nodes.items():\n",
        "        fig.add_trace(go.Scatter(\n",
        "            x=[t],\n",
        "            y=[coords[(t, i)]],\n",
        "            mode='markers+text',\n",
        "            marker=dict(size=10, color='blue'),\n",
        "            text=[str(val)],\n",
        "            textposition='top center',\n",
        "            showlegend=False\n",
        "        ))\n",
        "\n",
        "    fig.update_layout(\n",
        "        title=\"3-Period Variable Branching Tree (Symmetric Layout)\",\n",
        "        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),\n",
        "        width=900,\n",
        "        height=600,\n",
        "        plot_bgcolor='white'\n",
        "    )\n",
        "\n",
        "    fig.show()\n",
        "\n",
        "# Call the plotting function\n",
        "plot_variable_branching_tree_symmetric()\n"
      ],
      "id": "33b0ffa5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "from collections import defaultdict\n",
        "\n",
        "def plot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0):\n",
        "    \"\"\"\n",
        "    Plots a 3-period variable branching tree in a narrower vertical \n",
        "    layout and a longer horizontal layout.\n",
        "\n",
        "    :param vertical_scale: Factor (<1 = narrower, >1 = taller) for vertical spacing\n",
        "    :param horizontal_scale: Factor (>1 = longer, <1 = shorter) for horizontal spacing\n",
        "    \"\"\"\n",
        "    # 1. Build tree nodes/edges\n",
        "    nodes = {(0, 0): 100}  # Root node at time t=0, index=0 => value=100\n",
        "    edges = []\n",
        "\n",
        "    # Track how many nodes created at each period t\n",
        "    next_index = defaultdict(int)\n",
        "    next_index[0] = 1\n",
        "\n",
        "    # transitions: dict[(t, i)] -> list of factors from node (t,i)\n",
        "    transitions = {\n",
        "        (0, 0): [1.1, 0.9],\n",
        "        (1, 0): [1.2, 1.0, 0.8],\n",
        "        (1, 1): [1.1, 0.85],\n",
        "        (2, 0): [1.3, 0.9],\n",
        "        (2, 1): [1.2, 1.0],\n",
        "        (2, 2): [1.1],\n",
        "        (2, 3): [1.15, 0.95, 0.85],\n",
        "        (2, 4): [1.1, 0.9]\n",
        "    }\n",
        "\n",
        "    # Create nodes/edges\n",
        "    for (t, i), factors in transitions.items():\n",
        "        base_val = nodes[(t, i)]\n",
        "        for factor in factors:\n",
        "            child_t = t + 1\n",
        "            child_i = next_index[child_t]\n",
        "            next_index[child_t] += 1\n",
        "\n",
        "            child_val = round(base_val * factor, 2)\n",
        "            nodes[(child_t, child_i)] = child_val\n",
        "            edges.append(((t, i), (child_t, child_i)))\n",
        "\n",
        "    # 2. Assign symmetrical y-coords for each period\n",
        "    nodes_in_period = defaultdict(list)\n",
        "    for (t, i) in nodes.keys():\n",
        "        nodes_in_period[t].append(i)\n",
        "\n",
        "    coords = {}\n",
        "    for t in sorted(nodes_in_period.keys()):\n",
        "        node_list = sorted(nodes_in_period[t])\n",
        "        count = len(node_list)\n",
        "        # positions => 0..(count-1), shift so center is 0\n",
        "        for idx, node_i in enumerate(node_list):\n",
        "            shift = -(count - 1) / 2\n",
        "            y = (idx + shift) * vertical_scale\n",
        "            coords[(t, node_i)] = y\n",
        "\n",
        "    # 3. Build the Matplotlib figure\n",
        "    fig, ax = plt.subplots(figsize=(12, 4))  # Wider figure\n",
        "\n",
        "    # Plot edges\n",
        "    for ((t1, i1), (t2, i2)) in edges:\n",
        "        x_coords = [t1 * horizontal_scale, t2 * horizontal_scale]\n",
        "        y_coords = [coords[(t1, i1)], coords[(t2, i2)]]\n",
        "        ax.plot(x_coords, y_coords, color='black')\n",
        "\n",
        "    # Plot nodes + text\n",
        "    for (t, i), val in nodes.items():\n",
        "        x_ = t * horizontal_scale\n",
        "        y_ = coords[(t, i)]\n",
        "        ax.scatter(x_, y_, s=100, color='blue')\n",
        "        ax.text(x_, y_ + 0.2 * vertical_scale, str(val),\n",
        "                ha='center', va='bottom')\n",
        "\n",
        "    ax.set_title(\"3-Period Variable Branching Tree (Scaled)\")\n",
        "    ax.axis(\"equal\")\n",
        "    ax.axis(\"off\")\n",
        "    plt.show()\n",
        "\n",
        "# Example usage: narrower by vertical_scale=0.5, longer by horizontal_scale=2.0\n",
        "plot_variable_branching_tree_scaled(vertical_scale=0.5, horizontal_scale=2.0)"
      ],
      "id": "02f4d27a",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\kerry\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}