# Introduction to Monte Carlo and Binomial Models {#c_introcomputation}

In this chapter, we will introduce two principal numerical methods for
valuing derivative securities: Monte Carlo and binomial models. We will
consider two applications: valuing European options in the presence of
stochastic volatility with Monte Carlo and valuing American options via
binomial models. Additional applications of these methods will be
presented in
Chap. [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
reference="c_montecarlo"}. Throughout the chapter, we will assume there
is a constant risk-free rate. The last section, while quite important,
could be skimmed on first reading---the rest of the book does not build
upon it.

# Introduction to Monte Carlo {#s_mc_europeans}

According to our risk-neutral pricing formula
[\[riskneutralformula\]](#riskneutralformula){reference-type="eqref"
reference="riskneutralformula"}, the value of a security paying an
amount $x$ at date $T$ is
\begin{equation}\label{montecarlo1}
\E^{-rT}E^R[x]\;.
\end{equation}
To estimate this by Monte-Carlo means to simulate a sample of values for
the random variable
$x$
and to estimate the expectation by averaging the sample values.[^1] Of
course, for this to work, the sample must be generated from a
"population" having a distribution consistent with the risk-neutral
probabilities.

[^1]: Boyle [@boyle] introduced Monte-Carlo methods for derivative
    valuation, including the variance-reduction methods of control
    variates and antithetic variates to be discussed in
    Chap. [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
    reference="c_montecarlo"}.

The simplest example is valuing a European option under the
Black-Scholes assumptions. Of course, for calls and puts, this is
redundant, because we already have the Black-Scholes formulas.
Nevertheless, we will describe how to do this for the sake of
introducing the Monte Carlo method. In the case of a call option, the
random variable $x$ in
[\[montecarlo1\]](#montecarlo1){reference-type="eqref"
reference="montecarlo1"} is $\max(0,S(T)-K)$. To simulate a sample of
values for this random variable, we need to simulate the terminal stock
price $S(T)$. This is easy to do, because, under the Black-Scholes
assumptions, the logarithm of $S(T)$ is normally distributed under the
risk-neutral measure with mean $\log S(0)+\nu T$ and variance
$\sigma^2T$, where $\nu=r-q-\sigma^2/2$. Thus, we can simulate values
for $\log S(T)$ as $\log S(0)+\nu T + \sigma\sqrt{T}z$, where $z$ is a
standard normal. We can average the simulated values of
$\max(0,S(T)-K)$, or whatever the payoff of the derivative is, and then
discount at the risk-free rate to compute the date--0 value of the
derivative. This means that we generate some number $M$ of standard
normals $z_i$ and estimate the option value as $\E^{-rT}\bar{x}$, where
$\bar{x}$ is the mean of
$$x_i = \max\left(0,\E^{\log S(0)+\nu T + \sigma\sqrt{T}z_i}-K\right)\; .$$
To value options that are path-dependent we need to simulate the path of
the underlying asset price. Path-dependent options are discussed in
Chaps. [\[c_exotics\]](#c_exotics){reference-type="ref"
reference="c_exotics"}
and [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
reference="c_montecarlo"}.

There are two main drawbacks to Monte-Carlo methods. First, it is
difficult (though not impossible) to value early-exercise features.[^1]
To value early exercise, we need to know the value at each date if not
exercised, to compare to the intrinsic value. One could consider
performing a simulation at each date to calculate the value if not
exercised, but this value depends on the option to exercise early at
later dates, which cannot be calculated without knowing the value of
being able to exercise early at even later dates, etc. In contrast, the
binomial model (and finite difference models discussed in
Chap. [\[c_pde\]](#c_pde){reference-type="ref" reference="c_pde"}) can
easily handle early exercise but cannot easily handle path dependencies.

[^1]: Monte-Carlo methods for valuing early exercise include the
    stochastic mesh method of Broadie and Glasserman [@BG] and the
    regression method of Longstaff and Schwartz [@LS01]. Glasserman
    [@Glasserman] provides a good discussion of these methods and the
    relation between them.

The second drawback of Monte Carlo methods is that they can be quite
inefficient in terms of computation time (though, as will be explained
in Chap. [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
reference="c_montecarlo"}, they may be faster than alternative methods
for derivatives written on multiple assets). As in statistics, the
standard error of the estimate depends on the sample size. Specifically,
we observed in Sect.~\ref{s_statistics} that, given a random sample $\{x_1,\ldots,x_M\}$ of size $M$ from a population with mean $\mu$ and variance $\sigma^2$, the best estimate of $\mu$ is the sample mean $\bar{x}$, and the standard error of $\bar{x}$ (which means the standard deviation of $\bar{x}$ in repeated samples) is best estimated by
\begin{equation}\label{standarderror}
\sqrt{\frac{1}{M(M-1)}\left(\sum_{i=1}^{M} x_i^2-M\bar{x}^2\right)}\;.
\end{equation} \index{standard error}
Recall that $\bar{x}$ plus or minus 1.96 standard errors is a 95\% confidence interval for~$\mu$ when the $x_i$ are normally distributed.
In the context of European option valuation, the expression
[\[standarderror\]](#standarderror){reference-type="eqref"
reference="standarderror"} gives the standard error of the estimated
option value at maturity, and multiplication of
[\[standarderror\]](#standarderror){reference-type="eqref"
reference="standarderror"} by $\E^{-rT}$ gives the standard error of the
estimated date--0 option value.

To obtain an estimate with an acceptably small standard error may
require a large sample size and hence a relatively large amount of
computation time. The complexities of Monte Carlo methods arise from
trying to reduce the required sample size. In
Chap. [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
reference="c_montecarlo"}, we will describe two such methods (antithetic
variates and control variates). For those who want to engage in a more
detailed study of Monte Carlo methods, the book of Glasserman
[@Glasserman] is highly recommended. Jäckel [@Jackel] is useful for more
advanced readers, and Clewlow and Strickland [@CS] and Brandimarte
[@Brandimarte] are useful references that include computer code.

# Introduction to Binomial Models {#s_introbinomial}

As in the previous section, \index{binomial model} we will work with the dynamics of the logarithms of asset prices under the risk-neutral measure.  Thus, our starting point is the equation
\begin{equation}\label{logstock_riskneutral}
\D \log S = \left(r-q-\frac{\sigma^2}{2}\right)\,\D t + \sigma\,\D B\;,
\end{equation}
where $B$  represents a Brownian motion under the risk-neutral measure.

In the binomial model, we assume that if the stock price is $S$ at the
beginning of the period, it will be either $uS$ or $dS$ at the end of
the period, where the multiplicative factors $u$ and $d$ are constants
to be determined. This means that the rate of return is
$\varDelta S/S = u\!-\!1$ in the "up" state and
$\varDelta S/S = d\!-\!1$ in the "down state." There are three
parameters to the model: $u$, $d$, and the probability $p$ of the up
state (the probability of the down state being necessarily $1\!-\!p$).
The following illustrates a three-period model.

\begin{center}
\setlength{\unitlength}{0.6cm}
\begin{picture}(13,13)
\put(0,6){$S$}
\put(1,6){\vector(1,1){2}}
\put(1,6){\vector(1,-1){2}}
\put(5,8){\vector(1,1){2}}
\put(5,8){\vector(1,-1){2}}
\put(9,10){\vector(1,1){2}}
\put(9,10){\vector(1,-1){2}}
\put(5,4){\vector(1,1){2}}
\put(5,4){\vector(1,-1){2}}
\put(9,6){\vector(1,1){2}}
\put(9,6){\vector(1,-1){2}}
\put(9,2){\vector(1,1){2}}
\put(9,2){\vector(1,-1){2}}
\put(3.5,8){$uS$}
\put(3.5,4){$dS$}
\put(7.5,2){$d^2S$}
\put(7.5,6){$udS$}
\put(7.5,10){$u^2S$}
\put(11.5,0){$d^3S$}
\put(11.5,4){$ud^2S$}
\put(11.5,8){$du^2S$}
\put(11.5,12){$u^3S$}
\end{picture}
\end{center}

A tree constructed like this is "recombining" in the sense that the
stock price after an up-down sequence is the same as after a down-up
sequence. This is very important for reducing the computation time. For
example, the number of nodes at the final date is $N+1$ in a recombining
tree, where $N$ is the number of periods, but it is $2^N$ for a
non-recombining (sometimes called "bushy") tree. Hence, the computation
time will increase linearly with $N$ for a recombining tree but
exponentially with $N$ for a non-recombining tree. Unfortunately, this
computational savings is generally not possible for path-dependent
options, because the number of distinct paths through a tree (whether
recombining or not) is again $2^N$.
 
The value of a European derivative is of course the discounted
expectation of its value at maturity, discounting at the risk-free rate
and taking the expectation under the risk-neutral measure. The binomial
tree allows us to approximate the expectation very easily. We simply sum
over the nodes of the tree at the option maturity and weight each node
by its binomial probability. In an $N$-period model, the probability of
the top node is $p^N$, since the stock must go up each time to reach the
top node. There are $N$ paths reaching the second node from the top
(since the period of the single down move could be any one of the $N$
periods) and each such path has probability $p^{N-1}(1-p)$; therefore,
the probability of reaching the second node from the top is
$Np^{N-1}(1-p)$. More generally, the probability of going up $i$ times
and down $N-i$ times is
$$\frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\; ,$$
where as usual $x!$ denotes $x$ factorial. Therefore, the expectation,
for a European call option, is the following sum over the $N+1$ nodes at
date $N$ (starting with $i=0$ up moves and ending with $i=N$ up moves):
\begin{equation}\label{binomialsum}
\sum_{i=0}^N \frac{N!}{i!(N-i)!}p^i(1-p)^{N-i}\max(u^id^{N-i}S-K,0)\;.
\end{equation}
Multiplying the expectation by $\E^{-rT}$ yields the option value.

It is worthwhile to emphasize the close connection between this method
and the Monte-Carlo method discussed in the previous section. In the
Monte-Carlo method for valuing a European call option, we generate $M$
random values for $S(T)$ and estimate the expectation
$E^R[\max(0,S(T)-K)]$ by averaging the $M$ values. This amounts to
approximating the distribution of $S(T)$ by an $M$--point distribution,
each point being assigned equal probability. In the binomial method, we
choose a particular set of points for $S(T)$ and assign the
probabilities specified above in order to approximate the distribution
of $S(T)$. Both the Monte-Carlo and the binomial approximations are
known to converge to the continuous-time distribution of $S(T)$ as the
number of points increases. However, by specifically choosing the points
and their probabilities, the binomial method allows us to use a much
smaller number of points to obtain the same accuracy; i.e., for a given
desired accuracy, we can use many fewer periods $N$ in the binomial
model than we would need simulations $M$ in the Monte-Carlo method.
Thus, the binomial method will be much faster. Furthermore, as we will
discuss in the next section, the binomial method is much better for
pricing American options. On the other hand, as mentioned in the
previous section, to value a path-dependent option in an $N$--period
binomial tree would require the analysis of $2^N$ separate paths, so
Monte Carlo may be faster for path-dependent options. Finally, as we
will discuss in Sect. [\[s_curse\]](#s_curse){reference-type="ref"
reference="s_curse"}, Monte Carlo may be faster for options on multiple
assets.


There is an important alternative method for calculating the sum
[\[binomialsum\]](#binomialsum){reference-type="eqref"
reference="binomialsum"}, which is usually called "backward induction."
We will describe it here and implement it in the next section to value
American options. We begin at the last date, where there are $N+1$
nodes. We calculate the option value at each of these nodes, storing the
value at the bottom node as $C(0)$, the value at the next node up as
$C(1)$, etc. This is illustrated in the diagram on the next page. Then
we step back to the penultimate date. At each node at this date, we
calculate the option value as the discounted expectation of its value at
the last date. From each node, there are two nodes that can be reached
at the next date, corresponding to a down move or an up move. So, the
option value is calculated as

\begin{equation}\label{binomial001}
C = \E^{-r\varDelta t}p\,C_{\text{up}} + \E^{-r\varDelta t}(1-p)C_{\text{down}}\;.
\end{equation}
In terms of the vector notation shown in the diagram on the following page, the down move from node $i$ is also node $i$ and the up move is $i+1$.  So, we write over the elements of the $C$ vector as
\begin{equation}\label{binomial002}
C(i) = \E^{-r\varDelta t}p\,C(i+1) + \E^{-r\varDelta t}(1-p)C(i)\;.
\end{equation}
Discounting back through the tree like this, we reach date 0 and return
the option value as $C(0)$. The virtue of this procedure is that it
calculates a value for the option at each node in the tree, the value
being the discounted expectation of the subsequent values attained by
the option. This approach is essential for assessing the value of early
exercise.

# Binomial Models for American Options

Early exercise \index{early exercise} features are very simple to handle in a binomial
framework. One only has to use the backward induction approach and check
the optimality of early exercise at each node. Exercise is optimal when
the intrinsic value of the option exceeds the discounted expected value
of the option contingent on not exercising. When we back up in the tree,
we check whether exercise is optimal, and, when it is, we replace the
discounted expected value with the intrinsic value.


\begin{center}
\setlength{\unitlength}{0.6cm}
\begin{picture}(13,13)
\put(-.5,6){$C(0)$}
\put(1,6){\vector(1,1){2}}
\put(1,6){\vector(1,-1){2}}
\put(5,8){\vector(1,1){2}}
\put(5,8){\vector(1,-1){2}}
\put(9,10){\vector(1,1){2}}
\put(9,10){\vector(1,-1){2}}
\put(5,4){\vector(1,1){2}}
\put(5,4){\vector(1,-1){2}}
\put(9,6){\vector(1,1){2}}
\put(9,6){\vector(1,-1){2}}
\put(9,2){\vector(1,1){2}}
\put(9,2){\vector(1,-1){2}}
\put(3.5,8){$C(1)$}
\put(3.5,4){$C(0)$}
\put(7.5,2){$C(0)$}
\put(7.5,6){$C(1)$}
\put(7.5,10){$C(2)$}
\put(11.5,0){$C(0)$}
\put(11.5,4){$C(1)$}
\put(11.5,8){$C(2)$}
\put(11.5,12){$C(3)$}
\end{picture}
\end{center}

Early exercise is more important for puts than for calls (as discussed
in Sect. [\[s_fundamentalconcepts\]](#s_fundamentalconcepts){reference-type="ref"
reference="s_fundamentalconcepts"}, an American call on a
non-dividend-paying stock should not be exercised early) so we will
change our symbol for the option value from $C$ to $P$. For a put
option, we would calculate the value at each node at the end of the tree
as described in the previous section:

\begin{equation}\label{binomial003}
P(i) = \max\left(0,K-u^{i}d^{N-i}S\right)\;,
\end{equation}
for $i=0,\ldots,N$.  For a European put, we would also back up in the tree in accord with  \eqref{binomial002}:
\begin{equation}\label{binomial004}
P(i) = \E^{-r\varDelta t}p\,P(i+1) + \E^{-r\varDelta t}(1-p)P(i)\;.
\end{equation}
To accommodate early exercise, we simply need to assign to $P(i)$ the larger of this value and the value of early exercise.  At node $i$ at date $n$ the stock price is
$u^{i}d^{n-i}S$ and the intrinsic value of a put option is $\max(0,K-u^{i}d^{n-i}S)$.  Therefore we replace \eqref{binomial004} with
\begin{equation}\label{binomial005}
P(i) = \max\big(K-u^{i}d^{n-i}S, \;\E^{-r\varDelta t}p\,P(i+1) + \E^{-r\varDelta t}(1-p)P(i)\big)\;.
\end{equation}
This will be explained in more detail in Sect.~\ref{s_introcompvba}.

# Binomial Parameters {#s_binomialparameters}


Several different ways have been proposed for matching the binomial
model to the continuous-time model. Consider an $N$--period binomial
model for a time period of $T$ years. This means that the length of each
period is $\varDelta t = T/N$. In the continuous-time model, over a
discrete time period $\varDelta t$, we have
$$\varDelta \log S =\nu\,\varDelta t + \sigma\,\varDelta B\; ,$$
where $\nu = r-q-\sigma^2/2$ and $B$ is a Brownian motion under the risk-neutral measure.  The mean and variance, under the risk-neutral measure, of $\varDelta \log S$ in the continuous-time model are
\begin{align*}
E^R[\varDelta \log S] &= \nu\,\varDelta t\; ,\\
\var^R[\varDelta \log S]&=\sigma^2\varDelta t\; ,
\end{align*}
so 
\begin{align*}
\frac{E^R[\varDelta \log S]}{\varDelta t} &= \nu\; ,\\
\frac{\var^R[\varDelta \log S]}{\varDelta t}&=\sigma^2\;.
\end{align*}
In the binomial model, we have
\begin{align*}
\frac{E^R\big[\varDelta \log S\big]}{\varDelta t} &=\frac{p\,\log u+(1-p)\log d}{\varDelta t}\; ,\\
\frac{\var^R\big[\varDelta \log S\big] }{\varDelta t}&=\frac{p\,(1-p)(\log u-\log d)^2}{\varDelta t}\;.
\end{align*}
In order for the binomial model to converge in the appropriate sense to the continuous-time model as the number of periods $N \rightarrow \infty$ keeping the total amount of time $T$ fixed (equivalently, as $\varDelta t \rightarrow 0$), it is sufficient that
\begin{align*}
\frac{p\log u+(1-p)\log d}{\varDelta t} &\rightarrow \nu\; ,\\
\frac{p\,(1-p)(\log u-\log d)^2}{\varDelta t} &\rightarrow \sigma^2\;.
\end{align*}


The most popular model is probably that proposed by Cox, Ross and
Rubinstein [@CRR], \index{Cox-Ross-Rubinstein model} who set $d=1/u$ and 
\begin{subequations}
\begin{align}
u &= \E^{\sigma\sqrt{\varDelta t}}\;,\label{crru}\\
p &= \frac{\E^{(r-q)\varDelta t}-d}{u-d}\;.\label{crrp}
\end{align}
\end{subequations}
Another well-known model is that of Jarrow and Rudd \cite{JR}, \index{Jarrow-Rudd model} who take $p=1/2$ and
\begin{subequations}
\begin{align}
u &= \exp\left(\left((r-q-\frac{1}{2}\sigma^2\right)\varDelta t + \sigma\sqrt{\varDelta t}\right)\;,\label{jru}\\
d &= \exp\left(\left((r-q-\frac{1}{2}\sigma^2\right)\varDelta t - \sigma\sqrt{\varDelta t}\right)\;.\label{jrd}
\end{align}
\end{subequations}
Yet another method is proposed by 
Leisen and Reimer [@LR], and Jackson and Staunton [@JS] show that it is
more efficient for approximating the Black-Scholes value of a European
option than are the Cox-Ross-Rubinstein and Jarrow-Rudd trees.

For illustration, the Cox-Ross-Rubinstein tree will be implemented in
Sect. [\[s_introcompvba\]](#s_introcompvba){reference-type="ref"
reference="s_introcompvba"}. However, when we consider binomial models
for multiple assets in
Chap. [\[c_montecarlo\]](#c_montecarlo){reference-type="ref"
reference="c_montecarlo"}, we will use the tree proposed by Trigeorgis
[@Trigeorgis], because it is the simplest to explain in that context.

Trigeorgis proposes choosing $p$, $u$ and $d$ so that the mean and variance of $\varDelta \log S$ in the binomial model match those in the continuous-time model exactly.  This means that
\begin{subequations}
\begin{align*}
\frac{p\log u+(1-p)\log d}{\varDelta t} &= \nu\; ,\\
\frac{p(1-p)(\log u-\log d)^2}{\varDelta t} &= \sigma^2\;.
\end{align*}
\end{subequations}
These are two equations in the three unknowns, leaving one degree of
freedom, so Trigeorgis takes $d=1/u$, as do Cox, Ross and Rubinstein. As
we will show in the next section, taking $d=1/u$ simplifies the
calculations of deltas and gammas.

Solving these two equations yields\footnote{Notice that if we were to drop the $(\varDelta t)^2$ term in \eqref{trig1} (which we could do because it becomes increasingly negligible as $\varDelta t \rightarrow 0)$, then  \eqref{trig1} would be the same as \eqref{crru}.  The different choices of $p$ in \eqref{crrp} and \eqref{trig2} can be understood as follows.  Equation \eqref{crrp} implies that the expected stock price
$pS_u + (1-p)S_d$ equals $\E^{(r-q)\varDelta t}S$, so we have average growth at the rate $r-q$ as in the continuous-time model.  On the other hand,  \eqref{trig2} implies that the expected \emph{log} stock price $p \,\log S_u + (1-p) \log S_d$ equals $\log S + \nu \varDelta t$, so the expected change in the logarithm is $\nu\varDelta t$, also as in the continuous-time model.  Thus, both match the binomial model to the continuous-time model, the Cox-Ross-Rubinstein method focusing on the expected return (equivalently, the expected change in the price of the underlying) and the Trigeorgis method focusing on the expected continuously-compounded return (the expected change in the logarithm of the price).}
\begin{subequations}
\begin{align}
\log u&=\sqrt{\sigma^2\varDelta t + \nu^2(\varDelta t)^2}\;,\label{trig1}\\
p &= \frac{1}{2}+\frac{\nu\varDelta t}{2\log u}\;.\label{trig2}
\end{align}
\end{subequations}

# Binomial Greeks {#s_binomial_greeks}

To estimate Greeks in any valuation model, one can run the valuation
program twice, for two different parameter values, and then estimate the
Greek as the difference in value divided by the difference in
parameters. For example, to estimate vega when the volatility of the
underlying is $\sigma$, we could estimate the derivative value for a
volatility of $0.99\sigma$ and for a volatility of $1.01\sigma$.
Denoting the former derivative value by $C_d$ and the latter by $C_u$,
the vega can be estimated by
$$\frac{C_u-C_d}{1.01\sigma-0.99\sigma} = \frac{C_u-C_d}{0.02\sigma}\; .$$
We can in principle obtain a more precise estimate of the derivative by
making a smaller change in the parameter (e.g., using $0.999\sigma$ and
$1.001\sigma$) but computer round-off errors limit how small a parameter
change one should take in practice.

To estimate the gamma when the price of the underlying is $S$, we need to estimate the derivative value at two other prices for the underlying, which we will call $S_u$ and $S_d$, with  $S_u>S>S_d$.  As just explained, the estimate of the delta (which we continue to denote by~$\delta$) would be
\begin{equation}\label{binomialdelta100}
\delta = \frac{C_u-C_d}{S_u-S_d}\;,
\end{equation}
where $C_u$ denotes the derivative value when the underlying is equal to $S_u$ and~$C_d$ denotes the derivative value when the underlying is equal to $S_d$.
Letting~$C$ denote the derivative value when the underlying is equal to $S$, two other obvious estimates of the delta are
$$\delta_u = \frac{C_u-C}{S_u-S} \qquad \text{and} \qquad \delta_d = \frac{C-C_d}{S-S_d}\; .$$
The first of these should be understood as an estimate of the delta when the price of the underlying is at the midpoint of $S_u$ and $S$, and the second is an estimate of the delta when the price of the underlying is at the midpoint of $S_d$ and $S$.  The distance between these midpoints is 
$$\frac{S_u+S}{2} - \frac{S_d+S}{2} = \frac{S_u-S_d}{2}\; ,$$ so we obtain an estimate of $\Gamma$ (the derivative of $\delta$) as
\begin{equation}\label{binomialgamma100}
\Gamma = \frac{\delta_u-\delta_d}{(S_u-S_d)/2}\;.
\end{equation}


In a binomial model, it is possible to compute the most important Greeks, delta and gamma, more efficiently than by simply running the valuation program several times. 
Assume we have taken $d=1/u$, so after an up and a down move (or a down
and an up move) the stock price returns to its initial value $S$. After
fixing the length $\varDelta t = T/N$ of each time period, we redefine
$N=N+2$. This results in an $N+2$ period tree covering a time period of
length $T+2\varDelta t$.

Now consider the tree starting two periods from the initial date.  At the middle node shown below, the stock price is $udS=S$.  Ignoring the top and bottom nodes and the branches that follow them, the result of adding two periods is that the tree starting from $udS$ is an $N$--period tree for a time period of length $T$.  
\begin{center}
\setlength{\unitlength}{0.6cm}
\begin{picture}(13,13)
\put(9,10){\vector(1,1){2}}
\put(9,10){\vector(1,-1){2}}
\put(9,6){\vector(1,1){2}}
\put(9,6){\vector(1,-1){2}}
\put(9,2){\vector(1,1){2}}
\put(9,2){\vector(1,-1){2}}
\put(7.5,2){$d^2S$}
\put(7.5,6){$udS$}
\put(7.5,10){$u^2S$}
\put(11.5,0){$d^3S$}
\put(11.5,4){$ud^2S$}
\put(11.5,8){$du^2S$}
\put(11.5,12){$u^3S$}
\end{picture}
\end{center}
Hence, the derivative price calculated at the middle node will be the
price we are trying to estimate. The derivative price at the top node
will be the value of a derivative of maturity $T$ when the initial price
of the underlying is $u^2S$. Similarly, the derivative price at the
bottom node will be the value of a derivative of maturity $T$ when the
initial price of the underlying is $d^2S$. Thus, when we back up in the
tree to this date, we will have all of the information we need to return
an estimate of the derivative value and to return estimates of the delta
and gamma, taking $S_u=u^2S$ and $S_d = d^2S$ in equations
[\[binomialdelta100\]](#binomialdelta100){reference-type="eqref"
reference="binomialdelta100"} and
[\[binomialgamma100\]](#binomialgamma100){reference-type="eqref"
reference="binomialgamma100"}. We are not interested in the tree to the
left of what is shown above.

# Monte Carlo Greeks I: Difference Ratios {#s_montecarlogreeks1}

As with binomial models, Greeks can be calculated by Monte Carlo by
running the valuation program twice and computing a difference ratio,
for example $(C_u-C_d)/(S_u-S_d)$ to estimate a delta. However, to
minimize the error, and minimize the number of computations required,
one should use the same set of random draws to estimate the derivative
value for different values of the parameter. For path-independent
options (e.g., European puts and calls) under the Black-Scholes
assumptions, we only need to generate $S(T)$ and then we can compute
$S_u(T)$ as $[S_u(0)/S(0)] \times S(T)$ and $S_d(T)$ as
$[S_u(0)/S(0)] \times S(T)$. We can estimate standard errors for the
Greeks in the same way that we estimate the standard error of the
derivative value.

Actually, there is often a better method available that is just as
simple. This is called "pathwise calculation." We will explain this in
the next section. Here we will describe how to estimate the delta and
gamma of a derivative as sample means of difference ratios.

Consider initial prices for the underlying $S_u>S>S_d$. Denote the
underlying price at the option maturity in a given simulation by
$S_u(T)$ when the initial underlying price is $S_u$, by $S(T)$ when the
initial underlying price is $S$, and by $S_d(T)$ when the initial
underlying price is $S_d$. Under the Black-Scholes assumptions, the
logarithm of the stock price at date $T$ starting from the three initial
prices $S_d$, $S$ and $S_u$ is

\begin{align*}
\log S_d(T) &= \log S_d + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B(T)\; ,\\
\log S(T) &= \log S + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B(T)\; ,\\
\log S_u (T) &= \log S_u + \left(r-q-\frac{1}{2}\sigma^2\right)T + \sigma B(T)\;,
\end{align*}
so 
$$\log S_d(T) = \log S(T) + \log S_d - \log S\Longrightarrow S_d(T) = \left(\frac{S_d}{S}\right) S(T)\; ,$$
and
$$\log S_u(T) = \log S(T) + \log S_u - \log S \Longrightarrow S_u(T) = \left(\frac{S_u}{S}\right) S(T)\; .$$
Therefore, under the Black-Scholes assumptions, we only need to simulate $S(T)$ and then perform the multiplications indicated above to obtain $S_d(T)$ and $S_u(T)$. 

Consider a particular simulation and let $C_d(T)$ denote the value of the derivative at maturity  when the initial asset price is $S_d$, let  $C(T)$ denote the value of the derivative at maturity  when the initial asset price is $S$, and let $C_u(T)$ denote the value of the derivative at maturity  when the initial asset price is $S_u$.  For path-independent derivatives under the Black-Scholes assumptions, these can be computed directly from the simulation of $S(T)$ as just described.  However, the following applies to general European derivatives under general assumptions about the underlying asset price (for example, it could follow a GARCH process).

The estimates $C_d$, $C$ and $C_u$ of the date--0 derivative values, for the different initial prices of the underlying, are the discounted sample means of the $C_d(T)$, $C(T)$ and $C_u(T)$.
One way to estimate the delta is $(C_u-C_d)/(S_u-S_d)$.  This is a difference of discounted sample means, multiplied by the reciprocal of $S_u-S_d$.  Equivalently, it is the sample mean of the differences $C_u(T)-C_d(T)$, multiplied by $\E^{-rT}/(S_u-S_d)$.  As a sample mean, its standard error can be estimated as described in Chap.~\ref{c_stochasticvolatility}.   The standard error is
$$\frac{\E^{-rT}}{S_u-S_d}\sqrt{\frac{1}{M(M-1)}\left(\sum_{i=1}^M \left[C_{ui}(T)-C_{di}(T)\right]^2 - M\left[\overline{C_{u}(T)}-\overline{C_{d}(T)}\right]^2\right)}\; ,$$ \index{standard error}
where the overline denotes the sample mean and where $C_{ui}(T)$ [respectively, $C_{di}(T)$] denotes the value of the derivative at maturity in simulation $i$ when the initial asset price is $S_u$ [respectively, $S_d$].

The corresponding Monte Carlo estimate of the gamma is also a sample mean.  Simple algebra shows that the formula \eqref{binomialgamma100} is equivalent to
\begin{equation}\label{binomialgamma200}
\Gamma = \frac{2}{(S_u-S)(S_u-S_d)}C_u - \frac{2}{(S_u-S)(S-S_d)}C +\frac{2}{(S-S_d)(S_u-S_d)}C_d\;.
\end{equation}
Normally one would take $S_u=(1+\alpha)S$ and $S_d = (1-\alpha)S$ for some $\alpha$ (e.g., $\alpha=0.01$).  In this case  \eqref{binomialgamma200}
simplifies to
\begin{equation}\label{binomialgamma300}
\Gamma = \frac{C_u - 2C + C_d}{\alpha^2S^2}\;,
\end{equation}
and the standard error of the gamma is
\begin{multline*}\frac{\E^{-rT}}{\alpha^2S^2}\sqrt{\frac{1}{M(M-1)}}\\
\times \sqrt{\sum_{i=1}^M \left[C_{ui}(T)-2C_i(T)+C_{di}(T)\right]^2 -M\left[\overline{C_{u}(T)}-2\overline{C(T)}+\overline{C_{d}(T)}\right]^2}\; .
\end{multline*}


# Monte Carlo Greeks II: Pathwise Estimates {#s_montecarlogreeks2}

We will examine the bias in the Monte Carlo delta estimate discussed in
the preceding section and explain "pathwise" estimation of Greeks. By
"biased," we mean that the expected value of an estimate is different
from the true value. It is important to recognize that if a Monte Carlo
estimate is biased, then, even if a large number of simulations is used
and the standard error is nearly zero, the answer provided by the Monte
Carlo method will be incorrect. For simplicity, consider a European call
under the Black-Scholes assumptions.

The delta estimate we have considered is the discounted sample mean of 
\begin{equation}\label{montecarlodelta2}
\frac{C_u(T) - C_d(T)}{S_u-S_d}\;.
\end{equation}
This ratio takes on one of three values, depending on $S(T)$:
\begin{itemize}
\item If $S_u(T) \leq K$ then the option is out of the money in both the up and down cases; i.e., 
$$C_u(T) = C_d(T) = 0\; ,$$
so the ratio \eqref{montecarlodelta2} is zero.
\item If $S_d(T) \geq K$ then the option is in the money in both the up and down cases; i.e.,
\begin{align*} C_u(T) &= S_u(T) - K =\left(\frac{S_u}{S}\right)S(T) - K\; ,\\
C_d(T) &= S_d(T) - K = \left(\frac{S_d}{S}\right)S(T) - K\;,
\end{align*}
so the ratio  \eqref{montecarlodelta2} equals $S(T)/S$.
\item If $S_u(T) > K > S_d(T)$, then the option is in the money in only the up case; i.e.,
\begin{align*}
C_u(T) &= S_u(T) - K = \left(\frac{S_u}{S}\right)S(T) - K\; ,\\
C_d(T) &= 0\;,
\end{align*}
so the ratio \eqref{montecarlodelta2} equals 
$$\frac{\left(\frac{S_u}{S}\right)S(T) - K}{S_u-S_d} < \frac{S(T)}{S}\; .$$
\end{itemize}

The bias is induced by the third case above.  We can see this as follows.  We are trying to estimate
\begin{equation}\label{montecarlodelta4}
\frac{\partial }{\partial S} \E^{-rT}E^R \big[\max(0,S(T)-K)\big] = \E^{-rT}E^R  \left[ \frac{\partial }{\partial S} \max(0,S(T)-K)\right]\;.
\end{equation}
The delta estimate $(C_u-C_d)/(S_u-S_d)$ replaces the mean $E^R$ with the sample mean and replaces
\begin{equation}\label{montecarlodelta3}
\frac{\partial }{\partial S} \max(0,S(T)-K)
\end{equation}
with the ratio \eqref{montecarlodelta2}.  
The derivative \eqref{montecarlodelta3} takes on two possible values, depending on $S(T)$---we can ignore the case $S(T)=K$ because it occurs with zero probability:
\begin{itemize}
\item If $S(T) < K$, then $\max(0,S(T)-K) = 0$ and the derivative is zero.
\item If $S(T)>K$,  then $\max(0,S(T)-K) = S(T)-K$ and the derivative equals 
$$\frac{\partial S(T)}{\partial S}=\E^{(r-q-\sigma^2/2)T + \sigma B(T)} = \frac{S(T)}{S}\; .$$
\end{itemize}
Therefore, the true delta---the expectation \eqref{montecarlodelta4}---equals\footnote{By changing numeraires, we can show that \eqref{montecarlodelta5} equals $\E^{-qT}E^V[x] = \E^{-qT}\N(d_1)$, as we know from Chap.~\ref{c_blackscholes} is the delta of a European call in the Black-Scholes model (here, as in Chap.~\ref{c_blackscholes}, $V(t)=\E^{qt}S(t)$ denotes the value of the non-dividend-paying portfolio created from the stock).} 
\begin{equation}\label{montecarlodelta5}
\E^{-rT}E^R\left[\frac{S(T)}{S} x\right]\;,
\end{equation}
where $x$ is the random variable defined as
\begin{equation*}
x =  \begin{cases} 1 & \text{if $S(T)>K$}\; ,\\
0 & \text{otherwise}\;.
\end{cases}
\end{equation*}
 On the other hand, our  analysis of the ratio \eqref{montecarlodelta2} shows that the expected value of the delta estimate $(C_u-C_d)/(S_u-S_d)$ is
\begin{equation}\label{montecarlodelta6}
\E^{-rT}E^R\left[\frac{S(T)}{S} y\right] + \E^{-rT}E^R\left[\frac{S_uS(T)-SK}{S(S_u-S_d)}z\right]\;,
\end{equation}
where
\begin{align*}
y &=  \begin{cases} 1 & \text{if $S_d(T)>K$}\; ,\\
0 & \text{otherwise}\;.
\end{cases}
\intertext{and}
z &=  \begin{cases} 1 & \text{if $S_u(T)>K>S_d(T)$}\; ,\\
0 & \text{otherwise}\;.
\end{cases}
\end{align*}
To contrast \eqref{montecarlodelta5} and \eqref{montecarlodelta6}, note that if $y=1$ then $x=1$, so the term 
$E^R\left[\frac{S(T)}{S} y\right]$ in
[\[montecarlodelta6\]](#montecarlodelta6){reference-type="eqref"
reference="montecarlodelta6"} is "part of"
[\[montecarlodelta5\]](#montecarlodelta5){reference-type="eqref"
reference="montecarlodelta5"}. However, there are two partially
offsetting "errors" in
[\[montecarlodelta6\]](#montecarlodelta6){reference-type="eqref"
reference="montecarlodelta6"}: $z$ sometimes equals one when $x$ is
zero, and when both $z$ and $x$ are one, then the factor multiplying $z$
is smaller than the factor multiplying $x$. In any case, the expected
value [\[montecarlodelta6\]](#montecarlodelta6){reference-type="eqref"
reference="montecarlodelta6"} is not the same as the true delta
[\[montecarlodelta5\]](#montecarlodelta5){reference-type="eqref"
reference="montecarlodelta5"}. As noted before, this implies that the
delta estimate will be incorrect even if its standard error is zero. The
bias can be made as small as one wishes by taking the magnitude
$S_u-S_d$ of the perturbation to be small, but taking the perturbation
to be very small will introduce unacceptable roundoff error.

The obvious way to estimate the delta in this situation is simply to
compute the discounted sample average of $[S(T)/S]x$. This is called a
"pathwise" estimate \index{pathwise Monte Carlo Greeks} of the delta, because it only uses the sample paths of $S(t)$ rather than considering up and down perturbations. This method is due to Broadie and Glasserman [@bg2]. Because the pathwise estimate is a sample average, its standard error can be computed in the usual way.

To compute pathwise estimates in other models and for other Greeks, we
need the Greek to be an expectation as on the right-hand side of
[\[montecarlodelta4\]](#montecarlodelta4){reference-type="eqref"
reference="montecarlodelta4"}. Additional examples can be found in
Glasserman [@Glasserman] and Jäckel [@Jackel].


# Calculations in VBA {#s_introcompvba}

## Monte Carlo Valuation of a European Call {#monte-carlo-valuation-of-a-european-call .unnumbered}
We will illustrate Monte Carlo by valuing a European call under the
Black-Scholes assumptions. We will also estimate the delta by each of
the methods described in
Sects. [\[s_montecarlogreeks1\]](#s_montecarlogreeks1){reference-type="ref"
reference="s_montecarlogreeks1"}
and [\[s_montecarlogreeks2\]](#s_montecarlogreeks2){reference-type="ref"
reference="s_montecarlogreeks2"}. Of course, we know the call value and
its delta from the Black-Scholes formulas, and they can be used to
evaluate the accuracy of the Monte Carlo estimates.

In this circumstance, we only need to simulate the price of the underlying at the option maturity rather than the entire path of the price process.  To estimate the option delta as a difference ratio $(C_u-C_d)/(S_u-S_d)$, we use the perturbations $S_u = 1.01S$ and $S_d = 0.99S$.  The inputs are the same as for the Black-Scholes formula plus the sample size~$M$ (the number of stock prices to be simulated).

\addcontentsline{lof}{figure}{European Call MC}
\small\begin{verbatim}
Function European_Call_MC(S, K, r, sigma, q, T, M)
'
' Inputs are S = initial stock price
'            K = strike price
'            r = risk-free rate
'            sigma = volatility
'            q = dividend yield
'            T = time to maturity
'            M = number of simulations
'
' This outputs the row vector (call value, delta 1, delta 2)
'
Dim LogS0,drift,SigSqrT,UpChange,DownChange,SumCall,SumCallChange
Dim SumPathwise,LogS,LogSd,LogSu,CallV,CallVu,CallVd,i,Delta1,Delta2
LogS0 = Log(S)
drift = (r - q - 0.5 * sigma * sigma) * T
SigSqrT = sigma * Sqr(T)
UpChange = Log(1.01)
DownChange = Log(0.99)
SumCall = 0
SumCallChange = 0
SumPathwise = 0
For i = 1 To M
    LogS = LogS0 + drift + SigSqrT * RandN()     ' log S(T)
    CallV = Application.Max(0, Exp(LogS) - K)    ' call value
    SumCall = SumCall + CallV                    ' sum call values
    LogSu = LogS + UpChange                          ' log Su(T)
    CallVu = Application.Max(0, Exp(LogSu) - K)      ' call value
    LogSd = LogS + DownChange                        ' Sd(T)
    CallVd = Application.Max(0, Exp(LogSd) - K)      ' call value
    SumCallChange = SumCallChange + CallVu - CallVd  ' differences
    If Exp(LogS) > K Then
        SumPathwise = SumPathwise + Exp(LogS) / S    ' for pathwise
    End If
Next i
CallV = Exp(-r * T) * SumCall / M                      
Delta1 = Exp(-r * T) * SumCallChange / (M * 0.02 * S)  
Delta2 = Exp(-r * T) * SumPathwise / M                 
European_Call_MC = Array(CallV, Delta1, Delta2)
End Function
\end{verbatim}\normalsize

## Monte Carlo Valuation in a GARCH Model {#monte-carlo-valuation-in-a-garch-model .unnumbered}

For another example of Monte Carlo, we will value a European call option
and estimate its standard error in a GARCH model. The underlying asset
price is simulated as in Sect. [\[s_garch\]](#s_garch){reference-type="ref" reference="s_garch"}.
After each path of the underlying is simulated, we compute the date--T
value of the option. We sum these as the simulations proceed in order to
compute the average value. We also sum the squared date-- T option
values in order to compute the standard error of the estimate of the
date--0 option value.

In addition to the inputs in the previous function, we input  the number $N$ of time periods in the interval $[0,T]$---implying a GARCH model for returns over time intervals of length $\varDelta t = T/N$ under the risk-neutral measure---and the GARCH parameters $\kappa$, $\theta$, and~$\lambda$. To value a different type of European derivative, we would simply modify the statement 
\small\begin{center}
\verb!CallV = Application.Max(0,Exp(LogS)-K)!.
 \end{center}\normalsize

\addcontentsline{lof}{figure}{European Call GARCH MC}
\small\begin{verbatim}
Function Eur_Call_GARCH_MC(S,K,r,sigma0,q,T,N,kappa,theta,lambda,M)
'
' Inputs are S = initial stock price
'            K = strike price
'            r = risk-free rate
'            sigma0 = initial volatility
'            q = dividend yield
'            T = time to maturity
'            N = number of time periods
'            kappa = GARCH parameter
'            theta = GARCH parameter
'            lambda = GARCH parameter
'            M = number of simulations
'
' This returns the row vector (call value, standard error).
'
Dim dt, Sqrdt, a, b, c, LogS0, SumCall, SumCallSq, LogS, sigma
Dim y, CallV, StdError, i, j
dt = T / N
Sqrdt = Sqr(dt)
a = kappa * theta                ' GARCH parameter
b = (1 - kappa) * lambda         ' GARCH parameter
c = (1 - kappa) * (1 - lambda)   ' GARCH parameter
LogS0 = Log(S)                   ' store log stock price
SumCall = 0                      ' initialize running total
SumCallSq = 0                    ' initialize running total
For i = 1 To M
    LogS = LogS0                 ' initialize log stock price
    sigma = sigma0               ' initialize volatility
    For j = 1 To N               ' generate path
        y = sigma * RandN()
        LogS = LogS + (r-q-0.5*sigma*sigma)*dt + Sqrdt*y
        sigma = Sqr(a + b * y ^ 2 + c * sigma ^ 2)  ' update vol
    Next j
    CallV = Application.Max(0, Exp(LogS) - K)       ' date-T value
    SumCall = SumCall + CallV                       ' update sum
    SumCallSq = SumCallSq + CallV * CallV           ' update sum
Next i
CallV = Exp(-r * T) * SumCall / M  
StdError = Exp(-r * T) * Sqr((SumCallSq - SumCall * SumCall / M) / _
           (M * (M - 1)))
Eur_Call_GARCH_MC = Array(CallV, StdError)
End Function
\end{verbatim}\normalsize

## Binomial Valuation of European Options {#binomial-valuation-of-european-options .unnumbered}

The binomial model for path-independent European options can be implemented as follows.  We will use the Cox-Ross-Rubinstein parameters.  To value a different type of European option in a binomial model, one would only have to change the formula 
\small\begin{center}
\verb!Application.Max(S - K, 0)! 
\end{center}\normalsize
in the following.  We first define the binomial parameters and some useful constants, denoting the probability $p\,$ of an up move as \verb!pu! and the probability $1-p$ of a down move as~\verb!pd!.  

\addcontentsline{lof}{figure}{European Call Binomial}
\small\begin{verbatim}
Function European_Call_Binomial(S, K, r, sigma, q, T, N)
'
' Inputs are S = initial stock price
'            K = strike price
'            r = risk-free rate
'            sigma = volatility
'            q = dividend yield
'            T = time to maturity
'            N = number of time periods
'
Dim dt, u, d, pu, pd, u2, prob, CallV, i
dt = T / N                             ' length of time period
u = Exp(sigma * Sqr(dt))               ' size of up step
d = 1 / u                              ' size of down step
pu = (Exp((r - q) * dt) - d) / (u - d) ' probability of up step
pd = 1 - pu                            ' probability of down step
u2 = u * u
\end{verbatim}\normalsize

\noindent Now we calculate the stock price at the bottom node (the node corresponding to all down moves), the probability of reaching that node, and the first term in the sum \eqref{binomialsum}.

\small\begin{verbatim}
S = S * d ^ N            ' stock price at bottom node at last date
prob = pd ^ N            ' probability of bottom node at last date
CallV = prob * Application.Max(S - K, 0)      
\end{verbatim}\normalsize

To calculate the other $N$ terms in the sum, we note that the stock price when there are $i$ up moves is $u^2$ times the stock price with only $i-1$ up moves (because one more up move also means one fewer down move and adding an up and removing a down produces the factor $u/d = u^2$).  Furthermore, the ratio of the probability of $i$ up moves to $i-1$ up moves is
$$\frac{p^i(1-p)^{N-i}N!/i!(N-i)!}{p^{i-1}(1-p)^{N-i+1}N!/(i-1)!(N-i+1)!} = \frac{(N-i+1)p}{(1-p)i}\; .$$
Therefore, as we increase the index $i$ in computing the sum \eqref{binomialsum}, we need to multiply the previous stock price by $u^2$ and multiply the previous probability by $(N-i+1)p/[(1-p)i]$.  We add the result to \verb!CallV! each time and, at the end, discount by $\E^{-rT}$.

\small\begin{verbatim}
For i = 1 To N                                
    S = S * u2                                       
    prob = prob * (pu / pd) * (N - i + 1) / i        
    CallV = CallV + prob * Application.Max(S - K, 0) 
Next i
European_Call_Binomial = Exp(-r * T) * CallV
End Function
\end{verbatim}\normalsize

## Binomial Valuation of American Options {#binomial-valuation-of-american-options .unnumbered}
We will consider an American put.  It may also be optimal to exercise an American call early, if there is a positive dividend yield, and the same procedure can be used for American calls.
We begin as in the previous subsection by defining the binomial parameters, some useful constants, and the stock price at the bottom node at the last date.\footnote{Note that the variable name $S0$ is assigned to the initial stock price.  The variable $S$ is modified as we step up across the nodes at each date.  When we back up to the previous date, the initial stock price is still available in the variable $S0$.} We also compute the put value $P(0)$ at the bottom node at the last date.


\addcontentsline{lof}{figure}{American Put Binomial}
\small\begin{verbatim}
Function American_Put_Binomial(S0, K, r, sigma, q, T, N)
'
' Inputs are S0 = initial stock price
'            K = strike price
'            r = risk-free rate
'            sigma = volatility
'            q = dividend yield
'            T = time to maturity
'            N = number of time periods
'
Dim dt, u, d, pu, dpu, dpd, u2, S, i, j
Dim PutV() As Double
ReDim PutV(N)
dt = T / N                              ' length of time period
u = Exp(sigma * Sqr(dt))                ' size of up step
d = 1 / u                               ' size of down step
pu = (Exp((r - q) * dt) - d) / (u - d)  ' probability of up step
dpu = Exp(-r * dt) * pu                 ' discount x up prob 
dpd = Exp(-r * dt) * (1 - pu)           ' discount x down prob
u2 = u * u
S = S0 * d ^ N                          ' bottom stock price
PutV(0) = Application.Max(K - S, 0)     ' bottom put value
\end{verbatim}\normalsize

Now we loop over the other nodes at the last date, increasing the stock price by a factor of $u^2$ each time as before, and defining the put value as its intrinsic value at maturity.

\small\begin{verbatim}
For j = 1 To N
    S = S * u2
    PutV(j) = Application.Max(K - S, 0)
Next j
\end{verbatim}\normalsize

Now we do the backward induction. Note that a "period" is the time
period between successive dates. In a one-period model, there are two
dates (the beginning and end) and in general there are $N+1$ dates in an
$N$--period model. We index the dates as $i=0,\ldots,N$. Since we are
backing up in the tree, we step backwards from $i=N-1$ to $i=0$. At each
date we start by defining the stock price at the bottom node. At date
$i$ there have been $i$ past periods, so the bottom node corresponds to
$i$ down moves. The put value at each node is computed as the larger of
the discounted expected value and the value of immediate exercise (the
intrinsic value). Having already dealt with the bottom node ($j=0$) we
loop over the nodes $j=1,\ldots,i$ at each date $i$, increasing the
stock price by a factor of $u^2$ each time. When we have backed up to
date 0, we return the put value $P(0)$, the value at the bottom node,
which is the only node at date 0.

\small\begin{verbatim}
For i = N - 1 To 0 Step -1              ' back up in time to date 0
    S = S0 * d ^ i                      ' bottom stock price
    PutV(0) = Application.Max(K - S, dpd * PutV(0) + dpu * PutV(1))
    For j = 1 To i                      ' step up over nodes
        S = S * u2
        PutV(j) = Application.Max(K-S, dpd*PutV(j)+dpu*PutV(j+1))
    Next j
Next i
American_Put_Binomial = PutV(0)         
End Function
\end{verbatim}\normalsize

## Binomial Estimation of Delta and Gamma {#binomial-estimation-of-delta-and-gamma .unnumbered}

We add two periods to the model and then stop the backward induction at date $n=2$, as described in Sect.~\ref{s_binomial_greeks}.

\addcontentsline{lof}{figure}{American Put Binomial DG}
\small\begin{verbatim}
Function American_Put_Binomial_DG(S0, K, r, sigma, q, T, N)
'
' Inputs are S0 = initial stock price
'            K = strike price
'            r = risk-free rate
'            sigma = volatility
'            q = dividend yield
'            T = time to maturity
'            N = number of time periods
'
' This returns the row vector (put value, delta, gamma).
'
Dim dt, u, d, pu, dpu, dpd, u2, S, Su, Sd, Deltau, Deltad, dist
Dim i, j, NewN, Delta, Gamma
Dim PutV() As Double
ReDim PutV(N + 2)
dt = T / N                              ' length of time period
NewN = N + 2                            ' now we add 2 periods
u = Exp(sigma * Sqr(dt))                ' size of up step
d = 1 / u                               ' size of down step
pu = (Exp((r - q) * dt) - d) / (u - d)  ' probability of up step
dpu = Exp(-r * dt) * pu                 ' discount x up prob
dpd = Exp(-r * dt) * (1 - pu)           ' discount x down prob
u2 = u * u
S = S0 * d ^ NewN                       ' bottom stock price
PutV(0) = Application.Max(K - S, 0)     ' bottom put value
For j = 1 To NewN                       ' step up over nodes
    S = S * u2
    PutV(j) = Application.Max(K - S, 0)
Next j
For i = NewN - 1 To 2 Step -1           ' back up in time
    S = S0 * d ^ i                      ' bottom stock price
    PutV(0) = Application.Max(K - S, dpd * PutV(0) + dpu * PutV(1))
    For j = 1 To i                      ' step up over nodes
        S = S * u2
        PutV(j) = Application.Max(K-S, dpd*PutV(j)+dpu*PutV(j+1))
    Next j
Next i                             
Su = S0 * u2                       ' higher stock price  
Sd = S0 / u2                       ' lower stock price 
Deltau = (PutV(2) - PutV(1)) / (Su - S0) ' midpoint delta
Deltad = (PutV(1) - PutV(0)) / (S0 - Sd) ' midpoint delta
dist = S0 * (u2 - d * d)       ' dist between Su and Sd
Delta = (PutV(2) - PutV(0)) / dist
Gamma = 2 * (Deltau - Deltad) / dist
American_Put_Binomial_DG = Array(PutV(1), Delta, Gamma)
End Function
\end{verbatim}\normalsize

# Problems 
\begin{prob} Consider an at-the-money European call option on a non-dividend-paying stock with six months to maturity.  Take the initial stock price to be \$50, the interest rate to be 5\% and $\sigma=$30\%.  Compute the value in a binomial model with $N=10, 11, \ldots, 20$ and plot the values against $N$.  Is convergence monotone?
\end{prob}\begin{prob} Consider the same option as in the previous problem.  Roughly what value of $N$ is needed to get penny accuracy?  (To evaluate the accuracy, compare the price to the price given by the Black-Scholes formula.)
\end{prob}\begin{prob}  The "early exercise premium" is the difference between the value of an
American option and the value of a European option with the same
parameters. Compute the early exercise premium for an American put and
various values for the interest rate, exercise price, and stock
parameters. Under what circumstances is the early exercise premium
relatively large?

\end{prob}\begin{prob} \label{e_GARCHimpliedvols} Create an Excel worksheet in which the user inputs $S$, $r$, $\sigma$, $q$, $T$, $N$, $\kappa$, $\theta$, and $\lambda$.  Use the function \verb!European_Call_GARCH_MC! to compute call option prices for exercise prices $K=0.6S$, $0.7S$, $0,8S$, $0.9S$, $S$, $1.1S$, $1.2S$, $1.3S$ and $1.4S$, taking $M=500$ in each case.  For each computed price, use the function \verb!Black_Scholes_Call_Implied_Vol! to compute an implied Black-Scholes volatility.  Plot the implied volatilities against the exercise prices.
\end{prob}\begin{prob} \label{e_Hestoncall} Create a VBA function using Monte Carlo to estimate the value of a European call option in the Heston stochastic volatility model.  The inputs should be the initial stock price $S$, the strike price $K$, the risk-free rate $r$, the initial volatility $\sigma$, the dividend yield $q$, the time to maturity $T$, the number of time periods $N$, the parameters  $\kappa$, $\theta$, $\gamma$, and $\rho$, and the number of simulations $M$.  Return the estimated option value and its standard error.  
\end{prob}\begin{prob} Modify the VBA function in the previous exercise to also return the estimated delta of the option and the standard error of the delta.
\end{prob}\begin{prob} Repeat Prob.~\ref{e_GARCHimpliedvols} using the Heston model (the function developed in Prob.~\ref{e_Hestoncall}) to compute the call option prices, allowing the user to input $\gamma$ and~$\rho$ (instead of $\lambda$).  
\end{prob}
